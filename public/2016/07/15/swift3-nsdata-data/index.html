<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Data in Swift 3 parsing a Doom WAD File</title>
  <link rel="stylesheet" href="/css/bulma.min.css" />
  <link rel="stylesheet" href="/css/style.css" />

  <meta content="Swift 3 replaces NSData with the Data value type. Implement a Doom Wad file parser wit" name="description" /><meta content="benedikt, binary, bytes, c, clojure, clojurescript, cocoa, data, doom, html, ios, javascript, lumps, mac, nsdata, objective-c, photodesk, research, stylemac, swift, swift3, terhechte, wad" name="keywords" /><meta content="Benedikt Terhechte" name="author" /><meta content="Data in Swift 3 parsing a Doom WAD File" property="og:title" /><meta content="Swift 3 replaces NSData with the Data value type. Implement a Doom Wad file parser wit" property="og:description" /><meta content="http://appventure.me/2016/07/15/swift3-nsdata-data/" property="og:url" /><meta content="Data in Swift 3 parsing a Doom WAD File" name="twitter:title" /><meta content="Swift 3 replaces NSData with the Data value type. Implement a Doom Wad file parser wit" name="twitter:description" /><meta content="summary" name="twitter:card" /><meta content="http://appventure.me/img/ez@2x.png" name="twitter:image" /><meta content="http://appventure.me/img/ez@2x.png" property="og:image" />
  <meta name="twitter:site" content="@terhechte" />
  <meta name="twitter:creator" content="@terhechte" />
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,800" rel="stylesheet" />
  <script defer="defer" src="/js/fontawesome-all.min.js"></script>
  
 </head>
 <body>
  <section class="section" id="head">
   <div class="container" id="container">
    <div>

     <div class="columns">
      <div class="column is-3">
          <span id="brand"><a href="/index.html"><img src="/img/brand.png" srcset="/img/brand.png 1x, /img/brand@2x.png 2x" /></a></span>
      </div>
      <div class="column is-7">
       <span id="subbrand">
        Simple. Swift. Guides.</span>
      </div>
      <div class="column is-2">
          <div class="field">

          </div>
      </div>
     </div>
    </div>
   </div>
  </section>


  <section class="section" id="main">
   <div class="container" id="container">
    <div class="columns">
     <div class="column">
      <div class="columns">
       <div class="column">
        <div class="tabs">
		 
        </div>
       </div>
       <div class="column is-narrow">
        <div class="buttons has-addons is-hidden-mobile">
        </div>
       </div>
      </div>

      <div class="box" style="margin-bottom: 250px;">
            <h5 style="font-size: 38px; font-weight: bold;"><a class="xx-new-article" href="https://appventure.me/posts/2016-07-15-swift3-nsdata-data.html">AppVenture has been updated</a></h5>
            <p style="padding-top: 10px; padding-bottom: 10px; font-size: 18px;">
                All articles have been rewritten and improved. You will be forwarded
                to the updated article.
            </p>
            <p style="font-size: 18px; font-weight: bold;">
                <a class="xx-new-article" href="https://appventure.me/posts/2016-07-15-swift3-nsdata-data.html" id="xxx-new-article">Click here to go there directly.</a>
            </p>
            <script>
                 setTimeout(function(){ 
                    document.location.href=document.getElementById("xxx-new-article").href;
                },
                    0);
            </script>
      </div>




      <div role="content" id="maincontent" style="opacity: 0.5"><article id="article-758655663" class="article-post content is-medium">


 
          <h6><i class="fi-pencil"></i> Fri, 15 Jul 2016 <a href="/2016/07/15/swift3-nsdata-data/">#</a></h6>

        <h3><a href="/2016/07/15/swift3-nsdata-data/">Data in Swift 3 parsing a Doom WAD File</a></h3>



        <div class="actual-content">
<div id="outline-container-org62af723" class="outline-2">
<h2 id="org62af723"><span class="section-number-2">1</span> From NSData to Data in Swift 3</h2>
<div class="outline-text-2" id="text-1">
<p>
Swift 3 encompasses many different small and big changes to the language. One of them is the introduction of value type wrappers for common Foundation reference types such as NSData (<code>Data</code>) or NSDate (<code>Date</code>). These new types differ not only in their memory behaviour and name, their methods also differ from their reference-based counterparts<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>. From small changes to new method names up to big changes like completely removed functionalities, these new value types require some getting used to. This post will try to highlight some of the bigger changes happened to <code>Data</code> the value-based wrapper for <code>NSData</code>.
</p>

<p>
Even better, after going through the basics, we will write a small example application that will read and parse a Doom <sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> WAD file.
</p>

<div align="center">
<img src="/img-content/doom.png" srcset="/img-content/doom@2x.png 2x" /><br />
<br />
<br />
</div>
</div>

<div id="outline-container-org29d5d4c" class="outline-2">
<h2 id="org29d5d4c"><span class="section-number-2">2</span> Basic Differences</h2>
<div class="outline-text-2" id="text-2">
<p>
One of the most common usage scenarios for <code>NSData</code> is the loading and writing of data via these calls:
</p>

<div class="org-src-container">
<pre class="src src-swift">func writeToURL(_ url: NSURL, atomically atomically: Bool) -&gt; Bool
func writeToURL(_ url: NSURL, options writeOptionsMask: NSDataWritingOptions) throws
// ... (implementations for file: String instead of NSURL)
init?(contentsOfURL url: NSURL)
init(contentsOfURL url: NSURL, options readOptionsMask: NSDataReadingOptions) throws
// ... (implementations for file: String instead of NSURL)
</pre>
</div>

<p>
For those basic usages, very little changed. The new <code>Data</code> type offers these methods:
</p>

<div class="org-src-container">
<pre class="src src-swift">init(contentsOf: URL, options: ReadingOptions)
func write(to: URL, options: WritingOptions)
</pre>
</div>

<p>
Note that <code>Data</code> simplifies the various ways of reading and writing data from the file system into two calls while <code>NSData</code> offers multiple different methods.
</p>

<p>
Another difference can be observed when comparing the methods on <code>NSData</code> with those on <code>Data</code>. While <code>NSData</code> offers 30 methods &amp; properties, <code>Data</code> offers 130. This huge difference is easily explained via Swift's formidable Protocol Extensions. <code>Data</code> obtains many of those methods from the following protocols:
</p>

<ul class="org-ul">
<li>CustomStringConvertible</li>
<li>Equatable</li>
<li>Hashable</li>
<li>MutableCollection</li>
<li>RandomAccessCollection</li>
<li>RangeReplaceableCollection</li>
<li>ReferenceConvertible</li>
</ul>

<p>
This adds functionality to <code>Data</code> which did not exist in <code>NSData</code>. Here's a small sample:
</p>

<div class="org-src-container">
<pre class="src src-swift">func distance(from: Int, to: Int)
func dropFirst(Int)
func dropLast(Int)
func filter((UInt8) -&gt; Bool)
func flatMap&lt;ElementOfResult&gt;((UInt8) -&gt; ElementOfResult?)
func forEach((UInt8) -&gt; Void)
func index(Int, offsetBy: Int, limitedBy: Int)
func map&lt;T&gt;((UInt8) -&gt; T)
func max()
func min()
func partition()
func prefix(Int)
func reversed()
func sort()
func sorted()
func split(separator: UInt8, maxSplits: Int, omittingEmptySubsequences: Bool)
func reduce&lt;Result&gt;(Result, (partialResult: Result, UInt8) -&gt; Result)
</pre>
</div>

<p>
As you can see, many functional approaches, such as mapping or filtering can now be done on the byte contents of <code>Data</code> types. This, to me, is a huge improvement over <code>NSData</code>. An example of the benefits this brings is how easily you can now subscript and compare data:
</p>

<div class="org-src-container">
<pre class="src src-swift">var data = Data(bytes: [0x00, 0x01, 0x02, 0x03])  
print(data[2]) // 2
data[2] = 0x09
print (data == Data(bytes: [0x00, 0x01, 0x09, 0x03])) // true  
</pre>
</div>

<pre class="example">
2
true

</pre>

<p>
<code>Data</code> also offers several new initializers which specifically handle other common Swift data types:
</p>

<div class="org-src-container">
<pre class="src src-swift">init(bytes: Array&lt;UInt8&gt;)
init&lt;SourceType&gt;(buffer: UnsafeMutableBufferPointer&lt;SourceType&gt;)
init(repeating: UInt8, count: Int)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb124843" class="outline-2">
<h2 id="orgb124843"><span class="section-number-2">3</span> GetBytes</h2>
<div class="outline-text-2" id="text-3">
<p>
Another difference which you will run into if you're using <code>Data</code> to interact with lower level code such as <code>C</code> libraries is the distinct lack of the <code>NSData</code> <code>getBytes</code> method:
</p>

<div class="org-src-container">
<pre class="src src-swift">// NSData
func getBytes(_ buffer: UnsafeMutablePointer&lt;Void&gt;, length length: Int)
</pre>
</div>

<p>
There're many different usage scenarious for <code>getBytes</code>. One of the most common is when you need to parse a file and read the bytes into data types / variables. A common example: Say you want to read a binary file which encodes a list of items. The file is encoded as follows:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left"></col>

<col class="org-right"></col>

<col class="org-left"></col>
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Datatype</th>
<th scope="col" class="org-right">Size</th>
<th scope="col" class="org-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Char</td>
<td class="org-right">4</td>
<td class="org-left">Header (ABCD)</td>
</tr>

<tr>
<td class="org-left">UInt32</td>
<td class="org-right">4</td>
<td class="org-left">Start of Data</td>
</tr>

<tr>
<td class="org-left">UInt32</td>
<td class="org-right">4</td>
<td class="org-left">Amount of items</td>
</tr>
</tbody>
</table>

<p>
The file contains a 4 byte string "ABCD" tagging it as the correct file type. The next 4 bytes define the start of the actual data (i.e. where the header ends and the items begin), the final 4 bytes in the header define the amount of items stored in this file.
</p>

<p>
Parsing this data with <code>NSData</code> is pretty straight forward:
</p>

<div class="org-src-container">
<pre class="src src-swift">let data = ...
var length: UInt32 = 0
var start: UInt32 = 0
data.getBytes(&amp;start, range: NSRange(location: 4, length: 4))
data.getBytes(&amp;length, range: NSRange(location: 8, length: 4))
</pre>
</div>

<p>
This will return the correct result<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>. If your data does not contain C strings, there's an even easier way of doing this, you can simply define a <code>struct</code> with the correct fields and read the bytes directly into the struct:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left"></col>

<col class="org-right"></col>

<col class="org-left"></col>
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Datatype</th>
<th scope="col" class="org-right">Size</th>
<th scope="col" class="org-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">UInt32</td>
<td class="org-right">4</td>
<td class="org-left">Start of Data</td>
</tr>

<tr>
<td class="org-left">UInt32</td>
<td class="org-right">4</td>
<td class="org-left">Amount of items</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-swift">let data = ...
struct Header { 
  let start: UInt32
  let length: UInt32
}
var header = Header(start: 0, length: 0)
data.getBytes(&amp;header, range: NSRange(location: 0, length: 8))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc2446ba" class="outline-2">
<h2 id="orgc2446ba"><span class="section-number-2">4</span> Data alternatives to <code>getBytes</code></h2>
<div class="outline-text-2" id="text-4">
<p>
However, if you're using <code>Data</code> this functionality is not available anymore. Instead, <code>Data</code> offers a new method:
</p>

<div class="org-src-container">
<pre class="src src-swift">// Access the bytes in the data.
func withUnsafeBytes&lt;ResultType, ContentType&gt;((UnsafePointer&lt;ContentType&gt;) -&gt; ResultType)
</pre>
</div>

<p>
This method allows direct access of the our data's bytes from within a closure. Let's see a simple example:
</p>

<div class="org-src-container">
<pre class="src src-swift">let data = Data(bytes: [0x01, 0x02, 0x03])
data.withUnsafeBytes { (pointer: UnsafePointer&lt;UInt8&gt;) -&gt; Void in
    print(pointer)
    print(pointer.pointee)
}
// Prints: 
// : 0x00007f8dcb77cc50
// : 1
</pre>
</div>

<p>
Ok, now that we have an unsafe UInt8 pointer into our data, how does this help us? First of fall, we obviously need a different data type, and we're sure (we have to be!) that the data is indeed of this particular data type. We know that this data contains a Int32 type, so how do we decode it correctly?
</p>

<p>
As we already have a unsafe pointer (of type UInt8) it is easy to move this into an unsafe pointer of our target type. <code>UnsafePointer</code> has a <code>pointee</code> property which returns the type that the pointer is pointing to as the correct type:
</p>

<div class="org-src-container">
<pre class="src src-swift">let data = Data(bytes: [0x00, 0x01, 0x00, 0x00])
let result = data.withUnsafeBytes { (pointer: UnsafePointer&lt;Int32&gt;) -&gt; Int32 in
      return pointer.pointee
}
print(result)
//: 256
</pre>
</div>

<pre class="example">
256

</pre>

<p>
As you can see, we created a byte <code>Data</code> instance, and returned the data as <code>Int32</code> by defining an <code>UnsafePointer&lt;Int32&gt;</code> in the closure. You can shorten this code if the compiler is able to infer the result type from the context:
</p>

<div class="org-src-container">
<pre class="src src-swift">let result: Int32 = data.withUnsafeBytes { $0.pointee }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc4f784c" class="outline-2">
<h2 id="orgc4f784c"><span class="section-number-2">5</span> Lifetime of the data</h2>
<div class="outline-text-2" id="text-5">
<p>
One important consideration of using <code>withUnsafeBytes</code> (apart from the fact that the whole operation is unsafe) is that the lifetime of the pointer you're accessing is limited to the lifetime of your closure. As the documentation notes:
</p>

<blockquote>
<p>
Warning
The byte pointer argument should not be stored and used outside of the lifetime of the call to the closure.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org32bdbf5" class="outline-2">
<h2 id="org32bdbf5"><span class="section-number-2">6</span> Generic Solution</h2>
<div class="outline-text-2" id="text-6">
<p>
Now that we have a way of accessing raw bytes and casting them to the correct type, we ought to create a generic solution that allows us to perform this operation easily without the syntactical overhead. Also, we still did not account for the fact that we need to perform the operation on a subsequence of our data and not the whole <code>Data</code> instance. A generic solution would look like this:
</p>

<div class="org-src-container">
<pre class="src src-swift">extension Data {
    func scanValue&lt;T&gt;(start: Int, length: Int) -&gt; T {
        return self.subdata(in: start..&lt;start+length).withUnsafeBytes { $0.pointee }
    }
}
let data = Data(bytes: [0x01, 0x02, 0x01, 0x02])
let a: Int16 = data.scanValue(start: 0, length: 1)
print(a)
// : 1
</pre>
</div>

<pre class="example">
2

</pre>
<p>
Compared to our earlier code, this has a couple of notable differences:
</p>
<ul class="org-ul">
<li>We're using <code>subdata</code> to only scan the bytes of a specific slice of our Data.</li>
<li>We're using generics to support different possible data types for extraction</li>
</ul>
</div>
</div>

<div id="outline-container-orgd851e89" class="outline-2">
<h2 id="orgd851e89"><span class="section-number-2">7</span> To Data</h2>
<div class="outline-text-2" id="text-7">
<p>
The opposite case, taking an existing variable and getting a <code>Data</code> buffer to the content, is not relevant for the Doom example below, but easy enough to implement:
</p>

<div class="org-src-container">
<pre class="src src-swift">var variable = 256
let data = Data(buffer: UnsafeBufferPointer(start: &amp;variable, count: 1))
print(data) // : &lt;00010000 00000000&gt;
</pre>
</div>

<pre class="example">
&lt;00010000 00000000 00000000 00000000&gt;

</pre>
</div>
</div>

<div id="outline-container-org71684e6" class="outline-2">
<h2 id="org71684e6"><span class="section-number-2">8</span> Parsing the Doom WAD file</h2>
<div class="outline-text-2" id="text-8">
<p>
I've played a lot of Doom in  my youth. I loved the game. I also created a lot of Doom levels and modified the WAD file to incorporate new sprites, textures, and more. So when I thought about a nice (and simple) example of how to parse a binary file, I remembered the layout of the WAD file which is pretty straightforward and easy to implement. So I wrote a simple app that reads a WAD file and lists the names of all the floor textures stored in the WAD<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>.
</p>

<p>
The source code for this application <a href="https://github.com/terhechte/SwiftWadReader">is available on Github</a>.
</p>

<p>
The Doom WAD file layout is described in these two documents:
</p>
<ul class="org-ul">
<li><a href="http://doom.wikia.com/wiki/WAD">http://doom.wikia.com/wiki/WAD</a></li>
<li><a href="http://doomlegacy.sourceforge.net/hosted/doomspec1666.txt">http://doomlegacy.sourceforge.net/hosted/doomspec1666.txt</a></li>
</ul>

<p>
However, for our simple example, we only need to understand a subset of the format. First, each WAD file begins with a header:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left"></col>

<col class="org-right"></col>

<col class="org-left"></col>
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Datatype</th>
<th scope="col" class="org-right">Size</th>
<th scope="col" class="org-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Char</td>
<td class="org-right">4</td>
<td class="org-left">IWAD or PWAD string</td>
</tr>

<tr>
<td class="org-left">Int32</td>
<td class="org-right">4</td>
<td class="org-left">The number of lumps in the WAD</td>
</tr>

<tr>
<td class="org-left">Int32</td>
<td class="org-right">4</td>
<td class="org-left">Pointer to the location of the directory</td>
</tr>
</tbody>
</table>

<p>
The first 4 bytes are spend to identify the file format. <code>IWAD</code> are official Doom WAD files, <code>PWAD</code> are patches containing additional information patched at runtime into the main WAD file. Our application will only read <code>IWAD</code> files. The next 4 bytes define the number of <i>lumps</i> in the WAD. Lumps are the individual items that the Doom engine operates with: Textures, Sprite-Frames, Text blocks, Models, etc. Each texture is a distinct lump. The final 4 bytes define the location of the <i>directory</i>. We'll explain the directory below, once we start parsing it. First, lets parse the header.
</p>
</div>

<div id="outline-container-orgb6b4c13" class="outline-3">
<h3 id="orgb6b4c13"><span class="section-number-3">8.1</span> Parsing the Header</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Reading a WAD file is straight forward:
</p>

<div class="org-src-container">
<pre class="src src-swift">let data = try Data(contentsOf: wadFileURL, options: .alwaysMapped)
</pre>
</div>

<p>
Once we have the data, we need to parse the header. We're making heavy use of the <code>scanValue</code> <code>Data</code> extension we defined earlier.
</p>

<div class="org-src-container">
<pre class="src src-swift">public func validateWadFile() throws {
    // Several Wad File definitions
    let wadMaxSize = 12, wadLumpsStart = 4, wadDirectoryStart = 8, wadDefSize = 4
    // A WAD file always starts with a 12-byte header.
    guard data.count &gt;= wadMaxSize else { throw WadReaderError.invalidWadFile(reason: "File is too small") }

    // It contains three values:

    // The ASCII characters "IWAD" or "PWAD". Defines whether the WAD is an IWAD or a PWAD.
    let validStart = "IWAD".data(using: String.Encoding.ascii)!
    guard data.subdata(in: 0..&lt;wadDefSize) == validStart else
    { throw WadReaderError.invalidWadFile(reason: "Not an IWAD") }

    // An integer specifying the number of lumps in the WAD.
    let lumpsInteger: Int32 = data.scanValue(start: wadLumpsStart, length: wadDefSize)

    // An integer holding a pointer to the location of the directory.
    let directoryInteger: Int32 = data.scanValue(start: wadDirectoryStart, length: wadDefSize)

    guard lumpsInteger &gt; 0 &amp;&amp; directoryInteger &gt; Int32(wadMaxSize)
        else {
            throw WadReaderError.invalidWadFile(reason: "Empty Wad File")
    }
}
</pre>
</div>

<p>
You can find additional types (such as the <code>WadReaderError</code> <code>enum</code>) in <a href="https://github.com/terhechte/SwiftWadReader">the source on GitHub</a>. The next step is to parse the directory, so that we get the addresses and sizes of the individual lumps.
</p>
</div>
</div>

<div id="outline-container-orge55361c" class="outline-3">
<h3 id="orge55361c"><span class="section-number-3">8.2</span> Parsing the Directory</h3>
<div class="outline-text-3" id="text-8-2">
<p>
The directory associates names of lumps with the data that belong to them. It consists of a number of entries, each with a length of 16 bytes. The length of the directory is determined by the number given in the WAD header.
</p>

<p>
Each of the 16 bytes entries follows the same format:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left"></col>

<col class="org-right"></col>

<col class="org-left"></col>
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Datatype</th>
<th scope="col" class="org-right">Size</th>
<th scope="col" class="org-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Int32</td>
<td class="org-right">4</td>
<td class="org-left">The start of the lumps data in the file</td>
</tr>

<tr>
<td class="org-left">Int32</td>
<td class="org-right">4</td>
<td class="org-left">The size of the lump in bytes</td>
</tr>

<tr>
<td class="org-left">Char</td>
<td class="org-right">8</td>
<td class="org-left">An ASCII string defining the lump's name</td>
</tr>
</tbody>
</table>

<p>
The name char is a bit more complicated. The documentation says:
</p>

<blockquote>
<p>
An ASCII string defining the lump's name. Only the characters A-Z (uppercase), 0-9, and [ ] - _ should be used in lump names (an exception has to be made for some of the Arch-Vile sprites, which use "\"). When a string is less than 8 bytes long, it should be null-padded to the tight byte.
</p>
</blockquote>

<p>
Note the last sentence. In C, a String is terminated with the null character (<code>\0</code>). This signifies to the system that the memory for the string ends here. Doom saves space by having an optional null character. When the string is less than 8 bytes long, it will contain a null character, when it is of the max length (8 bytes) the 8th byte will be the final character, not the null character. 
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="org-left"></col>

<col class="org-left"></col>

<col class="org-left"></col>

<col class="org-left"></col>

<col class="org-left"></col>

<col class="org-left"></col>

<col class="org-right"></col>

<col class="org-left"></col>

<col class="org-right"></col>

<col class="org-left"></col>
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"> </th>
<th scope="col" class="org-left">0</th>
<th scope="col" class="org-left">1</th>
<th scope="col" class="org-left">2</th>
<th scope="col" class="org-left">3</th>
<th scope="col" class="org-left">4</th>
<th scope="col" class="org-right">5</th>
<th scope="col" class="org-left">6</th>
<th scope="col" class="org-right">7</th>
<th scope="col" class="org-left"> </th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Short</td>
<td class="org-left">I</td>
<td class="org-left">M</td>
<td class="org-left">P</td>
<td class="org-left"><code>\0</code></td>
<td class="org-left"><code>\0</code></td>
<td class="org-right"><code>\0</code></td>
<td class="org-left"><code>\0</code></td>
<td class="org-right"><code>\0</code></td>
<td class="org-left">#</td>
</tr>

<tr>
<td class="org-left">Long</td>
<td class="org-left">F</td>
<td class="org-left">L</td>
<td class="org-left">O</td>
<td class="org-left">O</td>
<td class="org-left">R</td>
<td class="org-right">4</td>
<td class="org-left">_</td>
<td class="org-right">5</td>
<td class="org-left">#</td>
</tr>
</tbody>
</table>

<p>
See above for an example. The Short name has a null character after the last letter in position 3, the long name does not have a null character, instead the last letter is the <b>5</b> from the name <b>FLOOR4_5</b>. The <code>#</code> signifies the beginning of the next item / piece of memory.
</p>

<p>
Before we venture into supporting this, lets first take care of the easier part, reading the start and size.
</p>

<p>
Before we start, we should define a data structure that can store the information from the directory:
</p>

<div class="org-src-container">
<pre class="src src-swift">public struct Lump {
    public let filepos: Int32
    public let size: Int32
    public let name: String
}
</pre>
</div>

<p>
Afterwards, we take the slice of data that constitutes our directory from the complete data instance. 
</p>

<div class="org-src-container">
<pre class="src src-swift">// Define the default size of a directory entry
let wadDirectoryEntrySize = 16
// Extract the directory slice from the main Data
let directory = data.subdata(in: Int(directoryLocation)..&lt;(Int(directoryLocation) + Int(numberOfLumps) * wadDirectoryEntrySize))
</pre>
</div>

<p>
Next, we can iterate over the <code>Data</code> in 16byte steps. This works great with Swift's <code>stride</code> function:
</p>

<div class="org-src-container">
<pre class="src src-swift">for currentIndex in stride(from: 0, to: directory.count, by: wadDirectoryEntrySize) {
    let currentDirectoryEntry = directory.subdata(in: currentIndex..&lt;currentIndex+wadDirectoryEntrySize)

    // An integer holding a pointer to the start of the lump's data in the file.
    let lumpStart: Int32 = currentDirectoryEntry.scanValue(start: 0, length: 4)

    // An integer representing the size of the lump in bytes.
    let lumpSize: Int32 = currentDirectoryEntry.scanValue(start: 4, length: 4)
    ...
}
</pre>
</div>

<p>
This was the easier part the next part is a bit more difficult.
</p>
</div>
</div>

<div id="outline-container-orgc9785bc" class="outline-3">
<h3 id="orgc9785bc"><span class="section-number-3">8.3</span> Parsing C Strings</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Remember, for each lump's name, we need to stop reading bytes into our Swift string once we reach a null terminator <b>or</b> once we reach 8 bytes. The very first thing to do is create a data slice with the relevant data:
</p>

<div class="org-src-container">
<pre class="src src-swift">let nameData = currentDirectoryEntry.subdata(in: 8..&lt;16)
</pre>
</div>

<p>
Swift offers great support for C String interoperability. This means that to create a string we just need to hand the data to a <code>String</code> initializer:
</p>

<div class="org-src-container">
<pre class="src src-swift">let lumpName = String(data: nameData, encoding: String.Encoding.ascii)
</pre>
</div>

<p>
This works, though the result is not correct. This method ignores the null terminator, so that all names, even the short ones, are converted to 8byte strings. As an example, the lump for the <b>IMP</b> character name becomes <b>IMP00000</b>. This happens because Doom fills the remaining 5 bytes with null characters and <code>String(data:encoding:)</code> does not interpret them but creates a string of the full 8 bytes of the <code>nameData</code>.
</p>

<p>
If we want to support null characters, Swift offers something else, a <code>cString</code> initializer which is defined for reading valid cStrings with null terminators:
</p>

<div class="org-src-container">
<pre class="src src-swift">// Produces a string containing the bytes in a given C array, 
// interpreted according to a given encoding.
init?(cString: UnsafePointer&lt;CChar&gt;, encoding enc: String.Encoding)
</pre>
</div>

<p>
Note that it doesn't require a <code>data</code> instance as its parameter but an unsafePointer to <code>CChars</code> instead. We already know how to do that, so lets write the code:
</p>

<div class="org-src-container">
<pre class="src src-swift">let lumpName2 = nameData.withUnsafeBytes({ (pointer: UnsafePointer&lt;UInt8&gt;) -&gt; String? in
    return String(cString: UnsafePointer&lt;CChar&gt;(pointer), encoding: String.Encoding.ascii)
})
</pre>
</div>

<p>
This, again, doesn't work. In all cases where Doom's names are less than 8 characters, this code works flawlessly, but once we reach a 8 byte name without a null terminator, it will continue reading (into the next 16byte segment) until it finds the next valid null terminator. This results in long strings with random memory at the end.
</p>

<p>
Since this logic is custom to Doom, we also need to implement custom code. As <code>Data</code> supports Swift's collection &amp; sequence operations, we can just solve this in terms of reduce:
</p>

<div class="org-src-container">
<pre class="src src-swift">let lumpName3Bytes = try nameData.reduce([UInt8](), { (a: [UInt8], b: UInt8) throws -&gt; [UInt8] in
    guard b &gt; 0 else { return a }
    guard a.count &lt;= 8 else { return a }
    return a + [b]
})
guard let lumpName3 = String(bytes: lumpName3Bytes, encoding: String.Encoding.ascii)
    else {
        throw WadReaderError.invalidLup(reason: "Could not decode lump name for bytes \(lumpName3Bytes)")
}
</pre>
</div>

<p>
This code just reduces over the <code>UInt8</code> bytes of our data and checks whether we have an early null terminator. This code works, <a href="https://appventure.me/2015/11/30/reduce-all-the-things/">though it is not necessarily fast as the data has to be moved through several abstractions.</a> 
</p>

<p>
It would be better if we could solve this similarly to how the Doom engine does it. Doom just moves the pointer of the <code>char*</code> and checks for each char whether it is a null terminator in order to break early. As Doom is written in low level C code, it can just iterate over the raw pointer addresses.
</p>

<p>
How would we implement this logic in Swift? We can actually do something quite similar in Swift by, again, utilizing <code>withUnsafeBytes</code>. Lets see:
</p>

<div class="org-src-container">
<pre class="src src-swift">
let finalLumpName = nameData.withUnsafeBytes({ (pointer: UnsafePointer&lt;CChar&gt;) -&gt; String? in
    var localPointer = pointer
    for _ in 0..&lt;8 {
        guard localPointer.pointee != CChar(0) else { break }
        localPointer = localPointer.successor()
    }
    let position = pointer.distance(to: localPointer)
    return String(data: nameData.subdata(in: 0..&lt;position),
                  encoding: String.Encoding.ascii)
})
guard let lumpName4 = finalLumpName else {
    throw WadReaderError.invalidLup(reason: "Could not decode lump name for bytes \(lumpName3Bytes)")
}
</pre>
</div>

<p>
Similar to our earlier uses of <code>withUnsafeBytes</code> we're receiving a pointer to the raw memory. <code>pointer</code> is a <code>let</code> constant, but we need to modify the variable, which is why we create a local mutable version in the first line <sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>.
</p>

<p>
Afterwards, we're performing the main work. We loop from 0 to 8 and for each loop iteration we test whether the char that the pointer is pointing to (the <code>pointee</code>) is equal to the null terminator (<code>CChar(0)</code>). If it is equal to the null terminator, this means that we found the null terminator early, and we break. If it is not equal to the null terminator, we overwrite <code>localPointer</code> with its successor, i.e. the next position in memory after the current pointer. That way, we're iterating byte by byte over the contents of our memory.
</p>

<p>
Once we're done, we calculate the distance between our original <code>pointer</code> and our <code>localPointer</code>. If we just advanced three times before finding a null terminator, the distance between the two pointers would be 3. This distance, finally, allows us to create a new String instance with the subdata of actual C String.
</p>

<p>
This allows us to create a new <code>Lump</code> struct with the required data:
</p>

<div class="org-src-container">
<pre class="src src-swift">lumps.append(Lump(filepos: lumpStart, size: lumpSize, name: lumpName4))                
</pre>
</div>

<p>
When you look into the source, you will see ominous references to <code>F_START</code> and <code>F_END</code>. Doom marks the beginning and end of special <i>lump regions</i> with empty lumps with magic names. <code>F_START / F_END</code> enclose all the floor texture lumps. We will ignore this additional step in this tutorial.
</p>

<p>
A screenshot from the final application:
</p>
<div align="center">
<img src="/img-content/doom-shot.png" srcset="/img-content/doom-shot@2x.png 2x" style="box-shadow: 6px 6px 32px rgba(0, 0, 0, 0.5); border-radius: 4px;" /><br />
<br />
<br />
</div>

<p>
Not really impressive, I know. One of the next installments on this blog  might concentrate on how to display those textures.
</p>
</div>
</div>
</div>

<div id="outline-container-org92185d7" class="outline-2">
<h2 id="org92185d7"><span class="section-number-2">9</span> Bridging to NSData</h2>
<div class="outline-text-2" id="text-9">
<p>
I find the new <code>Data</code> easier to work with than <code>NSData</code>. Nevertheless, if you need <code>NSData</code> or if you need to use the <code>getBytes</code> method, there's an easy way to convert <code>Data</code> to <code>NSData</code>. The Swift documentation writes:
</p>

<blockquote>
<p>
This type provides “copy-on-write” behavior, and is also bridged to the Objective-C NSData class. You can wrap an instance of a custom subclass of NSData in struct Data by converting it using myData as Data.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-swift">// Create a new Data Struct
let aDataStruct = Data()
// Get the underlying reference type NSData
let aDataReference = aDataStruct as NSData
</pre>
</div>

<p>
Whenever you feel that what you're trying to do seems to be really hard with the <code>Data</code> type, it is easy to go back to <code>NSData</code> to use the well known tried and trusted methods. However, in general you should strive to use the new <code>Data</code> type whenever possible (except if you need reference semantics):
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara">Some, such as <code>Date</code> aren't even wrappers but completely new implementations</div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara">Doom1, Doom2, Hexen, Heretic, or Ultimate Doom. Though I've only tested it with Doom1 Shareware</div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara">Note we did not make sure that this is indeed an ABCD file by testing for the first 4 bytes, but that would be easy to add</div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara">I kinda wanted to also display the textures but lacked the time to implement that.</div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara">Swift 3 dropped support for the useful <code>var</code> annotation in closure or function bodies</div></div>


</div>
</div></div></div>

        <div id="followme">
            <p>If you read this far, you should follow me (<a href="http://www.twitter.com/terhechte">@terhechte</a>) <br /> on <a href="http://www.twitter.com/terhechte"><i class="fi-social-twitter"></i> Twitter</a></p>
            <br />
        </div>
        

        <div class="footnotes">
            <ol></ol>
        </div>

        <p class="anchor"><i class="fi-anchor"></i></p>
 
      </article></div>


    </div>

    <div class="column is-narrow">

     <aside class="menu">

         



      <br />
      <ul class="menu-list">
       <li>
        <p class="menu-label">
         <a>
          <i class="fas fa-dove"></i>
          Swift Topics
         </a>
        </p>
        <ul>
            <li><a href="/topics/all.html">All</a></li>
           
            
            <li><a href="/topics/swift-tricks.html">Swift Tricks</a></li>
            
         
            
            <li><a href="/topics/language.html">Language</a></li>
            
         
            
            <li><a href="/topics/hands-on.html">Hands On</a></li>
            
         
            
            <li><a href="/topics/blog.html">Blog</a></li>
            
         
            
         
        </ul>
       </li>

       <li>
           <p class="menu-label">
               <a>
                   <i class="fas fa-book"></i>
                   Guides
               </a>
           </p>
           <ul>
                 
               <li><a href="/guides/pattern_matching/intro.html">🧩 Pattern Matching</a></li>
                 
               <li><a href="/guides/advanced_practical_enum_examples/introduction.html">🚦 Enums</a></li>
                 
               <li><a href="/guides/map_flatmap_reduce_more/intro.html">🗺 Map, Reduce &amp; more</a></li>
                 
               <li><a href="/guides/associated_types/associated_types.html">🧙🏻 Associated Types</a></li>
                 
               <li><a href="/guides/tuples/introduction.html">🍱 Tuples</a></li>
                 
               <li><a href="/guides/optionals/intro.html">⁉️ Optionals</a></li>
                 
               <li><a href="/guides/swift_reflection/introduction.html">🔮 Reflection</a></li>
                 
           </ul>
       </li>
      </ul>

      <div class="sidebar-banner">
          <a href="https://contravariance.rocks"><img src="/img/contravariance_banner.png" srcset="/img/contravariance_banner.png 1x, /img/contravariance_banner@2x.png 2x" /></a>
      </div>

      <ul class="menu-list">
       <li>
        <p class="menu-label">
         <a>
          <i class="fas fa-tags"></i>
          Tags
         </a>
        </p>
        <ul>

     
     <li><a href="/tags/pattern-matching.html" class="tags has-addons"><span class="tag is-info is-rounded">pattern matching</span><span class="tag is-primary is-rounded">25</span></a></li>
     
     <li><a href="/tags/switch.html" class="tags has-addons"><span class="tag is-info is-rounded">switch</span><span class="tag is-primary is-rounded">24</span></a></li>
     
     <li><a href="/tags/enum.html" class="tags has-addons"><span class="tag is-info is-rounded">enum</span><span class="tag is-primary is-rounded">20</span></a></li>
     
     <li><a href="/tags/associated.html" class="tags has-addons"><span class="tag is-info is-rounded">associated</span><span class="tag is-primary is-rounded">14</span></a></li>
     
     <li><a href="/tags/tuples.html" class="tags has-addons"><span class="tag is-info is-rounded">tuples</span><span class="tag is-primary is-rounded">13</span></a></li>
     
     <li><a href="/tags/reflection.html" class="tags has-addons"><span class="tag is-info is-rounded">reflection</span><span class="tag is-primary is-rounded">12</span></a></li>
     
     <li><a href="/tags/reduce.html" class="tags has-addons"><span class="tag is-info is-rounded">reduce</span><span class="tag is-primary is-rounded">11</span></a></li>
     
     <li><a href="/tags/box.html" class="tags has-addons"><span class="tag is-info is-rounded">box</span><span class="tag is-primary is-rounded">10</span></a></li>
     
     <li><a href="/tags/generics.html" class="tags has-addons"><span class="tag is-info is-rounded">generics</span><span class="tag is-primary is-rounded">7</span></a></li>
     
     <li><a href="/tags/compactmap.html" class="tags has-addons"><span class="tag is-info is-rounded">compactMap</span><span class="tag is-primary is-rounded">6</span></a></li>
     
     <li><a href="/tags/filter.html" class="tags has-addons"><span class="tag is-info is-rounded">filter</span><span class="tag is-primary is-rounded">6</span></a></li>
     
     <li><a href="/tags/map.html" class="tags has-addons"><span class="tag is-info is-rounded">map</span><span class="tag is-primary is-rounded">6</span></a></li>
     
     <li><a href="/tags/mirror.html" class="tags has-addons"><span class="tag is-info is-rounded">mirror</span><span class="tag is-primary is-rounded">6</span></a></li>
     
     <li><a href="/tags/protocol.html" class="tags has-addons"><span class="tag is-info is-rounded">protocol</span><span class="tag is-primary is-rounded">6</span></a></li>
     
     <li><a href="/tags/optionals.html" class="tags has-addons"><span class="tag is-info is-rounded">optionals</span><span class="tag is-primary is-rounded">5</span></a></li>
     
     <li><a href="/tags/where.html" class="tags has-addons"><span class="tag is-info is-rounded">where</span><span class="tag is-primary is-rounded">5</span></a></li>
     
     <li><a href="/tags/erasure.html" class="tags has-addons"><span class="tag is-info is-rounded">erasure</span><span class="tag is-primary is-rounded">4</span></a></li>
     
     <li><a href="/tags/equatable.html" class="tags has-addons"><span class="tag is-info is-rounded">equatable</span><span class="tag is-primary is-rounded">3</span></a></li>
     
     <li><a href="/tags/destructure.html" class="tags has-addons"><span class="tag is-info is-rounded">destructure</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/error.html" class="tags has-addons"><span class="tag is-info is-rounded">error</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/extension.html" class="tags has-addons"><span class="tag is-info is-rounded">extension</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/guard.html" class="tags has-addons"><span class="tag is-info is-rounded">guard</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/if-let.html" class="tags has-addons"><span class="tag is-info is-rounded">if let</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/is.html" class="tags has-addons"><span class="tag is-info is-rounded">is</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/objc.html" class="tags has-addons"><span class="tag is-info is-rounded">objc</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/optional.html" class="tags has-addons"><span class="tag is-info is-rounded">optional</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/struct.html" class="tags has-addons"><span class="tag is-info is-rounded">struct</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/try.html" class="tags has-addons"><span class="tag is-info is-rounded">try</span><span class="tag is-primary is-rounded">2</span></a></li>
     
     <li><a href="/tags/.html" class="tags has-addons"><span class="tag is-info is-rounded">?</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/caseiterable.html" class="tags has-addons"><span class="tag is-info is-rounded">CaseIterable</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/customreflectable.html" class="tags has-addons"><span class="tag is-info is-rounded">CustomReflectable</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/data.html" class="tags has-addons"><span class="tag is-info is-rounded">Data</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/expressiblebystringliteral.html" class="tags has-addons"><span class="tag is-info is-rounded">ExpressibleByStringLiteral</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/rawrepresentable.html" class="tags has-addons"><span class="tag is-info is-rounded">RawRepresentable</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/as.html" class="tags has-addons"><span class="tag is-info is-rounded">as</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/autoclosure.html" class="tags has-addons"><span class="tag is-info is-rounded">autoclosure</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/break.html" class="tags has-addons"><span class="tag is-info is-rounded">break</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/catch.html" class="tags has-addons"><span class="tag is-info is-rounded">catch</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/closure.html" class="tags has-addons"><span class="tag is-info is-rounded">closure</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/copyonwrite.html" class="tags has-addons"><span class="tag is-info is-rounded">copy-on-write</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/coredata.html" class="tags has-addons"><span class="tag is-info is-rounded">coredata</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/either.html" class="tags has-addons"><span class="tag is-info is-rounded">either</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/fallthrough.html" class="tags has-addons"><span class="tag is-info is-rounded">fallthrough</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/for.html" class="tags has-addons"><span class="tag is-info is-rounded">for</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/for-case.html" class="tags has-addons"><span class="tag is-info is-rounded">for case</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/groupby.html" class="tags has-addons"><span class="tag is-info is-rounded">groupby</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/guard-let.html" class="tags has-addons"><span class="tag is-info is-rounded">guard let</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/if-case.html" class="tags has-addons"><span class="tag is-info is-rounded">if case</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/indirect.html" class="tags has-addons"><span class="tag is-info is-rounded">indirect</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/init.html" class="tags has-addons"><span class="tag is-info is-rounded">init</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/init.html" class="tags has-addons"><span class="tag is-info is-rounded">init?</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/inout.html" class="tags has-addons"><span class="tag is-info is-rounded">inout</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/label.html" class="tags has-addons"><span class="tag is-info is-rounded">label</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/literal.html" class="tags has-addons"><span class="tag is-info is-rounded">literal</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/method.html" class="tags has-addons"><span class="tag is-info is-rounded">method</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/overload.html" class="tags has-addons"><span class="tag is-info is-rounded">overload</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/package.html" class="tags has-addons"><span class="tag is-info is-rounded">package</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/partition.html" class="tags has-addons"><span class="tag is-info is-rounded">partition</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/performance.html" class="tags has-addons"><span class="tag is-info is-rounded">performance</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/property.html" class="tags has-addons"><span class="tag is-info is-rounded">property</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/protocols.html" class="tags has-addons"><span class="tag is-info is-rounded">protocols</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/range.html" class="tags has-addons"><span class="tag is-info is-rounded">range</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/self.html" class="tags has-addons"><span class="tag is-info is-rounded">self</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/tupealias.html" class="tags has-addons"><span class="tag is-info is-rounded">tupealias</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/tuple.html" class="tags has-addons"><span class="tag is-info is-rounded">tuple</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/typealias.html" class="tags has-addons"><span class="tag is-info is-rounded">typealias</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/unique.html" class="tags has-addons"><span class="tag is-info is-rounded">unique</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/value-type.html" class="tags has-addons"><span class="tag is-info is-rounded">value type</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/valuetype.html" class="tags has-addons"><span class="tag is-info is-rounded">valuetype</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/vararg.html" class="tags has-addons"><span class="tag is-info is-rounded">vararg</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/wildcard.html" class="tags has-addons"><span class="tag is-info is-rounded">wildcard</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/zip.html" class="tags has-addons"><span class="tag is-info is-rounded">zip</span><span class="tag is-primary is-rounded">1</span></a></li>
     
     <li><a href="/tags/.html" class="tags has-addons"><span class="tag is-info is-rounded">~=</span><span class="tag is-primary is-rounded">1</span></a></li>
     

        </ul>
       </li>
      </ul>


     </aside> 


    </div>
   </div>
  </div>
 </section>

 <div class="footer">
  <article class="media" id="followme">
   <figure class="media-left">
    <p class="image is-64x64">
     <img src="/img/terhechte.jpg" class="profile-image" />
    </p>
   </figure>
   <div class="media-content">
       <div class="columns">
           <div class="column">
               <div class="content">
                   <p>
                       <strong>Benedikt Terhechte</strong> <a href="https://twitter.com/terhechte"><small>@terhechte</small></a>
                       <br />
                       If you read this far, you should <a href="https://twitter.com/terhechte">follow Benedikt on Twitter</a>.<br />
                       APPVENTURE is dedicated to providing articles about Swift, macOS, iOS &amp; Linux development.
                   </p>
                   <p>
                       <strong>2011 - 2019 Benedikt Terhechte</strong>
                   </p>
               </div>
           </div>
           <div class="column">
               <p>
                   <a href="https://terhech.de">Benedikt's private blog can be found
                       at <strong>terhech.de</strong></a>
               </p>
               <p>
                   <br />
                   <strong>Other Profiles</strong>
               </p>
               <p class="subtitle is-6">
                   <a href="https://twitter.com/terhechte"><i class="fab fa-twitter"></i></a>
                   <a href="https://www.xing.com/profile/Benedikt_Terhechte">
                       <i class="fab fa-xing"></i>
                   </a>
                   <a href="https://twitter.com/terhechte">
                       <i class="fab fa-github"></i>
                   </a>
                   <a href="https://news.ycombinator.com/user?id=terhechte">
                       <i class="fab fa-hacker-news"></i>
                   </a>
               </p>
           </div>
       </div>
   </div>
   <div class="media-right">
    <a href="https://twitter.com/terhechte" class="button is-info is-rounded">
     <i class="fab fa-twitter"></i> 
     Follow Me</a>
   </div>
  </article>
 </div>



</body>


</html>

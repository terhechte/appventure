{"./guides/catalyst/firststeps/scene_delegate.md":["af5afd20e35cef05",{"identifier":"9d93448d","filename":"scene_delegate.md","info":{"title":"How do I create a scene delegate?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-create-a-scene-delegate.html","content":"<p>Many of the macOS specific UIKit extensions require you to use a scene delegate. If your project was created before iOS 13 and you also don't intend to use multiple windows, you can follow these steps to add a scene delegate to your project and keep the app limited to one window:</p>\n<p>The first step is to add a scene manifest to your <code>Info.plist</code>. <a href=\"/img-content/catalyst/scene_manifest.png\">This can either be done in the Xcode plist editor</a> or by adding the following lines to your <code>Info.plist</code> in source code mode (You can just keep the default names. They're fine):</p>\n<pre class=\"XML\"><code><span class=\"techoutext techouxml\"><span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UIApplicationSceneManifest<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UIApplicationSupportsMultipleScenes<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">true</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneConfigurations<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n        <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UIWindowSceneSessionRoleApplication<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n        <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">array</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n            <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UILaunchStoryboardName<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>LaunchScreen<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneConfigurationName<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>Default Configuration<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneDelegateClassName<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>$(PRODUCT_MODULE_NAME).SceneDelegate<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneStoryboardFile<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>Main<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n            <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n        <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">array</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n</span></code></pre></code></pre>\n<p>Next, add the following two functions to your <code>AppDelegate</code>. Note that only one of them is used, but for posterity, it makes sense to add both in one go:</p>\n<pre class=\"Swift\"><code>     <span class=\"keyword\">func</span> application(<span class=\"keyword\">_</span> application: <span class=\"type\">UIApplication</span>, configurationForConnecting connectingSceneSession: <span class=\"type\">UISceneSession</span>, options: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) -&gt; <span class=\"type\">UISceneConfiguration</span> {\n\n         <span class=\"comment\">// Called when a new scene session is being created.</span>\n\n         <span class=\"comment\">// Use this method to select a configuration to create the new scene with.</span>\n\n         <span class=\"keyword\">return</span> <span class=\"type\">UISceneConfiguration</span>(name: \\<span class=\"string\">\"Default</span> <span class=\"type\">Configuration</span>\\<span class=\"string\">\"</span>, sessionRole: connectingSceneSession.<span class=\"property\">role</span>)\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> application(<span class=\"keyword\">_</span> application: <span class=\"type\">UIApplication</span>, didDiscardSceneSessions sceneSessions: <span class=\"type\">Set</span>&lt;<span class=\"type\">UISceneSession</span>&gt;) {\n\n         <span class=\"comment\">// Called when the user discards a scene session.</span>\n\n         <span class=\"comment\">// If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.</span>\n\n         <span class=\"comment\">// Use this method to release any resources that were specific to the discarded scenes, as they will not return.</span>\n\n     }\n</code></pre></code></pre>\n<p>Finally, add a new file, <code>SceneDelegate.swift</code> to your project and add the following code to it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> UIKit\n\n\n\n<span class=\"keyword\">class</span> SceneDelegate: <span class=\"type\">UIResponder</span>, <span class=\"type\">UIWindowSceneDelegate</span> {\n\n\n\n     <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?\n\n\n\n     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"comment\">// Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.</span>\n\n         <span class=\"comment\">// If using a storyboard, the `window` property will automatically be initialized and attached to the scene.</span>\n\n         <span class=\"comment\">// This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).</span>\n\n         <span class=\"keyword\">guard let _</span> = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>By default, apple also adds the following, empty, methods to a new <code>UIWindowSceneDelegate</code> conforming class, but you don't necessarily need them and can always add them later:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> sceneDidDisconnect(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneDidBecomeActive(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneWillResignActive(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneWillEnterForeground(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneDidEnterBackground(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n</code></pre></code></pre>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiscenedelegate?language=objc\">You can read more about them here.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"How do I create a scene delegate?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nMany of the macOS specific UIKit extensions require you to use a scene delegate. If your project was created before iOS 13 and you also don't intend to use multiple windows, you can follow these steps to add a scene delegate to your project and keep the app limited to one window:\n\nThe first step is to add a scene manifest to your `Info.plist`. [This can either be done in the Xcode plist editor](/img-content/catalyst/scene_manifest.png) or by adding the following lines to your `Info.plist` in source code mode (You can just keep the default names. They're fine):\n\n``` XML\n<key>UIApplicationSceneManifest</key>\n<dict>\n\t<key>UIApplicationSupportsMultipleScenes</key>\n\t<true/>\n\t<key>UISceneConfigurations</key>\n\t<dict>\n\t\t<key>UIWindowSceneSessionRoleApplication</key>\n\t\t<array>\n\t\t\t<dict>\n\t\t\t\t<key>UILaunchStoryboardName</key>\n\t\t\t\t<string>LaunchScreen</string>\n\t\t\t\t<key>UISceneConfigurationName</key>\n\t\t\t\t<string>Default Configuration</string>\n\t\t\t\t<key>UISceneDelegateClassName</key>\n\t\t\t\t<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>\n\t\t\t\t<key>UISceneStoryboardFile</key>\n\t\t\t\t<string>Main</string>\n\t\t\t</dict>\n\t\t</array>\n\t</dict>\n</dict>\n```\n\nNext, add the following two functions to your `AppDelegate`. Note that only one of them is used, but for posterity, it makes sense to add both in one go:\n\n``` swift\n    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {\n        // Called when a new scene session is being created.\n        // Use this method to select a configuration to create the new scene with.\n        return UISceneConfiguration(name: \"Default Configuration\", sessionRole: connectingSceneSession.role)\n    }\n\n    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {\n        // Called when the user discards a scene session.\n        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.\n        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.\n    }\n```\n\nFinally, add a new file, `SceneDelegate.swift` to your project and add the following code to it:\n\n``` swift\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.\n        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.\n        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).\n        guard let _ = (scene as? UIWindowScene) else { return }\n    }\n}\n```\n\nBy default, apple also adds the following, empty, methods to a new `UIWindowSceneDelegate` conforming class, but you don't necessarily need them and can always add them later:\n\n``` swift\nfunc sceneDidDisconnect(_ scene: UIScene)\nfunc sceneDidBecomeActive(_ scene: UIScene)\nfunc sceneWillResignActive(_ scene: UIScene)\nfunc sceneWillEnterForeground(_ scene: UIScene)\nfunc sceneDidEnterBackground(_ scene: UIScene)\n```\n\n[You can read more about them here.](https://developer.apple.com/documentation/uikit/uiscenedelegate?language=objc)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/objective_c_support.md":["28fa383ab9edc9bf",{"identifier":"03393500","filename":"objective_c_support.md","info":{"title":"Objective-C Support","tags":["objc","enum"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-objectivec-support.html","content":"<h1>Objective-C Support</h1>\n<p>Integer-based enums such as can be bridged to Objective-c via the <code>@objc</code> attribute:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">@objc enum</span> Bit: <span class=\"type\">Int</span> { \n\n   <span class=\"keyword\">case</span> zero = <span class=\"number\">0</span> \n\n   <span class=\"keyword\">case</span> one = <span class=\"number\">1</span>\n\n}\n</code></pre></code></pre>\n<p>However once you venture away from\nintegers (say <code>String</code>) or start using <code>associated values</code> you can't\nuse enums from within Objective-C.</p>\n<p>There is a manual way though. Add two methods to your\n<code>enum</code>, define a type replacement on the <code>@objc</code> side, and you can move\n<code>enums</code> back and forth just fine, without having to conform to private\nprotocols:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n}\n\n\n\n<span class=\"comment\">// This type could also exist in Objective-C code.</span>\n\n<span class=\"keyword\">@objc class</span> ObjcTrade: <span class=\"type\">NSObject</span> {\n\n     <span class=\"keyword\">var</span> type: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">var</span> stock: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> amount: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">init</span>(type: <span class=\"type\">Int</span>, stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>) {\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">type</span> = type\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">stock</span> = stock\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">amount</span> = amount\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Trade</span>  {\n\n\n\n     <span class=\"keyword\">func</span> toObjc() -&gt; <span class=\"type\">ObjcTrade</span> {\n\n         <span class=\"keyword\">switch self</span> {\n\n         <span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount):\n\n             <span class=\"keyword\">return</span> <span class=\"type\">ObjcTrade</span>(type: <span class=\"number\">0</span>, stock: stock, amount: amount)\n\n         <span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount):\n\n             <span class=\"keyword\">return</span> <span class=\"type\">ObjcTrade</span>(type: <span class=\"number\">1</span>, stock: stock, amount: amount)\n\n         }\n\n     }\n\n\n\n     <span class=\"keyword\">static func</span> fromObjc(source: <span class=\"type\">ObjcTrade</span>) -&gt; <span class=\"type\">Trade</span>? {\n\n         <span class=\"keyword\">switch</span> (source.<span class=\"property\">type</span>) {\n\n         <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(stock: source.<span class=\"property\">stock</span>, amount: source.<span class=\"property\">amount</span>)\n\n         <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"type\">Trade</span>.<span class=\"call\">sell</span>(stock: source.<span class=\"property\">stock</span>, amount: source.<span class=\"property\">amount</span>)\n\n         <span class=\"keyword\">default</span>: <span class=\"keyword\">return nil</span>\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This still has the downside that you need to mirror your <code>enum</code> via an\n<code>NSObject</code> based type on the Objective-C side (or you could just go and\nuse an <code>NSDictionary</code>), but if you ever end up in a situation where you\n<strong>need</strong> to access an enum with associated values from Objective-C, this\nis a way to do it.</p>\n","raw_content":"[frontMatter]\ntitle = \"Objective-C Support\"\ntags = [\"objc\", \"enum\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n---\n\n# Objective-C Support\n\nInteger-based enums such as can be bridged to Objective-c via the `@objc` attribute:\n\n``` Swift\n@objc enum Bit: Int { \n  case zero = 0 \n  case one = 1\n}\n```\n\nHowever once you venture away from\nintegers (say `String`) or start using `associated values` you can\\'t\nuse enums from within Objective-C.\n\nThere is a manual way though. Add two methods to your\n`enum`, define a type replacement on the `@objc` side, and you can move\n`enums` back and forth just fine, without having to conform to private\nprotocols:\n\n``` Swift\nenum Trade {\n    case buy(stock: String, amount: Int)\n    case sell(stock: String, amount: Int)\n}\n\n// This type could also exist in Objective-C code.\n@objc class ObjcTrade: NSObject {\n    var type: Int\n    var stock: String\n    var amount: Int\n    init(type: Int, stock: String, amount: Int) {\n        self.type = type\n        self.stock = stock\n        self.amount = amount\n    }\n}\n\nextension Trade  {\n\n    func toObjc() -> ObjcTrade {\n        switch self {\n        case let .buy(stock, amount):\n            return ObjcTrade(type: 0, stock: stock, amount: amount)\n        case let .sell(stock, amount):\n            return ObjcTrade(type: 1, stock: stock, amount: amount)\n        }\n    }\n\n    static func fromObjc(source: ObjcTrade) -> Trade? {\n        switch (source.type) {\n        case 0: return Trade.buy(stock: source.stock, amount: source.amount)\n        case 1: return Trade.sell(stock: source.stock, amount: source.amount)\n        default: return nil\n        }\n    }\n}\n```\n\nThis still has the downside that you need to mirror your `enum` via an\n`NSObject` based type on the Objective-C side (or you could just go and\nuse an `NSDictionary`), but if you ever end up in a situation where you\n**need** to access an enum with associated values from Objective-C, this\nis a way to do it.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/custom_new_window_entry.md":["9e0d070104fa36a8",{"identifier":"8ac8ac78","filename":"custom_new_window_entry.md","info":{"title":"How do I add a `New Window` entry to a custom MainMenu?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-add-a-new-window-entry-to-a-custom-mainmenu.html","content":"<p>Once you modify your Main Menu, you will find that the entry to create a new window has suddenly disappeared. That happens because the <code>New Window</code> entry is dynamicaly inserted by UIKit depending on whether your app supports multiple windows (or not).</p>\n<p>In order to support this again, you have to do the following:</p>\n<ol>\n<li>Create a new <code>UICommand</code> in your Storyboard for the <code>New Window</code> entry.</li>\n<li>Assign the title and your desired shortcut (probably Command + N).</li>\n<li>Select the <code>First Responder</code> in your <code>MainMenu Scene</code></li>\n</ol>\n<p><img src=\"/img-content/catalyst/storyfirstresponder.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>Switch to the <em>Attributes Inspector</em> (from the inspectors on the right)</li>\n<li>There, you will find an empty list named &quot;User Defined&quot;</li>\n<li>Add a new entry to this list with the following attributes:</li>\n<li>Action: <code>requestNewScene:</code>, Type: <code>id</code> (the default)</li>\n<li>Finally, drag from your <code>UICommand</code> menu entry to the First Responder and select the newly created action.</li>\n</ol>\n","raw_content":"[frontMatter]\ntitle = \"How do I add a `New Window` entry to a custom MainMenu?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nOnce you modify your Main Menu, you will find that the entry to create a new window has suddenly disappeared. That happens because the `New Window` entry is dynamicaly inserted by UIKit depending on whether your app supports multiple windows (or not).\n\nIn order to support this again, you have to do the following:\n\n1. Create a new `UICommand` in your Storyboard for the `New Window` entry.\n2. Assign the title and your desired shortcut (probably Command + N).\n3. Select the `First Responder` in your `MainMenu Scene`\n\n![](/img-content/catalyst/storyfirstresponder.png)\n\n4. Switch to the *Attributes Inspector* (from the inspectors on the right)\n5. There, you will find an empty list named \"User Defined\"\n6. Add a new entry to this list with the following attributes:\n7. Action: `requestNewScene:`, Type: `id` (the default)\n8. Finally, drag from your `UICommand` menu entry to the First Responder and select the newly created action.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/enable_disable_toolbar_items.md":["f25b2f4f9e267a69",{"identifier":"d244bb4c","filename":"enable_disable_toolbar_items.md","info":{"title":"How do I enable / disable toolbar items based on whats visible on screen?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-enable-disable-toolbar-items-based-on-whats-visible-on-screen.html","content":"<p>Currently, there doesn't seem to be a way to do this. I've tracked this as issue <em>FB6360289</em> in Apple's Feedback tool.</p>\n<p>I could not figure out how to dynamically update the enabled / disabled status of toolbar items based on app actions such as a new controller entering the responder chain. This makes it very difficult to implement toolbars that adapt to the users actions. Event Apple’s own Catalyst apps seem to be affected by this: The Stocks app has a “Share” toolbar item that just does nothing when pressed and nothing is selected (it is enabled, not disabled).</p>\n<p>The best solution is to have a singleton with access to the toolbar (or as a dependency injection) and then call a method on it that updates the contents of the toolbar. An easy way to do that is by iterating over the <code>toolbar.items</code> property and updating each entry accordingly (disabling / enabling).</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I enable / disable toolbar items based on whats visible on screen?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nCurrently, there doesn't seem to be a way to do this. I've tracked this as issue *FB6360289* in Apple's Feedback tool.\n\nI could not figure out how to dynamically update the enabled / disabled status of toolbar items based on app actions such as a new controller entering the responder chain. This makes it very difficult to implement toolbars that adapt to the users actions. Event Apple’s own Catalyst apps seem to be affected by this: The Stocks app has a “Share” toolbar item that just does nothing when pressed and nothing is selected (it is enabled, not disabled).\n\nThe best solution is to have a singleton with access to the toolbar (or as a dependency injection) and then call a method on it that updates the contents of the toolbar. An easy way to do that is by iterating over the `toolbar.items` property and updating each entry accordingly (disabling / enabling).\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/more_examples/interdig.md":["c24c210d16384a43",{"identifier":"335b7ae9","filename":"interdig.md","info":{"title":"Interdig","tags":["reduce","zip"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-interdig.html","content":"<h1>Interdig</h1>\n<p>This function allows you to combine two sequences by alternately\nselecting elements from each.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> interdig&lt;T&gt;(list1: [<span class=\"type\">T</span>], list2: [<span class=\"type\">T</span>]) -&gt; [<span class=\"type\">T</span>] {\n\n    <span class=\"keyword\">return</span> <span class=\"call\">zip</span>(list1, list2).<span class=\"call\">reduce</span>([], { (ac: [<span class=\"type\">T</span>], o: (<span class=\"type\">T</span>, <span class=\"type\">T</span>)) -&gt; [<span class=\"type\">T</span>] <span class=\"keyword\">in</span> \n\n         <span class=\"keyword\">return</span> ac + [o.<span class=\"number\">0</span>, o.<span class=\"number\">1</span>]\n\n    })\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">interdig</span>(list1: [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>], list2: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]))\n\n<span class=\"comment\">// : [1, 2, 3, 4, 5, 6]</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Interdig\"\ntags = [\"reduce\", \"zip\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Interdig\n\nThis function allows you to combine two sequences by alternately\nselecting elements from each.\n\n``` Swift\nfunc interdig<T>(list1: [T], list2: [T]) -> [T] {\n   return zip(list1, list2).reduce([], { (ac: [T], o: (T, T)) -> [T] in \n        return ac + [o.0, o.1]\n   })\n}\nprint(interdig(list1: [1, 3, 5], list2: [2, 4, 6]))\n// : [1, 2, 3, 4, 5, 6]\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/language_support/for_case.md":["d7b84babfb581fbc",{"identifier":"d35c6a1c","filename":"for_case.md","info":{"title":"For Case","tags":["pattern matching","switch","for","for case","where"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-for-case.html","content":"<h1>Using <strong>for case</strong></h1>\n<p>Let's write a simple array function which only returns the non-nil elements</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> nonnil&lt;T&gt;(array: [<span class=\"type\">T</span>?]) -&gt; [<span class=\"type\">T</span>] {\n\n    <span class=\"keyword\">var</span> result: [<span class=\"type\">T</span>] = []\n\n    <span class=\"keyword\">for case let</span> x? <span class=\"keyword\">in</span> array {\n\n       result.<span class=\"call\">append</span>(x)\n\n    }\n\n    <span class=\"keyword\">return</span> result\n\n}\n\n\n\n<span class=\"call\">print</span>(<span class=\"call\">nonnil</span>([\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">nil</span>, \\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"c</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">nil</span>]))\n</code></pre></code></pre>\n<p>The <code>case</code> keyword can be used in for loops just like in <code>switch</code> cases.\nHere's another example. Remember the game we talked about earlier?\nWell, after the first refactoring, our entity system now looks like\nthis:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Entity {\n\n     <span class=\"keyword\">enum</span> EntityType {\n\n         <span class=\"keyword\">case</span> soldier\n\n         <span class=\"keyword\">case</span> player\n\n     }\n\n     <span class=\"keyword\">case</span> <span class=\"type\">Entry</span>(type: <span class=\"type\">EntityType</span>, x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, hp: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>Fancy, this allows us to draw all items with even less code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for case let</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(t, x, y, <span class=\"keyword\">_</span>) <span class=\"keyword\">in</span> <span class=\"call\">gameEntities</span>()\n\n<span class=\"keyword\">where</span> x &gt; <span class=\"number\">0</span> &amp;&amp; y &gt; <span class=\"number\">0</span> {\n\n     <span class=\"call\">drawEntity</span>(t, x, y)\n\n}\n</code></pre></code></pre>\n<p>Our one line unwraps all the necessary properties, makes sure we're not\ndrawing beyond 0, and finally calls the render call (<code>drawEntity</code>).</p>\n<p>In order to see if the player won the game, we want to know if there is\nat least one Soldier with health &gt; 0</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> gameOver() -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">for case</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(.<span class=\"dotAccess\">soldier</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> hp) <span class=\"keyword\">in</span> <span class=\"call\">gameEntities</span>() \n\n     <span class=\"keyword\">where</span> hp &gt; <span class=\"number\">0</span> {<span class=\"keyword\">return false</span>}\n\n     <span class=\"keyword\">return true</span>\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">gameOver</span>())\n</code></pre></code></pre>\n<p>What's nice is that the <code>.soldier</code> match is part of the for query. This\nfeels a bit like <code>SQL</code> and less like imperative loop programming. Also,\nthis makes our intent clearer to the compiler, opening up the\npossibilities for dispatch enhancements down the road. Another nice\ntouch is that we don't have to spell out <code>Entity.EntityType.soldier</code>.\nSwift understands our intent even if we only write <code>.soldier</code> as above.</p>\n","raw_content":"[frontMatter]\ntitle = \"For Case\"\ntags = [\"pattern matching\", \"switch\", \"for\", \"for case\", \"where\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Using **for case**\n\nLet\\'s write a simple array function which only returns the non-nil elements\n\n``` Swift\nfunc nonnil<T>(array: [T?]) -> [T] {\n   var result: [T] = []\n   for case let x? in array {\n      result.append(x)\n   }\n   return result\n}\n\nprint(nonnil([\"a\", nil, \"b\", \"c\", nil]))\n```\n\nThe `case` keyword can be used in for loops just like in `switch` cases.\nHere\\'s another example. Remember the game we talked about earlier?\nWell, after the first refactoring, our entity system now looks like\nthis:\n\n``` Swift\nenum Entity {\n    enum EntityType {\n        case soldier\n        case player\n    }\n    case Entry(type: EntityType, x: Int, y: Int, hp: Int)\n}\n```\n\nFancy, this allows us to draw all items with even less code:\n\n``` Swift\nfor case let Entity.Entry(t, x, y, _) in gameEntities()\nwhere x > 0 && y > 0 {\n    drawEntity(t, x, y)\n}\n```\n\nOur one line unwraps all the necessary properties, makes sure we\\'re not\ndrawing beyond 0, and finally calls the render call (`drawEntity`).\n\nIn order to see if the player won the game, we want to know if there is\nat least one Soldier with health \\> 0\n\n``` Swift\nfunc gameOver() -> Bool {\n    for case Entity.Entry(.soldier, _, _, let hp) in gameEntities() \n    where hp > 0 {return false}\n    return true\n}\nprint(gameOver())\n```\n\nWhat\\'s nice is that the `.soldier` match is part of the for query. This\nfeels a bit like `SQL` and less like imperative loop programming. Also,\nthis makes our intent clearer to the compiler, opening up the\npossibilities for dispatch enhancements down the road. Another nice\ntouch is that we don\\'t have to spell out `Entity.EntityType.soldier`.\nSwift understands our intent even if we only write `.soldier` as above.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/language_support/if_case.md":["097097826a965570",{"identifier":"a9cb172e","filename":"if_case.md","info":{"title":"If Case","tags":["pattern matching","switch","if case"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-if-case.html","content":"<h1>Using <strong>if case</strong></h1>\n<p><code>if case</code> can be used as the opposite of <code>guard case</code>. It is a great way\nto unwrap and match data within a branch. In line with our previous\n<code>guard</code> example. Obviously, we need an move function. Something that\nallows us to say that an entity moved in a direction. Since our entities\nare <code>enums</code>, we need to return an updated entity.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> move(entity: <span class=\"type\">Entity</span>, xd: <span class=\"type\">Int</span>, yd: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Entity</span> {\n\n     <span class=\"keyword\">if case</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(<span class=\"keyword\">let</span> t, <span class=\"keyword\">let</span> x, <span class=\"keyword\">let</span> y, <span class=\"keyword\">let</span> hp) = entity\n\n     <span class=\"keyword\">where</span> (x + xd) &lt; <span class=\"number\">1000</span> &amp;&amp;\n\n         (y + yd) &lt; <span class=\"number\">1000</span> {\n\n     <span class=\"keyword\">return</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: t, x: (x + xd), y: (y + yd), hp: hp)\n\n     }\n\n     <span class=\"keyword\">return</span> entity\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">move</span>(<span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: .<span class=\"dotAccess\">soldier</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>, hp: <span class=\"number\">79</span>), xd: <span class=\"number\">30</span>, yd: <span class=\"number\">500</span>))\n\n<span class=\"comment\">// prints: Entry(main.Entity.EntityType.soldier, 40, 510, 79)</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"If Case\"\ntags = [\"pattern matching\", \"switch\", \"if case\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Using **if case**\n\n`if case` can be used as the opposite of `guard case`. It is a great way\nto unwrap and match data within a branch. In line with our previous\n`guard` example. Obviously, we need an move function. Something that\nallows us to say that an entity moved in a direction. Since our entities\nare `enums`, we need to return an updated entity.\n\n``` Swift\nfunc move(entity: Entity, xd: Int, yd: Int) -> Entity {\n    if case Entity.Entry(let t, let x, let y, let hp) = entity\n    where (x + xd) < 1000 &&\n        (y + yd) < 1000 {\n    return Entity.Entry(type: t, x: (x + xd), y: (y + yd), hp: hp)\n    }\n    return entity\n}\nprint(move(Entity.Entry(type: .soldier, x: 10, y: 10, hp: 79), xd: 30, yd: 500))\n// prints: Entry(main.Entity.EntityType.soldier, 40, 510, 79)\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/conditional_code.md":["eb6b9b1b4f450e6e",{"identifier":"e3f145b2","filename":"conditional_code.md","info":{"title":"How do I write code that only runs on macOS?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-write-code-that-only-runs-on-macos.html","content":"<p>You can implement conditional code via the new <code>targetEnvironment(UIKitForMac</code> directive:</p>\n<h2>Compile code only on the macOS target</h2>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyToolbar</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<h2>Compile code only on the iOS target</h2>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if !targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">import</span> ARKit\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I write code that only runs on macOS?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nYou can implement conditional code via the new `targetEnvironment(UIKitForMac` directive:\n\n## Compile code only on the macOS target\n\n``` swift\n#if targetEnvironment(UIKitForMac)\n  let toolbar = NSToolbar(identifier: \"MyToolbar\")\n#endif\n```\n\n## Compile code only on the iOS target\n\n``` swift\n#if !targetEnvironment(UIKitForMac)\n  import ARKit\n#endif\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/tips/cast_types.md":["604b93bba721a69d",{"identifier":"419ce0f4","filename":"cast_types.md","info":{"title":"Cast Types","tags":["keypath","casting","type-cast","anykeypath","erase"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-cast-types.html","content":"<h1>2. Cast Types Back</h1>\n<p>This is the opposite of what we just did. Instead of removing types, we're adding types back:</p>\n<pre class=\"Swift\"><code><span class=\"type\">AnyKeyPath</span> <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt;\n\n<span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; <span class=\"keyword\">as</span>? <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">Bool</span>&gt;\n</code></pre></code></pre>\n<p>Sometimes you might need to add generics in order to keep the necessary types around to perform the correct casting. An example of this was how we wrote</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>)\n</code></pre></code></pre>\n<p>instead of the simpler:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings(provider: <span class=\"type\">SettingsProvider</span>)\n</code></pre></code></pre>\n<p>The second version would work just as fine, but it would not allow us to use <code>Provider</code> as the <code>Root</code> type in our <code>WritableKeyPath&lt;Provider, Bool&gt;</code> cast.</p>\n","raw_content":"[frontMatter]\ntitle = \"Cast Types\"\ntags = [\"keypath\", \"casting\", \"type-cast\", \"anykeypath\", \"erase\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# 2. Cast Types Back\n\nThis is the opposite of what we just did. Instead of removing types, we're adding types back:\n\n``` Swift\nAnyKeyPath as? WritableKeyPath<User, String>\nPartialKeyPath<User> as? KeyPath<User, Bool>\n```\n\nSometimes you might need to add generics in order to keep the necessary types around to perform the correct casting. An example of this was how we wrote\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider)\n```\n\ninstead of the simpler:\n\n``` Swift\nfunc editSettings(provider: SettingsProvider)\n```\n\nThe second version would work just as fine, but it would not allow us to use `Provider` as the `Root` type in our `WritableKeyPath<Provider, Bool>` cast.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2019-02-24-anonymous-tuple-structs.md":["675dd03ce6bdb38c",{"identifier":"7b860d9e","filename":"2019-02-24-anonymous-tuple-structs.md","info":{"title":"Cleaner Classes with Structs and Tuples","tags":["tuple","struct"],"keywords":["ios","macos","swift","tuples","classes","structs"],"category":[],"created":"2019-02-24 10:30:30","description":"An easy way to add more structure to your classes by leveraging structs and enums","description_html":"<p>An easy way to add more structure to your classes by leveraging structs and enums</p>\n","published":true,"slug":"2019-02-24-anonymous-tuple-structs.html","meta":{"feature_image":"https://appventure.me/img-content/2019-02-24-anonymous-tuple-structs.jpg","thumbnail":"/img-content/tuple_structure.png"},"created_timestamp":1551004230,"date":"2019-02-24T10:30:30","date_info":{"year":2019,"month":2,"day":24,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2019-02-24-anonymous-tuple-structs.html","content":"<p>Imagine you're working on a social networking app and you have a\ncontroller that is responsible for displaying a user image with a follow\nand a like button. Imagine also, that - in line with the single\nresponsibility principle and view controller composition - the\n<strong><strong>like</strong></strong> and <strong><strong>follow</strong></strong> functionality is handled somewhere else.\nOur social network does have premium user accounts as well as corporate\nuser accounts (companies) and so there're a couple of configuration\noptions available for your <code>InteractiveUserImageController</code> (naming was\nnever my strong suit). One possible option of our class could look\n(partially) like this (for demonstration purposes, there're obviously a\nlot of things that we can change here):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> InteractiveUserImageController: <span class=\"type\">UIView</span> {\n\n     <span class=\"comment\">/// Should the Premium Layout be used</span>\n\n     <span class=\"keyword\">var</span> isPremium: <span class=\"type\">Bool</span>\n\n     <span class=\"comment\">/// What kind of account do we have</span>\n\n     <span class=\"keyword\">var</span> accountType: <span class=\"type\">AccountType</span>\n\n     <span class=\"comment\">/// Tapping the view will highlight it</span>\n\n     <span class=\"keyword\">var</span> isHighlighted: <span class=\"type\">Bool</span>\n\n     <span class=\"comment\">/// The username to display</span>\n\n     <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n     <span class=\"comment\">/// The profile image to display</span>\n\n     <span class=\"keyword\">var</span> profileImage: <span class=\"type\">UIImage</span>\n\n     <span class=\"comment\">/// Can the current user like this user</span>\n\n     <span class=\"keyword\">var</span> canLike: <span class=\"type\">Bool</span>\n\n     <span class=\"comment\">/// Can the current user follow this user</span>\n\n     <span class=\"keyword\">var</span> canFollow: <span class=\"type\">Bool</span>\n\n     <span class=\"comment\">/// Should the big like button be used</span>\n\n     <span class=\"keyword\">var</span> bigLikeButton: <span class=\"type\">Bool</span>\n\n     <span class=\"comment\">/// For some containers we need a special background color</span>\n\n     <span class=\"keyword\">var</span> alternativeBackgroundColor: <span class=\"type\">Bool</span>\n\n\n\n     <span class=\"keyword\">init</span>(...) {}\n\n}\n</code></pre></code></pre>\n<p>Now, these are a lot of properties. As our app grows, we might end up\nadding even more properties here. Of course, we can refactor and group\nthem by responsibility, but sometimes single responsibility still leads\nto quite a few properties. So how can we possibly structure this a bit\nbetter?</p>\n<h2>Swift Struct Structure</h2>\n<p>Swift's <code>struct</code> types can actually be really helpful here. What we can\ndo is group these properties by their type by moving them into\n<strong>one-time</strong> structs:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> InteractiveUserImageController: <span class=\"type\">UIView</span> {\n\n     <span class=\"keyword\">struct</span> DisplayOptions {\n\n         <span class=\"comment\">/// Should the big like button be used</span>\n\n         <span class=\"keyword\">var</span> bigLikeButton: <span class=\"type\">Bool</span>\n\n         <span class=\"comment\">/// For some containers we need a special background color</span>\n\n         <span class=\"keyword\">var</span> alternativeBackgroundColor: <span class=\"type\">Bool</span>\n\n         <span class=\"comment\">/// Should the Premium Layout be used</span>\n\n         <span class=\"keyword\">var</span> isPremium: <span class=\"type\">Bool</span>\n\n     }\n\n     <span class=\"keyword\">struct</span> UserOptions {\n\n         <span class=\"comment\">/// What kind of account do we have</span>\n\n         <span class=\"keyword\">var</span> accountType: <span class=\"type\">AccountType</span>\n\n         <span class=\"comment\">/// The username to display</span>\n\n         <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n         <span class=\"comment\">/// The profile image to display</span>\n\n         <span class=\"keyword\">var</span> profileImage: <span class=\"type\">UIImage</span>\n\n     }\n\n     <span class=\"keyword\">struct</span> State {\n\n         <span class=\"comment\">/// Tapping the view will highlight it</span>\n\n         <span class=\"keyword\">var</span> isHighlighted: <span class=\"type\">Bool</span>\n\n         <span class=\"comment\">/// Can the current user like this user</span>\n\n         <span class=\"keyword\">var</span> canLike: <span class=\"type\">Bool</span>\n\n         <span class=\"comment\">/// Can the current user follow this user</span>\n\n         <span class=\"keyword\">var</span> canFollow: <span class=\"type\">Bool</span>\n\n     }\n\n\n\n     <span class=\"keyword\">var</span> displayOptions = <span class=\"type\">DisplayOptions</span>(...)\n\n     <span class=\"keyword\">var</span> userOptions = <span class=\"type\">UserOptions</span>(...)\n\n     <span class=\"keyword\">var</span> state = <span class=\"type\">State</span>(...)\n\n\n\n     <span class=\"keyword\">init</span>(...) {}\n\n}\n</code></pre></code></pre>\n<p>As you can see, what we've done here is we moved the state into\nseperate <code>struct</code> types. Not only does this make the class cleaner, it\nalso makes it easier for new developers to find related options.</p>\n<p>This is already a very nice improvement, but we can do even better!</p>\n<p>The issue we have here is that there is an additional step involved when\nlooking up a property.</p>\n<p>Since we're using one-time struct types we have to define them\nsomewhere, (i.e. <code>struct DisplayOptions</code>), but we also have to\ninstantiate them somewhere (i.e.\n<code>let displayOptions = DisplayOptions(...)</code>. This is in general <strong>ok</strong>,\nbut in larger classes this might still require an additional lookup to\nfigure out the type of <code>displayOptions</code>. However, there is no way in\nSwift to create anonymous <code>struct</code> types like this <sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> displayOptions = <span class=\"keyword\">struct</span> {\n\n     <span class=\"comment\">/// Should the big like button be used</span>\n\n     <span class=\"keyword\">var</span> bigLikeButton: <span class=\"type\">Bool</span>\n\n     <span class=\"comment\">/// For some containers we need a special background color</span>\n\n     <span class=\"keyword\">var</span> alternativeBackgroundColor: <span class=\"type\">Bool</span>\n\n     <span class=\"comment\">/// Should the Premium Layout be used</span>\n\n     <span class=\"keyword\">var</span> isPremium: <span class=\"type\">Bool</span>\n\n}\n</code></pre></code></pre>\n<h2>Anonymous Structs nee Tuples</h2>\n<p>Actually, there is such a type in Swift. It is our good old friend, the\n<code>tuple</code>. See for yourself:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> displayOptions: (\n\n   bigLikeButton: <span class=\"type\">Bool</span>,\n\n   alternativeBackgroundColor: <span class=\"type\">Bool</span>,\n\n   isPremium: <span class=\"type\">Bool</span>\n\n)\n</code></pre></code></pre>\n<p>This defines a new type <code>displayOptions</code> that has three properties\n(<code>bigLikeButton</code>, <code>alternativeBackgroundColor</code>, <code>isPremium</code>) and can be\naccessed just like our <code>struct</code> from earlier:</p>\n<pre class=\"Swift\"><code>user.<span class=\"property\">displayOptions</span>.<span class=\"property\">alternativeBackgroundColor</span> = <span class=\"keyword\">true</span>\n</code></pre></code></pre>\n<p>Even better, the defintion does not need an additional initialization,\nso everything is in the same place.</p>\n<h2>Enforced Immutability</h2>\n<p>Finally, the whole <code>tuple</code> is either <code>mutable</code> or <code>immutable</code>. You can\nsee that in the first line: We're defining <code>var displayOptions</code> but no\n<code>var</code> or <code>let</code> <code>bigLikeButton</code>. <code>bigLikeButton</code> is also a <code>var</code> just\nlike <code>displayOptions</code>. The advantage of this is that this enforces\nmoving static constant properties (i.e. line height, header height) into\na different (<code>let</code>) group than mutable properties.</p>\n<h2>Add some data</h2>\n<p>As a nice addition, you can also use this feature when you need to\ninitialize these properties with values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> displayOptions = (\n\n   bigLikeButton: <span class=\"keyword\">true</span>,\n\n   alternativeBackgroundColor: <span class=\"keyword\">false</span>,\n\n   isPremium: <span class=\"keyword\">false</span>,\n\n   defaultUsername: \\<span class=\"string\">\"Anonymous</span>\\<span class=\"string\">\"</span>\n\n)\n</code></pre></code></pre>\n<p>Very similar to the earlier code, this defines a tuple of options but\nalso initializes them with the correct values right away.</p>\n<h2>Nesting</h2>\n<p>Naturally, you can also nest these tuple options easily, which makes it\neven easier compared to our original struct approach:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> UserFollowComponent {\n\n     <span class=\"keyword\">var</span> displayOptions = (\n\n         likeButton: (\n\n             bigButton: <span class=\"keyword\">true</span>,\n\n             alternativeBackgroundColor: <span class=\"keyword\">true</span>\n\n             ),\n\n         imageView: (\n\n             highlightLineWidth: <span class=\"number\">2.0</span>,\n\n             defaultColor: \\<span class=\"string\">\"#33854</span>\\<span class=\"string\">\"</span>\n\n         )\n\n     )\n\n}\n</code></pre></code></pre>\n<p>I hope you found this article useful. I'm using this simple pattern\nquit a lot in order to give my code more structure. Sometimes only for\n2-3 properties, but even then it is already beneficial.</p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>Unlike C</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"An easy way to add more structure to your classes by leveraging structs and enums\"\ntitle = \"Cleaner Classes with Structs and Tuples\"\ncreated = \"2019-02-24\"\npublished = true\nkeywords = [\"ios\", \"macos\", \"swift\", \"tuples\", \"classes\", \"structs\"]\nslug = \"2019-02-24-anonymous-tuple-structs.html\"\ntags = [\"tuple\", \"struct\"]\n[meta]\nfeature_image = \"https://appventure.me/img-content/2019-02-24-anonymous-tuple-structs.jpg\"\nthumbnail = \"/img-content/tuple_structure.png\"\n---\n\nImagine you\\'re working on a social networking app and you have a\ncontroller that is responsible for displaying a user image with a follow\nand a like button. Imagine also, that - in line with the single\nresponsibility principle and view controller composition - the\n****like**** and ****follow**** functionality is handled somewhere else.\nOur social network does have premium user accounts as well as corporate\nuser accounts (companies) and so there\\'re a couple of configuration\noptions available for your `InteractiveUserImageController` (naming was\nnever my strong suit). One possible option of our class could look\n(partially) like this (for demonstration purposes, there\\'re obviously a\nlot of things that we can change here):\n\n``` Swift\nfinal class InteractiveUserImageController: UIView {\n    /// Should the Premium Layout be used\n    var isPremium: Bool\n    /// What kind of account do we have\n    var accountType: AccountType\n    /// Tapping the view will highlight it\n    var isHighlighted: Bool\n    /// The username to display\n    var username: String\n    /// The profile image to display\n    var profileImage: UIImage\n    /// Can the current user like this user\n    var canLike: Bool\n    /// Can the current user follow this user\n    var canFollow: Bool\n    /// Should the big like button be used\n    var bigLikeButton: Bool\n    /// For some containers we need a special background color\n    var alternativeBackgroundColor: Bool\n\n    init(...) {}\n}\n```\n\nNow, these are a lot of properties. As our app grows, we might end up\nadding even more properties here. Of course, we can refactor and group\nthem by responsibility, but sometimes single responsibility still leads\nto quite a few properties. So how can we possibly structure this a bit\nbetter?\n\n## Swift Struct Structure\n\nSwift\\'s `struct` types can actually be really helpful here. What we can\ndo is group these properties by their type by moving them into\n**one-time** structs:\n\n``` Swift\nfinal class InteractiveUserImageController: UIView {\n    struct DisplayOptions {\n        /// Should the big like button be used\n        var bigLikeButton: Bool\n        /// For some containers we need a special background color\n        var alternativeBackgroundColor: Bool\n        /// Should the Premium Layout be used\n        var isPremium: Bool\n    }\n    struct UserOptions {\n        /// What kind of account do we have\n        var accountType: AccountType\n        /// The username to display\n        var username: String\n        /// The profile image to display\n        var profileImage: UIImage\n    }\n    struct State {\n        /// Tapping the view will highlight it\n        var isHighlighted: Bool\n        /// Can the current user like this user\n        var canLike: Bool\n        /// Can the current user follow this user\n        var canFollow: Bool\n    }\n\n    var displayOptions = DisplayOptions(...)\n    var userOptions = UserOptions(...)\n    var state = State(...)\n\n    init(...) {}\n}\n```\n\nAs you can see, what we\\'ve done here is we moved the state into\nseperate `struct` types. Not only does this make the class cleaner, it\nalso makes it easier for new developers to find related options.\n\nThis is already a very nice improvement, but we can do even better!\n\nThe issue we have here is that there is an additional step involved when\nlooking up a property.\n\nSince we\\'re using one-time struct types we have to define them\nsomewhere, (i.e. `struct DisplayOptions`), but we also have to\ninstantiate them somewhere (i.e.\n`let displayOptions = DisplayOptions(...)`. This is in general **ok**,\nbut in larger classes this might still require an additional lookup to\nfigure out the type of `displayOptions`. However, there is no way in\nSwift to create anonymous `struct` types like this [^1]:\n\n``` Swift\nlet displayOptions = struct {\n    /// Should the big like button be used\n    var bigLikeButton: Bool\n    /// For some containers we need a special background color\n    var alternativeBackgroundColor: Bool\n    /// Should the Premium Layout be used\n    var isPremium: Bool\n}\n```\n\n## Anonymous Structs nee Tuples\n\nActually, there is such a type in Swift. It is our good old friend, the\n`tuple`. See for yourself:\n\n``` Swift\nvar displayOptions: (\n  bigLikeButton: Bool,\n  alternativeBackgroundColor: Bool,\n  isPremium: Bool\n)\n```\n\nThis defines a new type `displayOptions` that has three properties\n(`bigLikeButton`, `alternativeBackgroundColor`, `isPremium`) and can be\naccessed just like our `struct` from earlier:\n\n``` Swift\nuser.displayOptions.alternativeBackgroundColor = true\n```\n\nEven better, the defintion does not need an additional initialization,\nso everything is in the same place.\n\n## Enforced Immutability\n\nFinally, the whole `tuple` is either `mutable` or `immutable`. You can\nsee that in the first line: We\\'re defining `var displayOptions` but no\n`var` or `let` `bigLikeButton`. `bigLikeButton` is also a `var` just\nlike `displayOptions`. The advantage of this is that this enforces\nmoving static constant properties (i.e. line height, header height) into\na different (`let`) group than mutable properties.\n\n## Add some data\n\nAs a nice addition, you can also use this feature when you need to\ninitialize these properties with values:\n\n``` Swift\nvar displayOptions = (\n  bigLikeButton: true,\n  alternativeBackgroundColor: false,\n  isPremium: false,\n  defaultUsername: \"Anonymous\"\n)\n```\n\nVery similar to the earlier code, this defines a tuple of options but\nalso initializes them with the correct values right away.\n\n## Nesting\n\nNaturally, you can also nest these tuple options easily, which makes it\neven easier compared to our original struct approach:\n\n``` Swift\nclass UserFollowComponent {\n    var displayOptions = (\n        likeButton: (\n            bigButton: true,\n            alternativeBackgroundColor: true\n            ),\n        imageView: (\n            highlightLineWidth: 2.0,\n            defaultColor: \"#33854\"\n        )\n    )\n}\n```\n\nI hope you found this article useful. I\\'m using this simple pattern\nquit a lot in order to give my code more structure. Sometimes only for\n2-3 properties, but even then it is already beneficial.\n\n[^1]: Unlike C\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2017-09-30-value-types-for-simple-difference-detection.md":["e90f1722beea6762",{"identifier":"b696ee33","filename":"2017-09-30-value-types-for-simple-difference-detection.md","info":{"title":"Value Types for Simple Difference Detection","tags":["struct","value type"],"keywords":["swift","value","types","uitableview","uicollectionview","valuetypes","struct","class","equatable","tuple"],"category":["Swift Tricks","All"],"created":"2017-09-30 10:30:30","description":"Utilize value types to quickly determine a differences between two sets of data","description_html":"<p>Utilize value types to quickly determine a differences between two sets of data</p>\n","published":true,"slug":"2017-09-30-value-types-for-simple-difference-detection.html","meta":{"swift_version":"4.0","thumbnail":"/img-content/value_types_diff.png"},"created_timestamp":1506767430,"date":"2017-09-30T10:30:30","date_info":{"year":2017,"month":9,"day":30,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2017-09-30-value-types-for-simple-difference-detection.html","content":"<p>Following sage advice I received from <a href=\"https://www.swiftbysundell.com/\">John\nSundell</a> half a year ago (I am a slow\nlearner) I will try to write about smaller pieces instead of focusing on\nlongform content. This should make it easier to update appventure more\noften. Thanks John!.</p>\n<p>Today, I'll write about value types: Value types are a very useful\naddition to Swift. Objective-C did offer C <code>struct</code> types and\n(obviously) classical value types such as numbers, but Swift goes way\nbeyond that by allowing us to also define more complex structures such\nas <code>Array</code>, <code>Set</code>, or <code>Dictionary</code> as value types. One of the best\nproperties of value types is that they can easily be compared given that\nthey're values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> one = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]\n\n<span class=\"keyword\">let</span> two = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]\n\n<span class=\"call\">print</span>(one == two) <span class=\"comment\">// returns true</span>\n</code></pre></code></pre>\n<p>This way of easily comparing arrays is something we can use to implement\na simple difference detection algorithm without using more heavy-weight\nsolutions. Imagine you have a simple app that downloads a list of\nentries from a server and displays them in a table view. Once a minute\nyou download a new list and reload the table view. This is not a\nparticularly nice solution as you're reloading the table view even when\nthere're no changes. If your data is defined as a <code>struct</code> and you\nimplement the <code>Equatable</code> protocol, then you can simply use the equality\noperator to see if the table view needs to be reloaded:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Data: <span class=\"type\">Equatable</span> {\n\n   <span class=\"keyword\">let</span> username: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">let</span> userid: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">static func</span> ==(lhs: <span class=\"type\">Data</span>, rhs: <span class=\"type\">Data</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">return</span> lhs.<span class=\"property\">username</span> == rhs.<span class=\"property\">username</span> &amp;&amp; lhs.<span class=\"property\">userid</span> == rhs.<span class=\"property\">userid</span>\n\n   }\n\n}\n\n<span class=\"keyword\">let</span> oldData: [<span class=\"type\">Data</span>] = <span class=\"call\">currentData</span>()\n\n<span class=\"keyword\">let</span> newData: [<span class=\"type\">Data</span>] = <span class=\"call\">retrieveNewData</span>()\n\n<span class=\"keyword\">guard</span> oldData != newData <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">return</span>\n\n}\n\n<span class=\"call\">updateData</span>(with: newData)\n</code></pre></code></pre>\n<p>However, it may be that your data is modelled using <code>struct</code> types, but\nthat they're very complex and change often. So you've never\nimplemented <code>Equatable</code>. Then you have three different options:</p>\n<ol>\n<li>Wait for Swift 4.1 which will <a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0185-synthesize-equatable-hashable.md\">hopefully merge a PR which will\nauto-generate</a>\n<code>Equatable</code> for <code>struct</code> types if all properties of a <code>struct</code> also\nconform to <code>Equatable</code>.</li>\n<li>Use Krzysztof Zabłocki's\n<a href=\"https://github.com/krzysztofzablocki/Sourcery\">Sourcery</a> which is a\nmeta programming framework that allows you to auto generate things\nlike <code>Equatable</code> conformance for your types (and much more).</li>\n<li>This I will explain in more detail as it is also a pattern that you\ncan use if your data is modelled using <code>class</code> types.</li>\n</ol>\n<p>The idea here is to store just the absolutely necessary information in a\nseperate difference detection cache. Imagine the following data model:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> Story {\n\n   <span class=\"keyword\">let</span> story_id: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">let</span> views: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">let</span> last_updated: <span class=\"type\">TimeInterval</span>\n\n   <span class=\"keyword\">let</span> description: <span class=\"type\">String</span>\n\n}\n</code></pre></code></pre>\n<p>In this example, a Story will never change its id and description. In\norder to create a simple cache, we can now just use the information we\nabsolutely need to determine a change and store them in tuples. Tuples\nwith up to 6 elements will automatically generate <code>Equatable</code>\nconformance:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> a = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n\n<span class=\"keyword\">let</span> b = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n\n<span class=\"call\">print</span>(a == b)\n</code></pre></code></pre>\n<p>With this in mind, we can generate our tuples:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> newInformation: [(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">TimeInterval</span>)] = \n\n   stories.<span class=\"call\">map</span>({ ($0.<span class=\"property\">story_id</span>, $0.<span class=\"property\">views</span>, $0.<span class=\"property\">last_updated</span>) })\n\n\n\n<span class=\"keyword\">guard</span> newInformation != oldInformation <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n</code></pre></code></pre>\n<p>This is a simple solution that leverages value types to give us an easy\nsolution for comparing sets of data. However, if you also need to\ndetermine insertions, deletions and moves then you can still do so with\nvalue types, but you need a proper diff algorithm such as\n<a href=\"https://github.com/jflinter/Dwifft\">Dwifft</a>.</p>\n<p>Nevertheless, for many simpler use cases it is good to remember that we\ncan easily build a comparison cache of tuples or structs to determine\ngeneral changes to data.</p>\n","raw_content":"[frontMatter]\ndescription = \"Utilize value types to quickly determine a differences between two sets of data\"\ntitle = \"Value Types for Simple Difference Detection\"\ncreated = \"2017-09-30\"\npublished = true\nkeywords = [\"swift\", \"value\", \"types\", \"uitableview\", \"uicollectionview\", \"valuetypes\", \"struct\", \"class\", \"equatable\", \"tuple\"]\nslug = \"2017-09-30-value-types-for-simple-difference-detection.html\"\ntags = [\"struct\", \"value type\"]\ncategory = [\"Swift Tricks\", \"All\"]\n\n[meta]\nswift_version = \"4.0\"\nthumbnail = \"/img-content/value_types_diff.png\"\n---\n\nFollowing sage advice I received from [John\nSundell](https://www.swiftbysundell.com/) half a year ago (I am a slow\nlearner) I will try to write about smaller pieces instead of focusing on\nlongform content. This should make it easier to update appventure more\noften. Thanks John!.\n\nToday, I\\'ll write about value types: Value types are a very useful\naddition to Swift. Objective-C did offer C `struct` types and\n(obviously) classical value types such as numbers, but Swift goes way\nbeyond that by allowing us to also define more complex structures such\nas `Array`, `Set`, or `Dictionary` as value types. One of the best\nproperties of value types is that they can easily be compared given that\nthey\\'re values:\n\n``` Swift\nlet one = [1, 2, 3]\nlet two = [1, 2, 3]\nprint(one == two) // returns true\n```\n\nThis way of easily comparing arrays is something we can use to implement\na simple difference detection algorithm without using more heavy-weight\nsolutions. Imagine you have a simple app that downloads a list of\nentries from a server and displays them in a table view. Once a minute\nyou download a new list and reload the table view. This is not a\nparticularly nice solution as you\\'re reloading the table view even when\nthere\\'re no changes. If your data is defined as a `struct` and you\nimplement the `Equatable` protocol, then you can simply use the equality\noperator to see if the table view needs to be reloaded:\n\n``` Swift\nstruct Data: Equatable {\n  let username: String\n  let userid: Int\n  static func ==(lhs: Data, rhs: Data) -> Bool {\n    return lhs.username == rhs.username && lhs.userid == rhs.userid\n  }\n}\nlet oldData: [Data] = currentData()\nlet newData: [Data] = retrieveNewData()\nguard oldData != newData else {\n    return\n}\nupdateData(with: newData)\n```\n\nHowever, it may be that your data is modelled using `struct` types, but\nthat they\\'re very complex and change often. So you\\'ve never\nimplemented `Equatable`. Then you have three different options:\n\n1.  Wait for Swift 4.1 which will [hopefully merge a PR which will\n    auto-generate](https://github.com/apple/swift-evolution/blob/master/proposals/0185-synthesize-equatable-hashable.md)\n    `Equatable` for `struct` types if all properties of a `struct` also\n    conform to `Equatable`.\n2.  Use Krzysztof Zabłocki\\'s\n    [Sourcery](https://github.com/krzysztofzablocki/Sourcery) which is a\n    meta programming framework that allows you to auto generate things\n    like `Equatable` conformance for your types (and much more).\n3.  This I will explain in more detail as it is also a pattern that you\n    can use if your data is modelled using `class` types.\n\nThe idea here is to store just the absolutely necessary information in a\nseperate difference detection cache. Imagine the following data model:\n\n``` Swift\nfinal class Story {\n  let story_id: Int\n  let views: Int\n  let last_updated: TimeInterval\n  let description: String\n}\n```\n\nIn this example, a Story will never change its id and description. In\norder to create a simple cache, we can now just use the information we\nabsolutely need to determine a change and store them in tuples. Tuples\nwith up to 6 elements will automatically generate `Equatable`\nconformance:\n\n``` Swift\nlet a = (1, 2, 3)\nlet b = (1, 2, 3)\nprint(a == b)\n```\n\nWith this in mind, we can generate our tuples:\n\n``` Swift\nlet newInformation: [(Int, Int, TimeInterval)] = \n  stories.map({ ($0.story_id, $0.views, $0.last_updated) })\n\nguard newInformation != oldInformation else { return }\n```\n\nThis is a simple solution that leverages value types to give us an easy\nsolution for comparing sets of data. However, if you also need to\ndetermine insertions, deletions and moves then you can still do so with\nvalue types, but you need a proper diff algorithm such as\n[Dwifft](https://github.com/jflinter/Dwifft).\n\nNevertheless, for many simpler use cases it is good to remember that we\ncan easily build a comparison cache of tuples or structs to determine\ngeneral changes to data.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/map.md":["3a575cbeb766884b",{"identifier":"c94b8a5b","filename":"map.md","info":{"title":"Map, compactMap & Filter","tags":["map","compactMap","filter","reduce"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-map-compactmap-filter.html","content":"<h1>Map</h1>\n<p>Lets re-implement <code>map</code> and call it <code>rmap</code> (short for <code>reduce map</code>)</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rmap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), combine: { \n\n       (<span class=\"keyword\">var</span> acc: [<span class=\"type\">Int</span>], obj: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n        acc.<span class=\"call\">append</span>(<span class=\"call\">transform</span>(obj))\n\n        <span class=\"keyword\">return</span> acc\n\n     })\n\n}\n\n<span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]\n\n<span class=\"keyword\">let</span> output = <span class=\"call\">rmap</span>(input, transform: { $0 * <span class=\"number\">2</span>})\n\n<span class=\"call\">assert</span>(output == [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>])\n</code></pre></code></pre>\n<p>This is a good example to understand the basics of <code>reduce</code>.</p>\n<ul>\n<li>First, we're calling reduce on a sequence of elements\n<code>elements.reduce...</code>.</li>\n<li>Next, We're giving it the accumulator, i.e. an empty Int array,\nwhich will form or return type / result <code>[Int]()</code></li>\n<li>After that, we're handing in the <code>combinator</code> which takes two\nparameters. The first is the accumulator which we just provided\n<code>acc: [Int]</code>, the second is the current object from our sequence\n<code>obj: Int</code>.</li>\n<li>The actual code in the <code>combinator</code> is simple. We simply transform\nthe obj and append it onto the accumulator. We then return the\naccumulator.</li>\n</ul>\n<p>This looks like much more code than just calling <code>map</code>. That's indeed\ntrue, but the version above is extra detailed in order to better explain\nhow <code>reduce</code> works. We can simplify it.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rmap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), combine: {$0 + [<span class=\"call\">transform</span>($1)]})\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">rmap</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], transform: { $0 * <span class=\"number\">2</span>}))\n\n<span class=\"comment\">// [2, 4, 6, 8]</span>\n</code></pre></code></pre>\n<p>This still works fine. What happened here? We're using the convenient\nfact that in Swift, the <code>+</code> operator also works for two sequences. So\n<code>[0, 1, 2] + [transform(4)]</code> takes the left sequence and adds the right\nsequence, consisting out of the transformed element, to it.</p>\n<p>It should be noted that, as of right now, <code>[1, 2, 3] + [4]</code> is slower\nthan <code>[1, 2, 3].append(4)</code>. If you operate on huge lists, instead of\nusing collection + collection, you should have a mutable accumulator and\nmutate it in place:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rmap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), combine: { (<span class=\"keyword\">var</span> ac: [<span class=\"type\">Int</span>], b: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span> \n\n         ac.<span class=\"call\">append</span>(<span class=\"call\">transform</span>(b))\n\n         <span class=\"keyword\">return</span> ac\n\n     })\n\n}\n</code></pre></code></pre>\n<p>In order to better understand <code>reduce</code> we will now go on and also\nimplement <code>compactMap</code> and <code>filter</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rcompactMap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>?) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), \n\n        combine: { <span class=\"keyword\">guard let</span> m = <span class=\"call\">transform</span>($1) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> $0 } \n\n                   <span class=\"keyword\">return</span> $0 + [m]})\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">rcompactMap</span>([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], transform: { <span class=\"keyword\">guard</span> $0 != <span class=\"number\">3</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }; <span class=\"keyword\">return</span> $0 * <span class=\"number\">2</span>}))\n\n<span class=\"comment\">// [2, 8]</span>\n</code></pre></code></pre>\n<p>The main difference is that we're adding a <code>guard</code> to make sure the\noptional contains a value.</p>\n<h1>Filter</h1>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rFilter(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], filter: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), \n\n        combine: { <span class=\"keyword\">guard</span> filter($1) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> $0 } \n\n                   <span class=\"keyword\">return</span> $0 + [$1]})\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">rFilter</span>([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>], filter: { $0 % <span class=\"number\">2</span> == <span class=\"number\">0</span>}))\n\n<span class=\"comment\">// [4, 6]</span>\n</code></pre></code></pre>\n<p>Again, a simple operation. We're leveraging guard again to make sure\nour filter condition holds.</p>\n<p>Up until now, <code>reduce</code> may feel like a more complicated version of <code>map</code>\nor <code>filter</code> without any major advantages. However, the combinator does\nnot need to be an array. It can be anything. This makes it easy for us\nto implement various reduction operations in a very simple way.</p>\n","raw_content":"[frontMatter]\ntitle = \"Map, compactMap & Filter\"\ntags = [\"map\", \"compactMap\", \"filter\", \"reduce\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Map\n\nLets re-implement `map` and call it `rmap` (short for `reduce map`)\n\n``` Swift\nfunc rmap(_ elements: [Int], transform: (Int) -> Int) -> [Int] {\n    return elements.reduce([Int](), combine: { \n      (var acc: [Int], obj: Int) -> [Int] in\n       acc.append(transform(obj))\n       return acc\n    })\n}\nlet input = [1, 2, 3, 4]\nlet output = rmap(input, transform: { $0 * 2})\nassert(output == [2, 4, 6, 8])\n```\n\nThis is a good example to understand the basics of `reduce`.\n\n-   First, we\\'re calling reduce on a sequence of elements\n    `elements.reduce...`.\n-   Next, We\\'re giving it the accumulator, i.e. an empty Int array,\n    which will form or return type / result `[Int]()`\n-   After that, we\\'re handing in the `combinator` which takes two\n    parameters. The first is the accumulator which we just provided\n    `acc: [Int]`, the second is the current object from our sequence\n    `obj: Int`.\n-   The actual code in the `combinator` is simple. We simply transform\n    the obj and append it onto the accumulator. We then return the\n    accumulator.\n\nThis looks like much more code than just calling `map`. That\\'s indeed\ntrue, but the version above is extra detailed in order to better explain\nhow `reduce` works. We can simplify it.\n\n``` Swift\nfunc rmap(_ elements: [Int], transform: (Int) -> Int) -> [Int] {\n    return elements.reduce([Int](), combine: {$0 + [transform($1)]})\n}\nprint(rmap([1, 2, 3, 4], transform: { $0 * 2}))\n// [2, 4, 6, 8]\n```\n\nThis still works fine. What happened here? We\\'re using the convenient\nfact that in Swift, the `+` operator also works for two sequences. So\n`[0, 1, 2] + [transform(4)]` takes the left sequence and adds the right\nsequence, consisting out of the transformed element, to it.\n\nIt should be noted that, as of right now, `[1, 2, 3] + [4]` is slower\nthan `[1, 2, 3].append(4)`. If you operate on huge lists, instead of\nusing collection + collection, you should have a mutable accumulator and\nmutate it in place:\n\n``` Swift\nfunc rmap(_ elements: [Int], transform: (Int) -> Int) -> [Int] {\n    return elements.reduce([Int](), combine: { (var ac: [Int], b: Int) -> [Int] in \n        ac.append(transform(b))\n        return ac\n    })\n}\n```\n\nIn order to better understand `reduce` we will now go on and also\nimplement `compactMap` and `filter`.\n\n``` Swift\nfunc rcompactMap(_ elements: [Int], transform: (Int) -> Int?) -> [Int] {\n    return elements.reduce([Int](), \n       combine: { guard let m = transform($1) else { return $0 } \n                  return $0 + [m]})\n}\nprint(rcompactMap([1, 3, 4], transform: { guard $0 != 3 else { return nil }; return $0 * 2}))\n// [2, 8]\n```\n\nThe main difference is that we\\'re adding a `guard` to make sure the\noptional contains a value.\n\n# Filter\n\n``` Swift\nfunc rFilter(_ elements: [Int], filter: (Int) -> Bool) -> [Int] {\n    return elements.reduce([Int](), \n       combine: { guard filter($1) else { return $0 } \n                  return $0 + [$1]})\n}\nprint(rFilter([1, 3, 4, 6], filter: { $0 % 2 == 0}))\n// [4, 6]\n```\n\nAgain, a simple operation. We\\'re leveraging guard again to make sure\nour filter condition holds.\n\nUp until now, `reduce` may feel like a more complicated version of `map`\nor `filter` without any major advantages. However, the combinator does\nnot need to be an array. It can be anything. This makes it easy for us\nto implement various reduction operations in a very simple way.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/multiple_windows.md":["45fe0fa7170c4e23",{"identifier":"8a195466","filename":"multiple_windows.md","info":{"title":"How do I support multiple windows?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-support-multiple-windows.html","content":"<p>Initially, this is rather simple. You just need to enable the <em>Supports multiple windows</em> setting for your target:</p>\n<p><img src=\"/img-content/catalyst/multiwindow.png\" alt=\"\" /></p>\n<p>After this, if you didn't <a href=\"firststeps/modify_menubar.md\">create your own MenuBar</a>, you will have a new <em>New Window</em> <code>Control + N</code> shortcut that you can use to instantiate a new window.</p>\n<p>If you did modify your menubar (as explained above) <a href=\"how/custom_new_window_entry.md\">you can re-create the <em>New Window</em> shortcut by following these explanations.</a></p>\n<p>Finally, if you want to support multiple <em>different</em> windows, that is <a href=\"how/multiple_different_windows.md\">explained here</a></p>\n","raw_content":"[frontMatter]\ntitle = \"How do I support multiple windows?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nInitially, this is rather simple. You just need to enable the *Supports multiple windows* setting for your target:\n\n![](/img-content/catalyst/multiwindow.png)\n\nAfter this, if you didn't [create your own MenuBar](firststeps/modify_menubar.md), you will have a new *New Window* `Control + N` shortcut that you can use to instantiate a new window.\n\nIf you did modify your menubar (as explained above) [you can re-create the *New Window* shortcut by following these explanations.](how/custom_new_window_entry.md)\n\nFinally, if you want to support multiple *different* windows, that is [explained here](how/multiple_different_windows.md)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/more_examples/chunk.md":["2aad8712f36ffb96",{"identifier":"c46284a4","filename":"chunk.md","info":{"title":"Chunk","tags":["map","compactMap","filter","reduce"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-chunk.html","content":"<h1>Chunk</h1>\n<p>This function returns self, broken up into non-overlapping arrays of\nlength <code>n</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> chunk&lt;T&gt;(<span class=\"keyword\">_</span> list: [<span class=\"type\">T</span>], length: <span class=\"type\">Int</span>) -&gt; [[<span class=\"type\">T</span>]] {\n\n    <span class=\"comment\">// Simplify the type signature by introducing a `typealias`</span>\n\n    <span class=\"keyword\">typealias</span> Acc = (stack: [[<span class=\"type\">T</span>]], cur: [<span class=\"type\">T</span>], cnt: <span class=\"type\">Int</span>)\n\n    \n\n    <span class=\"comment\">// Start with a `cnt` of 0</span>\n\n    <span class=\"keyword\">let</span> reducedList = list.<span class=\"call\">reduce</span>((stack: [], cur: [], cnt: <span class=\"number\">0</span>), { (ac: <span class=\"type\">Acc</span>, o: <span class=\"type\">T</span>) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span>\n\n       <span class=\"keyword\">if</span> ac.<span class=\"property\">cnt</span> == length {\n\n           <span class=\"keyword\">return</span> (stack: ac.<span class=\"property\">stack</span> + [ac.<span class=\"property\">cur</span>], cur: [o], cnt: <span class=\"number\">1</span>)\n\n       } <span class=\"keyword\">else</span> {\n\n           <span class=\"keyword\">return</span> (stack: ac.<span class=\"property\">stack</span>, cur: ac.<span class=\"property\">cur</span> + [o], cnt: ac.<span class=\"property\">cnt</span> + <span class=\"number\">1</span>)\n\n       }\n\n    })\n\n    <span class=\"keyword\">return</span> reducedList.<span class=\"property\">stack</span> + [reducedList.<span class=\"property\">cur</span>]\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">chunk</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>], length: <span class=\"number\">2</span>))\n\n<span class=\"comment\">// [[1, 2], [3, 4], [5, 6], [7]]</span>\n</code></pre></code></pre>\n<p>This function uses a more complicated <code>accumulator</code> consisting out of a\nstack, the current list, and the count.</p>\n","raw_content":"[frontMatter]\ntitle = \"Chunk\"\ntags = [\"map\", \"compactMap\", \"filter\", \"reduce\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Chunk\n\nThis function returns self, broken up into non-overlapping arrays of\nlength `n`:\n\n``` Swift\nfunc chunk<T>(_ list: [T], length: Int) -> [[T]] {\n   // Simplify the type signature by introducing a `typealias`\n   typealias Acc = (stack: [[T]], cur: [T], cnt: Int)\n   \n   // Start with a `cnt` of 0\n   let reducedList = list.reduce((stack: [], cur: [], cnt: 0), { (ac: Acc, o: T) -> Acc in\n      if ac.cnt == length {\n          return (stack: ac.stack + [ac.cur], cur: [o], cnt: 1)\n      } else {\n          return (stack: ac.stack, cur: ac.cur + [o], cnt: ac.cnt + 1)\n      }\n   })\n   return reducedList.stack + [reducedList.cur]\n}\nprint(chunk([1, 2, 3, 4, 5, 6, 7], length: 2))\n// [[1, 2], [3, 4], [5, 6], [7]]\n```\n\nThis function uses a more complicated `accumulator` consisting out of a\nstack, the current list, and the count.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./pages/guides.md":["3e9cafd90e26c80b",{"identifier":"4347d9eb","filename":"guides.md","info":{"title":"Guides","tags":[],"keywords":[],"category":[],"created":"2021-06-07 14:26:44","description":"","description_html":"","published":true,"slug":"guides.html","meta":{},"created_timestamp":1623076004,"date":"2021-06-07T14:26:44","date_info":{"year":2021,"month":6,"day":7,"hour":14,"minute":26,"second":44},"identifier":"","indexed":true},"slug":"/pages/guides.html","content":"<p>Temporary Hack. This Code will never display. Everything is in public/page.html</p>\n","raw_content":"[frontMatter]\ntitle = \"Guides\"\npublished = true\nslug = \"guides.html\"\n---\n\nTemporary Hack. This Code will never display. Everything is in public/page.html\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/absolute_basics/tuples_as_return_types.md":["f7315c78258ab4b3",{"identifier":"4029c331","filename":"tuples_as_return_types.md","info":{"title":"Tuples as Return Types","tags":["tuples","destructure"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-tuples-as-return-types.html","content":"<h1>Tuples as Return Types</h1>\n<p>Probably the next-best tuple use case is using them to return one-time\nstructures. Tuples as return types makes sense when you need to return\nmultiple return types.</p>\n<p>The following function is required to return a <code>User</code> from our database.\nHowever, in order to speed up processing, the user may be loaded from the\ncache instead of a query. If that's the case, the caller of the function\nshould also receive the information that the <code>User</code> was cached, and how\nlong it was since the last update from the database. We can easily do this\nwith tuples:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> userFromDatabase(id: <span class=\"type\">Int</span>) -&gt; (user: <span class=\"type\">User</span>, cached: <span class=\"type\">Bool</span>, updated: <span class=\"type\">Date</span>) {\n\n    ...\n\n}\n</code></pre></code></pre>\n<p>This function returns three values, the actual user <code>user</code>, whether the user is\ncached <code>cached</code> and when the user was lasted <code>updated</code>.</p>\n<p>This also saves you from introducing a new <code>struct</code> type.</p>\n<p>Since tuples can also be deconstructed on the fly, this even allows re-introducing\nthe variables at the call site:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> (user, cached, lastUpdated) = <span class=\"call\">userFromDatabase</span>()\n</code></pre></code></pre>\n<p>This will create three new variables in the current scope: <code>user</code>, <code>cached</code>, and <code>lastUpdated</code>.\nWe will describe this <code>destructuring</code> in more detail in the next chapter.</p>\n","raw_content":"[frontMatter]\ntitle = \"Tuples as Return Types\"\ntags = [\"tuples\", \"destructure\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Tuples as Return Types\n\nProbably the next-best tuple use case is using them to return one-time\nstructures. Tuples as return types makes sense when you need to return\nmultiple return types.\n\nThe following function is required to return a `User` from our database.\nHowever, in order to speed up processing, the user may be loaded from the\ncache instead of a query. If that's the case, the caller of the function\nshould also receive the information that the `User` was cached, and how\nlong it was since the last update from the database. We can easily do this\nwith tuples:\n\n``` Swift\nfunc userFromDatabase(id: Int) -> (user: User, cached: Bool, updated: Date) {\n   ...\n}\n```\n\nThis function returns three values, the actual user `user`, whether the user is\ncached `cached` and when the user was lasted `updated`.\n\nThis also saves you from introducing a new `struct` type.\n\nSince tuples can also be deconstructed on the fly, this even allows re-introducing\nthe variables at the call site:\n\n``` Swift\nlet (user, cached, lastUpdated) = userFromDatabase()\n```\n\nThis will create three new variables in the current scope: `user`, `cached`, and `lastUpdated`.\nWe will describe this `destructuring` in more detail in the next chapter.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/language_support/guard_case.md":["ff6c9e417008cc57",{"identifier":"52ea934e","filename":"guard_case.md","info":{"title":"Guard Case","tags":["pattern matching","switch","guard"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-guard-case.html","content":"<h1>Using <strong>guard case</strong></h1>\n<p>Another keyword which supports patterns is the newly introduced <code>guard</code>\nkeyword. You know how it allows you to bind <code>Optionals</code> into the local\nscope much like <code>if let</code> only without nesting things:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> example(a: <span class=\"type\">String</span>?) {\n\n     <span class=\"keyword\">guard let</span> a = a <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     <span class=\"call\">print</span>(a)\n\n}\n\n<span class=\"call\">example</span>(\\<span class=\"string\">\"yes</span>\\<span class=\"string\">\"</span>)\n</code></pre></code></pre>\n<p><code>guard let case</code> allows you to do something similar with the power that\npattern matching introduces. Let's have a look at our soldiers again.\nWe want to calculate the required HP until our player has full health\nagain. Soldiers can't regain HP, so we should always return 0 for a\nsoldier entity.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> <span class=\"type\">MAX_HP</span> = <span class=\"number\">100</span>\n\n\n\n<span class=\"keyword\">func</span> healthHP(entity: <span class=\"type\">Entity</span>) -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">guard case let</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(.<span class=\"dotAccess\">player</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, hp) = entity \n\n       <span class=\"keyword\">where</span> hp &lt; <span class=\"type\">MAX_HP</span> \n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"number\">0</span> }\n\n     <span class=\"keyword\">return</span> <span class=\"type\">MAX_HP</span> - hp\n\n}\n\n\n\n<span class=\"call\">print</span>(\\<span class=\"string\">\"Soldier</span>\\<span class=\"string\">\"</span>, <span class=\"call\">healthHP</span>(<span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: .<span class=\"dotAccess\">soldier</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>, hp: <span class=\"number\">79</span>)))\n\n<span class=\"call\">print</span>(\\<span class=\"string\">\"Player</span>\\<span class=\"string\">\"</span>, <span class=\"call\">healthHP</span>(<span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: .<span class=\"dotAccess\">player</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>, hp: <span class=\"number\">57</span>)))\n\n\n\n<span class=\"comment\">// Prints:</span>\n\n\\<span class=\"string\">\"Soldier</span> <span class=\"number\">0</span>\\<span class=\"string\">\"</span>\n\n\\<span class=\"string\">\"Player</span> <span class=\"number\">43</span>\\<span class=\"string\">\"</span>\n\n\n</code></pre></code></pre>\n<p>This is a beautiful example of the culmination of the various mechanisms\nwe've discussed so far.</p>\n<ul>\n<li>It is very clear, there is no nesting involved</li>\n<li>Logic and initialization of state are handled at the top of the\n<code>func</code> which improves readability</li>\n<li>Very terse.</li>\n</ul>\n<p>This can also be very successfully combined with <code>switch</code> and <code>for</code> to\nwrap complex logical constructs into an easy to read format. Of course,\nthat won't make the logic any easier to understand, but at least it\nwill be provided in a much saner package. Especially if you use <code>enums</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Guard Case\"\ntags = [\"pattern matching\", \"switch\", \"guard\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Using **guard case**\n\nAnother keyword which supports patterns is the newly introduced `guard`\nkeyword. You know how it allows you to bind `Optionals` into the local\nscope much like `if let` only without nesting things:\n\n``` Swift\nfunc example(a: String?) {\n    guard let a = a else { return }\n    print(a)\n}\nexample(\"yes\")\n```\n\n`guard let case` allows you to do something similar with the power that\npattern matching introduces. Let\\'s have a look at our soldiers again.\nWe want to calculate the required HP until our player has full health\nagain. Soldiers can\\'t regain HP, so we should always return 0 for a\nsoldier entity.\n\n``` Swift\nlet MAX_HP = 100\n\nfunc healthHP(entity: Entity) -> Int {\n    guard case let Entity.Entry(.player, _, _, hp) = entity \n      where hp < MAX_HP \n        else { return 0 }\n    return MAX_HP - hp\n}\n\nprint(\"Soldier\", healthHP(Entity.Entry(type: .soldier, x: 10, y: 10, hp: 79)))\nprint(\"Player\", healthHP(Entity.Entry(type: .player, x: 10, y: 10, hp: 57)))\n\n// Prints:\n\"Soldier 0\"\n\"Player 43\"\n\n```\n\nThis is a beautiful example of the culmination of the various mechanisms\nwe\\'ve discussed so far.\n\n-   It is very clear, there is no nesting involved\n-   Logic and initialization of state are handled at the top of the\n    `func` which improves readability\n-   Very terse.\n\nThis can also be very successfully combined with `switch` and `for` to\nwrap complex logical constructs into an easy to read format. Of course,\nthat won\\'t make the logic any easier to understand, but at least it\nwill be provided in a much saner package. Especially if you use `enums`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/custom_mirrors/intro.md":["97ac09f2b91490f9",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Custom Mirrors","tags":["reflection","mirror","CustomReflectable"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-custom-mirrors.html","content":"<h1>Custom Mirrors</h1>\n<p>As we already discussed earlier, there're other options creating a\nMirror. This is useful, for example, if you need to customize just how\nmuch of your <strong>subject</strong> can be seen with a mirror. The <code>Mirror Struct</code>\nhas additional initializers for this.</p>\n<p>This is especially useful in two cases:</p>\n<ol>\n<li>If reflection is a core part of your code, so that you have more control</li>\n<li>If you write a library and you expect that consumers will use reflection on it and you'd rather surpress that.</li>\n</ol>\n<p>The way you use it is via the <code>CustomReflectable</code> protocol. This protocol only has one requirement: <code>var customMirror: Mirror</code>. If you implement it, you can create your own <code>Mirror</code> and return that instead of the custom <code>Mirror(reflecting:)</code> one.</p>\n","raw_content":"[frontMatter]\ntitle = \"Custom Mirrors\"\ntags = [\"reflection\", \"mirror\", \"CustomReflectable\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Custom Mirrors\n\nAs we already discussed earlier, there\\'re other options creating a\nMirror. This is useful, for example, if you need to customize just how\nmuch of your **subject** can be seen with a mirror. The `Mirror Struct`\nhas additional initializers for this.\n\nThis is especially useful in two cases:\n\n1. If reflection is a core part of your code, so that you have more control\n2. If you write a library and you expect that consumers will use reflection on it and you'd rather surpress that.\n\nThe way you use it is via the `CustomReflectable` protocol. This protocol only has one requirement: `var customMirror: Mirror`. If you implement it, you can create your own `Mirror` and return that instead of the custom `Mirror(reflecting:)` one.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/touchbar_images.md":["0ceed2a47726028d",{"identifier":"0fb43146","filename":"touchbar_images.md","info":{"title":"How do I use the cool TouchBar images that Apple provides with AppKit?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-use-the-cool-touchbar-images-that-apple-provides-with-appkit.html","content":"<p>Apple has a very nice set of default touchbar images outlined here:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/\">https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/</a></li>\n<li><a href=\"https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc\">https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc</a></li>\n</ul>\n<p>These currently can't be used in Catalyst apps (FB6312494).</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I use the cool TouchBar images that Apple provides with AppKit?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nApple has a very nice set of default touchbar images outlined here:\n\n- [https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/](https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/)\n- [https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc](https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc)\n\nThese currently can't be used in Catalyst apps (FB6312494).\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/error_handling.md":["f8f6b43da9e83fb1",{"identifier":"c0bcf42c","filename":"error_handling.md","info":{"title":"Error Handling","tags":["error"],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-error-handling.html","content":"<h1>Error Handling</h1>\n<p>One of the prime examples of Enum usage in Swift is, of course, the new\nerror handling in Swift 2.0. Your throwing function can throw anything\nwhich conforms to the empty <code>ErrorType</code> protocol. As the Swift\ndocumentation succinctly observes:</p>\n<blockquote>\n<p>Swift enumerations are particularly well suited to modeling a group of\nrelated error conditions, with associated values allowing for\nadditional information about the nature of an error to be\ncommunicated.</p>\n</blockquote>\n<p>As an example, have a look at the popular <a href=\"https://github.com/thoughtbot/Argo\">JSON Decoding library\nArgo</a>. When their JSON Decoding\nfails, it can fail due to two primary reasons.</p>\n<ol>\n<li>The JSON Data lacks a key which the end model requires (say your\nmodel has a property <code>username</code> and somehow the JSON lacks that)</li>\n<li>There's a type mismatch. Say instead of a String the <code>username</code>\nproperty in the JSON contains an <code>NSNull</code> <sup class=\"footnote-reference\"><a href=\"#6\">1</a></sup>.</li>\n</ol>\n<p>In addition to that, Argo also includes a custom error for anything not\nfitting in these two categories above. Their <code>ErrorType enum</code> looks like\nthis:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> DecodeError: <span class=\"type\">Error</span> {\n\n   <span class=\"keyword\">case</span> typeMismatch(expected: <span class=\"type\">String</span>, actual: <span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> missingKey(<span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> custom(<span class=\"type\">String</span>)\n\n}\n</code></pre></code></pre>\n<p>All cases have associated values that contain additional information\nabout the error in question.</p>\n<p>A more general <code>ErrorType</code> for complete HTTP / REST API handling could\nlook like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> APIError : <span class=\"type\">Error</span> {\n\n     <span class=\"comment\">// Can't connect to the server (maybe offline?)</span>\n\n     <span class=\"keyword\">case</span> connectionError(error: <span class=\"type\">NSError</span>)\n\n     <span class=\"comment\">// The server responded with a non 200 status code</span>\n\n     <span class=\"keyword\">case</span> serverError(statusCode: <span class=\"type\">Int</span>, error: <span class=\"type\">NSError</span>)\n\n     <span class=\"comment\">// We got no data (0 bytes) back from the server</span>\n\n     <span class=\"keyword\">case</span> noDataError\n\n     <span class=\"comment\">// The server response can't be converted from JSON to a Dictionary</span>\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONSerializationError</span>(error: <span class=\"type\">Error</span>)\n\n     <span class=\"comment\">// The Argo decoding Failed</span>\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONMappingError</span>(converstionError: <span class=\"type\">DecodeError</span>)\n\n}\n</code></pre></code></pre>\n<p>This <code>ErrorType</code> implements the complete REST Stack up to the point\nwhere your app would get the completely decoded native <code>struct</code> or\n<code>class</code> object.</p>\n<p>More information on <code>ErrorType</code> and more <code>enum</code> examples in this context\ncan be found in the official documentation\n<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html\">here</a>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Error Handling\"\ntags = [\"error\"]\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Error Handling\n\nOne of the prime examples of Enum usage in Swift is, of course, the new\nerror handling in Swift 2.0. Your throwing function can throw anything\nwhich conforms to the empty `ErrorType` protocol. As the Swift\ndocumentation succinctly observes:\n\n> Swift enumerations are particularly well suited to modeling a group of\n> related error conditions, with associated values allowing for\n> additional information about the nature of an error to be\n> communicated.\n\nAs an example, have a look at the popular [JSON Decoding library\nArgo](https://github.com/thoughtbot/Argo). When their JSON Decoding\nfails, it can fail due to two primary reasons.\n\n1.  The JSON Data lacks a key which the end model requires (say your\n    model has a property `username` and somehow the JSON lacks that)\n2.  There\\'s a type mismatch. Say instead of a String the `username`\n    property in the JSON contains an `NSNull` [^6].\n\nIn addition to that, Argo also includes a custom error for anything not\nfitting in these two categories above. Their `ErrorType enum` looks like\nthis:\n\n``` Swift\nenum DecodeError: Error {\n  case typeMismatch(expected: String, actual: String)\n  case missingKey(String)\n  case custom(String)\n}\n```\n\nAll cases have associated values that contain additional information\nabout the error in question.\n\nA more general `ErrorType` for complete HTTP / REST API handling could\nlook like this:\n\n``` Swift\nenum APIError : Error {\n    // Can't connect to the server (maybe offline?)\n    case connectionError(error: NSError)\n    // The server responded with a non 200 status code\n    case serverError(statusCode: Int, error: NSError)\n    // We got no data (0 bytes) back from the server\n    case noDataError\n    // The server response can't be converted from JSON to a Dictionary\n    case JSONSerializationError(error: Error)\n    // The Argo decoding Failed\n    case JSONMappingError(converstionError: DecodeError)\n}\n```\n\nThis `ErrorType` implements the complete REST Stack up to the point\nwhere your app would get the completely decoded native `struct` or\n`class` object.\n\nMore information on `ErrorType` and more `enum` examples in this context\ncan be found in the official documentation\n[here](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html).\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/swift_reflection/complete_book.html":["e3b0c44298fc1c14",{"identifier":"c7c8","filename":"complete_book.html","info":{"title":"The Swift Reflection API and what you can do with it","tags":[],"keywords":["feature","swift","reflection","struct","class","displayType","mirror","api","reflecting","any","anyobject"],"category":[],"created":"2015-10-24 10:30:30","description":"In this guide we'll examine the Swift reflection API, see how fast it is, and will try to show use cases where it can be applied successfully.","description_html":"<p>In this guide we'll examine the Swift reflection API, see how fast it is, and will try to show use cases where it can be applied successfully.</p>\n","published":true,"slug":"2015-10-24-swift-reflection-api-what-you-can-do.html","meta":{"short_code":"<pre class='Swift'><code><span class='source swift'><span class='apvstorage apvtype swift'>let</span> m <span class='apvkeyword apvoperator apvassignment swift'>=</span> Mirror(reflecting: me) </span></code></pre></code></pre>","short_title":"🔮 Reflection","swift_version":"5.1"},"created_timestamp":1445682630,"date":"2015-10-24T10:30:30","date_info":{"year":2015,"month":10,"day":24,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/swift_reflection/complete_book.html","content":"<h1>Introduction</h1>\n<p>Even though Swift stresses strong types, compile time safety and static\ndispatch, it still offers a Reflection mechanism as part of the standard\nlibrary.</p>\n<p>Reflection means that you can ask Swift at runtime questions about types.\nI.e. you can tell Swift &quot;what are the methods that this class implements&quot;</p>\n<p>This might not sound useful, but in reality is allows to do some really\nclever tricks: For example, you could write a function that takes any\n<code>struct</code>, lists all the properties (<code>var username, var age</code>, etc)\nand writes this information into Core Data.</p>\n<p>Reflection in Swift is <code>read-only</code>, so you can't write any properties.\nHowever, it is still quite powerful. This guide will explain reflection\nand also show how it can be used in a practical way (the aforementioned\nstruct to Core Data example).</p>\n<p>The best understanding of the topic can be achieved by having a look at\nthe API to see what it offers us.</p>\n<h1>Mirrors</h1>\n<p>Swift's reflection capabilities are based around a <code>struct</code> called\n<strong>Mirror</strong>. You create a mirror for a particular <code>subject</code> and the\nmirror will then let you query it.</p>\n<p>Before we look at the API, let's define a simple data structure that we can experiment on.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> Foundation\n\n\n\n<span class=\"keyword\">public class</span> Store {\n\n     <span class=\"keyword\">let</span> storesToDisk: <span class=\"type\">Bool</span> = <span class=\"keyword\">true</span>\n\n}\n\n<span class=\"keyword\">public class</span> BookmarkStore: <span class=\"type\">Store</span> {\n\n     <span class=\"keyword\">let</span> itemCount: <span class=\"type\">Int</span> = <span class=\"number\">10</span>\n\n}\n\n<span class=\"keyword\">public struct</span> Bookmark {\n\n    <span class=\"keyword\">enum</span> Group {\n\n       <span class=\"keyword\">case</span> tech\n\n       <span class=\"keyword\">case</span> news\n\n    }\n\n    <span class=\"keyword\">private let</span> store = {\n\n        <span class=\"keyword\">return</span> <span class=\"type\">BookmarkStore</span>()\n\n    }()\n\n    <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>?\n\n    <span class=\"keyword\">let</span> url: <span class=\"type\">URL</span>\n\n    <span class=\"keyword\">let</span> keywords: [<span class=\"type\">String</span>]\n\n    <span class=\"keyword\">let</span> group: <span class=\"type\">Group</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> aBookmark = <span class=\"type\">Bookmark</span>(title: \\<span class=\"string\">\"Appventure</span>\\<span class=\"string\">\"</span>, url: <span class=\"type\">URL</span>(string: \\<span class=\"string\">\"appventure</span>.<span class=\"property\">me</span>\\<span class=\"string\">\"</span>)!, keywords: [\\<span class=\"string\">\"Swift</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"iOS</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"OSX</span>\\<span class=\"string\">\"</span>], group: .<span class=\"dotAccess\">tech</span>)\n</code></pre></code></pre>\n<p>So, we have a <code>Bookmark</code>. Bookmarks can have titles, urls, keywords, and bookmarks can belong to a <code>Group</code>. There is also a <code>BookmarkStore</code> and a more general <code>Store</code>. So, how do we query this data structure at runtime?</p>\n<h1>Creating a Mirror</h1>\n<p>The easiest way of creating a mirror is the <code>reflecting</code> initializer:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public init</span>(reflecting: <span class=\"type\">Any</span>)\n</code></pre></code></pre>\n<p>Lets use it with our <code>Bookmark</code> <code>struct</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> myMirror = <span class=\"type\">Mirror</span>(reflecting: aBookmark)\n\n<span class=\"call\">print</span>(myMirror)\n\n<span class=\"comment\">// prints : Mirror for Bookmark</span>\n</code></pre></code></pre>\n<p>So this creates a <code>Mirror for Bookmark</code>. As you can see, the type of the\nsubject is <code>Any</code>. This is the most general type in Swift. Anything under\nthe Swift Sun is at least of type <code>Any</code> <sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>. So this makes the mirror\ncompatible with <code>struct</code>, <code>class</code>, <code>enum</code>, <code>Tuple</code>, <code>Array</code>,\n<code>Dictionary</code>, <code>Set</code>, etc.</p>\n<p>There are three additional initializers in the Mirror struct, however\nthose are mostly used for circumstances where you'd want to provide\nyour own, custom mirror.</p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>In particular, <code>Any</code> is an empty protocol and everything implicitly conforms to this protocol</p>\n</div>\n<h1>What is in a Mirror</h1>\n<p>The <code>Mirror struct</code> contains several <code>types</code> to help you identify the\ninformation you'd like to query.</p>\n<p>The first one is the <code>DisplayStyle</code> <code>enum</code> which tells you the type of\nthe subject:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public enum</span> DisplayStyle {\n\n     <span class=\"keyword\">case</span> `<span class=\"keyword\">struct</span>`\n\n     <span class=\"keyword\">case</span> `<span class=\"keyword\">class</span>`\n\n     <span class=\"keyword\">case</span> `<span class=\"keyword\">enum</span>`\n\n     <span class=\"keyword\">case</span> tuple\n\n     <span class=\"keyword\">case</span> optional\n\n     <span class=\"keyword\">case</span> collection\n\n     <span class=\"keyword\">case</span> dictionary\n\n     <span class=\"keyword\">case set</span>\n\n}\n</code></pre></code></pre>\n<p>Those are the supported types of the reflection API. As we saw earlier,\nreflection only requires an <code>Any</code> type, and there're many things in the\nSwift standard library that are of type <code>Any</code> but aren't listed in the\n<code>DisplayStyle</code> enum above. What happens when you try to reflect over one\nof those, say a closure?</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> closure = { (a: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in return</span> a * <span class=\"number\">2</span> }\n\n<span class=\"keyword\">let</span> aMirror = <span class=\"type\">Mirror</span>(reflecting: closure)\n</code></pre></code></pre>\n<p>In this case, you'd get a mirror, but the <code>DisplayStyle</code> would be nil\n<sup class=\"footnote-reference\"><a href=\"#2\">1</a></sup></p>\n<p>There's also a <code>typealias</code> for the child elements of a <code>Mirror</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public typealias</span> Child = (label: <span class=\"type\">String</span>?, value: <span class=\"type\">Any</span>)\n</code></pre></code></pre>\n<p>So each child consists out of an optional <strong>label</strong> and a <strong>value</strong> of\ntype <code>Any</code>. Why would the label be an <code>Optional</code>? If you think about it,\nit makes sense, not all of the structures that are supported by\nreflection have children with names. A <code>struct</code> has the property's name\nas the label, but a Collection only has indexes, not names. Tuples are a\nlittle bit special. In Swift values in tuple could have optional labels.\nDoesn't matter if value in tupple is labeled or not, in reflection\ntuple will have labels &quot;.0&quot;, &quot;.1&quot; and so on.</p>\n<p>Next up is the <code>AncestorRepresentation</code> <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public enum</span> AncestorRepresentation {\n\n     <span class=\"comment\">/// Generate a default mirror for all ancestor classes.  This is the</span>\n\n     <span class=\"comment\">/// default behavior.</span>\n\n     <span class=\"keyword\">case</span> generated\n\n     <span class=\"comment\">/// Use the nearest ancestor's implementation of `customMirror()` to</span>\n\n     <span class=\"comment\">/// create a mirror for that ancestor.</span>      \n\n     <span class=\"keyword\">case</span> customized(<span class=\"keyword\">@escaping</span> () -&gt; <span class=\"type\">Mirror</span>)\n\n     <span class=\"comment\">/// Suppress the representation of all ancestor classes.  The</span>\n\n     <span class=\"comment\">/// resulting `Mirror`'s `superclassMirror()` is `nil`.</span>\n\n     <span class=\"keyword\">case</span> suppressed\n\n}\n</code></pre></code></pre>\n<p>This <code>enum</code> is used to define how superclasses of the reflected subject\nshould be reflected. I.e. this is only used for subjects of type\n<code>class</code>. The default (as you can see) is that Swift generates an\nadditional mirror for each superclass. However, if you need more\nflexibility here, you can use the <code>AncestorRepresentation enum</code> to\ndefine how superclasses are being mirrored.</p>\n<h1>How to use a Mirror</h1>\n<p>So we have our <code>myMirror</code> instance variable that reflects our <code>Bookmark</code>. What do we do with it?</p>\n<p>These are the available properties / methods on a <code>Mirror</code>:</p>\n<ul>\n<li><code>let children: Children</code>: The child elements of our subject</li>\n<li><code>displayStyle: Mirror.DisplayStyle?</code>: The display style of the\nsubject</li>\n<li><code>let subjectType: Any.Type</code> : The type of the subject</li>\n<li><code>func superclassMirror() -&gt; Mirror?</code>: The mirror of the subject's\nsuperclass</li>\n</ul>\n<p>In the next step, we will analyze each of these.</p>\n<h3>displayStyle</h3>\n<p>This is easy. It will just return a case of the <code>DisplayStyle</code> <code>enum</code>.\nIf you're trying to reflect over an unsupported type, you'll get an\nempty <code>Optional</code> back (as explained above).</p>\n<pre class=\"Swift\"><code>print (aMirror.<span class=\"property\">displayStyle</span>)\n\n<span class=\"comment\">// prints: Optional(Swift.Mirror.DisplayStyle.struct)</span>\n</code></pre></code></pre>\n<h3>children</h3>\n<p>This returns a <code>AnyCollection&lt;Child&gt;</code> with all the children that\nthe subject contains. Children are not limited to entries in an <code>Array</code>\nor <code>Dictionary</code>. All properties of a <code>struct</code> or <code>class</code>, for example,\nare also children returned by this property. The protocol\n<code>AnyCollection</code> means that this is a type <a href=\"lnk::type-erase\">erased <code>Collection</code>.</a></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for case let</span> (label?, value) <span class=\"keyword\">in</span> myMirror.<span class=\"property\">children</span> {\n\n     print (label, value)\n\n}\n\n<span class=\"comment\">//prints:</span>\n\n<span class=\"comment\">//: store main.BookmarkStore</span>\n\n<span class=\"comment\">//: title Optional(\\\"Appventure\\\")</span>\n\n<span class=\"comment\">//: url appventure.me</span>\n\n<span class=\"comment\">//: keywords [\\\"Swift\\\", \\\"iOS\\\", \\\"OSX\\\"]</span>\n\n<span class=\"comment\">//: group tech</span>\n</code></pre></code></pre>\n<h3>SubjectType</h3>\n<p>This is the type of the subject:</p>\n<pre class=\"Swift\"><code><span class=\"call\">print</span>(aMirror.<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//prints : Bookmark</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: <span class=\"number\">5</span>).<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//prints : Int</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: \\<span class=\"string\">\"test</span>\\<span class=\"string\">\"</span>).<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//prints : String</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: <span class=\"type\">Null</span>()).<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//print : Null</span>\n</code></pre></code></pre>\n<p>However, the Swift documentation has the following to say:</p>\n<blockquote>\n<p>This type may differ from the subject's dynamic type when <code>self</code> is\nthe <code>superclassMirror()</code> of another mirror.</p>\n</blockquote>\n<h3>SuperclassMirror</h3>\n<p>This is the mirror of the superclass of our subject. If the subject is\nnot a class, this will be an empty <code>Optional</code>. If this is a class-based\ntype, you'll get a new <code>Mirror</code>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// try our struct</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: aBookmark).<span class=\"call\">superclassMirror</span>())\n\n<span class=\"comment\">// prints: nil</span>\n\n<span class=\"comment\">// try a class</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: myBookmark.<span class=\"property\">store</span>).<span class=\"call\">superclassMirror</span>())\n\n<span class=\"comment\">// prints: Optional(Mirror for Store)</span>\n\n\n</code></pre></code></pre>\n<h1>Structs to Core Data</h1>\n<p>Imagine we're working at the newest, hot, tech startup: <strong>Books\nBunny</strong>. We offer an Artificial Intelligence with a browser plugin that\nautomatically analyses all the sites that the user visits and\nautomatically bookmarks the relevant urls.</p>\n<p>Our server backend is\nobviously written in Swift. Since we have millions of site visits active\nin our system at a time, we'd like to use <code>structs</code> for the analysis\npart of each site that a user visits. However, if our AI decides that\nthis is worthy of a bookmark, we'd like to use CoreData to store this\ntype in a database.</p>\n<p>Now, we don't want to write custom serialization to Core Data code\nwhenever we introduce a new <code>struct</code>. Rather, we'd like to develop this\nin a way so that we can utilize it for all future <code>structs</code> we develop.</p>\n<p>So, how do we do that?</p>\n<h1>Structs to Core Data</h1>\n<p>Remember, we have a <code>struct</code> and want to automatically convert this to\n<code>NSManagedObject</code> (<strong>Core Data</strong>).</p>\n<p>If we want to support different <code>structs</code> or even types, we can\nimplement this as a protocol and then make sure our desired types\nconform to it. So which functionality should our imaginary protocol\noffer?</p>\n<ul>\n<li>First, it should allow us to define the name of the <strong>Core Data\nEntity</strong> that we want to create</li>\n<li>Second, it should have a way to tell it to convert itself to an\n<code>NSManagedObject</code></li>\n</ul>\n<p>Our <code>protocol</code> could look something like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> StructDecoder {\n\n     <span class=\"comment\">// The name of our Core Data Entity</span>\n\n     <span class=\"keyword\">static var</span> <span class=\"type\">EntityName</span>: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n     <span class=\"comment\">// Return an NSManagedObject with our properties set</span>\n\n     <span class=\"keyword\">func</span> toCoreData(context: <span class=\"type\">NSManagedObjectContext</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">NSManagedObject</span>\n\n}\n</code></pre></code></pre>\n<p>The <code>toCoreData</code> method uses exception handling to\nthrow an error, if the conversion fails. There're several possible\nerror cases, which are outlined in the <code>ErrorType</code> <code>enum</code> below:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> SerializationError: <span class=\"type\">ErrorType</span> {\n\n     <span class=\"comment\">// We only support structs</span>\n\n     <span class=\"keyword\">case</span> structRequired\n\n     <span class=\"comment\">// The entity does not exist in the Core Data Model</span>\n\n     <span class=\"keyword\">case</span> unknownEntity(name: <span class=\"type\">String</span>)\n\n     <span class=\"comment\">// The provided type cannot be stored in core data</span>\n\n     <span class=\"keyword\">case</span> unsupportedSubType(label: <span class=\"type\">String</span>?)\n\n}\n</code></pre></code></pre>\n<p>We have three error cases that our conversion has to look out for. The\nfirst one is that we're trying to apply it to something that is not a\n<code>struct</code>. The second is that the <code>entity</code> we're trying to create does\nnot exist in our Core Data Model. The third is that we're trying to\nwrite something into Core Data which can not be stored there (i.e. an\n<code>enum</code>).</p>\n<p>Let's create a struct and add protocol conformance:</p>\n<h2>Bookmark struct</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Bookmark {\n\n    <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>\n\n    <span class=\"keyword\">let</span> url: <span class=\"type\">URL</span>\n\n    <span class=\"keyword\">let</span> pagerank: <span class=\"type\">Int</span>\n\n    <span class=\"keyword\">let</span> created: <span class=\"type\">Date</span>\n\n}\n</code></pre></code></pre>\n<p>Next, we'd like to implement the <code>toCoreData</code> method.</p>\n<h2>Protocol Extension</h2>\n<p>We could, of course, write this anew for each <code>struct</code>, but that's a\nlot of work. Structs do not support inheritance, so we can't use a base\nclass. However, we can use a <code>protocol extension</code> to extend to all\nconforming <code>structs</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">StructDecoder</span> {\n\n     <span class=\"keyword\">func</span> toCoreData(context: <span class=\"type\">NSManagedObjectContext</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">NSManagedObject</span> {\n\n     }\n\n}\n</code></pre></code></pre>\n<p>As this extension is being applied to our conforming <code>structs</code>, this\nmethod will be called in the structs context. Thus, within the\nextension, <code>self</code> refers to the <code>struct</code> which we'd like to analyze.</p>\n<p>So, the first step for us is to create an <code>NSManagedObject</code> into which\nwe can then write the values from our <code>Bookmark struct</code>. How do we do\nthat?</p>\n<h2>A Bit of Core Data</h2>\n<p>Core Data is a tad verbose, so in order to create an object, we need the\nfollowing steps:</p>\n<ol>\n<li>Get the name of the entity which we'd like to create (as a string)</li>\n<li>Take the <code>NSManagedObjectContext</code>, and create an\n<code>NSEntityDescription</code> for our entity</li>\n<li>Create an <code>NSManagedObject</code> with this information.</li>\n</ol>\n<p>When we implement this, we have:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Get the name of the Core Data Entity</span>\n\n<span class=\"keyword\">let</span> entityName = <span class=\"call\">type</span>(of: <span class=\"keyword\">self</span>).<span class=\"type\">EntityName</span>\n\n\n\n<span class=\"comment\">// Create the Entity Description</span>\n\n<span class=\"comment\">// The entity may not exist, so we're using a 'guard let' to throw</span> \n\n<span class=\"comment\">// an error in case it does not exist in our core data model</span>\n\n<span class=\"keyword\">guard let</span> desc = <span class=\"type\">NSEntityDescription</span>.<span class=\"call\">entityForName</span>(entityName, inManagedObjectContext: context)\n\n     <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"call\">unknownEntity</span>(name: entityName) }\n\n\n\n<span class=\"comment\">// Create the NSManagedObject</span>\n\n<span class=\"keyword\">let</span> managedObject = <span class=\"type\">NSManagedObject</span>(entity: desc, insertIntoManagedObjectContext: context)\n</code></pre></code></pre>\n<h2>Implementing the Reflection</h2>\n<p>Next up, we'd like to use the Reflection API to read our bookmarks\nproperties and write it into our <code>NSManagedObject</code> instance.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Create a Mirror</span>\n\n<span class=\"keyword\">let</span> mirror = <span class=\"type\">Mirror</span>(reflecting: <span class=\"keyword\">self</span>)\n\n\n\n<span class=\"comment\">// Make sure we're analyzing a struct</span>\n\n<span class=\"keyword\">guard</span> mirror.<span class=\"property\">displayStyle</span> == .<span class=\"dotAccess\">struct</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">SerializationError</span>.<span class=\"property\">structRequired</span> }\n</code></pre></code></pre>\n<p>We're making sure that this is indeed a <code>struct</code> by testing the\n<code>displayStyle</code> property.</p>\n<p>So now we have a <code>Mirror</code> that allows us to read properties, and we have\na <code>NSManagedObject</code> which we can set properties on. As the mirror offers\na way to read all children, we can iterate over them and set the values.\nSo let's do that.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for case let</span> (label?, value) <span class=\"keyword\">in</span> mirror.<span class=\"property\">children</span> {\n\n     managedObject.<span class=\"call\">setValue</span>(value, forKey: label)\n\n}\n</code></pre></code></pre>\n<p>Now, the only thing left to do is return our <code>NSManagedObject</code>. The\ncomplete code looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">StructDecoder</span> {\n\n     <span class=\"keyword\">func</span> toCoreData(context: <span class=\"type\">NSManagedObjectContext</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">NSManagedObject</span> {\n\n         <span class=\"keyword\">let</span> entityName = <span class=\"call\">type</span>(of:<span class=\"keyword\">self</span>).<span class=\"type\">EntityName</span>\n\n\n\n         <span class=\"comment\">// Create the Entity Description</span>\n\n         <span class=\"keyword\">guard let</span> desc = <span class=\"type\">NSEntityDescription</span>.<span class=\"call\">entityForName</span>(entityName, inManagedObjectContext: context)\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">UnknownEntity</span>(name: entityName) }\n\n\n\n         <span class=\"comment\">// Create the NSManagedObject</span>\n\n         <span class=\"keyword\">let</span> managedObject = <span class=\"type\">NSManagedObject</span>(entity: desc, insertIntoManagedObjectContext: context)\n\n\n\n         <span class=\"comment\">// Create a Mirror</span>\n\n         <span class=\"keyword\">let</span> mirror = <span class=\"type\">Mirror</span>(reflecting: <span class=\"keyword\">self</span>)\n\n\n\n         <span class=\"comment\">// Make sure we're analyzing a struct</span>\n\n         <span class=\"keyword\">guard</span> mirror.<span class=\"property\">displayStyle</span> == .<span class=\"dotAccess\">Struct</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">SerializationError</span>.<span class=\"property\">structRequired</span> }\n\n\n\n         <span class=\"keyword\">for case let</span> (label?, anyValue) <span class=\"keyword\">in</span> mirror.<span class=\"property\">children</span> {\n\n             managedObject.<span class=\"call\">setValue</span>(anyValue, forKey: label)\n\n         }\n\n\n\n         <span class=\"keyword\">return</span> managedObject\n\n     }\n\n}\n</code></pre></code></pre>\n<p>That's it. We're converting our <code>struct</code> to <code>NSManagedObject</code>.</p>\n<h1>Performance</h1>\n<p>So we just wrote some code that converts <code>struct</code> types via <code>reflection</code> at runtime to <code>Core Data</code> types.\nHow fast is this? Can this be used well in production? I did some testing:</p>\n<style type=\"text/css\">\n  .linechart {\n      border: 3px solid white;\n      border-radius: 32px;\n      font-family: Sans-Serif;\n      color: white;\n      font-weight: normal;\n      padding: 4px;\n      margin-bottom: 20px;\n  }\n  .redxx {\n      background-color: red;\n  }\n  .greenxx {\n      background-color: green;\n  }\n  .linechart > span {\n      padding: 4px;\n  }\n  h3.ggx {\n      font-family: Sans-Serif;\nfont-weight: normal;\n  }\n  .orangexx {\n      background-color: orange;\n  }\n</style>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px;\">\n<h3 class='ggx'>Create 2000 NSManagedObjects</h3>\n<div class=\"linechart greenxx\" style=\"width: 30%\">\n    <span>Native: 0.062 seconds</span>\n</div>\n<div class=\"linechart redxx\">\n    <span>Reflection: 0.207 seconds</span>\n</div>\n</div>\n<p>Native, here, means creating an <code>NSManagedObject</code> and setting the\nproperty values via <code>setValueForKey</code>. If you create a <code>NSManagedObject</code>\nsubclass within Core Data and set the values directly on the properties\n(without the dynamic <code>setValueForKey</code> overhead) this is probably even\nfaster.</p>\n<p>So, as you can see, using reflection slows the whole process of creating\n<code>NSManagedObjects</code> down by about <strong>3.5x</strong>. This is fine when you're\nusing this for a limited amount of items, or when you don't have to\ncare about speed. However, when you need to reflect over a huge amount\nof <code>structs</code>, this will probably kill your app's performance.</p>\n<h1>Custom Mirrors</h1>\n<p>As we already discussed earlier, there're other options creating a\nMirror. This is useful, for example, if you need to customize just how\nmuch of your <strong>subject</strong> can be seen with a mirror. The <code>Mirror Struct</code>\nhas additional initializers for this.</p>\n<p>This is especially useful in two cases:</p>\n<ol>\n<li>If reflection is a core part of your code, so that you have more control</li>\n<li>If you write a library and you expect that consumers will use reflection on it and you'd rather surpress that.</li>\n</ol>\n<p>The way you use it is via the <code>CustomReflectable</code> protocol. This protocol only has one requirement: <code>var customMirror: Mirror</code>. If you implement it, you can create your own <code>Mirror</code> and return that instead of the custom <code>Mirror(reflecting:)</code> one.</p>\n<h1>Collections</h1>\n<p>In order to</p>\n<p>The first special <code>init</code> is tailor-made for collections:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>&lt;Subject, C&gt;(<span class=\"keyword\">_</span> subject: <span class=\"type\">Subject</span>, children: <span class=\"type\">C</span>, displayStyle: <span class=\"type\">Mirror</span>.<span class=\"type\">DisplayStyle</span>? = <span class=\"keyword\">nil</span>, ancestorRepresentation: <span class=\"type\">Mirror</span>.<span class=\"type\">AncestorRepresentation</span> = .<span class=\"dotAccess\">generated</span>) <span class=\"keyword\">where</span> <span class=\"type\">C</span> : <span class=\"type\">Collection</span>, <span class=\"type\">C</span>.<span class=\"type\">Element</span> == <span class=\"type\">Mirror</span>.<span class=\"type\">Child</span>\n</code></pre></code></pre>\n<p>Compared to the <code>init(reflecting:)</code> initializer above, this one allows\nus to define much more details about the reflection process.</p>\n<ul>\n<li>It only works for collections</li>\n<li>We can set the subject to be reflected <strong>and</strong> the children of the\nsubject (the collection contents)</li>\n</ul>\n<h1>Classes or Structs</h1>\n<p>The second can be used for a <code>class</code> or a <code>struct</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>&lt;Subject&gt;(<span class=\"keyword\">_</span> subject: <span class=\"type\">Subject</span>, children: <span class=\"type\">KeyValuePairs</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">Any</span>&gt;, displayStyle: <span class=\"type\">Mirror</span>.<span class=\"type\">DisplayStyle</span>? = <span class=\"keyword\">nil</span>, ancestorRepresentation: <span class=\"type\">Mirror</span>.<span class=\"type\">AncestorRepresentation</span> = .<span class=\"dotAccess\">generated</span>)\n</code></pre></code></pre>\n<p>Interesting to note, here, is that you provide the children (i.e.\nproperties) of your subject as a <code>KeyValuePairs&lt;String, Any&gt;</code> which is a bit like\na dictionary only that it can be used directly as function parameters.</p>\n<h1>Conclusion</h1>\n<p>So, where does this leave us? What are good use cases for this?\nObviously, if you're working a lot of <code>NSManagedObject</code>'s, this will\nconsiderably slow down your code base. Also if you only have one or two\n<code>structs</code>, it is easier, more performant, and less magical if you simply\nwrite a serialization technique yourself with the domain knowledge of\nyour individual <code>struct</code>.</p>\n<p>Rather, the reflection technique showcased here can be used if you have\nmany, complicated structs, and you'd like to store some of those\nsometimes.</p>\n<p>Examples would be:</p>\n<ul>\n<li>Setting Favorites</li>\n<li>Storing Bookmarks</li>\n<li>Staring Items</li>\n<li>Keeping the last selection</li>\n<li>Storing the ast open item across restarts</li>\n<li>Temporary storage of items during specific processes.</li>\n</ul>\n<p>Apart from that, of course, you can also use reflection for other use\ncases:</p>\n<ul>\n<li>Iterate over tuples</li>\n<li>Analyze classes</li>\n<li>Runtime analysis of object conformance</li>\n<li>Converting to / from JSON (or other types)</li>\n<li>Generated detailed logging / debugging information automatically\n(i.e. for externally generated objects)</li>\n</ul>\n<h1>More Information</h1>\n<p>The source documentation of the Reflection API is very detailed. I'd\nencourage everyone to have a look at that as well.</p>\n<p>Also, there's a much more exhaustive implementation of the techniques\nshowcased here in the <a href=\"http://github.com/terhechte/corevalue\">CoreValue</a>\nproject on GitHub which allows you to easily encode and decode from / to\nStructs to CoreData.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/problem_redux.md":["0b76655017b4c4b4",{"identifier":"059c08f8","filename":"problem_redux.md","info":{"title":"Simple Problem Redux","tags":["reduce"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-simple-problem-redux.html","content":"<p>We can now go back to our initial count &amp; average problem and try to\nsolve it with <code>reduce</code>.</p>\n<h1>InfoFromState, take two</h1>\n<pre class=\"Swift\"><code>\n\n   <span class=\"keyword\">func</span> infoFromState(state: <span class=\"type\">String</span>, persons: [[<span class=\"type\">String</span>: <span class=\"type\">Any</span>]]) \n\n       -&gt; (count: <span class=\"type\">Int</span>, age: <span class=\"type\">Float</span>) {\n\n\n\n       <span class=\"comment\">// The type alias in the function will keep the code cleaner</span>\n\n       <span class=\"keyword\">typealias</span> Acc = (count: <span class=\"type\">Int</span>, age: <span class=\"type\">Float</span>)\n\n\n\n       <span class=\"comment\">// reduce into a temporary variable</span>\n\n       <span class=\"keyword\">let</span> u = persons.<span class=\"call\">reduce</span>((count: <span class=\"number\">0</span>, age: <span class=\"number\">0.0</span>)) {\n\n           (ac: <span class=\"type\">Acc</span>, p) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span>\n\n\n\n           <span class=\"comment\">// Retrive the state and the age</span>\n\n           <span class=\"keyword\">guard let</span> personState = (p[\\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span>)?.<span class=\"call\">componentsSeparatedByString</span>(\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>).<span class=\"property\">last</span>,\n\n                 personAge = p[\\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">Int</span>\n\n\n\n             <span class=\"comment\">// make sure the person is from the correct state</span>\n\n             <span class=\"keyword\">where</span> personState == state\n\n\n\n             <span class=\"comment\">// if age or state are missing, or personState!=state, leave</span>\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> ac }\n\n\n\n           <span class=\"comment\">// Finally, accumulate the acount and the age</span>\n\n           <span class=\"keyword\">return</span> (count: ac.<span class=\"property\">count</span> + <span class=\"number\">1</span>, age: ac.<span class=\"property\">age</span> + <span class=\"type\">Float</span>(personAge))\n\n       }\n\n\n\n   <span class=\"comment\">// our result is the count and the age divided by count</span>\n\n   <span class=\"keyword\">return</span> (age: u.<span class=\"property\">age</span> / <span class=\"type\">Float</span>(u.<span class=\"property\">count</span>), count: u.<span class=\"property\">count</span>)\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">infoFromState</span>(state: \\<span class=\"string\">\"CA</span>\\<span class=\"string\">\"</span>, persons: persons))\n\n<span class=\"comment\">// prints: (count: 3, age: 34.3333)</span>\n</code></pre></code></pre>\n<p>As in earlier examples above, we're once again using a <code>tuple</code> to share\nstate in the accumulator. Apart from that, the code is easy to\nunderstand.</p>\n<p>We also defined a <code>typealias</code> <strong>Acc</strong> within the <code>func</code> in order to\nsimplify the type annotations a bit.</p>\n","raw_content":"[frontMatter]\ntitle = \"Simple Problem Redux\"\ntags = [\"reduce\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\nWe can now go back to our initial count & average problem and try to\nsolve it with `reduce`.\n\n# InfoFromState, take two\n\n``` Swift\n\n  func infoFromState(state: String, persons: [[String: Any]]) \n      -> (count: Int, age: Float) {\n\n      // The type alias in the function will keep the code cleaner\n      typealias Acc = (count: Int, age: Float)\n\n      // reduce into a temporary variable\n      let u = persons.reduce((count: 0, age: 0.0)) {\n          (ac: Acc, p) -> Acc in\n\n          // Retrive the state and the age\n          guard let personState = (p[\"city\"] as? String)?.componentsSeparatedByString(\", \").last,\n                personAge = p[\"age\"] as? Int\n\n            // make sure the person is from the correct state\n            where personState == state\n\n            // if age or state are missing, or personState!=state, leave\n            else { return ac }\n\n          // Finally, accumulate the acount and the age\n          return (count: ac.count + 1, age: ac.age + Float(personAge))\n      }\n\n  // our result is the count and the age divided by count\n  return (age: u.age / Float(u.count), count: u.count)\n}\nprint(infoFromState(state: \"CA\", persons: persons))\n// prints: (count: 3, age: 34.3333)\n```\n\nAs in earlier examples above, we\\'re once again using a `tuple` to share\nstate in the accumulator. Apart from that, the code is easy to\nunderstand.\n\nWe also defined a `typealias` **Acc** within the `func` in order to\nsimplify the type annotations a bit.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/intro.md":["48030aae7129b2e7",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Advanced Tuples","tags":["tuples"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-advanced-tuples.html","content":"<h1>Advanced Tuples</h1>\n<p>Now that we've seen the basics of how to use tuples, we will\nlook at more advanced use cases. This also means there will be\nless often situations where you can apply those patterns.</p>\n<p>Nevertheless, it is still very valuable to have them in your\ntoolbox.</p>\n","raw_content":"[frontMatter]\ntitle = \"Advanced Tuples\"\ntags = [\"tuples\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Advanced Tuples\n\nNow that we've seen the basics of how to use tuples, we will \nlook at more advanced use cases. This also means there will be\nless often situations where you can apply those patterns.\n\nNevertheless, it is still very valuable to have them in your\ntoolbox.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/sandbox.md":["b6eae1914f37fc8e",{"identifier":"850cee0f","filename":"sandbox.md","info":{"title":"How do I configure the macOS sandbox?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-configure-the-macos-sandbox.html","content":"<p>The macOS sandbox is a system that allows you to define which operating system services your app target is allowed to use. Here's a list of the available options:</p>\n<ul>\n<li>Incoming Connections: Your app is a server</li>\n<li>Outgoing Connections: Your app is a client (i.e. read anything from network)</li>\n<li>Camera access</li>\n<li>Audio Input</li>\n<li>USB</li>\n<li>Printing</li>\n<li>Bluetooth</li>\n<li>Accessing the users' Contacts</li>\n<li>Accessing the users' Location</li>\n<li>Accessing the users' Calendar</li>\n<li>File access to various user locations</li>\n</ul>\n<p>If you do not set these entitlements on your app, then you code is not allowed to access these services, and the app will crash or error when you try to do so.</p>\n<p>The sandbox is enabled automatically once you enable a Catalyst target on your iPad app. The settings can be found in the &quot;Signing &amp; Capabilities&quot; section and look like this:</p>\n<p><img src=\"/img-content/catalyst/sandbox.png\" alt=\"\" /></p>\n<p>Please note that the sandbox is not mandatory on macOS. You can disable it and then your app has much more leeway in what it can do on a users system. However, it is required if you want to ship your app on the macOS App Store.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I configure the macOS sandbox?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nThe macOS sandbox is a system that allows you to define which operating system services your app target is allowed to use. Here's a list of the available options:\n\n- Incoming Connections: Your app is a server\n- Outgoing Connections: Your app is a client (i.e. read anything from network)\n- Camera access\n- Audio Input\n- USB\n- Printing\n- Bluetooth\n- Accessing the users' Contacts\n- Accessing the users' Location\n- Accessing the users' Calendar\n- File access to various user locations\n\nIf you do not set these entitlements on your app, then you code is not allowed to access these services, and the app will crash or error when you try to do so.\n\nThe sandbox is enabled automatically once you enable a Catalyst target on your iPad app. The settings can be found in the \"Signing & Capabilities\" section and look like this:\n\n![](/img-content/catalyst/sandbox.png)\n\nPlease note that the sandbox is not mandatory on macOS. You can disable it and then your app has much more leeway in what it can do on a users system. However, it is required if you want to ship your app on the macOS App Store.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2019-03-20-appventure-relaunch.md":["c8caa54352f6a34c",{"identifier":"3ebc6a55","filename":"2019-03-20-appventure-relaunch.md","info":{"title":"Relaunching Appventure","tags":[],"keywords":["appventure","relaunch"],"category":[],"created":"2019-03-20 10:30:30","description":"Appventure has been relaunched to focus more on Swift","description_html":"<p>Appventure has been relaunched to focus more on Swift</p>\n","published":true,"slug":null,"meta":{"feature_image":"https://appventure.me/img-content/appventure-relaunch.png","thumbnail":"/img-content/appventure_relaunch.png"},"created_timestamp":1553077830,"date":"2019-03-20T10:30:30","date_info":{"year":2019,"month":3,"day":20,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2019-3-20-relaunching-appventure.html","content":"<h1>TLDR</h1>\n<p>I'm terribly excited to finally relaunch <code>appventure.me</code> with new structure, new looks and new purpose:</p>\n<ul>\n<li>Posts are separated into articles and guides now.</li>\n<li>Guides are long-form explanations on a specific subject, such as <code>pattern matching</code>. Guides can have multiple chapters, they're a bit like small books.</li>\n<li>Guides try to take a specific subject and explain it in very much detail.</li>\n<li>Articles are more or less short Swift tips and tricks or opinion pieces</li>\n<li>The old non-Swift content <a href=\"https://terhech.de\">moved to a completely different website, terhech.de</a></li>\n<li>Appventure.me is all about Swift now</li>\n<li>Almost all content &amp; examples have been updated to the current Swift version (minus some old articles that were specific to Swift 1.0 or Swift 2.0). Each chapter and article clearly states the Swift version it was written for.</li>\n<li>There's side-wide search now (top right)</li>\n<li>The site moved to a completely new static site generator</li>\n<li>I'm planning much more regular content updates</li>\n</ul>\n<h1>The long form explanation</h1>\n<p>I'm really excited about this update. I started working on more than a year ago but, due to time constraints and private issues, work stalled. I finally got around to working on it again earlier this year and finally made it. One of the reasons (I tell myself) of why there were few updates to this site in the past year was that the technical underpinnings were tricky.</p>\n<h2>The old stack</h2>\n<p>The old appventure stack ran on a custom static site generator that I wrote in Clojure in 2013. I really wanted to write the content in Emacs Org-Mode instead of Markdown so what I did was that for rendering the content, I'd fire up Emacs from the static site generator, parse the Org-Mode file, spit out the HTML, and render that into the filesystem. This worked well, but as appventure grew, this became terribly slow. On my old computer, rendering appventure after adding an article too around 4 minutes. Even worse, once I'd fixed a typo in the article, it took another 4 minutes. Now, I could have fixed all that, but I didn't want to. I'm not doing Clojure anymore and I can hardly still read the code. So when I set out to update appventure, I needed to fix the following tasks:</p>\n<ul>\n<li>Find or write a new static site engine that has many features and is <em>fast</em></li>\n<li>Update the looks of appventure</li>\n<li>Update all the content to the most recent Swift version</li>\n</ul>\n<p>Static site generators kind of are the new todo apps so I set out to write a new one. I really enjoyed working on it, and it is rendering all of appventure as well as <a href=\"https://terhech.de\">terhech.de</a> now. It is still closed source as I had to add a lot of hacks in the end in order to support enough features so that appventure could launch. I might open source it once I feel that it has enough abstractions for it to be useful for more people than just me.</p>\n<p>This new static site generator renders appventure in a much shorter amount of time, it also detects changes in source files and reloads the browser, which makes it a joy to use. I hope this will make it easier for me to create content.</p>\n<h2>Non-Swift Content</h2>\n<p>I mentioned <a href=\"https://terhech.de\">terhech.de</a> above. Over the years I had many articles that I would have liked to write but that I felt would not fit well on appventure as they were not about Swift (or development, <a href=\"https://sarbatka.com\">example, my music</a>). While I was working on the new appventure I felt that I needed a new host for the non-Swift content that was previously hosted on appventure. That's what <a href=\"https://terhech.de\">terhech.de</a> is about. That's where I will write about tech and non-tech topics. Some of the previous appventure articles (example, my recent project <a href=\"https://twitter.com/terhechte/gitsi\">Gitsi</a>) moved over.</p>\n<h2>New features</h2>\n<p>As listed above, the new static site generator has a lot of nice features which improve the structure of appventure:</p>\n<ul>\n<li>There's now a project-wide search</li>\n<li>Posts are separated into articles and guides now.</li>\n<li>Guides are long-form explanations on a specific subject, such as <code>pattern matching</code>. Guides can have multiple chapters, they're a bit like small books.</li>\n<li>Guides try to take a specific subject and explain it in very much detail.</li>\n<li>Articles are more or less short Swift tips and tricks or opinion pieces</li>\n</ul>\n<h2>Guides</h2>\n<p>As explained above, I decided to split up many of the current articles into guides.</p>\n<p>When you visit a guide, (such as the <a href=\"lnk::switch\">guide to pattern matching</a>), you will see that there is a content menu in the top left corner. This will show the full contents of the guide, making it easy to pick just the specific part you'd like to read about.</p>\n<p>Guides are not static. I'll continue to update guides by adding new chapters. New chapters can easily be detected as they'll have a small <code>NEW</code> icon next to their name. I'll also announce new chapters on <a href=\"https://twitter.com/terhechte\">twitter</a> and they'll pop up in the RSS feed.</p>\n<h2>Updated Content</h2>\n<p>Most of the content has been updated to the current Swift version. Obviously, I might have missed the one or other issue. If you find a bug, feel free to point it out to me by <a href=\"https://github.com/terhechte/appventure\">creating an issue on the Github repo</a>. Some articles have not been updated to the current Swift release yet. The guides, however, all have.</p>\n<h2>Feedback</h2>\n<p>I'm looking forward to feedback on the new website! Whether it is positive or negative feedback, <a href=\"https://twitter.com/terhechte\">feel free to point it out to me!</a> I hope you like it, cheers, Benedikt</p>\n","raw_content":"[frontMatter]\ndescription = \"Appventure has been relaunched to focus more on Swift\"\ntitle = \"Relaunching Appventure\"\ncreated = \"2019-03-20\"\npublished = true\nkeywords = [\"appventure\", \"relaunch\"]\ntags = []\n\n[meta]\nfeature_image = \"https://appventure.me/img-content/appventure-relaunch.png\"\nthumbnail = \"/img-content/appventure_relaunch.png\"\n---\n\n# TLDR\n\nI'm terribly excited to finally relaunch `appventure.me` with new structure, new looks and new purpose:\n\n- Posts are separated into articles and guides now. \n- Guides are long-form explanations on a specific subject, such as `pattern matching`. Guides can have multiple chapters, they're a bit like small books. \n- Guides try to take a specific subject and explain it in very much detail.\n- Articles are more or less short Swift tips and tricks or opinion pieces\n- The old non-Swift content [moved to a completely different website, terhech.de](https://terhech.de)\n- Appventure.me is all about Swift now\n- Almost all content & examples have been updated to the current Swift version (minus some old articles that were specific to Swift 1.0 or Swift 2.0). Each chapter and article clearly states the Swift version it was written for.\n- There's side-wide search now (top right)\n- The site moved to a completely new static site generator\n- I'm planning much more regular content updates\n\n# The long form explanation\n\nI'm really excited about this update. I started working on more than a year ago but, due to time constraints and private issues, work stalled. I finally got around to working on it again earlier this year and finally made it. One of the reasons (I tell myself) of why there were few updates to this site in the past year was that the technical underpinnings were tricky. \n\n## The old stack\n\nThe old appventure stack ran on a custom static site generator that I wrote in Clojure in 2013. I really wanted to write the content in Emacs Org-Mode instead of Markdown so what I did was that for rendering the content, I'd fire up Emacs from the static site generator, parse the Org-Mode file, spit out the HTML, and render that into the filesystem. This worked well, but as appventure grew, this became terribly slow. On my old computer, rendering appventure after adding an article too around 4 minutes. Even worse, once I'd fixed a typo in the article, it took another 4 minutes. Now, I could have fixed all that, but I didn't want to. I'm not doing Clojure anymore and I can hardly still read the code. So when I set out to update appventure, I needed to fix the following tasks:\n\n- Find or write a new static site engine that has many features and is *fast*\n- Update the looks of appventure\n- Update all the content to the most recent Swift version\n\nStatic site generators kind of are the new todo apps so I set out to write a new one. I really enjoyed working on it, and it is rendering all of appventure as well as [terhech.de](https://terhech.de) now. It is still closed source as I had to add a lot of hacks in the end in order to support enough features so that appventure could launch. I might open source it once I feel that it has enough abstractions for it to be useful for more people than just me.\n\nThis new static site generator renders appventure in a much shorter amount of time, it also detects changes in source files and reloads the browser, which makes it a joy to use. I hope this will make it easier for me to create content.\n\n## Non-Swift Content\n\nI mentioned [terhech.de](https://terhech.de) above. Over the years I had many articles that I would have liked to write but that I felt would not fit well on appventure as they were not about Swift (or development, [example, my music](https://sarbatka.com)). While I was working on the new appventure I felt that I needed a new host for the non-Swift content that was previously hosted on appventure. That's what [terhech.de](https://terhech.de) is about. That's where I will write about tech and non-tech topics. Some of the previous appventure articles (example, my recent project [Gitsi](https://twitter.com/terhechte/gitsi)) moved over.\n\n## New features\n\nAs listed above, the new static site generator has a lot of nice features which improve the structure of appventure:\n- There's now a project-wide search\n- Posts are separated into articles and guides now. \n- Guides are long-form explanations on a specific subject, such as `pattern matching`. Guides can have multiple chapters, they're a bit like small books. \n- Guides try to take a specific subject and explain it in very much detail.\n- Articles are more or less short Swift tips and tricks or opinion pieces\n\n## Guides\n\nAs explained above, I decided to split up many of the current articles into guides. \n\nWhen you visit a guide, (such as the [guide to pattern matching](lnk::switch)), you will see that there is a content menu in the top left corner. This will show the full contents of the guide, making it easy to pick just the specific part you'd like to read about.\n\nGuides are not static. I'll continue to update guides by adding new chapters. New chapters can easily be detected as they'll have a small `NEW` icon next to their name. I'll also announce new chapters on [twitter](https://twitter.com/terhechte) and they'll pop up in the RSS feed.\n\n## Updated Content\n\nMost of the content has been updated to the current Swift version. Obviously, I might have missed the one or other issue. If you find a bug, feel free to point it out to me by [creating an issue on the Github repo](https://github.com/terhechte/appventure). Some articles have not been updated to the current Swift release yet. The guides, however, all have.\n\n## Feedback\n\nI'm looking forward to feedback on the new website! Whether it is positive or negative feedback, [feel free to point it out to me!](https://twitter.com/terhechte) I hope you like it, cheers, Benedikt\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/sdks.md":["9fb408cbfa9009eb",{"identifier":"90a4dc12","filename":"sdks.md","info":{"title":"Third Party SDKs","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-third-party-sdks.html","content":"<p>Catalyst requires new builds of your third party frameworks and SDKs. The iOS or Simulator builds are not appropriate. This means that until your third party, closed source advertising or tracking library offers a new release with an added <code>UIKitForMac</code> target, you won't be able to build your app.</p>\n<p>As a temporary solution, if you wrapped all these dependencies in a wrapper, <a href=\"rel::firststeps/conditional_compilation.md\">you can just use conditional compilation to just not ship them on macOS.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"Third Party SDKs\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nCatalyst requires new builds of your third party frameworks and SDKs. The iOS or Simulator builds are not appropriate. This means that until your third party, closed source advertising or tracking library offers a new release with an added `UIKitForMac` target, you won't be able to build your app.\n\nAs a temporary solution, if you wrapped all these dependencies in a wrapper, [you can just use conditional compilation to just not ship them on macOS.](rel::firststeps/conditional_compilation.md)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/intro/nesting.md":["1d6d25cbc255d8a8",{"identifier":"1efffc6c","filename":"nesting.md","info":{"title":"Nesting","tags":["keypath","nesting"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-nesting.html","content":"<h1>Nesting</h1>\n<p>Obviously, you can also nest KeyPaths. Now, our <code>User</code> also has an <code>address</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Address {\n\n   <span class=\"keyword\">var</span> street: <span class=\"type\">String</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">var</span> address: <span class=\"type\">Address</span>\n\n}\n</code></pre></code></pre>\n<p>If we want to create a keypath to the amount of characters of the <code>street</code> of the user's address, we can simply do that like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">Int</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">address</span>.<span class=\"property\">street</span>.<span class=\"property\">count</span>\n</code></pre></code></pre>\n<p>As you can see, this is a <code>KeyPath</code> from <code>User</code> to <code>Int</code> because it points from the <code>User</code> to his address' street' count. <code>count</code>, finally, is a <code>Int</code> type.</p>\n","raw_content":"[frontMatter]\ntitle = \"Nesting\"\ntags = [\"keypath\", \"nesting\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Nesting\n\nObviously, you can also nest KeyPaths. Now, our `User` also has an `address`:\n\n``` Swift\nstruct Address {\n  var street: String\n}\n\nstruct User {\n  var username: String\n  var address: Address\n}\n```\n\nIf we want to create a keypath to the amount of characters of the `street` of the user's address, we can simply do that like this:\n\n``` Swift\nlet keyPath: KeyPath<User, Int> = \\User.address.street.count\n```\n\nAs you can see, this is a `KeyPath` from `User` to `Int` because it points from the `User` to his address' street' count. `count`, finally, is a `Int` type.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/tuple_pattern.md":["38cb6692ee842504",{"identifier":"a7c14e05","filename":"tuple_pattern.md","info":{"title":"Tuple Pattern","tags":["pattern matching","switch","tuple"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-tuple-pattern.html","content":"<h1>Tuple Pattern</h1>\n<p><a href=\"lnk::tuple\">We have a full article on tuples</a>, but here is a quick overview:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> age = <span class=\"number\">23</span>\n\n<span class=\"keyword\">let</span> job: <span class=\"type\">String</span>? = \\<span class=\"string\">\"Operator</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> payload: <span class=\"type\">Any</span> = <span class=\"type\">NSDictionary</span>()\n\n\n\n<span class=\"keyword\">switch</span> (age, job, payload) {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> age, <span class=\"keyword\">_</span>?, <span class=\"keyword\">_ as</span> <span class=\"type\">NSDictionary</span>):\n\n     <span class=\"call\">print</span>(age)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>Here, we're combining three values into a tuple (imagine they're\ncoming from different API calls) and matching them in one go. Note that\nthe pattern achieves three things:</p>\n<ol>\n<li>It extracts the age</li>\n<li>It makes sure there is a job, even though we don't need it</li>\n<li>It makes sure that the payload is of kind <code>NSDictionary</code> even though\nwe don't need the actual value either.</li>\n</ol>\n","raw_content":"[frontMatter]\ntitle = \"Tuple Pattern\"\ntags = [\"pattern matching\", \"switch\", \"tuple\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Tuple Pattern\n\n[We have a full article on tuples](lnk::tuple), but here is a quick overview:\n\n``` Swift\nlet age = 23\nlet job: String? = \"Operator\"\nlet payload: Any = NSDictionary()\n\nswitch (age, job, payload) {\ncase (let age, _?, _ as NSDictionary):\n    print(age)\ndefault: ()\n}\n```\n\nHere, we\\'re combining three values into a tuple (imagine they\\'re\ncoming from different API calls) and matching them in one go. Note that\nthe pattern achieves three things:\n\n1.  It extracts the age\n2.  It makes sure there is a job, even though we don\\'t need it\n3.  It makes sure that the payload is of kind `NSDictionary` even though\n    we don\\'t need the actual value either.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/hide_tabbar_with_toolbar.md":["51c2031de68a7a9e",{"identifier":"bdfec35f","filename":"hide_tabbar_with_toolbar.md","info":{"title":"How do I hide my iOS tabbar when I display a macOS toolbar?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-hide-my-ios-tabbar-when-i-display-a-macos-toolbar.html","content":"<p>If you want to hide your iOS tabbar, just as you're displaying your macOS toolbar, this is what you can do in your <code>SceneDelegate</code>:</p>\n<pre class=\"Swift\"><code>     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n         <span class=\"keyword\">if let</span> windowScene = scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span> {\n\n             <span class=\"keyword\">if let</span> titlebar = windowScene.<span class=\"property\">titlebar</span> {\n\n                 <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"NerauToolbar</span>\\<span class=\"string\">\"</span>)\n\n\n\n                 <span class=\"keyword\">let</span> rootViewController = window?.<span class=\"property\">rootViewController</span> <span class=\"keyword\">as</span>? <span class=\"type\">UITabBarController</span>\n\n                 rootViewController?.<span class=\"property\">tabBar</span>.<span class=\"property\">isHidden</span> = <span class=\"keyword\">true</span>\n\n\n\n                 toolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n                 titlebar.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n\n\n                 titlebar.<span class=\"property\">toolbar</span> = toolbar\n\n             }\n\n         }\n\n         <span class=\"preprocessing\">#endif</span>\n\n     }\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I hide my iOS tabbar when I display a macOS toolbar?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nIf you want to hide your iOS tabbar, just as you're displaying your macOS toolbar, this is what you can do in your `SceneDelegate`:\n\n``` swift\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        #if targetEnvironment(UIKitForMac)\n        if let windowScene = scene as? UIWindowScene {\n            if let titlebar = windowScene.titlebar {\n                let toolbar = NSToolbar(identifier: \"NerauToolbar\")\n\n                let rootViewController = window?.rootViewController as? UITabBarController\n                rootViewController?.tabBar.isHidden = true\n\n                toolbar.delegate = self\n                titlebar.titleVisibility = .hidden\n\n                titlebar.toolbar = toolbar\n            }\n        }\n        #endif\n    }\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/issues/issues.md":["9180049b247deedb",{"identifier":"75b56c20","filename":"issues.md","info":{"title":"Known Issues?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-known-issues.html","content":"<p>This is a list of somehow known issues, i.e. bugs where enough people seem to have them that it seems it is not an issue in your app but instead related to the current beta. This list is helpful to keep you from trying to hunt down a bug that's not yours.</p>\n<h2>My app crashes when I close a window</h2>\n<p>If you see this when closing a window:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">***</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> Terminating app due to uncaught exception <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>NSRangeException<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span>, reason: <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>Cannot remove an observer &lt;UISystemInputAssistantViewController 0x1010adcf0&gt; for the key path &quot;bounds&quot; from &lt;CALayer 0x600000295bc0&gt; because it is not registered as an observer.<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span></span>\n</span></code></pre></code></pre>\n<p>That seems to be an issue in the current beta</p>\n<h2>My app crashes with &quot;another instance of this process was already running&quot;</h2>\n<p>This seems to be a bug or a feature in Catalina. With AppKit apps, multiple instances of the same app (with the same bundle identifier) can be running without an issue. If you duplicate <code>Calculator.app</code> 5 times and start them all, you have 5 calculators running. This seems to not be the case with Catalyst apps. If a Catalyst apps crashes in a certain way, apparently the system thinks it is still running. Thus, you can't run it again. Currently the only solution I know of is to reboot Catalina. Congratulations. The full error is:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">Couldn<span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>t register uikitformac.com.stylemac.Nerau.gsEvents with the bootstrap server. Error: unknown error code (1100).\nThis generally means that another instance of this process was already running or is hung in the debugger.\n</span></span></span></span></code></pre></code></pre>\n<h2>I get weird SwiftUIKit compiler errors</h2>\n<p>Could it be that your <code>Xcode-beta.app</code> is either not in <code>/Applications</code> or not named <code>Xcode-beta.app</code>? (I.e. <code>Xcode-Beta v11.app</code>. Then, Catalyst apps currently won't compile.</p>\n<h2>When I create a new Window, the <code>NSUserActivity</code> disappears</h2>\n<p>This seems to be rather flaky currently.</p>\n","raw_content":"[frontMatter]\ntitle = \"Known Issues?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\nThis is a list of somehow known issues, i.e. bugs where enough people seem to have them that it seems it is not an issue in your app but instead related to the current beta. This list is helpful to keep you from trying to hunt down a bug that's not yours.\n\n## My app crashes when I close a window\n\nIf you see this when closing a window:\n\n``` bash\n *** Terminating app due to uncaught exception 'NSRangeException', reason: 'Cannot remove an observer <UISystemInputAssistantViewController 0x1010adcf0> for the key path \"bounds\" from <CALayer 0x600000295bc0> because it is not registered as an observer.'\n```\n\nThat seems to be an issue in the current beta\n\n## My app crashes with \"another instance of this process was already running\"\n\nThis seems to be a bug or a feature in Catalina. With AppKit apps, multiple instances of the same app (with the same bundle identifier) can be running without an issue. If you duplicate `Calculator.app` 5 times and start them all, you have 5 calculators running. This seems to not be the case with Catalyst apps. If a Catalyst apps crashes in a certain way, apparently the system thinks it is still running. Thus, you can't run it again. Currently the only solution I know of is to reboot Catalina. Congratulations. The full error is:\n\n``` bash\nCouldn't register uikitformac.com.stylemac.Nerau.gsEvents with the bootstrap server. Error: unknown error code (1100).\nThis generally means that another instance of this process was already running or is hung in the debugger.\n```\n\n## I get weird SwiftUIKit compiler errors\n\nCould it be that your `Xcode-beta.app` is either not in `/Applications` or not named `Xcode-beta.app`? (I.e. `Xcode-Beta v11.app`. Then, Catalyst apps currently won't compile.\n\n## When I create a new Window, the `NSUserActivity` disappears\n\nThis seems to be rather flaky currently.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/conclusion.md":["70cb5bf118326e2d",{"identifier":"c97953ae","filename":"conclusion.md","info":{"title":"Conclusion","tags":["reflection"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-conclusion.html","content":"<h1>Conclusion</h1>\n<p>So, where does this leave us? What are good use cases for this?\nObviously, if you're working a lot of <code>NSManagedObject</code>'s, this will\nconsiderably slow down your code base. Also if you only have one or two\n<code>structs</code>, it is easier, more performant, and less magical if you simply\nwrite a serialization technique yourself with the domain knowledge of\nyour individual <code>struct</code>.</p>\n<p>Rather, the reflection technique showcased here can be used if you have\nmany, complicated structs, and you'd like to store some of those\nsometimes.</p>\n<p>Examples would be:</p>\n<ul>\n<li>Setting Favorites</li>\n<li>Storing Bookmarks</li>\n<li>Staring Items</li>\n<li>Keeping the last selection</li>\n<li>Storing the ast open item across restarts</li>\n<li>Temporary storage of items during specific processes.</li>\n</ul>\n<p>Apart from that, of course, you can also use reflection for other use\ncases:</p>\n<ul>\n<li>Iterate over tuples</li>\n<li>Analyze classes</li>\n<li>Runtime analysis of object conformance</li>\n<li>Converting to / from JSON (or other types)</li>\n<li>Generated detailed logging / debugging information automatically\n(i.e. for externally generated objects)</li>\n</ul>\n<h1>More Information</h1>\n<p>The source documentation of the Reflection API is very detailed. I'd\nencourage everyone to have a look at that as well.</p>\n<p>Also, there's a much more exhaustive implementation of the techniques\nshowcased here in the <a href=\"http://github.com/terhechte/corevalue\">CoreValue</a>\nproject on GitHub which allows you to easily encode and decode from / to\nStructs to CoreData.</p>\n","raw_content":"[frontMatter]\ntitle = \"Conclusion\"\ntags = [\"reflection\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Conclusion\n\nSo, where does this leave us? What are good use cases for this?\nObviously, if you\\'re working a lot of `NSManagedObject`\\'s, this will\nconsiderably slow down your code base. Also if you only have one or two\n`structs`, it is easier, more performant, and less magical if you simply\nwrite a serialization technique yourself with the domain knowledge of\nyour individual `struct`.\n\nRather, the reflection technique showcased here can be used if you have\nmany, complicated structs, and you\\'d like to store some of those\nsometimes.\n\nExamples would be:\n\n-   Setting Favorites\n-   Storing Bookmarks\n-   Staring Items\n-   Keeping the last selection\n-   Storing the ast open item across restarts\n-   Temporary storage of items during specific processes.\n\nApart from that, of course, you can also use reflection for other use\ncases:\n\n-   Iterate over tuples\n-   Analyze classes\n-   Runtime analysis of object conformance\n-   Converting to / from JSON (or other types)\n-   Generated detailed logging / debugging information automatically\n    (i.e. for externally generated objects)\n\n# More Information\n\nThe source documentation of the Reflection API is very detailed. I\\'d\nencourage everyone to have a look at that as well.\n\nAlso, there\\'s a much more exhaustive implementation of the techniques\nshowcased here in the [CoreValue](http://github.com/terhechte/corevalue)\nproject on GitHub which allows you to easily encode and decode from / to\nStructs to CoreData.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/keyboard_shortcuts.md":["bb7531d0a598018d",{"identifier":"d76f2d35","filename":"keyboard_shortcuts.md","info":{"title":"How do I support keyboard shortcuts?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-support-keyboard-shortcuts.html","content":"<p>Keyboard shortcuts are implemented via the existing <code>UIKeyCommand</code> system on <code>UIResponder</code>. Here's a simple example of how your currently visible view controller can listen for <code>Escape</code> key presses by the user:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> MyKeyListeningViewController: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">override var</span> keyCommands: [<span class=\"type\">UIKeyCommand</span>]? {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">UIKeyCommand</span>(input: <span class=\"type\">UIKeyCommand</span>.<span class=\"property\">inputEscape</span>,\n\n                              modifierFlags: [],\n\n                              action: <span class=\"keyword\">#selector</span>(<span class=\"call\">doCancelCommand</span>(sender:)))\n\n         ]\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Keep in mind that on macOS multiple views can easily be visible at the same time and <a href=\"how/responder_chain.md\">the rules of the responder chain apply.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"How do I support keyboard shortcuts?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nKeyboard shortcuts are implemented via the existing `UIKeyCommand` system on `UIResponder`. Here's a simple example of how your currently visible view controller can listen for `Escape` key presses by the user:\n\n``` swift\nclass MyKeyListeningViewController: UIViewController {\n    override var keyCommands: [UIKeyCommand]? {\n        return [UIKeyCommand(input: UIKeyCommand.inputEscape,\n                             modifierFlags: [],\n                             action: #selector(doCancelCommand(sender:)))\n        ]\n    }\n}\n```\n\nKeep in mind that on macOS multiple views can easily be visible at the same time and [the rules of the responder chain apply.](how/responder_chain.md)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/more_examples/unique.md":["9cdfa4a7c49f8a0d",{"identifier":"404ffc71","filename":"unique.md","info":{"title":"Unique","tags":["reduce","unique"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-unique.html","content":"<h1>Unique</h1>\n<p>Return a list with all duplicates removed. The better solution would be\nto use a <code>Set</code>.</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>].<span class=\"call\">reduce</span>([], { (a: [<span class=\"type\">Int</span>], b: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n   <span class=\"keyword\">if</span> a.<span class=\"call\">contains</span>(b) {\n\n     <span class=\"keyword\">return</span> a\n\n   } <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">return</span> a + [b]\n\n   }\n\n})\n\n<span class=\"comment\">// prints: 1, 2, 5, 7</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Unique\"\ntags = [\"reduce\", \"unique\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Unique\n\nReturn a list with all duplicates removed. The better solution would be\nto use a `Set`.\n\n``` Swift\n[1, 2, 5, 1, 7].reduce([], { (a: [Int], b: Int) -> [Int] in\n  if a.contains(b) {\n    return a\n  } else {\n    return a + [b]\n  }\n})\n// prints: 1, 2, 5, 7\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/performance.md":["c10beeffc963a326",{"identifier":"6f3dfaf0","filename":"performance.md","info":{"title":"Performance & inout","tags":["reduce","inout","valuetype","copy-on-write"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-performance-inout.html","content":"<h1>Performance</h1>\n<p>Apart from the higher flexibility that <code>reduce</code> offers, it has another\nadvantage: Oftentimes, chaining <code>map</code> and <code>filter</code> induces a performance\npenalty as Swift has to iterate over your collection multiple times in\norder to generate the required data. Imagine the following code:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">map</span>({ $0 + <span class=\"number\">3</span>})\n\n     .<span class=\"call\">filter</span>({ $0 % <span class=\"number\">2</span> == <span class=\"number\">0</span>})\n\n     .<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, +)\n</code></pre></code></pre>\n<p>Apart from being nonsensical, it is also wasting CPU cycles. The initial\nsequence will be iterated over 3 times. First to map it, then to filter\nit, and finally to sum up the contents. Instead, all of this can just as\nwell be implemented as one reduce call, which greatly improves the\nperformance:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, { (ac: <span class=\"type\">Int</span>, r: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in</span> \n\n    <span class=\"keyword\">if</span> (r + <span class=\"number\">3</span>) % <span class=\"number\">2</span> == <span class=\"number\">0</span> {\n\n      <span class=\"keyword\">return</span> ac + r + <span class=\"number\">3</span>\n\n    } <span class=\"keyword\">else</span> {\n\n      <span class=\"keyword\">return</span> ac\n\n    }\n\n})\n</code></pre></code></pre>\n<p>Here's a quick benchmark of running both versions and the for-loop\nversion below over an list with 100.000 items:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> ux = <span class=\"number\">0</span>\n\n<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>) {\n\n     <span class=\"keyword\">if</span> (i + <span class=\"number\">3</span>) % <span class=\"number\">2</span> == <span class=\"number\">0</span> {\n\n         ux += (i + <span class=\"number\">3</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<style type=\"text/css\">\n.linechart {\n    border: 3px solid white;\n    border-radius: 32px;\n    font-family: Sans-Serif;\n    color: white;\n    font-weight: normal;\n    padding: 4px;\n    margin-bottom: 20px;\n}\n.redxx {\n    background-color: red;\n}\n.greenxx {\n    background-color: green;\n}\n.linechart > span {\n    padding: 4px;\n}\nh3.ggx {\n    font-family: Sans-Serif;\nfont-weight: normal;\n}\n.orangexx {\n    background-color: orange;\n}\n</style>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart greenxx\" style=\"width: 41%\">\n<span>For Loop: 0.030 seconds</span>\n</div>\n<div class=\"linechart orangexx\" style=\"width: 47%\">\n<span>Reduce: 0.034 seconds</span>\n</div>\n<div class=\"linechart redxx\">\n<span>Map/Filter: 0.072 seconds</span>\n</div>\n</div>\n<p>As you can see, the <code>reduce</code> version' performance is very close to the\nmutating for loop and more than twice as fast as the chaining operation.</p>\n<p>However, in other situations, chained operation can greatly outperform\n<code>reduce</code>. Consider the following example where we add <em>3</em> to each entry in the array.</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">map</span>({ $0 + <span class=\"number\">3</span>}).<span class=\"call\">reverse</span>().<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n\n<span class=\"comment\">// 0.027 Seconds</span>\n</code></pre></code></pre>\n<p>And the <code>reduce</code> version:</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">reduce</span>([], { (ac: [<span class=\"type\">Int</span>], r: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">return</span> ac + [r + <span class=\"number\">3</span>]\n\n}).<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n\n\n\n<span class=\"comment\">// 2.927 Seconds</span>\n</code></pre></code></pre>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart\" style=\"width: 100%\">\n<span>For Loop: 0.027 seconds</span>\n</div>\n<div class=\"linechart redxx\" style=\"width: 100%\">\n<span>Reduce: 2.927 seconds</span>\n</div>\n</div>\n<p>Here, we have a stark performance difference of 0.027s for the chained\noperation vs. 2.927s for the reduce operation, what's happening\nhere?</p>\n<p><code>Arrays</code> in Swift are value types with so-called <code>copy on write</code> semantics.</p>\n<h1>Copy on Write</h1>\n<p>Imagine you had a struct <code>User</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> benedikt = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Benedikt</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">var</span> secondBenedikt = benedikt\n\n<span class=\"keyword\">var</span> thirdBenedikt = benedikt\n</code></pre></code></pre>\n<p><code>struct</code> types in Swift are value types. Value type means that each copy\nis a new distinct value. So if I were to change the <code>username</code> value of <code>secondBenedikt</code> to\n<code>Klaus</code>, then the <code>username</code> value of the other two benedikts (<code>benedikt</code>, <code>thirdBenedikt</code>)\nwould still be <code>Benedikt</code> and not <code>Klaus</code>. So, everytime you do a <code>a = b</code>, <code>b</code> is <strong>copied</strong> to <code>a</code>.</p>\n<p>Copy operations, however, are expensive. All that memory has to be copied from <code>a</code> to <code>b</code>. So Swift employs\na smart trick: As long as you don't <strong>mutate / modify</strong> a variable, it will just not copy it.</p>\n<p>So in our example above, <code>benedikt</code>, <code>secondBenedikt</code>, and <code>thirdBenedikt</code> are the same thing, they point\nto the same memory. Only once you change one of them (say <code>benedikt.username = 'Hans'</code>) will they be copied\ninto distinct types.</p>\n<p>So what's all that to do with our <code>reduce</code> issue here?</p>\n<h1>Array Value Types</h1>\n<p>Arrays are <code>value types</code>, too. This means that whenever an array is mutated, a new copy is created.\nSo in our <code>reduce</code> function:</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">reduce</span>([], { (ac: [<span class=\"type\">Int</span>], r: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">return</span> ac + [r + <span class=\"number\">3</span>]\n\n}).<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n</code></pre></code></pre>\n<p>This will copy the array 100000 times. That's why the performance is so abysmal.\nSo how do we fix this?</p>\n<h1>The power of <code>inout</code></h1>\n<p>There's another version of <code>reduce</code> with slightly different parameters. Its function signature\nlooks like this (simplified):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> reduce&lt;Result&gt;(into initialResult: <span class=\"type\">Result</span>, \n\n   <span class=\"keyword\">_</span> updateAccumulatingResult: (<span class=\"keyword\">inout</span> <span class=\"type\">Result</span>, <span class=\"type\">Element</span>) <span class=\"keyword\">throws</span> -&gt; ()) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">Result</span>\n</code></pre></code></pre>\n<p>The magic is the <code>inout Result</code>. Inout is a special attribute that you can use\nin function signatures to denote to Swift that you wish to refer to the same instance of\na type without making copies. The name implies how it works: When the function is called, the\nvalue is <code>moved in</code> to the function, when the function is done, the value is <code>moved out</code> again.</p>\n<p>In the case of our arrays, instead of making multiple copies, we will always modify the same array.</p>\n<p>So if we rewrite our <code>reduce</code> from above with <code>reduce(into:)</code> what is the performance?</p>\n<p>Here is the updated code:</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">reduce</span>(into: [<span class=\"type\">Int</span>](), { ac, r <span class=\"keyword\">in</span>\n\n                 <span class=\"keyword\">return</span> ac.<span class=\"call\">append</span>(r + <span class=\"number\">3</span>)\n\n             }).<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n</code></pre></code></pre>\n<p>And this is the new performance:</p>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart\" style=\"width: 100%\">\n<span>Map: 0.0295 seconds</span>\n</div>\n<div class=\"linechart\" style=\"width: 100%\">\n<span>Reduce Into: 0.0376 seconds</span>\n</div>\n<div class=\"linechart redxx\" style=\"width: 100%\">\n<span>Reduce: 1.49 seconds</span>\n</div>\n</div>\n<p>We're almost reached the speed of the simpler <code>map</code> implementation. It is much\nfaster now. Awesome!</p>\n","raw_content":"[frontMatter]\ntitle = \"Performance & inout\"\ntags = [\"reduce\", \"inout\", \"valuetype\", \"copy-on-write\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Performance\n\nApart from the higher flexibility that `reduce` offers, it has another\nadvantage: Oftentimes, chaining `map` and `filter` induces a performance\npenalty as Swift has to iterate over your collection multiple times in\norder to generate the required data. Imagine the following code:\n\n``` Swift\n[0, 1, 2, 3, 4].map({ $0 + 3})\n    .filter({ $0 % 2 == 0})\n    .reduce(0, +)\n```\n\nApart from being nonsensical, it is also wasting CPU cycles. The initial\nsequence will be iterated over 3 times. First to map it, then to filter\nit, and finally to sum up the contents. Instead, all of this can just as\nwell be implemented as one reduce call, which greatly improves the\nperformance:\n\n``` Swift\n[0, 1, 2, 3, 4].reduce(0, { (ac: Int, r: Int) -> Int in \n   if (r + 3) % 2 == 0 {\n     return ac + r + 3\n   } else {\n     return ac\n   }\n})\n```\n\nHere\\'s a quick benchmark of running both versions and the for-loop\nversion below over an list with 100.000 items:\n\n``` Swift\nvar ux = 0\nfor i in Array(0...100000) {\n    if (i + 3) % 2 == 0 {\n        ux += (i + 3)\n    }\n}\n```\n\n<style type=\"text/css\">\n.linechart {\n    border: 3px solid white;\n    border-radius: 32px;\n    font-family: Sans-Serif;\n    color: white;\n    font-weight: normal;\n    padding: 4px;\n    margin-bottom: 20px;\n}\n.redxx {\n    background-color: red;\n}\n.greenxx {\n    background-color: green;\n}\n.linechart > span {\n    padding: 4px;\n}\nh3.ggx {\n    font-family: Sans-Serif;\nfont-weight: normal;\n}\n.orangexx {\n    background-color: orange;\n}\n</style>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart greenxx\" style=\"width: 41%\">\n<span>For Loop: 0.030 seconds</span>\n</div>\n<div class=\"linechart orangexx\" style=\"width: 47%\">\n<span>Reduce: 0.034 seconds</span>\n</div>\n<div class=\"linechart redxx\">\n<span>Map/Filter: 0.072 seconds</span>\n</div>\n</div>\n\nAs you can see, the `reduce` version\\' performance is very close to the\nmutating for loop and more than twice as fast as the chaining operation.\n\nHowever, in other situations, chained operation can greatly outperform\n`reduce`. Consider the following example where we add *3* to each entry in the array.\n\n``` Swift\nArray(0...100000).map({ $0 + 3}).reverse().prefix(3)\n// 0.027 Seconds\n```\n\nAnd the `reduce` version:\n\n``` Swift\nArray(0...100000).reduce([], { (ac: [Int], r: Int) -> [Int] in\n    return ac + [r + 3]\n}).prefix(3)\n\n// 2.927 Seconds\n```\n\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart\" style=\"width: 100%\">\n<span>For Loop: 0.027 seconds</span>\n</div>\n<div class=\"linechart redxx\" style=\"width: 100%\">\n<span>Reduce: 2.927 seconds</span>\n</div>\n</div>\n\nHere, we have a stark performance difference of 0.027s for the chained\noperation vs. 2.927s for the reduce operation, what\\'s happening\nhere?\n\n`Arrays` in Swift are value types with so-called `copy on write` semantics.\n\n# Copy on Write\n\nImagine you had a struct `User`: \n``` Swift\nstruct User {\n  var username: String\n}\nvar benedikt = User(username: \"Benedikt\")\nvar secondBenedikt = benedikt\nvar thirdBenedikt = benedikt\n```\n\n`struct` types in Swift are value types. Value type means that each copy\nis a new distinct value. So if I were to change the `username` value of `secondBenedikt` to\n`Klaus`, then the `username` value of the other two benedikts (`benedikt`, `thirdBenedikt`)\nwould still be `Benedikt` and not `Klaus`. So, everytime you do a `a = b`, `b` is **copied** to `a`.\n\nCopy operations, however, are expensive. All that memory has to be copied from `a` to `b`. So Swift employs\na smart trick: As long as you don't **mutate / modify** a variable, it will just not copy it. \n\nSo in our example above, `benedikt`, `secondBenedikt`, and `thirdBenedikt` are the same thing, they point\nto the same memory. Only once you change one of them (say `benedikt.username = 'Hans'`) will they be copied\ninto distinct types.\n\nSo what's all that to do with our `reduce` issue here?\n\n# Array Value Types\n\nArrays are `value types`, too. This means that whenever an array is mutated, a new copy is created.\nSo in our `reduce` function:\n\n``` Swift\nArray(0...100000).reduce([], { (ac: [Int], r: Int) -> [Int] in\n    return ac + [r + 3]\n}).prefix(3)\n```\n\nThis will copy the array 100000 times. That's why the performance is so abysmal. \nSo how do we fix this?\n\n# The power of `inout`\n\nThere's another version of `reduce` with slightly different parameters. Its function signature\nlooks like this (simplified):\n\n``` Swift\nfunc reduce<Result>(into initialResult: Result, \n  _ updateAccumulatingResult: (inout Result, Element) throws -> ()) rethrows -> Result\n```\n\nThe magic is the `inout Result`. Inout is a special attribute that you can use\nin function signatures to denote to Swift that you wish to refer to the same instance of\na type without making copies. The name implies how it works: When the function is called, the\nvalue is `moved in` to the function, when the function is done, the value is `moved out` again.\n\nIn the case of our arrays, instead of making multiple copies, we will always modify the same array.\n\nSo if we rewrite our `reduce` from above with `reduce(into:)` what is the performance?\n\nHere is the updated code:\n\n``` Swift\nArray(0...100000).reduce(into: [Int](), { ac, r in\n                return ac.append(r + 3)\n            }).prefix(3)\n```\n\nAnd this is the new performance:\n\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart\" style=\"width: 100%\">\n<span>Map: 0.0295 seconds</span>\n</div>\n<div class=\"linechart\" style=\"width: 100%\">\n<span>Reduce Into: 0.0376 seconds</span>\n</div>\n<div class=\"linechart redxx\" style=\"width: 100%\">\n<span>Reduce: 1.49 seconds</span>\n</div>\n</div>\n\nWe're almost reached the speed of the simpler `map` implementation. It is much\nfaster now. Awesome!\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/working_around_associated_type_issues/equatable.md":["5dbd5afb19154799",{"identifier":"21abc874","filename":"equatable.md","info":{"title":"Equatable","tags":["box","associated","protocol","equatable"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-equatable.html","content":"<h1>Make Your Types Equatable</h1>\n<p>The first solution for the archetypical problem is also a really simple\none. Instead of enforcing <code>Equatable</code> on your custom <code>protocol</code>, you can\nsimply require your full fledged, final, types to conform to the\n<code>Equatable</code> protocol instead of your custom protocol. Consider the\npreviously defined <code>Bookmarkable</code> protocol:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Bookmarkable {\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Bookmark: <span class=\"type\">Bookmarkable</span>, <span class=\"type\">Equatable</span> {\n\n   <span class=\"keyword\">var</span> identifier: <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"keyword\">func</span> ==(lhs: <span class=\"type\">Bookmark</span>, rhs: <span class=\"type\">Bookmark</span>) -&gt; <span class=\"type\">Bool</span> {\n\n   <span class=\"keyword\">return</span> lhs.<span class=\"property\">identifier</span> == rhs.<span class=\"property\">identifier</span>\n\n}\n\n\n\n<span class=\"keyword\">var</span> myBookmarks: [<span class=\"type\">Bookmark</span>] = []\n</code></pre></code></pre>\n<p>In the example above, the <code>Equatable</code> requirement actually stems from\nthe <code>Bookmark</code> type conforming to the <code>Equatable</code> protocol, not the\n<code>Bookmarkable</code> protocol itself. The actual <code>Equatable</code> information,\nhowever, lies in the new <code>identifier</code> property, which has been added to\nthe <code>Bookmark</code> <code>struct</code>. As you can easily see, this also requires you\nto make the <code>myBookmarks</code> array require only elements of type\n<code>Bookmark</code>. A serious disgression if you're used to using protocols\nlike partially anonymous types. A better solution, if your design allows\nfor it, goes one step further by enforcing the new <code>property</code> which we\nintroduced in this example.</p>\n<h2>Equatable Properties</h2>\n<p>Here, the idea is that we take one of the types that already implement\n<code>Equatable</code> in a proper way (i.e. <code>Int</code>, <code>String</code>, ...) and add a new\n<code>property</code> requirement to our <code>Bookmarkable</code> protocol. Then, we can use\nthis <code>property</code> to add <code>Equatable</code> support without actually implementing\n<code>Equatable</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Bookmarkable {\n\n     <span class=\"keyword\">var</span> identifier: <span class=\"type\">Int</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Bookmark: <span class=\"type\">Bookmarkable</span> {\n\n     <span class=\"keyword\">var</span> identifier: <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"keyword\">var</span> myBookmarks: [<span class=\"type\">Bookmarkable</span>] = []\n</code></pre></code></pre>\n<p>The main change, compared to the code above, is that the\n<code>var identifier</code> moved to the <code>Bookmarkable</code> protocol and that we\nremoved the <code>func ==</code>.</p>\n<p>While this works better, it still has a major deficit. Since\n<code>Bookmarkable</code> does not directly comply with <code>Equatable</code>, you will not\ngain the standard library's methods that specifically deal with\n<code>Equatable</code> types. So instead of being able to call <code>Array.contains</code>\nlike this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> ourBookmark = <span class=\"type\">Bookmark</span>(identifier: <span class=\"number\">0</span>)\n\n<span class=\"keyword\">let</span> result = myBookmarks.<span class=\"call\">contains</span>(ourBookmark)\n</code></pre></code></pre>\n<p>You will have to use the more verbose closure-based version:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> ourBookmark = <span class=\"type\">Bookmark</span>(identifier: <span class=\"number\">0</span>)\n\n\n\n<span class=\"keyword\">let</span> result = myBookmarks.<span class=\"call\">contains</span> { (bookmark) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">return</span> bookmark.<span class=\"property\">identifier</span> == ourBookmark.<span class=\"property\">identifier</span>\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Equatable\"\ntags = [\"box\", \"associated\", \"protocol\", \"equatable\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Make Your Types Equatable\n\nThe first solution for the archetypical problem is also a really simple\none. Instead of enforcing `Equatable` on your custom `protocol`, you can\nsimply require your full fledged, final, types to conform to the\n`Equatable` protocol instead of your custom protocol. Consider the\npreviously defined `Bookmarkable` protocol:\n\n``` Swift\nprotocol Bookmarkable {\n}\n\nstruct Bookmark: Bookmarkable, Equatable {\n  var identifier: Int\n}\n\nfunc ==(lhs: Bookmark, rhs: Bookmark) -> Bool {\n  return lhs.identifier == rhs.identifier\n}\n\nvar myBookmarks: [Bookmark] = []\n```\n\nIn the example above, the `Equatable` requirement actually stems from\nthe `Bookmark` type conforming to the `Equatable` protocol, not the\n`Bookmarkable` protocol itself. The actual `Equatable` information,\nhowever, lies in the new `identifier` property, which has been added to\nthe `Bookmark` `struct`. As you can easily see, this also requires you\nto make the `myBookmarks` array require only elements of type\n`Bookmark`. A serious disgression if you\\'re used to using protocols\nlike partially anonymous types. A better solution, if your design allows\nfor it, goes one step further by enforcing the new `property` which we\nintroduced in this example.\n\n## Equatable Properties\n\nHere, the idea is that we take one of the types that already implement\n`Equatable` in a proper way (i.e. `Int`, `String`, ...) and add a new\n`property` requirement to our `Bookmarkable` protocol. Then, we can use\nthis `property` to add `Equatable` support without actually implementing\n`Equatable`:\n\n``` Swift\nprotocol Bookmarkable {\n    var identifier: Int { get }\n}\n\nstruct Bookmark: Bookmarkable {\n    var identifier: Int\n}\n\nvar myBookmarks: [Bookmarkable] = []\n```\n\nThe main change, compared to the code above, is that the\n`var identifier` moved to the `Bookmarkable` protocol and that we\nremoved the `func ==`.\n\nWhile this works better, it still has a major deficit. Since\n`Bookmarkable` does not directly comply with `Equatable`, you will not\ngain the standard library\\'s methods that specifically deal with\n`Equatable` types. So instead of being able to call `Array.contains`\nlike this:\n\n``` Swift\nlet ourBookmark = Bookmark(identifier: 0)\nlet result = myBookmarks.contains(ourBookmark)\n```\n\nYou will have to use the more verbose closure-based version:\n\n``` Swift\nlet ourBookmark = Bookmark(identifier: 0)\n\nlet result = myBookmarks.contains { (bookmark) -> Bool in\n    return bookmark.identifier == ourBookmark.identifier\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/responder_chain.md":["43fdb2cfa9116a2b",{"identifier":"c9b76610","filename":"responder_chain.md","info":{"title":"How do I use the responder chain?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-use-the-responder-chain.html","content":"<p>The responder chain is a event handling system at the heart of macOS and iOS.\nEvery touch event coming in, for example, uses this responder chain to reach the currently active <code>UIControl</code>. The main building block of the responder chain is the <code>UIResponder</code> class which is a superclass of <code>UIViewController</code> or <code>UIView</code>.</p>\n<p>Apple has very useful information on this available:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events\">iOS: Using Responders and the Responder Chain</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/EventOverview/EventArchitecture/EventArchitecture.html\">macOS: Event Architecture Overview</a></li>\n</ul>\n<p>Below, I'll quote the most important sections to understand the thing:</p>\n<p>Responders receive the raw event data and must either handle the event or forward it to another responder object. When your app receives an event, UIKit automatically directs that event to the most appropriate responder object, known as the first responder.</p>\n<p>Unhandled events are passed from responder to responder in the active responder chain.</p>\n<p>Here's an image from the Apple Documentation:</p>\n<p><img src=\"/img-content/catalyst/responderchain.png\" alt=\"\" /></p>\n<p>Now imagine that you're entering text in the text field. The following will happen:</p>\n<ol>\n<li>If the text field does not handle an event, UIKit sends the event to the text field’s parent UIView object</li>\n<li>If that does not handle the event, it is forwarded to the next UIView.</li>\n<li>If that does not handle the event, it is forwarded to the UIViewController (which is the root view controller of the window)</li>\n<li>If the view controller is not handling the event, it is forwarded to the <code>UIApplication</code></li>\n<li>If the UIApplication is not handling the event, it is handled by the <code>UIApplicationDelegate</code></li>\n</ol>\n<p>This also means that if you really need to catch a certain event, you can always set up the required selector / method in your app delegate.</p>\n<h2>Altering the Responder Chain</h2>\n<p>You can alter the responder chain by overriding the next property of your responder objects. When you do this, the next responder is the object that you return.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I use the responder chain?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nThe responder chain is a event handling system at the heart of macOS and iOS.\nEvery touch event coming in, for example, uses this responder chain to reach the currently active `UIControl`. The main building block of the responder chain is the `UIResponder` class which is a superclass of `UIViewController` or `UIView`.\n\nApple has very useful information on this available:\n\n- [iOS: Using Responders and the Responder Chain](https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events)\n- [macOS: Event Architecture Overview](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/EventOverview/EventArchitecture/EventArchitecture.html)\n\nBelow, I'll quote the most important sections to understand the thing:\n\nResponders receive the raw event data and must either handle the event or forward it to another responder object. When your app receives an event, UIKit automatically directs that event to the most appropriate responder object, known as the first responder.\n\nUnhandled events are passed from responder to responder in the active responder chain.\n\nHere's an image from the Apple Documentation:\n\n![](/img-content/catalyst/responderchain.png)\n\nNow imagine that you're entering text in the text field. The following will happen:\n\n1. If the text field does not handle an event, UIKit sends the event to the text field’s parent UIView object\n2. If that does not handle the event, it is forwarded to the next UIView.\n3. If that does not handle the event, it is forwarded to the UIViewController (which is the root view controller of the window)\n4. If the view controller is not handling the event, it is forwarded to the `UIApplication`\n5. If the UIApplication is not handling the event, it is handled by the `UIApplicationDelegate`\n\nThis also means that if you really need to catch a certain event, you can always set up the required selector / method in your app delegate.\n\n## Altering the Responder Chain\n\nYou can alter the responder chain by overriding the next property of your responder objects. When you do this, the next responder is the object that you return.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/enable_disable_touchbar_items.md":["c0454b3d0e00d3de",{"identifier":"63657610","filename":"enable_disable_touchbar_items.md","info":{"title":"How do I enable / disable touchbar items based on whats visible on screen?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-enable-disable-touchbar-items-based-on-whats-visible-on-screen.html","content":"<p>This is similar to <a href=\"how/dynamically_update_touchbar.md\">how you would dynamically modify the contents of your touchbar: Update the touchbar and set it again.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"How do I enable / disable touchbar items based on whats visible on screen?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nThis is similar to [how you would dynamically modify the contents of your touchbar: Update the touchbar and set it again.](how/dynamically_update_touchbar.md)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/conditional_compilation.md":["8d4a531882adf1c5",{"identifier":"eb61e595","filename":"conditional_compilation.md","info":{"title":"Conditional Compilation","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-conditional-compilation.html","content":"<p>If you want to compile code that runs only on macOS, you can do that by using the following, new compile time attribute:</p>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyToolbar</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Obviously, to do it the other way around, you just inverse it:</p>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if !targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">import</span> ARKit\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Conditional Compilation\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nIf you want to compile code that runs only on macOS, you can do that by using the following, new compile time attribute:\n\n``` swift\n#if targetEnvironment(UIKitForMac)\n  let toolbar = NSToolbar(identifier: \"MyToolbar\")\n#endif\n```\n\nObviously, to do it the other way around, you just inverse it:\n\n``` swift\n#if !targetEnvironment(UIKitForMac)\n  import ARKit\n#endif\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/optionals/advanced_optionals.md":["86ac0c018ce41a78",{"identifier":"fc973309","filename":"advanced_optionals.md","info":{"title":"Advanced Optionals","tags":["optionals","if let","guard let"],"keywords":[],"category":[],"created":"2019-03-02 16:04:26","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551542666,"date":"2019-03-02T16:04:26","date_info":{"year":2019,"month":3,"day":2,"hour":16,"minute":4,"second":26},"identifier":"","indexed":true},"slug":"//2019-3-2-advanced-optionals.html","content":"<h1>Advanced Optionals</h1>\n<p>We've already seen the basics of handling optionals. However, there's much more you can do.\nIn this section we'll explore optionals even more and have a look at some advanced ways of\nhandling optionals</p>\n<h2>Optional Chaining</h2>\n<p>Now imagine your work on a relationship database, and your data are\nusers and their relations. So you'd have a Person and then the person\ncould have an optional child and the child could have an optional\nsibling and that sibling could have an optional child, and so on.</p>\n<p>Since all of these are <code>Person</code> types, we could model the type like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Person {\n\n   <span class=\"keyword\">var</span> child: <span class=\"type\">Person</span>?\n\n   <span class=\"keyword\">var</span> sibling: <span class=\"type\">Person</span>?\n\n   <span class=\"keyword\">var</span> father: <span class=\"type\">Person</span>?\n\n   <span class=\"keyword\">var</span> mother: <span class=\"type\">Person</span>?\n\n}\n</code></pre></code></pre>\n<p>All of our properties are optional because they can all be nil.\nNow imagine you'd like to find the following relative:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">person</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> child -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> sibling -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> child -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> mother</span>\n</span></code></pre></code></pre>\n<p>So, how would we do that with <code>if let</code> in Swift? Let us have a try:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> child = person.<span class=\"property\">child</span>,\n\n    <span class=\"keyword\">let</span> sibling = person.<span class=\"property\">sibling</span>,\n\n    <span class=\"keyword\">let</span> nextChild = person.<span class=\"property\">child</span>,\n\n    <span class=\"keyword\">let</span> mother = nextChild.<span class=\"call\">mother</span> {\n\n    <span class=\"call\">print</span>(mother)\n\n    }\n</code></pre></code></pre>\n<p>This is a lot of code and can quickly become confusing. Thankfully,\nSwift has another feature which lets us write this in a much simpler fashion.</p>\n<p>The idea being that in a chain of operations on optionals\n(such as Optional.child -&gt; Optional.silbing -&gt; Optional.child)\nif any of these operations returns nil, we stop executing the chain early.</p>\n<p>You represent this behaviour via a <code>?</code> before calling a method. Here is the\nprevious example implemented with the <code>optional chaining</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> mother = person.<span class=\"property\">child</span>?.<span class=\"property\">sibling</span>?.<span class=\"property\">child</span>?.<span class=\"property\">mother</span> {\n\n   <span class=\"call\">print</span>(mother)\n\n}\n</code></pre></code></pre>\n<p>We're basically telling Swift &quot;If the value of the child property of person is not\noptional, then please get me the sibling property from it&quot;. And we do the same again\nfor the next propery.</p>\n<p>This, also, works great for dictionaries where all return values are always optional.</p>\n<pre class=\"Swift\"><code>example[\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>]?[\\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>]?[\\<span class=\"string\">\"c</span>\\<span class=\"string\">\"</span>]\n</code></pre></code></pre>\n<p>By adding <code>?</code> in between each call / access, Swift will\nautomatically unwrap if there is a value, or stop the chain as soon\nas any one evaluates to nil.</p>\n<h2>Map</h2>\n<p>Consider the following code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> example() -&gt; <span class=\"type\">Int</span>? {<span class=\"keyword\">return</span> <span class=\"number\">10</span>}\n\n\n\n<span class=\"keyword\">if let</span> value = <span class=\"call\">example</span>() {\n\n     <span class=\"call\">storeInDatabase</span>(value * <span class=\"number\">2</span>)\n\n}\n</code></pre></code></pre>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">If we break down the logic, what we\\&#39;re really trying to achieve,\nwere it not for optionals, is the following:\n\n``` Swift\nstoreInDatabase(example() * 10)\n```\n\nOptionals are still very useful here, as they prevent us from the\ndanger of multiplying nil with 10 and trying to store that in the\ndatabase. But still, we have to admit that the optionals code looks\nmore convoluted. As you can imagine, there\\&#39;s a solution to this, of\ncourse.\n\nOptionals offer an implementation of the `map` function which will\ncall the value of an optional with a supplied closure if\nthe optional has a value.\n</span></code></pre></code></pre>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> px: <span class=\"type\">Int</span>? = <span class=\"number\">5</span>\n\n\n\n<span class=\"comment\">// This will print \\\"5\\\"</span>\n\npx.<span class=\"call\">map</span> { <span class=\"call\">print</span>($0) }\n\n\n\n<span class=\"comment\">// This will do nothing</span>\n\n<span class=\"keyword\">let</span> px: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\npx.<span class=\"call\">map</span> { <span class=\"call\">print</span>($0) }\n\n\n</code></pre></code></pre>\n<p>This lets us rewrite our example from above in terms of <code>map</code> as follows:</p>\n<pre class=\"Swift\"><code><span class=\"call\">example</span>().<span class=\"call\">map</span>({ number <span class=\"keyword\">in</span> \n\n   <span class=\"call\">storeInDatabase</span>(number * <span class=\"number\">2</span>) \n\n})\n</code></pre></code></pre>\n<p>What happens here is: When the return value of <code>example()</code> is not optional, then the closure\nwill be called the value as <code>number</code> and so we can call the <code>storeInDatabase</code> function with our number multiplied by two. If the return value of <code>example()</code> is empty, nothing will happen.</p>\n<p>With Swift's nice simplified closure syntax we can even simply this example to the following:</p>\n<pre class=\"Swift\"><code><span class=\"call\">example</span>().<span class=\"call\">map</span> { <span class=\"call\">storeInDatabase</span>($0 * <span class=\"number\">2</span>) }\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Advanced Optionals\"\ntags = [\"optionals\", \"if let\", \"guard let\"]\ncreated = \"2019-03-02 16:04:26\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Advanced Optionals\n\nWe've already seen the basics of handling optionals. However, there's much more you can do.\nIn this section we'll explore optionals even more and have a look at some advanced ways of\nhandling optionals\n\n## Optional Chaining\n\nNow imagine your work on a relationship database, and your data are\nusers and their relations. So you'd have a Person and then the person\ncould have an optional child and the child could have an optional \nsibling and that sibling could have an optional child, and so on.\n\nSince all of these are `Person` types, we could model the type like this:\n\n``` Swift\nstruct Person {\n  var child: Person?\n  var sibling: Person?\n  var father: Person?\n  var mother: Person?\n}\n```\n\nAll of our properties are optional because they can all be nil.\nNow imagine you'd like to find the following relative:\n\n``` bash\nperson -> child -> sibling -> child -> mother\n```\n\nSo, how would we do that with `if let` in Swift? Let us have a try:\n\n``` Swift\nif let child = person.child,\n   let sibling = person.sibling,\n   let nextChild = person.child,\n   let mother = nextChild.mother {\n   print(mother)\n   }\n```\n\nThis is a lot of code and can quickly become confusing. Thankfully,\nSwift has another feature which lets us write this in a much simpler fashion.\n\nThe idea being that in a chain of operations on optionals\n(such as Optional.child -> Optional.silbing -> Optional.child) \nif any of these operations returns nil, we stop executing the chain early.\n\nYou represent this behaviour via a `?` before calling a method. Here is the\nprevious example implemented with the `optional chaining`:\n\n``` Swift\nif let mother = person.child?.sibling?.child?.mother {\n  print(mother)\n}\n```\n\nWe're basically telling Swift \"If the value of the child property of person is not\noptional, then please get me the sibling property from it\". And we do the same again\nfor the next propery.\n\nThis, also, works great for dictionaries where all return values are always optional.\n\n  ``` Swift\n  example[\"a\"]?[\"b\"]?[\"c\"]\n  ```\n\nBy adding `?` in between each call / access, Swift will\nautomatically unwrap if there is a value, or stop the chain as soon\nas any one evaluates to nil.\n\n## Map\n\nConsider the following code:\n\n``` Swift\nfunc example() -> Int? {return 10}\n\nif let value = example() {\n    storeInDatabase(value * 2)\n}\n```\n\n    If we break down the logic, what we\\'re really trying to achieve,\n    were it not for optionals, is the following:\n\n    ``` Swift\n    storeInDatabase(example() * 10)\n    ```\n\n    Optionals are still very useful here, as they prevent us from the\n    danger of multiplying nil with 10 and trying to store that in the\n    database. But still, we have to admit that the optionals code looks\n    more convoluted. As you can imagine, there\\'s a solution to this, of\n    course.\n\n    Optionals offer an implementation of the `map` function which will\n    call the value of an optional with a supplied closure if\n    the optional has a value.\n\n``` Swift\nlet px: Int? = 5\n\n// This will print \"5\"\npx.map { print($0) }\n\n// This will do nothing\nlet px: Int? = nil\npx.map { print($0) }\n\n```\n\nThis lets us rewrite our example from above in terms of `map` as follows:\n\n``` Swift\nexample().map({ number in \n  storeInDatabase(number * 2) \n})\n```\n\nWhat happens here is: When the return value of `example()` is not optional, then the closure\nwill be called the value as `number` and so we can call the `storeInDatabase` function with our number multiplied by two. If the return value of `example()` is empty, nothing will happen.\n\nWith Swift's nice simplified closure syntax we can even simply this example to the following:\n\n``` Swift\nexample().map { storeInDatabase($0 * 2) }\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/pattern_types.md":["4b199178db97f432",{"identifier":"eaaa327a","filename":"pattern_types.md","info":{"title":"Pattern Types","tags":["pattern matching","switch"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-pattern-types.html","content":"<h1>Pattern Types</h1>\n<p>So now we've seen several patterns in action. But what's the syntax\nhere? Which other things can we match for? Swift distinguishes <strong>7</strong>\ndifferent patterns. We're going to have a quick look at each of them.</p>\n<p>All of those patterns can not only be used with the <code>switch</code> keyword,\nbut also with the <code>if</code>, <code>guard</code>, and <code>for</code> keywords. For details on\nthis, read on.</p>\n","raw_content":"[frontMatter]\ntitle = \"Pattern Types\"\ntags = [\"pattern matching\", \"switch\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Pattern Types\n\nSo now we\\'ve seen several patterns in action. But what\\'s the syntax\nhere? Which other things can we match for? Swift distinguishes **7**\ndifferent patterns. We\\'re going to have a quick look at each of them.\n\nAll of those patterns can not only be used with the `switch` keyword,\nbut also with the `if`, `guard`, and `for` keywords. For details on\nthis, read on.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/diving_in/intro.md":["67242c85fb8d1ebd",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Diving In: Basic Enums","tags":["enum"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-diving-in-basic-enums.html","content":"<h1>Diving In</h1>\n<p>A short overview of how to define and use enums.</p>\n<p>We're working on a game, and the player can move in four directions. So\nour player movement is restricted. He can only go right or left. You could model\nthat in the following manner:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if</span> movement == \\<span class=\"string\">\"left</span>\\<span class=\"string\">\"</span> { ... }\n\n<span class=\"keyword\">else if</span> movement == \\<span class=\"string\">\"right</span>\\<span class=\"string\">\"</span> { ...}\n</code></pre></code></pre>\n<p>However this is dangerous, what if we have a typo in our code and\n<code>movement</code> is neither <code>left</code> nor <code>right</code> but <code>leeft</code>?. Wouldn't it be cool\nif the compiler would point out if we have a typo like that? You could just write:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> moveLeft = <span class=\"number\">0</span>\n\n<span class=\"keyword\">let</span> moveRight = <span class=\"number\">1</span>\n\n<span class=\"keyword\">if</span> movement == moveLeft { ... }\n\n<span class=\"keyword\">else if</span> movement == moveRight { ... }\n</code></pre></code></pre>\n<p>This would solve our problem of typos in the code, but if we had more movements,\nit would be an easy bug to forget to handle all the movements. Imagine somebody\nextends the code in a couple of months and adds two new movements:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> moveUp = <span class=\"number\">0</span>\n\n<span class=\"keyword\">let</span> moveDown = <span class=\"number\">1</span>\n</code></pre></code></pre>\n<p>This developer forgets to update the <code>if</code> logic, though, so now we have more\nmovements but we forgot to handle them. Wouldn't it be great if the compiler would\ntell us if we forgot to handle all the cases of our movements? That's what the <code>enum</code>\ntype is for:</p>\n<h2>Defining Basic Enums</h2>\n<p><code>Enum</code>s tell Swift that a particular set of <code>cases</code> belong together. Our movement\n<code>enum</code> could look like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Movement {\n\n<span class=\"keyword\">case</span> left\n\n<span class=\"keyword\">case</span> right\n\n}\n</code></pre></code></pre>\n<p>It is considered proper style in Swift to always use lowercase for the enum <code>case</code> name</p>\n<p>Swift's <a href=\"lnk::switch\">switch</a> allows you to handle all the states of an <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> myMovement = <span class=\"type\">Movement</span>.<span class=\"property\">left</span>\n\n<span class=\"keyword\">switch</span> myMovement {\n\n<span class=\"keyword\">case</span> <span class=\"type\">Movement</span>.<span class=\"property\">left</span>: player.<span class=\"call\">goLeft</span>()\n\n<span class=\"keyword\">case</span> <span class=\"type\">Movement</span>.<span class=\"property\">right</span>: player.<span class=\"call\">goRight</span>()\n\n}\n</code></pre></code></pre>\n<p>If we would add another <code>case</code> (such as <code>up</code>), then the compiler would complain.</p>\n<p>There's also a really nice shortcut in Swift. Since the compiler knows that <code>myMovement</code> is\nof type <code>Movement</code> you don't have to write that out explicitly. This also works:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> myMovement {\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">left</span>: player.<span class=\"call\">goLeft</span>()\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">right</span>: player.<span class=\"call\">goRight</span>()\n\n}\n</code></pre></code></pre>\n<p>It is considered good style to not write out the <code>enum</code> name. Theyre may be situations where you have to do it in order to please the Compiler though.</p>\n<h2>Handling Enums</h2>\n<p>Besides the <code>switch</code> statement above, Swift also offers many more ways of handling <code>enum</code> types. Many of which can be found in our <a href=\"lnk::switch\">Pattern Matching Guide</a>, some of the will also be handled in this guide on <code>enum</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Diving In: Basic Enums\"\ntags = [\"enum\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Diving In\n\nA short overview of how to define and use enums.\n\nWe\\'re working on a game, and the player can move in four directions. So\nour player movement is restricted. He can only go right or left. You could model\nthat in the following manner:\n\n``` Swift\nif movement == \"left\" { ... }\nelse if movement == \"right\" { ...}\n```\n\nHowever this is dangerous, what if we have a typo in our code and\n`movement` is neither `left` nor `right` but `leeft`?. Wouldn't it be cool\nif the compiler would point out if we have a typo like that? You could just write:\n\n``` Swift\nlet moveLeft = 0\nlet moveRight = 1\nif movement == moveLeft { ... }\nelse if movement == moveRight { ... }\n```\n\nThis would solve our problem of typos in the code, but if we had more movements,\nit would be an easy bug to forget to handle all the movements. Imagine somebody\nextends the code in a couple of months and adds two new movements:\n\n``` Swift\nlet moveUp = 0\nlet moveDown = 1\n```\n\nThis developer forgets to update the `if` logic, though, so now we have more\nmovements but we forgot to handle them. Wouldn't it be great if the compiler would\ntell us if we forgot to handle all the cases of our movements? That's what the `enum`\ntype is for:\n\n## Defining Basic Enums\n\n`Enum`s tell Swift that a particular set of `cases` belong together. Our movement\n`enum` could look like this:\n\n``` Swift\nenum Movement {\ncase left\ncase right\n}\n```\n\nIt is considered proper style in Swift to always use lowercase for the enum `case` name\n\nSwift's [switch](lnk::switch) allows you to handle all the states of an `enum`:\n\n``` Swift\nlet myMovement = Movement.left\nswitch myMovement {\ncase Movement.left: player.goLeft()\ncase Movement.right: player.goRight()\n}\n```\n\nIf we would add another `case` (such as `up`), then the compiler would complain.\n\nThere's also a really nice shortcut in Swift. Since the compiler knows that `myMovement` is\nof type `Movement` you don't have to write that out explicitly. This also works:\n\n``` Swift\nswitch myMovement {\ncase .left: player.goLeft()\ncase .right: player.goRight()\n}\n```\n\nIt is considered good style to not write out the `enum` name. Theyre may be situations where you have to do it in order to please the Compiler though.\n\n## Handling Enums\n\nBesides the `switch` statement above, Swift also offers many more ways of handling `enum` types. Many of which can be found in our [Pattern Matching Guide](lnk::switch), some of the will also be handled in this guide on `enum`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/segmented_control_toolbar.md":["2ba4d0e4666200a2",{"identifier":"b7b992ad","filename":"segmented_control_toolbar.md","info":{"title":"How do I display a segmented control in the toolbar?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-display-a-segmented-control-in-the-toolbar.html","content":"<p>A segmented control is a convenient replacement for the iOS tabbar, as it also groups related segments and only allows one of them to be active.\nIt is basically just another type of <code>NSToolbarItem</code>. Thus, the process is very similar to <a href=\"firststeps/toolbar.md\">how you set up a toolbar with elements before</a>.</p>\n<ol>\n<li>Define a identifier</li>\n<li>Return the identifiers</li>\n<li>For the new identifier, return a segmented control</li>\n<li>Set up an action and target for the segmented control</li>\n</ol>\n<p>As a bonus point, you can tell the toolbar that the segmented control should be the centered item in the toolbar (much like with a tabbar).</p>\n<p><a href=\"how/hide_tabbar_with_toolbar.md\">In this example, we also have a UITabBar that we're hiding</a>, so that the switching of the visible view controller is still handled by the hidden tabbar.</p>\n<p>Here is the necessary code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> SceneDelegate: <span class=\"type\">UIResponder</span>, <span class=\"type\">UIWindowSceneDelegate</span>, <span class=\"type\">NSToolbarDelegate</span> {\n\n\n\n     <span class=\"comment\">// We need a toolbar identifier</span>\n\n     <span class=\"keyword\">static let</span> <span class=\"type\">SegmentedItemToolbarIdentifier</span> = <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"PrimaryGroup</span>\\<span class=\"string\">\"</span>)\n\n\n\n     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n         <span class=\"keyword\">if let</span> windowScene = scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span> {\n\n             <span class=\"keyword\">if let</span> titlebar = windowScene.<span class=\"property\">titlebar</span> {\n\n                 <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"NerauToolbar</span>\\<span class=\"string\">\"</span>)\n\n\n\n                 <span class=\"keyword\">let</span> rootViewController = window?.<span class=\"property\">rootViewController</span> <span class=\"keyword\">as</span>? <span class=\"type\">UITabBarController</span>\n\n         <span class=\"comment\">// Hide the tabbasr</span>\n\n                 rootViewController?.<span class=\"property\">tabBar</span>.<span class=\"property\">isHidden</span> = <span class=\"keyword\">true</span>\n\n\n\n                 toolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n\n\n         <span class=\"comment\">// Our segmented control should be centered</span>\n\n\n\n                 toolbar.<span class=\"property\">centeredItemIdentifier</span> = <span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>\n\n                 titlebar.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n\n\n                 titlebar.<span class=\"property\">toolbar</span> = toolbar\n\n             }\n\n         }\n\n         <span class=\"preprocessing\">#endif</span>\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbar(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>, itemForItemIdentifier itemIdentifier: <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>, willBeInsertedIntoToolbar flag: <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">NSToolbarItem</span>? {\n\n             <span class=\"keyword\">if</span> (itemIdentifier == <span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>) {\n\n             <span class=\"comment\">// Create a new group item that hosts two buttons</span>\n\n                 <span class=\"keyword\">let</span> group = <span class=\"type\">NSToolbarItemGroup</span>(itemIdentifier: <span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>,\n\n                                                titles: [\\<span class=\"string\">\"Startpage</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Categories</span>\\<span class=\"string\">\"</span>],\n\n                                                selectionMode: .<span class=\"dotAccess\">selectOne</span>,\n\n                                                labels: [\\<span class=\"string\">\"section1</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"section2</span>\\<span class=\"string\">\"</span>],\n\n                                                target: <span class=\"keyword\">self</span>,\n\n                                                action: <span class=\"keyword\">#selector</span>(toolbarGroupSelectionChanged))\n\n\n\n         <span class=\"comment\">// Set the initial selection</span>\n\n                 group.<span class=\"call\">setSelected</span>(<span class=\"keyword\">true</span>, at: <span class=\"number\">0</span>)\n\n\n\n                 <span class=\"keyword\">return</span> group\n\n             }\n\n         <span class=\"keyword\">return nil</span>\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> toolbarGroupSelectionChanged(sender: <span class=\"type\">NSToolbarItemGroup</span>) {\n\n         <span class=\"comment\">// This is called when the user changes the selection</span>\n\n     <span class=\"comment\">// Notice how we get the tab bar controller and change the selection there</span>\n\n         <span class=\"keyword\">let</span> rootViewController = window?.<span class=\"property\">rootViewController</span> <span class=\"keyword\">as</span>? <span class=\"type\">UITabBarController</span>\n\n         rootViewController?.<span class=\"property\">selectedIndex</span> = sender.<span class=\"property\">selectedIndex</span>\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>,\n\n                 <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>]\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarAllowedItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return self</span>.<span class=\"call\">toolbarDefaultItemIdentifiers</span>(toolbar)\n\n     }\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I display a segmented control in the toolbar?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nA segmented control is a convenient replacement for the iOS tabbar, as it also groups related segments and only allows one of them to be active.\nIt is basically just another type of `NSToolbarItem`. Thus, the process is very similar to [how you set up a toolbar with elements before](firststeps/toolbar.md).\n\n1. Define a identifier\n2. Return the identifiers\n3. For the new identifier, return a segmented control\n4. Set up an action and target for the segmented control\n\nAs a bonus point, you can tell the toolbar that the segmented control should be the centered item in the toolbar (much like with a tabbar).\n\n[In this example, we also have a UITabBar that we're hiding](how/hide_tabbar_with_toolbar.md), so that the switching of the visible view controller is still handled by the hidden tabbar.\n\nHere is the necessary code:\n\n``` swift\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate, NSToolbarDelegate {\n\n    // We need a toolbar identifier\n    static let SegmentedItemToolbarIdentifier = NSToolbarItem.Identifier(rawValue: \"PrimaryGroup\")\n\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        #if targetEnvironment(UIKitForMac)\n        if let windowScene = scene as? UIWindowScene {\n            if let titlebar = windowScene.titlebar {\n                let toolbar = NSToolbar(identifier: \"NerauToolbar\")\n\n                let rootViewController = window?.rootViewController as? UITabBarController\n\t\t// Hide the tabbasr\n                rootViewController?.tabBar.isHidden = true\n\n                toolbar.delegate = self\n\n\t\t// Our segmented control should be centered\n\n                toolbar.centeredItemIdentifier = SceneDelegate.SegmentedItemToolbarIdentifier\n                titlebar.titleVisibility = .hidden\n\n                titlebar.toolbar = toolbar\n            }\n        }\n        #endif\n    }\n\n    func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -> NSToolbarItem? {\n            if (itemIdentifier == SceneDelegate.SegmentedItemToolbarIdentifier) {\n\t        // Create a new group item that hosts two buttons\n                let group = NSToolbarItemGroup(itemIdentifier: SceneDelegate.SegmentedItemToolbarIdentifier,\n                                               titles: [\"Startpage\", \"Categories\"],\n                                               selectionMode: .selectOne,\n                                               labels: [\"section1\", \"section2\"],\n                                               target: self,\n                                               action: #selector(toolbarGroupSelectionChanged))\n\n\t\t// Set the initial selection\n                group.setSelected(true, at: 0)\n\n                return group\n            }\n    \treturn nil\n    }\n\n    @objc func toolbarGroupSelectionChanged(sender: NSToolbarItemGroup) {\n        // This is called when the user changes the selection\n\t// Notice how we get the tab bar controller and change the selection there\n        let rootViewController = window?.rootViewController as? UITabBarController\n        rootViewController?.selectedIndex = sender.selectedIndex\n    }\n\n    func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return [SceneDelegate.SegmentedItemToolbarIdentifier,\n                NSToolbarItem.Identifier.flexibleSpace]\n    }\n\n    func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return self.toolbarDefaultItemIdentifiers(toolbar)\n    }\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swiftui/overview.md":["1a0321cb51214184",{"identifier":"7a798740","filename":"overview.md","info":{"title":"Declarative Programming","tags":["swiftui"],"keywords":[],"category":[],"created":"2019-06-11 21:01:50","description":"Quick introduction into declarative programming","description_html":"<p>Quick introduction into declarative programming</p>\n","published":true,"slug":null,"meta":{"feature_image":"/img-content/swiftui_article.jpg"},"created_timestamp":1560286910,"date":"2019-06-11T21:01:50","date_info":{"year":2019,"month":6,"day":11,"hour":21,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-6-11-declarative-programming.html","content":"<h1>Declarative.. what? Reactive.. what?</h1>\n<p>When SwiftUI came out some developers were quick to draw parallels to other existing app development technologies such as RxSwift, React, Flutter, Elm, and others. Indeed, some of the key ideas of SwiftUI are similar to what these other technologies offer. However, even if you've never used one of them, don't be afraid. While the general ideas are the same, the implementations vary wildly. You'd also not claim to be a <code>.NET</code> developer just because <code>Windows Forms</code> and UIKit are object oriented UI frameworks. In a similar manner the details matter and that is, really, where we all start as beginners again.</p>\n<p>Below, you will find a quick introduction into declarative and reactive programming. If you think you already know this, <a href=\"javascript:next()\">just move on to the next part where we build a shoe composer in SwiftUI.</a></p>\n<h1>The beauty of a game engine</h1>\n<p>One point that was reiterated during 2019 WWDC as well as numerous conference talks, blog posts and tweets before that is that state is a very fickle thing. Many bugs manifest because we have a variable that is shared between places and one of the places updates it while the other doesn't register this update, and suddenly we have different state in two places and confusing things happen. Imagine a search field that doesn't update the result list when the user replaces the next with a paste command. The problem is not that we forgot to also remember to update the list on paste, the problem is that the state of the search field contents exists in two places: In the search field and in the result list as a predicate. The correct solution would be to have the state only in one place and both the list and the search field connect to this value. As the value changes, both the text field and the list redraw.</p>\n<p>Most 3D game engines work this way. While the fundamentals of a game engine are incredibly complicated, the basics are stunningly simple. A game engine works as follows:</p>\n<ul>\n<li>Have a internal state of what the world looks like (which player is where, which enemies are where)</li>\n<li>Draw the whole world</li>\n<li>while True\n<ul>\n<li>Take user input, calculate enemy movement</li>\n<li>Update the internal state</li>\n<li>Draw the whole world</li>\n</ul>\n</li>\n</ul>\n<p>Can you pin-point what is so fundamentally simple about this? There are no UIViews or UIButtons or UITableViews that need to be updated once the user enters something. Everything is being re-rendered all the time. Each change to the internal state (the user moved) results in a complete re-render of the whole scene. There're no hidden views, forgotten UIViewController children, data sources, UI updates, and so on. The whole scene, really, is just a long list of draw calls based on the current state.</p>\n<h1>Being lazy</h1>\n<p>Doing this with a traditional UI framework like UIKit would be rather cumbersome. Not only would the CPU be busy allocating and deallocating a lot of views all the time, all the user actions would also result in heavy flickering and jittery movements. That's because all of UIKit is build on the model that views are not recreated 60 times a second. However, our UI apps don't actually change like a game scene. Instead, only some elements change. In a game, each movement usually moves all the vertices of the scene around. In our apps, most of the time, just one element changes its state. Thus we can add an optimization to make this game engine approach much more feasible for our us: We only re-render what actually changed. If the user taps a button, this button needs to be re-rendered, everything else can be kept as is. This is one of the magic ingredients of SwiftUI.</p>\n<h1>A game engine that does UI</h1>\n<p>SwiftUI does everything explained above. It forces you to share state with bindings among multiple views. If state changes, the views are compared to see if the new state would change their output. If that's the case they're re-rendered. If not, they're kept as is. With this approach, SwiftUI is like a game engine for UI apps. Instead of thinking how you would add and remove buttons, you just re-render your whole UI based on the current state. SwiftUI makes sure that only the relevant parts are actually updated. This is best explained with a simple example.</p>\n<h1>A simple example</h1>\n<p>Imagine you have an app with a toggle button and a search field. The toggle button controls the visibility of the search field. Here is our UIKit implementation:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> ButtonView: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">var</span> toggleButton = <span class=\"type\">UISwitch</span>()\n\n     <span class=\"keyword\">var</span> searchField = <span class=\"type\">UISearchTextField</span>()\n\n     \n\n     <span class=\"keyword\">override func</span> viewDidAppear(<span class=\"keyword\">_</span> animated: <span class=\"type\">Bool</span>) {\n\n         <span class=\"keyword\">super</span>.<span class=\"call\">viewDidAppear</span>(animated)\n\n         toggleButton.<span class=\"call\">addTarget</span>(<span class=\"keyword\">self</span>, action: <span class=\"keyword\">#selector</span>(<span class=\"call\">didTapButton</span>(sender:)), for: .<span class=\"dotAccess\">allTouchEvents</span>)\n\n         searchField.<span class=\"property\">isHidden</span> = <span class=\"keyword\">true</span>\n\n         view.<span class=\"call\">addSubview</span>(toggleButton)\n\n         view.<span class=\"call\">addSubview</span>(searchField)\n\n     }\n\n     \n\n     <span class=\"keyword\">@objc func</span> didTapButton(sender: <span class=\"type\">UISwitch</span>) {\n\n         searchField.<span class=\"property\">isHidden</span> = !toggleButton.<span class=\"property\">isOn</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This is classic iOS code and while there are many things that can be improved here, it shows a standard pattern. In contrast to the game engine example we had earlier, this view is not re-rendered for every user action. In fact, this view has state in multiple places: <code>searchField.isHidden</code> and <code>toggleButton.isOn</code>. We assign them in <code>didTapButton</code>, but this is not a clear binding that UIKit knows about. If we just change <code>toggleButton.isOn = true</code> somewhere else, the searchfield will not change. Lets look at a (simplified) SwiftUI alternative:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ButtonView : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@State var</span> visible: <span class=\"type\">Bool</span> = <span class=\"keyword\">false</span>\n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span> {\n\n             <span class=\"type\">Toggle</span>(isOn: <span class=\"property\">$visible</span>) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Toggle</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"keyword\">if</span> visible {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Hello</span> <span class=\"type\">World</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>So what is happening here? First of all, we're missing a lot of ceremony around the initialization and creation of UI elements. Where is our toggle initialized, and where is our text initialized? Also, where are we setting the value from the toggle on the <code>hidden</code> property of the text? Also, what's with the weird <code>some View</code>, <code>@State</code>, <code>VStack</code>, and <code>$visible</code>. We will explain one after the other.</p>\n<p>First of all, remember what we said earlier. SwiftUI is like a lazy game engine. Whenever something changes, the UI is rerendered. Since our UI is always rerendered, we don't have to care about state, about the allocation and creation and initialization of buttons. Instead, we just describe to Swift what the UI should look like (akin to the <code>draw</code> calls in a game engine). That's what's happening here. Our <code>var body : some View</code> is a property that returns the complete description of our current UI. The UI is composed out of UI components. In our example this is <code>VStack</code>, <code>Toggle</code>, and <code>Text</code>.</p>\n<ul>\n<li><code>VStack</code>: This is a vertical stack. It aligns its children in a vertical list.</li>\n<li><code>Toggle</code>: Is our toggle button. However, compared to UIKit the toggle button requires a value that stores the current toggle value. <em>It doesn't store it itself</em>. There is no internal toggle state. Instead, the toggle requires you to tell it where to store its state. We do this with the <code>$NameOfVariable</code>. The syntax for this might look a bit alien, but we will ignore this for now for the sake of simplicity.</li>\n<li><code>Text</code>: This will construct a new <code>label</code>. Easy.</li>\n<li><code>if visible</code>: This also looks kinda obvious. If the variable <code>visible</code> is set to <code>true</code> then, please render the text field. But.. how does this update? Initially, <code>visible</code> is set to false, so how does the <code>Text</code> become visible again? Remember, just like a game engine, whenever the state changes, we re-render the UI. So that means that whenever <code>visible</code> changes its value, the <code>if visible</code> is executed again.</li>\n</ul>\n<p>But how does Swift figure out that <code>var visible</code> has changed? We did not set a <code>didSet</code> or <code>set {} get {}</code> for this property, neither did we use <code>@managed</code>, <code>@objc</code> or <code>@dynamic</code>. Instead there is a new thing! <code>@State</code>. This is what tells Swift that <code>visible</code> should be a special variable that we can bind components to. Components such as our <code>Toggle</code> button. <code>@State</code> is used for component / view local state. The way it works is as follows:</p>\n<ol>\n<li><code>@State var visible: Bool</code> will create a new variable with a lot of update and subscription machinery in the background.</li>\n<li><code>Toggle(isOn: $visible)</code> will bind to this <code>visisble</code> value. Whenever <code>visible</code> changes, our toggle will change. Changing our toggle will always also change <code>visible</code>. These two are linked.</li>\n<li>Since we're referring to our <code>visible</code> variable from within our <code>body</code> (via <code>if visible</code>) Swift knows that our <code>body</code> is dependent upon <code>visible</code>. This means that whenever <code>visible</code> changes, Swift will be like &quot;Oh, visible changed, this means the view is probably out of date, I will re-render the view&quot;.</li>\n</ol>\n<p>So, our <code>if visible { Text(...) }</code> will be re-executed whenever our toggle is pressed.</p>\n<h2>Multiple toggles</h2>\n<p>With the above, you might wonder, what happens if we add multiple toggles and or buttons to modify our state? Does it still work? Of course it does! Here's a convoluted example:</p>\n<p><img src=\"/img-content/swiftui_intro_toggles.png\" width=\"40%\" style=\"box-shadow: 2px 2px 24px 0px rgba(0, 0, 0, 0.6);\" /></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ButtonView : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@State var</span> visible: <span class=\"type\">Bool</span> = <span class=\"keyword\">false</span>\n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span> {\n\n             <span class=\"type\">Toggle</span>(isOn: <span class=\"property\">$visible</span>) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Toggle</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"type\">Toggle</span>(isOn: <span class=\"property\">$visible</span>) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Toggle</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"type\">Button</span>(action: {\n\n                 <span class=\"keyword\">self</span>.<span class=\"property\">visible</span>.<span class=\"call\">toggle</span>()\n\n             }) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Yeah</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"keyword\">if</span> visible {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Hello</span> <span class=\"type\">World</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Here, we have not one, not two, but there toggles that all refer to our <code>visible</code>. Tapping any one of them will change our state and will also update all our other toggles. This shows how powerful it is to have a declarative UI system that uses bindings to make sure there is only one source of truth.</p>\n<p>This was a brief overview of how SwiftUI works, and in the next section (coming soon!) we will build a UI to customize sneakers. Here's a preview already:</p>\n<p><img src=\"/img-content/swiftui_intro_preview_sneakers.png\" width=\"30%\" style=\"box-shadow: 2px 2px 24px 0px rgba(0, 0, 0, 0.6);\" /></p>\n","raw_content":"[frontMatter]\ntitle = \"Declarative Programming\"\ntags = [\"swiftui\"]\ncreated = \"2019-06-11 21:01:50\"\ndescription = \"Quick introduction into declarative programming\"\npublished = true\n\n[meta]\nfeature_image = \"/img-content/swiftui_article.jpg\"\n\n---\n\n# Declarative.. what? Reactive.. what?\n\nWhen SwiftUI came out some developers were quick to draw parallels to other existing app development technologies such as RxSwift, React, Flutter, Elm, and others. Indeed, some of the key ideas of SwiftUI are similar to what these other technologies offer. However, even if you've never used one of them, don't be afraid. While the general ideas are the same, the implementations vary wildly. You'd also not claim to be a `.NET` developer just because `Windows Forms` and UIKit are object oriented UI frameworks. In a similar manner the details matter and that is, really, where we all start as beginners again. \n\nBelow, you will find a quick introduction into declarative and reactive programming. If you think you already know this, [just move on to the next part where we build a shoe composer in SwiftUI.](javascript:next())\n\n# The beauty of a game engine\n\nOne point that was reiterated during 2019 WWDC as well as numerous conference talks, blog posts and tweets before that is that state is a very fickle thing. Many bugs manifest because we have a variable that is shared between places and one of the places updates it while the other doesn't register this update, and suddenly we have different state in two places and confusing things happen. Imagine a search field that doesn't update the result list when the user replaces the next with a paste command. The problem is not that we forgot to also remember to update the list on paste, the problem is that the state of the search field contents exists in two places: In the search field and in the result list as a predicate. The correct solution would be to have the state only in one place and both the list and the search field connect to this value. As the value changes, both the text field and the list redraw.\n\nMost 3D game engines work this way. While the fundamentals of a game engine are incredibly complicated, the basics are stunningly simple. A game engine works as follows:\n\n- Have a internal state of what the world looks like (which player is where, which enemies are where)\n- Draw the whole world\n- while True\n  - Take user input, calculate enemy movement\n  - Update the internal state\n  - Draw the whole world\n\nCan you pin-point what is so fundamentally simple about this? There are no UIViews or UIButtons or UITableViews that need to be updated once the user enters something. Everything is being re-rendered all the time. Each change to the internal state (the user moved) results in a complete re-render of the whole scene. There're no hidden views, forgotten UIViewController children, data sources, UI updates, and so on. The whole scene, really, is just a long list of draw calls based on the current state.\n\n# Being lazy\n\nDoing this with a traditional UI framework like UIKit would be rather cumbersome. Not only would the CPU be busy allocating and deallocating a lot of views all the time, all the user actions would also result in heavy flickering and jittery movements. That's because all of UIKit is build on the model that views are not recreated 60 times a second. However, our UI apps don't actually change like a game scene. Instead, only some elements change. In a game, each movement usually moves all the vertices of the scene around. In our apps, most of the time, just one element changes its state. Thus we can add an optimization to make this game engine approach much more feasible for our us: We only re-render what actually changed. If the user taps a button, this button needs to be re-rendered, everything else can be kept as is. This is one of the magic ingredients of SwiftUI.\n\n# A game engine that does UI\n\nSwiftUI does everything explained above. It forces you to share state with bindings among multiple views. If state changes, the views are compared to see if the new state would change their output. If that's the case they're re-rendered. If not, they're kept as is. With this approach, SwiftUI is like a game engine for UI apps. Instead of thinking how you would add and remove buttons, you just re-render your whole UI based on the current state. SwiftUI makes sure that only the relevant parts are actually updated. This is best explained with a simple example.\n\n# A simple example\n\nImagine you have an app with a toggle button and a search field. The toggle button controls the visibility of the search field. Here is our UIKit implementation:\n\n``` Swift\nfinal class ButtonView: UIViewController {\n    var toggleButton = UISwitch()\n    var searchField = UISearchTextField()\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        toggleButton.addTarget(self, action: #selector(didTapButton(sender:)), for: .allTouchEvents)\n        searchField.isHidden = true\n        view.addSubview(toggleButton)\n        view.addSubview(searchField)\n    }\n    \n    @objc func didTapButton(sender: UISwitch) {\n        searchField.isHidden = !toggleButton.isOn\n    }\n}\n```\n\nThis is classic iOS code and while there are many things that can be improved here, it shows a standard pattern. In contrast to the game engine example we had earlier, this view is not re-rendered for every user action. In fact, this view has state in multiple places: `searchField.isHidden` and `toggleButton.isOn`. We assign them in `didTapButton`, but this is not a clear binding that UIKit knows about. If we just change `toggleButton.isOn = true` somewhere else, the searchfield will not change. Lets look at a (simplified) SwiftUI alternative:\n\n\n``` swift\nstruct ButtonView : View {\n    @State var visible: Bool = false\n    var body : some View {\n        VStack {\n            Toggle(isOn: $visible) {\n                Text(\"Toggle\")\n            }\n            if visible {\n                Text(\"Hello World\")\n            }\n        }\n    }\n}\n```\n\nSo what is happening here? First of all, we're missing a lot of ceremony around the initialization and creation of UI elements. Where is our toggle initialized, and where is our text initialized? Also, where are we setting the value from the toggle on the `hidden` property of the text? Also, what's with the weird `some View`, `@State`, `VStack`, and `$visible`. We will explain one after the other. \n\nFirst of all, remember what we said earlier. SwiftUI is like a lazy game engine. Whenever something changes, the UI is rerendered. Since our UI is always rerendered, we don't have to care about state, about the allocation and creation and initialization of buttons. Instead, we just describe to Swift what the UI should look like (akin to the `draw` calls in a game engine). That's what's happening here. Our `var body : some View` is a property that returns the complete description of our current UI. The UI is composed out of UI components. In our example this is `VStack`, `Toggle`, and `Text`.\n\n- `VStack`: This is a vertical stack. It aligns its children in a vertical list. \n- `Toggle`: Is our toggle button. However, compared to UIKit the toggle button requires a value that stores the current toggle value. *It doesn't store it itself*. There is no internal toggle state. Instead, the toggle requires you to tell it where to store its state. We do this with the `$NameOfVariable`. The syntax for this might look a bit alien, but we will ignore this for now for the sake of simplicity.\n- `Text`: This will construct a new `label`. Easy.\n- `if visible`: This also looks kinda obvious. If the variable `visible` is set to `true` then, please render the text field. But.. how does this update? Initially, `visible` is set to false, so how does the `Text` become visible again? Remember, just like a game engine, whenever the state changes, we re-render the UI. So that means that whenever `visible` changes its value, the `if visible` is executed again.\n\nBut how does Swift figure out that `var visible` has changed? We did not set a `didSet` or `set {} get {}` for this property, neither did we use `@managed`, `@objc` or `@dynamic`. Instead there is a new thing! `@State`. This is what tells Swift that `visible` should be a special variable that we can bind components to. Components such as our `Toggle` button. `@State` is used for component / view local state. The way it works is as follows:\n\n1. `@State var visible: Bool` will create a new variable with a lot of update and subscription machinery in the background. \n2. `Toggle(isOn: $visible)` will bind to this `visisble` value. Whenever `visible` changes, our toggle will change. Changing our toggle will always also change `visible`. These two are linked.\n3. Since we're referring to our `visible` variable from within our `body` (via `if visible`) Swift knows that our `body` is dependent upon `visible`. This means that whenever `visible` changes, Swift will be like \"Oh, visible changed, this means the view is probably out of date, I will re-render the view\". \n\nSo, our `if visible { Text(...) }` will be re-executed whenever our toggle is pressed.\n\n## Multiple toggles\n\nWith the above, you might wonder, what happens if we add multiple toggles and or buttons to modify our state? Does it still work? Of course it does! Here's a convoluted example:\n\n<img src=\"/img-content/swiftui_intro_toggles.png\" width=\"40%\" style=\"box-shadow: 2px 2px 24px 0px rgba(0, 0, 0, 0.6);\" />\n\n``` swift\nstruct ButtonView : View {\n    @State var visible: Bool = false\n    var body : some View {\n        VStack {\n            Toggle(isOn: $visible) {\n                Text(\"Toggle\")\n            }\n            Toggle(isOn: $visible) {\n                Text(\"Toggle\")\n            }\n            Button(action: {\n                self.visible.toggle()\n            }) {\n                Text(\"Yeah\")\n            }\n            if visible {\n                Text(\"Hello World\")\n            }\n        }\n    }\n}\n```\n\nHere, we have not one, not two, but there toggles that all refer to our `visible`. Tapping any one of them will change our state and will also update all our other toggles. This shows how powerful it is to have a declarative UI system that uses bindings to make sure there is only one source of truth.\n\nThis was a brief overview of how SwiftUI works, and in the next section (coming soon!) we will build a UI to customize sneakers. Here's a preview already:\n\n<img src=\"/img-content/swiftui_intro_preview_sneakers.png\" width=\"30%\" style=\"box-shadow: 2px 2px 24px 0px rgba(0, 0, 0, 0.6);\" />\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/enums_standard_library.md":["43dca647b7ecae44",{"identifier":"3b44c086","filename":"enums_standard_library.md","info":{"title":"Enums in the Standard Library","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-enums-in-the-standard-library.html","content":"<h1>Enums in the Standard Library test</h1>\n<p>Before we go on and explore various use cases for enums in your\nprojects, it might be tempting to see some of the enums being used in\nthe Swift standard library, so let's have a look.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit\"><strong>Bit</strong></a>\nThe <code>Bit</code> enum can have two possible values, <strong>One</strong>, and <strong>Zero</strong>. It\nis used as the <code>Index</code> type for <code>CollectionOfOne&lt;T&gt;</code>.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_\"><strong>FloatingPointClassification</strong></a>\nThis enum defines the set of possible IEEE 754 &quot;classes&quot;, like\n<code>NegativeInfinity</code>, <code>PositiveZero</code>, or <code>SignalingNaN</code>.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation\"><strong>Mirror.AncestorRepresentation</strong></a>,\nand\n<a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle\"><strong>Mirror.DisplayStyle</strong></a>\nThese two are used in the context of the Swift Reflection API.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq\"><strong>Optional</strong></a>\nNot much to say here</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process\"><strong>Process</strong></a>\nThe Process enum contains the command line arguments of the current\nprocess (<code>Process.argc</code>, <code>Process.arguments</code>). This is a particularly\ninteresting <code>enum</code> as it used to be a <code>struct</code> in Swift 1.0.</p>\n","raw_content":"[frontMatter]\ntitle = \"Enums in the Standard Library\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n---\n\n# Enums in the Standard Library test\n\nBefore we go on and explore various use cases for enums in your\nprojects, it might be tempting to see some of the enums being used in\nthe Swift standard library, so let\\'s have a look.\n\n[**Bit**](https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit)\nThe `Bit` enum can have two possible values, **One**, and **Zero**. It\nis used as the `Index` type for `CollectionOfOne<T>`.\n\n[**FloatingPointClassification**](https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_)\nThis enum defines the set of possible IEEE 754 \\\"classes\\\", like\n`NegativeInfinity`, `PositiveZero`, or `SignalingNaN`.\n\n[**Mirror.AncestorRepresentation**](https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation),\nand\n[**Mirror.DisplayStyle**](https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle)\nThese two are used in the context of the Swift Reflection API.\n\n[**Optional**](https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq)\nNot much to say here\n\n[**Process**](https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process)\nThe Process enum contains the command line arguments of the current\nprocess (`Process.argc`, `Process.arguments`). This is a particularly\ninteresting `enum` as it used to be a `struct` in Swift 1.0.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/issues.md":["47b40cf0dc4b4742",{"identifier":"75b56c20","filename":"issues.md","info":{"title":"What are some issues that I will run into?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-what-are-some-issues-that-i-will-run-into.html","content":"<h2>A brief list of notable differences</h2>\n<ul>\n<li>The bundle identifier for the macOS version of your app is different. If you use bundle identifiers for something specific, be aware of this</li>\n<li>KeyChain sharing differs briefly, <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps\">as outlined by Apple here</a> (search for &quot;macOS&quot; on that page)</li>\n<li>Custom multitouch behaviour can't be automated. Views have to be updated for that</li>\n<li>Your app will not be killed if it consumes too much memory. The system will just swap</li>\n</ul>\n<h2>With Catalyst, you should use the newever versions of these old, deprecated, frameworks:</h2>\n<ul>\n<li>AddressBook -&gt; Contacts</li>\n<li>AddressBookUI -&gt; ContactsUI</li>\n<li>AssetsLibrary -&gt; Photos</li>\n<li>OpenGL ES -&gt; Metal</li>\n<li>GLKit -&gt; MetalKit</li>\n<li>UIWebView -&gt; WKWebView</li>\n</ul>\n","raw_content":"[frontMatter]\ntitle = \"What are some issues that I will run into?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n## A brief list of notable differences\n\n- The bundle identifier for the macOS version of your app is different. If you use bundle identifiers for something specific, be aware of this\n- KeyChain sharing differs briefly, [as outlined by Apple here](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps) (search for \"macOS\" on that page)\n- Custom multitouch behaviour can't be automated. Views have to be updated for that\n- Your app will not be killed if it consumes too much memory. The system will just swap\n\n## With Catalyst, you should use the newever versions of these old, deprecated, frameworks:\n\n- AddressBook -> Contacts\n- AddressBookUI -> ContactsUI\n- AssetsLibrary -> Photos\n- OpenGL ES -> Metal\n- GLKit -> MetalKit\n- UIWebView -> WKWebView\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/laws_of_composition.md":["c71c1eed46c4d261",{"identifier":"57c9a37d","filename":"laws_of_composition.md","info":{"title":"Laws of Composition","tags":["keypath","composition"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-laws-of-composition.html","content":"<h1>Laws of composition</h1>\n<h2>Appending type-erased keypaths</h2>\n<p>There're some additional constraints that need to hold in order to allow joining keypaths. In general, you can combine any type of keypath with any other types, except for the following combinations:</p>\n<h3>Impossible keypaths combinations</h3>\n<p>| <strong>First</strong>                | <strong>Second</strong>     |\n|--------------------------|----------------|\n| KeyPath                  | AnyKeyPath     |\n| KeyPath                  | PartialKeyPath |\n| WritableKeyPath          | AnyKeyPath     |\n| WritableKeyPath          | PartialKeyPath |\n| ReferenceWritableKeyPath | AnyKeyPath     |\n| ReferenceWritableKeyPath | PartialKeyPath |</p>\n<p>This is actually quite easy to remember. You can't append a <code>AnyKeyPath</code> or a <code>PartialKeyPath</code> to a non-type-erased <code>KeyPath</code> type.</p>\n<p>The rule is that the <code>KeyPath</code> to be appended has to have at least as many generic types as the type being appended to.</p>\n<h2>Appending to type-erased keypaths</h2>\n<p>The second rule is that appending anything to a type-erased keypath will return an optional keypath:</p>\n<h3>Keypaths combinations returning Optional</h3>\n<p>| <strong>First</strong>                | <strong>Second</strong>     |\n|--------------------------|----------------|\n| AnyKeyPath               | Anything       |\n| PartialKeyPath           | Anything       |</p>\n<h2>Appending invalid types</h2>\n<p>The third, and final, rule is that you can't append non-matching types. So, for example appending <code>KeyPath&lt;User, String&gt;</code> and <code>KeyPath&lt;Address, Int&gt;</code> will fail at compile time because the types don't match up.</p>\n","raw_content":"[frontMatter]\ntitle = \"Laws of Composition\"\ntags = [\"keypath\", \"composition\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Laws of composition\n\n## Appending type-erased keypaths\n\nThere're some additional constraints that need to hold in order to allow joining keypaths. In general, you can combine any type of keypath with any other types, except for the following combinations:\n\n### Impossible keypaths combinations\n\n| **First**                | **Second**     |\n|--------------------------|----------------|\n| KeyPath                  | AnyKeyPath     |\n| KeyPath                  | PartialKeyPath |\n| WritableKeyPath          | AnyKeyPath     |\n| WritableKeyPath          | PartialKeyPath |\n| ReferenceWritableKeyPath | AnyKeyPath     |\n| ReferenceWritableKeyPath | PartialKeyPath |\n\nThis is actually quite easy to remember. You can't append a `AnyKeyPath` or a `PartialKeyPath` to a non-type-erased `KeyPath` type. \n\nThe rule is that the `KeyPath` to be appended has to have at least as many generic types as the type being appended to.\n\n## Appending to type-erased keypaths\n\nThe second rule is that appending anything to a type-erased keypath will return an optional keypath:\n\n### Keypaths combinations returning Optional\n\n| **First**                | **Second**     |\n|--------------------------|----------------|\n| AnyKeyPath               | Anything       |\n| PartialKeyPath           | Anything       |\n\n## Appending invalid types\n\nThe third, and final, rule is that you can't append non-matching types. So, for example appending `KeyPath<User, String>` and `KeyPath<Address, Int>` will fail at compile time because the types don't match up.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/generic_settings/handling_settings.md":["d90dc887a6e620de",{"identifier":"2fa2acd5","filename":"handling_settings.md","info":{"title":"Handling Settings","tags":["keypath","generics","recursion","anykeypath","type-cast"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-handling-settings.html","content":"<h1>Handling the Settings</h1>\n<p>The next part is crucial. What do we intend to do with these settings? The natural way would be to build a UI that displays them and allows the user to edit them. Another option would be to set settings to specific values. All of these things are possible. We will do something slightly simpler which still explains the basics of the code without requiring us to write a lot of UI code. In this example, we will iterate over the settings, print out their title and value, and will then change the value to <code>true</code> if it is <code>Bool</code>. However, as mentioned above, you can use the very same pattern to display these settings in a very nice UI.</p>\n<p>The first thing we need is a function we can call with our settings. This function needs to be generic. We should be able to call it with any type. To do this, it will only have one argument of the <code>SettingsProvider</code> type. However, later on, we will also need the specific type that implements the protocol, which is why we code this in a generic manner:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   ...\n\n}\n\n\n\n<span class=\"comment\">/// And lets call it</span>\n\n<span class=\"keyword\">let</span> appSettings = <span class=\"type\">Settings</span>()\n\n<span class=\"call\">editSettings</span>(appSettings)\n</code></pre></code></pre>\n<p>Since our <code>SettingsProvider</code> only really offers one property, the <code>settingsEntries</code> we will iterate over them:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     \n\n   }\n\n}\n</code></pre></code></pre>\n<p>Remember how we created settings entries for nested settings, such as <code>ProfileSettings</code> as well as the actual settings values, such as <code>PrivacySettings.passcode</code>? In this case, we have to disambigiuate, do we have an actual value that we want to print and edit, or do we have another, nested, settings provider? To do this, we will get the value of the current <code>KeyPath</code> from the <code>Provider</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: setting.<span class=\"property\">keyPath</span>]\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Here, we tell Swift to give us the value in the current <code>SettingsProvider</code> at the <code>KeyPath</code> <code>setting.keypath</code>. This doesn't really solve our problem, though. This value could still be a <code>Bool</code> type or a <code>PrivacySettings</code> type. We can't check whether the type is <code>PrivacySettings</code> because we want to be generic, work with any type. However, since all nested settings also <strong>have</strong> to implement the <code>SettingsProvider</code> protocol, we can simply test for this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: setting.<span class=\"property\">keyPath</span>]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Via the <code>value as? SettingsProvider</code> we're just asking Swift at runtime whether the <code>value</code> is actually a type we want to handle (such as <code>Bool</code>, or <code>String</code>) or another nested <code>SettingsProvider</code> that we'd like to iterate over. Which is precisely what we will do next, iterate over the provider again. However, since we may have another settings provider, and then another one, we would need to write more and more for loops:</p>\n<pre class=\"Swift\"><code>   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: setting.<span class=\"property\">keyPath</span>]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> nestedSetting <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settingsEntries</span> {\n\n         <span class=\"keyword\">let</span> value = provider[keyPath: nestedSetting.<span class=\"property\">keyPath</span>]\n\n         <span class=\"keyword\">if let</span> nestedNestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n           <span class=\"keyword\">for</span> nestedNestedSetting <span class=\"keyword\">in</span> nestedNestedProvider.<span class=\"property\">settingsEntries</span> {\n\n           ...\n\n           }\n\n         }\n\n       }\n\n     }\n\n   }\n</code></pre></code></pre>\n<p>This is truly terrible. Instead, we will move this iteration code into a inlined function <code>updateSetting</code> that can be called recursively. So, whenever we identify another nested provider, we will simply call the function again:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"comment\">// All subsequent iterations happen here</span>\n\n   <span class=\"keyword\">func</span> updateSetting(keyPath: <span class=\"type\">AnyKeyPath</span>, title: <span class=\"type\">String</span>) {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settings</span> {\n\n         <span class=\"comment\">// ??</span>\n\n       }\n\n     }\n\n   }\n\n\n\n   <span class=\"comment\">// The initial iteration</span>\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"call\">updateSetting</span>(keyPath: setting.<span class=\"property\">keyPath</span>, title: setting.<span class=\"property\">title</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Here, we moved the iteration code into its own function. It has two parameters, the <code>keyPath</code> of the value we want to test, and the title of the current setting. The keypath helps us to extract the value:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n</code></pre></code></pre>\n<p>The value is then tested for being another <code>SettingsProvider</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n  ...\n\n}\n</code></pre></code></pre>\n<p>But what do we do now? In the first step, here, the <code>keyPath</code> would be <code>\\Settings.profileSettings</code> and the <code>value</code> will be <code>ProfileSettings</code>.\nBut what do we do now? If we iterate over the <code>ProfileSettings</code> as a <code>SettingsProvider</code> we get two new SettingsEntries, one for <code>displayName</code>, and one for <code>shareUpdates</code>. However, our <code>updateSetting</code> function always calls <code>let value = provider[keyPath: keyPath]</code> on the original <code>provider</code>, the <code>Settings</code> class that was given as a parameter to the <code>editSettings</code> function. This makes sense, because we want to edit the contents of this <code>Settings</code> type.</p>\n<p>So we have a keypath to <code>\\Setting.profileSettings</code> and a keypath to <code>\\ProfileSettings.displayName</code> and we want to retrieve the value at <code>\\Setting.profileSettings.displayName</code>. We can use Swift's <code>KeyPath</code> composition!</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"comment\">// All subsequent iterations happen here</span>\n\n   <span class=\"keyword\">func</span> updateSetting(keyPath: <span class=\"type\">AnyKeyPath</span>, title: <span class=\"type\">String</span>) {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settings</span> {\n\n         <span class=\"comment\">// Join the keypaths</span>\n\n         <span class=\"keyword\">if let</span> joined = keyPath.<span class=\"call\">appending</span>(path: item.<span class=\"property\">keyPath</span>) {\n\n           <span class=\"call\">updateSetting</span>(keyPath: joined, title: item.<span class=\"property\">title</span>)\n\n         }\n\n       }\n\n     }\n\n   }\n\n\n\n   <span class=\"comment\">// The initial iteration</span>\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"call\">updateSetting</span>(keyPath: setting.<span class=\"property\">keyPath</span>, title: setting.<span class=\"property\">title</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>In the code above, the magic happens in the following three lines:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> joined = keyPath.<span class=\"call\">appending</span>(path: item.<span class=\"property\">keyPath</span>) {\n\n   <span class=\"call\">updateSetting</span>(keyPath: joined, title: item.<span class=\"property\">title</span>)\n\n}\n</code></pre></code></pre>\n<p>We take the original <code>keyPath</code> that was given to the <code>updateSettings</code> function first (i.e. <code>\\Setting.profileSettings</code>) and we take the <code>item.keyPath</code>, which is the keypath of the current item (i.e. <code>\\ProfileSettings.displayName</code>) and join them to <code>\\Setting.profileSettings.displayName</code>. Now we can use this <code>joined</code> keypath to retrieve the value of the <code>displayName</code> property of the <code>provider</code> instance and perform another iteration. By implementing it this way, we can easily support more nesting hierachies.</p>\n<p>So what happens when our <code>value</code> isn't another nested <code>SettingsProvider</code> but an actual value such as <code>String</code> or <code>Bool</code> (<code>displayName</code> or <code>shareUpdates</code>). Since we want to be able to change the value that is stored here (from <code>false</code> to <code>true</code>) we do a run-time cast from this <code>keyPath</code> to a <code>WritableKeyPath</code> to figure out if we have an editable value.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> writableKeypath = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;???, ???&gt; {\n\n}\n</code></pre></code></pre>\n<p>However, <code>WritableKeyPath</code> needs two types, the <code>Root</code> and the <code>Value</code>, what do we insert here? We don't know the type of the <code>Root</code> as we're iterating over <code>Settings</code>, <code>ProfileSettings</code>, <code>PrivacySettings</code>, etc, right? It could be anything. Actually, we do know the type of <code>Root</code>. Since our keypaths are joined (<code>\\Settings.profileSettings.displayName</code>) our root is <strong>always</strong> <code>Settings</code>. So we could write <code>WritableKeyPath&lt;Settings, ???&gt;</code> but now our function would not be generic anymore. If we look at the header of our original function, though, we see something interesting:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n...\n</code></pre></code></pre>\n<p>We actually do have our root type, as the <code>Provider</code> generic type to the <code>editSettings</code> function. So we can just write <code>WritableKeyPath&lt;Provider, ???&gt;</code>. The second type of our <code>WritableKeyPath</code> is also easy. If we want to edit boolean flags, it is <code>Bool</code>, and if we want to edit <code>Strings</code> it is .. well, <code>String</code>. Lets type this out:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"comment\">// All subsequent iterations happen here</span>\n\n   <span class=\"keyword\">func</span> updateSetting(keyPath: <span class=\"type\">AnyKeyPath</span>, title: <span class=\"type\">String</span>) {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settings</span> {\n\n         <span class=\"keyword\">if let</span> joined = keyPath.<span class=\"call\">appending</span>(path: item.<span class=\"property\">keyPath</span>) {\n\n           <span class=\"call\">updateSetting</span>(keyPath: joined, title: item.<span class=\"property\">title</span>)\n\n         }\n\n       }\n\n     } <span class=\"keyword\">else if let</span> writable = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">Provider</span>, <span class=\"type\">Bool</span>&gt; {\n\n       <span class=\"call\">print</span>(title)\n\n       provider[keyPath: writable] = <span class=\"keyword\">true</span>\n\n     }\n\n   }\n\n\n\n   <span class=\"comment\">// The initial iteration</span>\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"call\">updateSetting</span>(keyPath: setting.<span class=\"property\">keyPath</span>, title: setting.<span class=\"property\">title</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>That's it! We cast the keypath to a writable variant, and then we can modify the contents of our <code>Settings</code> type (or nested types). Everything happens in these additional lines of code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> writable = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">Provider</span>, <span class=\"type\">Bool</span>&gt; {\n\n       <span class=\"call\">print</span>(title)\n\n       provider[keyPath: writable] = <span class=\"keyword\">true</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Subsequently, we could easily extend these lines to also query for <code>WritableKeyPath&lt;Provider, String&gt;</code> or <code>WritableKeyPath&lt;Provider, Double&gt;</code>, etc.</p>\n<p>This is our final function. It allows us to handle app settings in a completely generic manner. It iterates over them, it can display them (we did not see that because the code size would have exploded), and it can edit them. Without ever knowing the actual shape of the settings type. It can also be used for structures other than settings. Any complex type can be iterated in this manner.</p>\n<p>However, this was only a small example of what you can do with keypaths. There is even more! Lets have a look.</p>\n","raw_content":"[frontMatter]\ntitle = \"Handling Settings\"\ntags = [\"keypath\", \"generics\", \"recursion\", \"anykeypath\", \"type-cast\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Handling the Settings\n\nThe next part is crucial. What do we intend to do with these settings? The natural way would be to build a UI that displays them and allows the user to edit them. Another option would be to set settings to specific values. All of these things are possible. We will do something slightly simpler which still explains the basics of the code without requiring us to write a lot of UI code. In this example, we will iterate over the settings, print out their title and value, and will then change the value to `true` if it is `Bool`. However, as mentioned above, you can use the very same pattern to display these settings in a very nice UI.\n\nThe first thing we need is a function we can call with our settings. This function needs to be generic. We should be able to call it with any type. To do this, it will only have one argument of the `SettingsProvider` type. However, later on, we will also need the specific type that implements the protocol, which is why we code this in a generic manner:\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n  ...\n}\n\n/// And lets call it\nlet appSettings = Settings()\neditSettings(appSettings)\n```\n\nSince our `SettingsProvider` only really offers one property, the `settingsEntries` we will iterate over them:\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n  for setting in provider.settingsEntries {\n    \n  }\n}\n```\n\nRemember how we created settings entries for nested settings, such as `ProfileSettings` as well as the actual settings values, such as `PrivacySettings.passcode`? In this case, we have to disambigiuate, do we have an actual value that we want to print and edit, or do we have another, nested, settings provider? To do this, we will get the value of the current `KeyPath` from the `Provider`:\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n  for setting in provider.settingsEntries {\n    let value = provider[keyPath: setting.keyPath]\n  }\n}\n```\n\nHere, we tell Swift to give us the value in the current `SettingsProvider` at the `KeyPath` `setting.keypath`. This doesn't really solve our problem, though. This value could still be a `Bool` type or a `PrivacySettings` type. We can't check whether the type is `PrivacySettings` because we want to be generic, work with any type. However, since all nested settings also **have** to implement the `SettingsProvider` protocol, we can simply test for this:\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n  for setting in provider.settingsEntries {\n    let value = provider[keyPath: setting.keyPath]\n    if let nestedProvider = value as? SettingsProvider {\n    }\n  }\n}\n```\n\nVia the `value as? SettingsProvider` we're just asking Swift at runtime whether the `value` is actually a type we want to handle (such as `Bool`, or `String`) or another nested `SettingsProvider` that we'd like to iterate over. Which is precisely what we will do next, iterate over the provider again. However, since we may have another settings provider, and then another one, we would need to write more and more for loops:\n\n``` Swift\n  for setting in provider.settingsEntries {\n    let value = provider[keyPath: setting.keyPath]\n    if let nestedProvider = value as? SettingsProvider {\n      for nestedSetting in nestedProvider.settingsEntries {\n        let value = provider[keyPath: nestedSetting.keyPath]\n        if let nestedNestedProvider = value as? SettingsProvider {\n          for nestedNestedSetting in nestedNestedProvider.settingsEntries {\n          ...\n          }\n        }\n      }\n    }\n  }\n```\n\nThis is truly terrible. Instead, we will move this iteration code into a inlined function `updateSetting` that can be called recursively. So, whenever we identify another nested provider, we will simply call the function again:\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n  // All subsequent iterations happen here\n  func updateSetting(keyPath: AnyKeyPath, title: String) {\n    let value = provider[keyPath: keyPath]\n    if let nestedProvider = value as? SettingsProvider {\n      for item in nestedProvider.settings {\n        // ??\n      }\n    }\n  }\n\n  // The initial iteration\n  for setting in provider.settingsEntries {\n    updateSetting(keyPath: setting.keyPath, title: setting.title)\n  }\n}\n```\n\nHere, we moved the iteration code into its own function. It has two parameters, the `keyPath` of the value we want to test, and the title of the current setting. The keypath helps us to extract the value:\n\n``` Swift\nlet value = provider[keyPath: keyPath]\n```\n\nThe value is then tested for being another `SettingsProvider`:\n\n``` Swift\nif let nestedProvider = value as? SettingsProvider {\n ...\n}\n```\n\nBut what do we do now? In the first step, here, the `keyPath` would be `\\Settings.profileSettings` and the `value` will be `ProfileSettings`. \nBut what do we do now? If we iterate over the `ProfileSettings` as a `SettingsProvider` we get two new SettingsEntries, one for `displayName`, and one for `shareUpdates`. However, our `updateSetting` function always calls `let value = provider[keyPath: keyPath]` on the original `provider`, the `Settings` class that was given as a parameter to the `editSettings` function. This makes sense, because we want to edit the contents of this `Settings` type. \n\nSo we have a keypath to `\\Setting.profileSettings` and a keypath to `\\ProfileSettings.displayName` and we want to retrieve the value at `\\Setting.profileSettings.displayName`. We can use Swift's `KeyPath` composition!\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n  // All subsequent iterations happen here\n  func updateSetting(keyPath: AnyKeyPath, title: String) {\n    let value = provider[keyPath: keyPath]\n    if let nestedProvider = value as? SettingsProvider {\n      for item in nestedProvider.settings {\n        // Join the keypaths\n        if let joined = keyPath.appending(path: item.keyPath) {\n          updateSetting(keyPath: joined, title: item.title)\n        }\n      }\n    }\n  }\n\n  // The initial iteration\n  for setting in provider.settingsEntries {\n    updateSetting(keyPath: setting.keyPath, title: setting.title)\n  }\n}\n```\n\nIn the code above, the magic happens in the following three lines:\n\n``` Swift\nif let joined = keyPath.appending(path: item.keyPath) {\n  updateSetting(keyPath: joined, title: item.title)\n}\n```\n\nWe take the original `keyPath` that was given to the `updateSettings` function first (i.e. `\\Setting.profileSettings`) and we take the `item.keyPath`, which is the keypath of the current item (i.e. `\\ProfileSettings.displayName`) and join them to `\\Setting.profileSettings.displayName`. Now we can use this `joined` keypath to retrieve the value of the `displayName` property of the `provider` instance and perform another iteration. By implementing it this way, we can easily support more nesting hierachies.\n\nSo what happens when our `value` isn't another nested `SettingsProvider` but an actual value such as `String` or `Bool` (`displayName` or `shareUpdates`). Since we want to be able to change the value that is stored here (from `false` to `true`) we do a run-time cast from this `keyPath` to a `WritableKeyPath` to figure out if we have an editable value.\n\n``` Swift\nif let writableKeypath = keyPath as? WritableKeyPath<???, ???> {\n}\n```\n\nHowever, `WritableKeyPath` needs two types, the `Root` and the `Value`, what do we insert here? We don't know the type of the `Root` as we're iterating over `Settings`, `ProfileSettings`, `PrivacySettings`, etc, right? It could be anything. Actually, we do know the type of `Root`. Since our keypaths are joined (`\\Settings.profileSettings.displayName`) our root is **always** `Settings`. So we could write `WritableKeyPath<Settings, ???>` but now our function would not be generic anymore. If we look at the header of our original function, though, we see something interesting:\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n...\n```\n\nWe actually do have our root type, as the `Provider` generic type to the `editSettings` function. So we can just write `WritableKeyPath<Provider, ???>`. The second type of our `WritableKeyPath` is also easy. If we want to edit boolean flags, it is `Bool`, and if we want to edit `Strings` it is .. well, `String`. Lets type this out:\n\n``` Swift\nfunc editSettings<Provider: SettingsProvider>(provider: Provider) {\n  // All subsequent iterations happen here\n  func updateSetting(keyPath: AnyKeyPath, title: String) {\n    let value = provider[keyPath: keyPath]\n    if let nestedProvider = value as? SettingsProvider {\n      for item in nestedProvider.settings {\n        if let joined = keyPath.appending(path: item.keyPath) {\n          updateSetting(keyPath: joined, title: item.title)\n        }\n      }\n    } else if let writable = keyPath as? WritableKeyPath<Provider, Bool> {\n      print(title)\n      provider[keyPath: writable] = true\n    }\n  }\n\n  // The initial iteration\n  for setting in provider.settingsEntries {\n    updateSetting(keyPath: setting.keyPath, title: setting.title)\n  }\n}\n```\n\nThat's it! We cast the keypath to a writable variant, and then we can modify the contents of our `Settings` type (or nested types). Everything happens in these additional lines of code:\n\n``` Swift\nif let writable = keyPath as? WritableKeyPath<Provider, Bool> {\n      print(title)\n      provider[keyPath: writable] = true\n    }\n}\n```\n\nSubsequently, we could easily extend these lines to also query for `WritableKeyPath<Provider, String>` or `WritableKeyPath<Provider, Double>`, etc.\n\nThis is our final function. It allows us to handle app settings in a completely generic manner. It iterates over them, it can display them (we did not see that because the code size would have exploded), and it can edit them. Without ever knowing the actual shape of the settings type. It can also be used for structures other than settings. Any complex type can be iterated in this manner.\n\nHowever, this was only a small example of what you can do with keypaths. There is even more! Lets have a look.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/type_erasure/intro.md":["53a9f0522ece22be",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Type Erasure","tags":["box","associated","generics","erasure","protocol"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-type-erasure.html","content":"<h1>Type Erasure</h1>\n<p>Quite often, when Swift's associated types are dicussed, <code>type erasure</code>\nis mentioned as another solution to the problem of handling the issues\nthat <code>associated types</code> bring along.</p>\n<p>Type Erasure in the context of <code>associated types</code> solves one particular\nproblem. We'll use computers as an example. Back in the golden age of\ndesktop operating systems, you could buy a desktop computer with many\nnon-X86 CPU architectures: PowerPC, Alpha, Sparc, 68000, and so on. One\nof the many differences were the <code>endianness</code> of the architecture. Lets\nmodel these computers in Swift:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> CPU {\n\n     <span class=\"keyword\">var</span> littleEndian: <span class=\"type\">Bool</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> PowerPC: <span class=\"type\">CPU</span> {\n\n     <span class=\"keyword\">let</span> littleEndian = <span class=\"keyword\">false</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> X86: <span class=\"type\">CPU</span> {\n\n     <span class=\"keyword\">let</span> littleEndian = <span class=\"keyword\">true</span>\n\n}\n</code></pre></code></pre>\n<p>Next up, we want to define a protocol for a computer. It could be a\ndesktop computer or a phone or maybe a game console, so we use a\nprotocol. In order to model the CPU, we're using an <code>associated type</code>,\nso that the actual type can define the CPU:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Computer {\n\n     <span class=\"keyword\">associatedtype</span> ProcessorType: <span class=\"type\">CPU</span>\n\n     <span class=\"keyword\">var</span> processor: <span class=\"type\">ProcessorType</span> { <span class=\"keyword\">get</span> }\n\n     <span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>Based on this, we can now define a couple of systems:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> PowerMacG5: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">let</span> processor = <span class=\"type\">PowerPC</span>()\n\n     <span class=\"keyword\">let</span> processorCount = <span class=\"number\">2</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Xbox360: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">let</span> processor = <span class=\"type\">PowerPC</span>()\n\n     <span class=\"keyword\">let</span> processorCount = <span class=\"number\">1</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> MacPro: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">let</span> processor = <span class=\"type\">X86</span>()\n\n     <span class=\"keyword\">let</span> processorCount = <span class=\"number\">1</span>\n\n}\n</code></pre></code></pre>\n<p>Now that we have all this, we'd like to perform a computation on all\n<strong>PowerPC</strong> based computers. I.e. something like:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> powerComputers = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>()]\n</code></pre></code></pre>\n<p>However, what would be the type of this? We can't use the <code>Computer</code>\nprotocol, as it contains <code>associated types</code>. However, the\n<code>associated types</code> for the PowerMacG5 <strong>and</strong> the Xbox360 <strong>are</strong> the\nsame, so in terms of types, Swift ought to understand that those things\nare kinda similar. However, there's no way to (easily) express this in\nthe type system; both <strong>PowerMacG5</strong> and <strong>Xbox360</strong> are not the correct\ntypes for the array:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// None of those work</span>\n\n<span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">PowerMacG5</span>] = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>]\n\n<span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">Xbox360</span>] = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>]\n\n<span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">Computer</span>] = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>]\n</code></pre></code></pre>\n<p>Type erasure is a solution for this. The idea is to box the actual type\ninto a generic wrapper so that Swift can coalesce around wrapper + type.\nThe solution we're aiming for would look like this in the end:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">AnyComputer</span>&lt;<span class=\"type\">PowerPC</span>&gt;] = [<span class=\"type\">AnyComputer</span>(<span class=\"type\">PowerMacG5</span>()), <span class=\"type\">AnyComputer</span>(<span class=\"type\">Xbox360</span>())]\n</code></pre></code></pre>\n<p>Now we would have our <strong>shared</strong> type, in this case it is\n<code>AnyComputer&lt;CPU&gt;</code>. Where does this mystic <code>AnyComputer</code> come from? We\nhave to build it ourselves. This is a multi-step process, and requires\nquite a bit of boilerplate. We will start simple and expand step by\nstep. This solution requires multiple types.</p>\n","raw_content":"[frontMatter]\ntitle = \"Type Erasure\"\ntags = [\"box\", \"associated\", \"generics\", \"erasure\", \"protocol\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Type Erasure\n\nQuite often, when Swift\\'s associated types are dicussed, `type erasure`\nis mentioned as another solution to the problem of handling the issues\nthat `associated types` bring along.\n\nType Erasure in the context of `associated types` solves one particular\nproblem. We\\'ll use computers as an example. Back in the golden age of\ndesktop operating systems, you could buy a desktop computer with many\nnon-X86 CPU architectures: PowerPC, Alpha, Sparc, 68000, and so on. One\nof the many differences were the `endianness` of the architecture. Lets\nmodel these computers in Swift:\n\n``` Swift\nprotocol CPU {\n    var littleEndian: Bool { get }\n}\n\nstruct PowerPC: CPU {\n    let littleEndian = false\n}\n\nstruct X86: CPU {\n    let littleEndian = true\n}\n```\n\nNext up, we want to define a protocol for a computer. It could be a\ndesktop computer or a phone or maybe a game console, so we use a\nprotocol. In order to model the CPU, we\\'re using an `associated type`,\nso that the actual type can define the CPU:\n\n``` Swift\nprotocol Computer {\n    associatedtype ProcessorType: CPU\n    var processor: ProcessorType { get }\n    var processorCount: Int { get }\n}\n```\n\nBased on this, we can now define a couple of systems:\n\n``` Swift\nstruct PowerMacG5: Computer {\n    let processor = PowerPC()\n    let processorCount = 2\n}\n\nstruct Xbox360: Computer {\n    let processor = PowerPC()\n    let processorCount = 1\n}\n\nstruct MacPro: Computer {\n    let processor = X86()\n    let processorCount = 1\n}\n```\n\nNow that we have all this, we\\'d like to perform a computation on all\n**PowerPC** based computers. I.e. something like:\n\n``` Swift\nlet powerComputers = [PowerMacG5(), Xbox360()]\n```\n\nHowever, what would be the type of this? We can\\'t use the `Computer`\nprotocol, as it contains `associated types`. However, the\n`associated types` for the PowerMacG5 **and** the Xbox360 **are** the\nsame, so in terms of types, Swift ought to understand that those things\nare kinda similar. However, there\\'s no way to (easily) express this in\nthe type system; both **PowerMacG5** and **Xbox360** are not the correct\ntypes for the array:\n\n``` Swift\n// None of those work\nlet powerComputers: [PowerMacG5] = [PowerMacG5(), Xbox360]\nlet powerComputers: [Xbox360] = [PowerMacG5(), Xbox360]\nlet powerComputers: [Computer] = [PowerMacG5(), Xbox360]\n```\n\nType erasure is a solution for this. The idea is to box the actual type\ninto a generic wrapper so that Swift can coalesce around wrapper + type.\nThe solution we\\'re aiming for would look like this in the end:\n\n``` Swift\nlet powerComputers: [AnyComputer<PowerPC>] = [AnyComputer(PowerMacG5()), AnyComputer(Xbox360())]\n```\n\nNow we would have our **shared** type, in this case it is\n`AnyComputer<CPU>`. Where does this mystic `AnyComputer` come from? We\nhave to build it ourselves. This is a multi-step process, and requires\nquite a bit of boilerplate. We will start simple and expand step by\nstep. This solution requires multiple types.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swiftui/preface.md":["16123c852b8f104a",{"identifier":"bd14e602","filename":"preface.md","info":{"title":"Preface","tags":["swiftui"],"keywords":[],"category":[],"created":"2019-06-11 21:01:50","description":"A brief introduction into the aim of this guide","description_html":"<p>A brief introduction into the aim of this guide</p>\n","published":true,"slug":null,"meta":{"feature_image":"/img-content/swiftui_article.jpg"},"created_timestamp":1560286910,"date":"2019-06-11T21:01:50","date_info":{"year":2019,"month":6,"day":11,"hour":21,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-6-11-preface.html","content":"<h1>Preface</h1>\n<p>When Apple released Swift in 2014 it was a tectonic shift for the Apple development community. One that few people had anticipated. Though while Swift was a much different language than Objective-C, the methods and function you'd call, the frameworks, kept unchanged. In fact, you could ignore the enums and associated types and write Swift that looked and felt much like Objective-C, utilising Foundation and UIKit just as before. This was important for Apple because the scope of UIKit and Foundation is much bigger than that of Swift.</p>\n<p>With SwiftUI, all of this changes. While a Objective-C developer from the 80s would feel right at home with 2017 era Swift code employing target action or delegate mechanisms, a SwiftUI project would look much more alien to him. Apple moved past its development history (shared with NeXT) of the past ~30 years in a generational leap that will hopefully be the base for decades to come. In doing so, Apple also moved the goalpost of mobile application development:</p>\n<ul>\n<li>A shared framework for all Apple platforms (iOS, macOS, watchOS, etc)</li>\n<li>Declarative with live reload and live preview</li>\n<li>Type-Safe UI declarations</li>\n<li>Going beyond Interface Builder</li>\n<li>High level abstraction that will allow future compile time optimizations</li>\n<li>Fully compatible with UIKit / AppKit</li>\n<li>Automatic support for dark mode, dynamic text, and more</li>\n<li>Smart dependency injection via environments</li>\n<li>Combine framework for well thought-out bindings</li>\n<li>much more</li>\n</ul>\n<p>However, don't throw away your old code just yet. While SwiftUI is very exciting (as all Shiny New Things tend to be), it is also a very early beta. Apple already shipped some watchOS apps with SwiftUI (Calculator is an example) but at the same time a calculator on the watch is a different beast than a 200k LOC iPhone app. Some important components will come in a later beta, some components might only come next year, the documentation is still very, very sparse, live preview requires the beta of macOS Catalina.</p>\n<p>In general, it seems that much of the flexibility that UIKit offered has been replaced with a more high level and less customizable interface. You can always resort to UIKit though. This is also a very important point to stress.</p>\n<p>Just as Swift changed a lot after its introduction, I also expected SwiftUI to change in the coming years. This guide introduces SwiftUI in a general manner by developing a small app. It also lists various tips and tricks for things that are difficult or non-intuitive to do in SwiftUI. Lets begin!</p>\n","raw_content":"[frontMatter]\ntitle = \"Preface\"\ntags = [\"swiftui\"]\ncreated = \"2019-06-11 21:01:50\"\ndescription = \"A brief introduction into the aim of this guide\"\npublished = true\n\n[meta]\nfeature_image = \"/img-content/swiftui_article.jpg\"\n\n---\n\n# Preface\n\nWhen Apple released Swift in 2014 it was a tectonic shift for the Apple development community. One that few people had anticipated. Though while Swift was a much different language than Objective-C, the methods and function you'd call, the frameworks, kept unchanged. In fact, you could ignore the enums and associated types and write Swift that looked and felt much like Objective-C, utilising Foundation and UIKit just as before. This was important for Apple because the scope of UIKit and Foundation is much bigger than that of Swift.\n\nWith SwiftUI, all of this changes. While a Objective-C developer from the 80s would feel right at home with 2017 era Swift code employing target action or delegate mechanisms, a SwiftUI project would look much more alien to him. Apple moved past its development history (shared with NeXT) of the past ~30 years in a generational leap that will hopefully be the base for decades to come. In doing so, Apple also moved the goalpost of mobile application development:\n\n- A shared framework for all Apple platforms (iOS, macOS, watchOS, etc)\n- Declarative with live reload and live preview\n- Type-Safe UI declarations\n- Going beyond Interface Builder\n- High level abstraction that will allow future compile time optimizations\n- Fully compatible with UIKit / AppKit\n- Automatic support for dark mode, dynamic text, and more\n- Smart dependency injection via environments\n- Combine framework for well thought-out bindings\n- much more\n\nHowever, don't throw away your old code just yet. While SwiftUI is very exciting (as all Shiny New Things tend to be), it is also a very early beta. Apple already shipped some watchOS apps with SwiftUI (Calculator is an example) but at the same time a calculator on the watch is a different beast than a 200k LOC iPhone app. Some important components will come in a later beta, some components might only come next year, the documentation is still very, very sparse, live preview requires the beta of macOS Catalina. \n\nIn general, it seems that much of the flexibility that UIKit offered has been replaced with a more high level and less customizable interface. You can always resort to UIKit though. This is also a very important point to stress. \n\nJust as Swift changed a lot after its introduction, I also expected SwiftUI to change in the coming years. This guide introduces SwiftUI in a general manner by developing a small app. It also lists various tips and tricks for things that are difficult or non-intuitive to do in SwiftUI. Lets begin!\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/anonymous_structs.md":["97af67e9195d4d36",{"identifier":"d6438897","filename":"anonymous_structs.md","info":{"title":"Anonymous Structs","tags":["tuples","struct"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-anonymous-structs.html","content":"<h1>Anonymous Structs</h1>\n<p>Tuples as well as structs allow you to combine different types into one\ntype:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> user1 = (name: \\<span class=\"string\">\"Carl</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">40</span>)\n\n<span class=\"comment\">// vs.</span>\n\n<span class=\"keyword\">struct</span> User {\n\n     <span class=\"keyword\">let</span> name: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">let</span> age: <span class=\"type\">Int</span>\n\n}\n\n<span class=\"keyword\">let</span> user2 = <span class=\"type\">User</span>(name: \\<span class=\"string\">\"Steve</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">39</span>)\n</code></pre></code></pre>\n<p>As you can see, these two types are similar, but whereas the tuple\nexists simply as an instance, the struct requires both a struct\ndeclaration and a struct initializer. This similarity can be leveraged\nwhenever you have the need to define a temporary struct inside a\nfunction or method. As the Swift docs say:</p>\n<blockquote>\n<p>Tuples are useful for temporary groups of related values. (...) If\nyour data structure is likely to persist beyond a temporary scope,\nmodel it as a class or structure (...)</p>\n</blockquote>\n<p>As an example of this, consider the following situation where the return\nvalues from several functions first need to be uniquely collected and\nthen inserted:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> zipForUser(userid: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> { <span class=\"keyword\">return</span> \\<span class=\"string\">\"12124</span>\\<span class=\"string\">\"</span> }\n\n<span class=\"keyword\">func</span> streetForUser(userid: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> { <span class=\"keyword\">return</span> \\<span class=\"string\">\"Charles</span> <span class=\"type\">Street</span>\\<span class=\"string\">\"</span> }\n\n<span class=\"keyword\">let</span> users = [user1]\n\n\n\n<span class=\"comment\">// Find all unique streets in our userbase</span>\n\n<span class=\"keyword\">var</span> streets: [<span class=\"type\">String</span>: (zip: <span class=\"type\">String</span>, street: <span class=\"type\">String</span>, count: <span class=\"type\">Int</span>)] = [:]\n\n<span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> users {\n\n     <span class=\"keyword\">let</span> zip = <span class=\"call\">zipForUser</span>(userid: user.<span class=\"property\">name</span>)\n\n     <span class=\"keyword\">let</span> street = <span class=\"call\">streetForUser</span>(userid: user.<span class=\"property\">name</span>)\n\n     <span class=\"keyword\">let</span> key = \\<span class=\"string\">\"</span>\\(zip)-\\(street)\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">if let</span> (<span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, count) = streets[key] {\n\n         streets[key] = (zip, street, count + <span class=\"number\">1</span>)\n\n     } <span class=\"keyword\">else</span> {\n\n         streets[key] = (zip, street, <span class=\"number\">1</span>)\n\n     }\n\n}\n\n\n\n<span class=\"comment\">// drawStreetsOnMap(streets.values)</span>\n\n<span class=\"keyword\">for</span> street <span class=\"keyword\">in</span> streets.<span class=\"property\">values</span> { <span class=\"call\">print</span>(street) }\n</code></pre></code></pre>\n<p>Here, the tuple is being used as a simple structure for a short-duration\nuse case. Defining a struct would also be possible but not strictly\nnecessary.</p>\n<p>Another example would be a class that handles algorithmic data, and\nyou're moving a temporary result from one method to the next one.\nDefining an extra struct for something only used once (in between two or\nthree methods) may not be required.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Made up algorithm</span>\n\n<span class=\"keyword\">func</span> calculateInterim(values: [<span class=\"type\">Int</span>]) -&gt; \n\n     (r: <span class=\"type\">Int</span>, alpha: <span class=\"type\">CGFloat</span>, chi: (<span class=\"type\">CGFloat</span>, <span class=\"type\">CGFloat</span>)) {\n\n     <span class=\"keyword\">return</span> (values[<span class=\"number\">0</span>], <span class=\"number\">2</span>, (<span class=\"number\">4</span>, <span class=\"number\">8</span>))\n\n}\n\n<span class=\"keyword\">func</span> expandInterim(interim: (r: <span class=\"type\">Int</span>, \n\n                          alpha: <span class=\"type\">CGFloat</span>, \n\n                            chi: (<span class=\"type\">CGFloat</span>, <span class=\"type\">CGFloat</span>))) -&gt; <span class=\"type\">CGFloat</span> {\n\n     <span class=\"keyword\">return</span> <span class=\"type\">CGFloat</span>(interim.<span class=\"property\">r</span>) + interim.<span class=\"property\">alpha</span> + interim.<span class=\"property\">chi</span>.<span class=\"number\">0</span> + interim.<span class=\"property\">chi</span>.<span class=\"number\">1</span>\n\n}\n\n\n\n<span class=\"call\">print</span>(<span class=\"call\">expandInterim</span>(interim: <span class=\"call\">calculateInterim</span>(values: [<span class=\"number\">1</span>])))\n</code></pre></code></pre>\n<p>There is, of course, a fine line here. Defining a struct for one\ninstance is overly complex; defining a tuple 4 times instead of one\nstruct is overly complex too. Finding the sweet spot depends.</p>\n","raw_content":"[frontMatter]\ntitle = \"Anonymous Structs\"\ntags = [\"tuples\", \"struct\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Anonymous Structs\n\nTuples as well as structs allow you to combine different types into one\ntype:\n\n``` Swift\nlet user1 = (name: \"Carl\", age: 40)\n// vs.\nstruct User {\n    let name: String\n    let age: Int\n}\nlet user2 = User(name: \"Steve\", age: 39)\n```\n\nAs you can see, these two types are similar, but whereas the tuple\nexists simply as an instance, the struct requires both a struct\ndeclaration and a struct initializer. This similarity can be leveraged\nwhenever you have the need to define a temporary struct inside a\nfunction or method. As the Swift docs say:\n\n> Tuples are useful for temporary groups of related values. (...) If\n> your data structure is likely to persist beyond a temporary scope,\n> model it as a class or structure (...)\n\nAs an example of this, consider the following situation where the return\nvalues from several functions first need to be uniquely collected and\nthen inserted:\n\n``` Swift\nfunc zipForUser(userid: String) -> String { return \"12124\" }\nfunc streetForUser(userid: String) -> String { return \"Charles Street\" }\nlet users = [user1]\n\n// Find all unique streets in our userbase\nvar streets: [String: (zip: String, street: String, count: Int)] = [:]\nfor user in users {\n    let zip = zipForUser(userid: user.name)\n    let street = streetForUser(userid: user.name)\n    let key = \"\\(zip)-\\(street)\"\n    if let (_, _, count) = streets[key] {\n        streets[key] = (zip, street, count + 1)\n    } else {\n        streets[key] = (zip, street, 1)\n    }\n}\n\n// drawStreetsOnMap(streets.values)\nfor street in streets.values { print(street) }\n```\n\nHere, the tuple is being used as a simple structure for a short-duration\nuse case. Defining a struct would also be possible but not strictly\nnecessary.\n\nAnother example would be a class that handles algorithmic data, and\nyou\\'re moving a temporary result from one method to the next one.\nDefining an extra struct for something only used once (in between two or\nthree methods) may not be required.\n\n``` Swift\n// Made up algorithm\nfunc calculateInterim(values: [Int]) -> \n    (r: Int, alpha: CGFloat, chi: (CGFloat, CGFloat)) {\n    return (values[0], 2, (4, 8))\n}\nfunc expandInterim(interim: (r: Int, \n                         alpha: CGFloat, \n                           chi: (CGFloat, CGFloat))) -> CGFloat {\n    return CGFloat(interim.r) + interim.alpha + interim.chi.0 + interim.chi.1\n}\n\nprint(expandInterim(interim: calculateInterim(values: [1])))\n```\n\nThere is, of course, a fine line here. Defining a struct for one\ninstance is overly complex; defining a tuple 4 times instead of one\nstruct is overly complex too. Finding the sweet spot depends.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/generics.md":["8e5355534d5ba6b0",{"identifier":"3ee1fa7b","filename":"generics.md","info":{"title":"Generics","tags":["tuples","generics","typealias","either"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-generics.html","content":"<h1>Generics</h1>\n<p>There's no <code>Tuple</code> type available in Swift. If you wonder why that is,\nthink about it: every tuple is a totally different type, depending on\nthe types within it. So instead of defining a generic tuple requirement,\nyou define the specific but generic incarnation of the tuple you intend\nto use:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> wantsTuple&lt;T1, T2&gt;(<span class=\"keyword\">_</span> tuple: (<span class=\"type\">T1</span>, <span class=\"type\">T2</span>)) -&gt; <span class=\"type\">T1</span> {\n\n     <span class=\"keyword\">return</span> tuple.<span class=\"number\">0</span>\n\n}\n\n\n\n<span class=\"call\">wantsTuple</span>((\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>)) <span class=\"comment\">// \\\"a\\\"</span>\n\n<span class=\"call\">wantsTuple</span>((<span class=\"number\">1</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// 1</span>\n</code></pre></code></pre>\n<p>You can also use tuples in <code>typealiases</code>, thus allowing subclasses to\nfill out your types with details. This looks fairly useless and\ncomplicated, but I've already had a use case where I need to do exactly\nthis.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> BaseClass&lt;A,B&gt; {\n\n     <span class=\"keyword\">typealias</span> Element = (<span class=\"type\">A</span>, <span class=\"type\">B</span>)\n\n     <span class=\"keyword\">func</span> add(<span class=\"keyword\">_</span> elm: <span class=\"type\">Element</span>) {\n\n         <span class=\"call\">print</span>(elm)\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">class</span> IntegerClass&lt;B&gt; : <span class=\"type\">BaseClass</span>&lt;<span class=\"type\">Int</span>, <span class=\"type\">B</span>&gt; {\n\n}\n\n\n\n<span class=\"keyword\">let</span> example = <span class=\"type\">IntegerClass</span>&lt;<span class=\"type\">String</span>&gt;()\n\nexample.<span class=\"call\">add</span>((<span class=\"number\">5</span>, \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>))\n\n<span class=\"comment\">// Prints (5, \\\"\\\")</span>\n</code></pre></code></pre>\n<p>You can also define a <code>typealias</code> with generic parameters\nlike in this example where we introduce a custom <code>Either</code> type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> MyEither&lt;A, B&gt; = (left: <span class=\"type\">A</span>, right: <span class=\"type\">B</span>)\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Generics\"\ntags = [\"tuples\", \"generics\", \"typealias\", \"either\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Generics\n\nThere\\'s no `Tuple` type available in Swift. If you wonder why that is,\nthink about it: every tuple is a totally different type, depending on\nthe types within it. So instead of defining a generic tuple requirement,\nyou define the specific but generic incarnation of the tuple you intend\nto use:\n\n``` Swift\nfunc wantsTuple<T1, T2>(_ tuple: (T1, T2)) -> T1 {\n    return tuple.0\n}\n\nwantsTuple((\"a\", \"b\")) // \"a\"\nwantsTuple((1, 2)) // 1\n```\n\nYou can also use tuples in `typealiases`, thus allowing subclasses to\nfill out your types with details. This looks fairly useless and\ncomplicated, but I\\'ve already had a use case where I need to do exactly\nthis.\n\n``` Swift\nclass BaseClass<A,B> {\n    typealias Element = (A, B)\n    func add(_ elm: Element) {\n        print(elm)\n    }\n}\n\nclass IntegerClass<B> : BaseClass<Int, B> {\n}\n\nlet example = IntegerClass<String>()\nexample.add((5, \"\"))\n// Prints (5, \"\")\n```\n\nYou can also define a `typealias` with generic parameters\nlike in this example where we introduce a custom `Either` type:\n\n``` Swift\ntypealias MyEither<A, B> = (left: A, right: B)\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/drag_and_drop.md":["da78c77d2f82a0b7",{"identifier":"5e7430a1","filename":"drag_and_drop.md","info":{"title":"How do I implement drag and drop?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-implement-drag-and-drop.html","content":"<p>Drag and drop is implemented via the same mechanisms that also support drag and drop on iOS. Below, you can see an example of a simple <code>UIViewContoller</code> that allows droping JSON files onto the application in order to import them.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// This is the identifier of a JSON File</span>\n\n<span class=\"keyword\">private let</span> <span class=\"type\">JSONTypeIdentifier</span> = \\<span class=\"string\">\"public</span>.<span class=\"property\">json</span>\\<span class=\"string\">\"</span>\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">MyDragAndDropSupportingViewController</span>: <span class=\"type\">UIDropInteractionDelegate</span> {\n\n     <span class=\"keyword\">func</span> dropInteraction(<span class=\"keyword\">_</span> interaction: <span class=\"type\">UIDropInteraction</span>,\n\n                          canHandle session: <span class=\"type\">UIDropSession</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"comment\">// We tell the drag and drop system that we support JSON</span>\n\n         <span class=\"keyword\">return</span> session.<span class=\"call\">hasItemsConforming</span>(toTypeIdentifiers: [<span class=\"type\">JSONTypeIdentifier</span>])\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> dropInteraction(<span class=\"keyword\">_</span> interaction: <span class=\"type\">UIDropInteraction</span>, sessionDidUpdate session: <span class=\"type\">UIDropSession</span>) -&gt; <span class=\"type\">UIDropProposal</span> {\n\n         <span class=\"comment\">// If a drag comes in, we copy the file. We don't want to consume it.</span>\n\n         <span class=\"keyword\">return</span> <span class=\"type\">UIDropProposal</span>(operation: .<span class=\"dotAccess\">copy</span>)\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> dropInteraction(<span class=\"keyword\">_</span> interaction: <span class=\"type\">UIDropInteraction</span>, performDrop session: <span class=\"type\">UIDropSession</span>) {\n\n         <span class=\"comment\">// This is called with an array of NSURL</span>\n\n     session.<span class=\"call\">loadObjects</span>(ofClass: <span class=\"type\">URL</span>.<span class=\"keyword\">self</span>) { urls <span class=\"keyword\">in</span>\n\n             <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> urls {\n\n                 <span class=\"call\">importJSONData</span>(from: url)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>As with other Catalyst technologies, <a href=\"https://developer.apple.com/documentation/uikit/drag_and_drop/making_a_view_into_a_drop_destination\">there is a lot of good Apple documentation for this as this is the same as on iOS.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"How do I implement drag and drop?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nDrag and drop is implemented via the same mechanisms that also support drag and drop on iOS. Below, you can see an example of a simple `UIViewContoller` that allows droping JSON files onto the application in order to import them.\n\n``` swift\n/// This is the identifier of a JSON File\nprivate let JSONTypeIdentifier = \"public.json\"\n\nextension MyDragAndDropSupportingViewController: UIDropInteractionDelegate {\n    func dropInteraction(_ interaction: UIDropInteraction,\n                         canHandle session: UIDropSession) -> Bool {\n\t// We tell the drag and drop system that we support JSON\n        return session.hasItemsConforming(toTypeIdentifiers: [JSONTypeIdentifier])\n    }\n\n    func dropInteraction(_ interaction: UIDropInteraction, sessionDidUpdate session: UIDropSession) -> UIDropProposal {\n        // If a drag comes in, we copy the file. We don't want to consume it.\n        return UIDropProposal(operation: .copy)\n    }\n\n    func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {\n        // This is called with an array of NSURL\n\tsession.loadObjects(ofClass: URL.self) { urls in\n            for url in urls {\n                importJSONData(from: url)\n            }\n        }\n    }\n}\n```\n\nAs with other Catalyst technologies, [there is a lot of good Apple documentation for this as this is the same as on iOS.](https://developer.apple.com/documentation/uikit/drag_and_drop/making_a_view_into_a_drop_destination)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/intro.md":["415a8b7e38e3dc80",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Introduction","tags":["keypath","valueForKeyPath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"feature_image":"https://appventure.me/img-content/keypath_feature_image.gif","swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-introduction.html","content":"<h1>KeyPaths in Swift</h1>\n<p>Lets talk KeyPaths. Modern KeyPaths. <strong>Swift KeyPaths</strong>. Not <code>Objective-C</code>'s  <code>valueForKeyPath: @&quot;controller.property&quot;</code>.</p>\n<p>These particular, modern, swifty, keypaths were added with Swift 4.2. They differ from the old <code>Objective-C</code> ones by being type-safe and composable.</p>\n<p>Not everyone is aware of the useful functionality that Swift's new keypaths offer. They're a great addition to your toolbelt because they allow you to find abstractions for problems where protocols alone are not sufficient.</p>\n<p>This guide will first introduce Swift's KeyPaths, then discuss the underlying theory, showcase their usefulness with practical examples, and finally list tips and tricks for applying them in daily work.</p>\n<p>Lets start with a very basic introduction.</p>\n","raw_content":"[frontMatter]\ntitle = \"Introduction\"\ntags = [\"keypath\", \"valueForKeyPath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\nfeature_image = \"https://appventure.me/img-content/keypath_feature_image.gif\"\n---\n\n# KeyPaths in Swift\n\nLets talk KeyPaths. Modern KeyPaths. **Swift KeyPaths**. Not `Objective-C`'s  `valueForKeyPath: @\"controller.property\"`.\n\nThese particular, modern, swifty, keypaths were added with Swift 4.2. They differ from the old `Objective-C` ones by being type-safe and composable. \n\nNot everyone is aware of the useful functionality that Swift's new keypaths offer. They're a great addition to your toolbelt because they allow you to find abstractions for problems where protocols alone are not sufficient.\n\nThis guide will first introduce Swift's KeyPaths, then discuss the underlying theory, showcase their usefulness with practical examples, and finally list tips and tricks for applying them in daily work.\n\nLets start with a very basic introduction.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/generic_settings/settings_entries.md":["3779df22047903ff",{"identifier":"15800c64","filename":"settings_entries.md","info":{"title":"Settings Entries","tags":["keypath","anykeypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-settings-entries.html","content":"<h1>Settings Entries</h1>\n<p>Fundamentally, the first thing we need is a way to describe a particular settings entry. It is not sufficient to just know the value of the settings; we also need a title, a subtitle, maybe some help, or an icon. We will summarize this information into a <code>SettingsEntry</code> struct. This struct will also contain a keypath that points at the individual value this setting refers to.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> SettingsEntry {\n\n   <span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span>\n\n   <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">let</span> subtitle: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">let</span> icon: <span class=\"type\">UIImage</span>\n\n}\n</code></pre></code></pre>\n<p>For the sake of simplicity, we will use the following, shorter struct in the upcoming code examples:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> SettingsEntry {\n\n   <span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span>\n\n   <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>\n\n}\n</code></pre></code></pre>\n<p>Note that the type of the keypath is <code>AnyKeyPath</code>. We have to do that because our types can be anything: <code>\\Settings.privacySettings</code>, <code>\\PrivacySettings.passcode</code>, or <code>\\ProfileSettings.displayName</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Settings Entries\"\ntags = [\"keypath\", \"anykeypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Settings Entries\n\nFundamentally, the first thing we need is a way to describe a particular settings entry. It is not sufficient to just know the value of the settings; we also need a title, a subtitle, maybe some help, or an icon. We will summarize this information into a `SettingsEntry` struct. This struct will also contain a keypath that points at the individual value this setting refers to.\n\n``` Swift\nstruct SettingsEntry {\n  let keyPath: AnyKeyPath\n  let title: String\n  let subtitle: String\n  let icon: UIImage\n}\n```\n\nFor the sake of simplicity, we will use the following, shorter struct in the upcoming code examples:\n\n``` Swift\nstruct SettingsEntry {\n  let keyPath: AnyKeyPath\n  let title: String\n}\n```\n\nNote that the type of the keypath is `AnyKeyPath`. We have to do that because our types can be anything: `\\Settings.privacySettings`, `\\PrivacySettings.passcode`, or `\\ProfileSettings.displayName`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/diving_in/nesting_enums.md":["5fbb31492e42e0f4",{"identifier":"68bdf1c4","filename":"nesting_enums.md","info":{"title":"Nesting Enums","tags":["enum"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-nesting-enums.html","content":"<h1>Nesting Enums</h1>\n<p>If you have specific sub type requirements, you can also logically nest\nenums in an enum. This allows you to contain specific information on\nyour enum case within the actual enum. Imagine a character in an RPG.\nEach character can have a weapon, all characters have access to the same\nset of weapons. All other instances in the game do not have access to\nthose weapons (they're trolls, they just have clubs).</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character {\n\n   <span class=\"keyword\">enum</span> Weapon {\n\n     <span class=\"keyword\">case</span> bow\n\n     <span class=\"keyword\">case</span> sword\n\n     <span class=\"keyword\">case</span> lance\n\n     <span class=\"keyword\">case</span> dagger\n\n   }\n\n   <span class=\"keyword\">enum</span> Helmet {\n\n     <span class=\"keyword\">case</span> wooden\n\n     <span class=\"keyword\">case</span> iron\n\n     <span class=\"keyword\">case</span> diamond\n\n   }\n\n   <span class=\"keyword\">case</span> thief\n\n   <span class=\"keyword\">case</span> warrior\n\n   <span class=\"keyword\">case</span> knight\n\n}\n</code></pre></code></pre>\n<p>Now you have a hierachical system to describe the various items that\nyour character has access to.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> character = <span class=\"type\">Character</span>.<span class=\"property\">thief</span>\n\n<span class=\"keyword\">let</span> weapon = <span class=\"type\">Character</span>.<span class=\"type\">Weapon</span>.<span class=\"property\">bow</span>\n\n<span class=\"keyword\">let</span> helmet = <span class=\"type\">Character</span>.<span class=\"type\">Helmet</span>.<span class=\"property\">iron</span>\n</code></pre></code></pre>\n<p>If you add initializers for the nested <code>enum</code> types, you can still benefit from not having\nto type out the the long description. Imagine a function that calculates how strong a\ncharacter is, based on the character, the weapon, and the helmet:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> strength(of character: <span class=\"type\">Character</span>, \n\n      with weapon: <span class=\"type\">Character</span>.<span class=\"property\">weapon</span>, \n\n      and armor: <span class=\"type\">Character</span>.<span class=\"type\">Helmet</span>) {\n\n      <span class=\"keyword\">return</span> <span class=\"number\">0</span>\n\n}\n\n\n\n<span class=\"comment\">// You can still call it like this:</span>\n\n<span class=\"call\">strength</span>(of: .<span class=\"dotAccess\">thief</span>, with: .<span class=\"dotAccess\">bow</span>, and: .<span class=\"dotAccess\">wooden</span>)\n</code></pre></code></pre>\n<p>This is still really clear and easy to understand.</p>\n<h1>Containing Enums</h1>\n<p>In a similar vein, you can also embed enums in <code>structs</code> or <code>classes</code>.\nContinuing with our previous example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Character {\n\n    <span class=\"keyword\">enum</span> CharacterType {\n\n     <span class=\"keyword\">case</span> thief\n\n     <span class=\"keyword\">case</span> warrior\n\n     <span class=\"keyword\">case</span> knight\n\n   }\n\n   <span class=\"keyword\">enum</span> Weapon {\n\n     <span class=\"keyword\">case</span> bow\n\n     <span class=\"keyword\">case</span> sword\n\n     <span class=\"keyword\">case</span> lance\n\n     <span class=\"keyword\">case</span> dagger\n\n   }\n\n   <span class=\"keyword\">let</span> type: <span class=\"type\">CharacterType</span>\n\n   <span class=\"keyword\">let</span> weapon: <span class=\"type\">Weapon</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> warrior = <span class=\"type\">Character</span>(type: .<span class=\"dotAccess\">warrior</span>, weapon: .<span class=\"dotAccess\">sword</span>)\n</code></pre></code></pre>\n<p>This really helps in keeping related information together.</p>\n","raw_content":"[frontMatter]\ntitle = \"Nesting Enums\"\ntags = [\"enum\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Nesting Enums\n\nIf you have specific sub type requirements, you can also logically nest\nenums in an enum. This allows you to contain specific information on\nyour enum case within the actual enum. Imagine a character in an RPG.\nEach character can have a weapon, all characters have access to the same\nset of weapons. All other instances in the game do not have access to\nthose weapons (they\\'re trolls, they just have clubs).\n\n``` Swift\nenum Character {\n  enum Weapon {\n    case bow\n    case sword\n    case lance\n    case dagger\n  }\n  enum Helmet {\n    case wooden\n    case iron\n    case diamond\n  }\n  case thief\n  case warrior\n  case knight\n}\n```\n\nNow you have a hierachical system to describe the various items that\nyour character has access to.\n\n``` Swift\nlet character = Character.thief\nlet weapon = Character.Weapon.bow\nlet helmet = Character.Helmet.iron\n```\n\nIf you add initializers for the nested `enum` types, you can still benefit from not having\nto type out the the long description. Imagine a function that calculates how strong a \ncharacter is, based on the character, the weapon, and the helmet:\n\n``` Swift\nfunc strength(of character: Character, \n     with weapon: Character.weapon, \n     and armor: Character.Helmet) {\n     return 0\n}\n\n// You can still call it like this:\nstrength(of: .thief, with: .bow, and: .wooden)\n```\n\nThis is still really clear and easy to understand.\n\n# Containing Enums\n\nIn a similar vein, you can also embed enums in `structs` or `classes`.\nContinuing with our previous example:\n\n``` Swift\nstruct Character {\n   enum CharacterType {\n    case thief\n    case warrior\n    case knight\n  }\n  enum Weapon {\n    case bow\n    case sword\n    case lance\n    case dagger\n  }\n  let type: CharacterType\n  let weapon: Weapon\n}\n\nlet warrior = Character(type: .warrior, weapon: .sword)\n```\n\nThis really helps in keeping related information together.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/mirrors/intro.md":["f93ae9fde60eef7f",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Mirrors","tags":["reflection","mirror"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-mirrors.html","content":"<h1>Mirrors</h1>\n<p>Swift's reflection capabilities are based around a <code>struct</code> called\n<strong>Mirror</strong>. You create a mirror for a particular <code>subject</code> and the\nmirror will then let you query it.</p>\n<p>Before we look at the API, let's define a simple data structure that we can experiment on.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> Foundation\n\n\n\n<span class=\"keyword\">public class</span> Store {\n\n     <span class=\"keyword\">let</span> storesToDisk: <span class=\"type\">Bool</span> = <span class=\"keyword\">true</span>\n\n}\n\n<span class=\"keyword\">public class</span> BookmarkStore: <span class=\"type\">Store</span> {\n\n     <span class=\"keyword\">let</span> itemCount: <span class=\"type\">Int</span> = <span class=\"number\">10</span>\n\n}\n\n<span class=\"keyword\">public struct</span> Bookmark {\n\n    <span class=\"keyword\">enum</span> Group {\n\n       <span class=\"keyword\">case</span> tech\n\n       <span class=\"keyword\">case</span> news\n\n    }\n\n    <span class=\"keyword\">private let</span> store = {\n\n        <span class=\"keyword\">return</span> <span class=\"type\">BookmarkStore</span>()\n\n    }()\n\n    <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>?\n\n    <span class=\"keyword\">let</span> url: <span class=\"type\">URL</span>\n\n    <span class=\"keyword\">let</span> keywords: [<span class=\"type\">String</span>]\n\n    <span class=\"keyword\">let</span> group: <span class=\"type\">Group</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> aBookmark = <span class=\"type\">Bookmark</span>(title: \\<span class=\"string\">\"Appventure</span>\\<span class=\"string\">\"</span>, url: <span class=\"type\">URL</span>(string: \\<span class=\"string\">\"appventure</span>.<span class=\"property\">me</span>\\<span class=\"string\">\"</span>)!, keywords: [\\<span class=\"string\">\"Swift</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"iOS</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"OSX</span>\\<span class=\"string\">\"</span>], group: .<span class=\"dotAccess\">tech</span>)\n</code></pre></code></pre>\n<p>So, we have a <code>Bookmark</code>. Bookmarks can have titles, urls, keywords, and bookmarks can belong to a <code>Group</code>. There is also a <code>BookmarkStore</code> and a more general <code>Store</code>. So, how do we query this data structure at runtime?</p>\n","raw_content":"[frontMatter]\ntitle = \"Mirrors\"\ntags = [\"reflection\", \"mirror\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Mirrors\n\nSwift\\'s reflection capabilities are based around a `struct` called\n**Mirror**. You create a mirror for a particular `subject` and the\nmirror will then let you query it.\n\nBefore we look at the API, let\\'s define a simple data structure that we can experiment on.\n\n``` Swift\nimport Foundation\n\npublic class Store {\n    let storesToDisk: Bool = true\n}\npublic class BookmarkStore: Store {\n    let itemCount: Int = 10\n}\npublic struct Bookmark {\n   enum Group {\n      case tech\n      case news\n   }\n   private let store = {\n       return BookmarkStore()\n   }()\n   let title: String?\n   let url: URL\n   let keywords: [String]\n   let group: Group\n}\n\nlet aBookmark = Bookmark(title: \"Appventure\", url: URL(string: \"appventure.me\")!, keywords: [\"Swift\", \"iOS\", \"OSX\"], group: .tech)\n```\n\nSo, we have a `Bookmark`. Bookmarks can have titles, urls, keywords, and bookmarks can belong to a `Group`. There is also a `BookmarkStore` and a more general `Store`. So, how do we query this data structure at runtime?\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/associated_types/complete_book.html":["e3b0c44298fc1c14",{"identifier":"1d48","filename":"complete_book.html","info":{"title":"Patterns for Working With Associated Types","tags":[],"keywords":["swift","protocol","protocols","associated","associatedtype","typealias","pattern","pat"],"category":[],"created":"2017-12-10 10:30:30","description":"Understand how to model your way around some of the issues that arise when introducing associated types into your protocols","description_html":"<p>Understand how to model your way around some of the issues that arise when introducing associated types into your protocols</p>\n","published":true,"slug":"2017-12-10-patterns-for-working-with-associated-types.html","meta":{"featured":"true","swift_version":"5.1","short_code":"<pre class='Swift'><code><span class='source swift'><span class='apvstorage apvtype swift'>protocol</span> Host {<br/> associatedType Client<br/>} </span></code></pre></code></pre>","short_title":"🧙🏻 Associated Types"},"created_timestamp":1512901830,"date":"2017-12-10T10:30:30","date_info":{"year":2017,"month":12,"day":10,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/associated_types/complete_book.html","content":"<h1>Associated Types</h1>\n<p>Swift is a powerful language with a very powerful type system. Among the\nfeatures that define said type system are <code>associated types</code>. They can\nbe defined on a <code>protocol</code> to allow implementors of the <code>protocol</code> to\nspecialize certain types in a generic way:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Example {\n\n   <span class=\"keyword\">associatedtype</span> Value\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">Value</span> { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>In the snippet above, any type that implements the <code>Example</code> protocol\nhas to define the <code>Value</code> type. Protocols with <code>associated types</code> can be\nunderstood as <strong>unfinished types</strong>. Compared to regular protocols, which\ncan be used within Swift like normal types, those protocols can only be\nused as a generic constraint. This means that once your type requires an\n<code>associated type</code>, using it suddenly becomes much more complicated.</p>\n<p>The example below shows an example of <strong><strong>finishing</strong></strong> a type. By\nexplicitly telling the compiler that the <code>Value</code> type is <code>Int</code> it is now\nable to understand <code>ImplementExample</code> fully.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ImplementExample: <span class=\"type\">Example</span> {\n\n   <span class=\"keyword\">typealias</span> Value = <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Associated types are useful for a certain kind of problems where\nsubclassing and composition does allow you to build the right kind of\nabstractions. However, this is a seperate\ntopic. The topic of this article, on the other hand, is what to do when\nyou end up with associated types trouble.</p>\n<h1>Associated Types Trouble</h1>\n<p>The classic example of <code>associated types</code> trouble certainly is the\nfollowing Swift error message:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">protocol</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>Bookmarkable<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span> can only be used as a generic constraint because it has Self </span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">or</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> associated type requirements</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">var</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> bookmarks: <span class=\"techoukeyword techoucontrol techouregexp techouset techoubegin techoushell\">[</span>Bookmarkable<span class=\"techoukeyword techoucontrol techouregexp techouset techouend techoushell\">]</span></span>\n</span></code></pre></code></pre>\n<p>This happens once your type conforms to a protocol which conforms to\n<code>Equatable</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Bookmarkable: <span class=\"type\">Equatable</span> {\n\n}\n\n\n\n<span class=\"keyword\">struct</span> User {\n\n     <span class=\"keyword\">var</span> bookmarks: [<span class=\"type\">Bookmarkable</span>]\n\n}\n</code></pre></code></pre>\n<p>Here, the problem is that <code>Equatable</code> contains a method <code>==</code> which has\ntwo paramters of type <code>Self</code>. Protocol Methods with <code>Self</code> parameters\nautomatically opt in to <code>associated types</code>.</p>\n<p>Let's investigate several patterns that allow\nyou to work your way around the <code>associated type</code> requirement or that\nshow how such a type can be handled.</p>\n<h1>Make Your Types Equatable</h1>\n<p>The first solution for the archetypical problem is also a really simple\none. Instead of enforcing <code>Equatable</code> on your custom <code>protocol</code>, you can\nsimply require your full fledged, final, types to conform to the\n<code>Equatable</code> protocol instead of your custom protocol. Consider the\npreviously defined <code>Bookmarkable</code> protocol:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Bookmarkable {\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Bookmark: <span class=\"type\">Bookmarkable</span>, <span class=\"type\">Equatable</span> {\n\n   <span class=\"keyword\">var</span> identifier: <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"keyword\">func</span> ==(lhs: <span class=\"type\">Bookmark</span>, rhs: <span class=\"type\">Bookmark</span>) -&gt; <span class=\"type\">Bool</span> {\n\n   <span class=\"keyword\">return</span> lhs.<span class=\"property\">identifier</span> == rhs.<span class=\"property\">identifier</span>\n\n}\n\n\n\n<span class=\"keyword\">var</span> myBookmarks: [<span class=\"type\">Bookmark</span>] = []\n</code></pre></code></pre>\n<p>In the example above, the <code>Equatable</code> requirement actually stems from\nthe <code>Bookmark</code> type conforming to the <code>Equatable</code> protocol, not the\n<code>Bookmarkable</code> protocol itself. The actual <code>Equatable</code> information,\nhowever, lies in the new <code>identifier</code> property, which has been added to\nthe <code>Bookmark</code> <code>struct</code>. As you can easily see, this also requires you\nto make the <code>myBookmarks</code> array require only elements of type\n<code>Bookmark</code>. A serious disgression if you're used to using protocols\nlike partially anonymous types. A better solution, if your design allows\nfor it, goes one step further by enforcing the new <code>property</code> which we\nintroduced in this example.</p>\n<h2>Equatable Properties</h2>\n<p>Here, the idea is that we take one of the types that already implement\n<code>Equatable</code> in a proper way (i.e. <code>Int</code>, <code>String</code>, ...) and add a new\n<code>property</code> requirement to our <code>Bookmarkable</code> protocol. Then, we can use\nthis <code>property</code> to add <code>Equatable</code> support without actually implementing\n<code>Equatable</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Bookmarkable {\n\n     <span class=\"keyword\">var</span> identifier: <span class=\"type\">Int</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Bookmark: <span class=\"type\">Bookmarkable</span> {\n\n     <span class=\"keyword\">var</span> identifier: <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"keyword\">var</span> myBookmarks: [<span class=\"type\">Bookmarkable</span>] = []\n</code></pre></code></pre>\n<p>The main change, compared to the code above, is that the\n<code>var identifier</code> moved to the <code>Bookmarkable</code> protocol and that we\nremoved the <code>func ==</code>.</p>\n<p>While this works better, it still has a major deficit. Since\n<code>Bookmarkable</code> does not directly comply with <code>Equatable</code>, you will not\ngain the standard library's methods that specifically deal with\n<code>Equatable</code> types. So instead of being able to call <code>Array.contains</code>\nlike this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> ourBookmark = <span class=\"type\">Bookmark</span>(identifier: <span class=\"number\">0</span>)\n\n<span class=\"keyword\">let</span> result = myBookmarks.<span class=\"call\">contains</span>(ourBookmark)\n</code></pre></code></pre>\n<p>You will have to use the more verbose closure-based version:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> ourBookmark = <span class=\"type\">Bookmark</span>(identifier: <span class=\"number\">0</span>)\n\n\n\n<span class=\"keyword\">let</span> result = myBookmarks.<span class=\"call\">contains</span> { (bookmark) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">return</span> bookmark.<span class=\"property\">identifier</span> == ourBookmark.<span class=\"property\">identifier</span>\n\n}\n</code></pre></code></pre>\n<h1>Associated Types and Self</h1>\n<p>Another vector which can introduce <code>associated types</code> into your codebase\nis the usage of <code>Self</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Example {\n\n   <span class=\"comment\">/// Indirect Associated Type</span>\n\n   <span class=\"keyword\">var</span> builder: <span class=\"type\">Self</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"comment\">/// Indirect Associated Type</span>\n\n   <span class=\"keyword\">func</span> makeSomething(with example: <span class=\"type\">Self</span>)\n\n}\n\n<span class=\"keyword\">var</span> myExamples: [<span class=\"type\">Example</span>] = []\n</code></pre></code></pre>\n<p>As you can see in the example above, using <code>Self</code> as a method parameter\nor using <code>Self</code> as a property type automatically introduces an\n<code>associated type</code> (like we saw with <code>Equatable</code>, earlier).</p>\n<p>The most helpful note here is that once you use a <code>method</code> instead of a\n<code>property</code> in order to return something of type <code>Self</code> you will not opt\nin to an <code>associated type</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Example {\n\n   <span class=\"comment\">/// No Indirect Associated Type</span>\n\n   <span class=\"keyword\">func</span> builder() -&gt; <span class=\"type\">Self</span>\n\n}\n\n<span class=\"keyword\">var</span> myExamples: [<span class=\"type\">Example</span>] = []\n</code></pre></code></pre>\n<p>This example works fine. No <code>indirect associated</code> type is introduced.</p>\n<h1>Method-Only Types</h1>\n<p>If your <code>associated type</code> requirement doesn't come from <code>Equatable</code>\nconformance but instead from your own use, you can double-check if you\nactually need these associated types.</p>\n<p>Take this example of a validator type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Validator {\n\n     <span class=\"keyword\">associatedtype</span> I\n\n     <span class=\"keyword\">func</span> validate(<span class=\"keyword\">_</span> input: <span class=\"type\">I</span>) -&gt; <span class=\"type\">Bool</span>\n\n}\n</code></pre></code></pre>\n<p>As the <code>associated type</code> is only used in one method, you can\nalternatively just make it a <code>generic</code> method and thus save yourself\nfrom introducing unnecessary unfinished types:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Validator {\n\n     <span class=\"keyword\">func</span> validate&lt;I&gt;(<span class=\"keyword\">_</span> input: <span class=\"type\">I</span>) -&gt; <span class=\"type\">Bool</span>\n\n}\n</code></pre></code></pre>\n<h1>Hiding Behind Protocols</h1>\n<p>This is an especially useful and flexible pattern. It can be used in\nmany situations where you want to use protocols with <code>associated types</code>\nlike a normal, full fledged type, but still be able to opt in to the\ngeneric part if necessary. The idea here is that you define two\nprotocols that share common methods. Only one of those protocols\ncontains <code>associated types</code>, the other does not. Your types conform to\nboth protocols. This means that you can use the <strong>normal</strong> protocol as a\ntype for all situations. If you, then, need to use the parts of the type\nthat only affect the <code>associated type</code>, you can do so by means of a\nruntime cast.</p>\n<p>Begin by defining an <code>associated</code> Protocol <code>ExampleAssociatedProtocol</code>\nthat is shadowed by a <code>normal</code> Protocol <code>ExampleProtocol</code>.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// The `Normal` Protocol</span>\n\n<span class=\"keyword\">protocol</span> ExampleProtocol {\n\n   <span class=\"keyword\">var</span> anyValue: <span class=\"type\">Any</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"comment\">/// The Protocol with an associated type</span>\n\n<span class=\"keyword\">protocol</span> ExampleAssociatedProtocol: <span class=\"type\">ExampleProtocol</span> {\n\n   <span class=\"keyword\">associatedtype</span> Value\n\n\n\n   <span class=\"comment\">/// Retrieving the actual associated type</span>\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">Value</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"comment\">/// Conform to the `ExampleProtocol`</span>\n\n<span class=\"keyword\">extension</span> <span class=\"type\">ExampleAssociatedProtocol</span> {\n\n   <span class=\"keyword\">var</span> anyValue: <span class=\"type\">Any</span> {\n\n     <span class=\"keyword\">return</span> value\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Now, you can use the <code>ExampleProtocol</code> as a normal type throughout your\napp in all situations where a protocol with an <code>associated type</code> would\notherwise fail:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> World {\n\n   <span class=\"keyword\">var</span> examples: [<span class=\"type\">ExampleProtocol</span>]\n\n\n\n   <span class=\"keyword\">let</span> example: <span class=\"type\">ExampleProtocol</span>\n\n\n\n   <span class=\"keyword\">func</span> generate() -&gt; <span class=\"type\">ExampleProtocol</span> { \n\n     <span class=\"keyword\">return</span> example\n\n   }\n\n}\n</code></pre></code></pre>\n<p>However, if you need to access the property that is specific to the\n<code>ExampleAssociatedProtocol</code> (<code>value</code>) then you can do so through at\nruntime.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Custom type implementing `ExampleAssociatedProtocol`</span>\n\n<span class=\"keyword\">struct</span> IntExample: <span class=\"type\">ExampleAssociatedProtocol</span> {\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"comment\">/// Custom type implementing `ExampleAssociatedProtocol`</span>\n\n<span class=\"keyword\">struct</span> StringExample: <span class=\"type\">ExampleAssociatedProtocol</span> {\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">String</span>\n\n}\n\n\n\n<span class=\"comment\">/// Shadowing via `ExampleProtocol`</span>\n\n<span class=\"keyword\">let</span> myExamples: [<span class=\"type\">ExampleProtocol</span>] = \n\n     [<span class=\"type\">StringExample</span>(value: \\<span class=\"string\">\"A</span>\\<span class=\"string\">\"</span>), <span class=\"type\">IntExample</span>(value: <span class=\"number\">10</span>)]\n\n\n\n<span class=\"comment\">/// Runtime Casting</span>\n\n<span class=\"keyword\">for</span> aNormalExample <span class=\"keyword\">in</span> myExamples {\n\n   <span class=\"keyword\">if let</span> anAssociatedExample = aNormalExample <span class=\"keyword\">as</span>? <span class=\"type\">IntExample</span> {\n\n     <span class=\"call\">print</span>(anAssociatedExample.<span class=\"property\">value</span>)\n\n   }\n\n   <span class=\"keyword\">if let</span> anAssociatedExample = aNormalExample <span class=\"keyword\">as</span>? <span class=\"type\">StringExample</span> {\n\n     <span class=\"call\">print</span>(anAssociatedExample.<span class=\"property\">value</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>This will print &quot;A10&quot; as both types (<code>IntExample</code> and <code>StringExample</code>)\nare being identified at runtime via a cast from <code>ExampleProtocol</code>.</p>\n<h1>Type Erasure</h1>\n<p>Quite often, when Swift's associated types are dicussed, <code>type erasure</code>\nis mentioned as another solution to the problem of handling the issues\nthat <code>associated types</code> bring along.</p>\n<p>Type Erasure in the context of <code>associated types</code> solves one particular\nproblem. We'll use computers as an example. Back in the golden age of\ndesktop operating systems, you could buy a desktop computer with many\nnon-X86 CPU architectures: PowerPC, Alpha, Sparc, 68000, and so on. One\nof the many differences were the <code>endianness</code> of the architecture. Lets\nmodel these computers in Swift:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> CPU {\n\n     <span class=\"keyword\">var</span> littleEndian: <span class=\"type\">Bool</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> PowerPC: <span class=\"type\">CPU</span> {\n\n     <span class=\"keyword\">let</span> littleEndian = <span class=\"keyword\">false</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> X86: <span class=\"type\">CPU</span> {\n\n     <span class=\"keyword\">let</span> littleEndian = <span class=\"keyword\">true</span>\n\n}\n</code></pre></code></pre>\n<p>Next up, we want to define a protocol for a computer. It could be a\ndesktop computer or a phone or maybe a game console, so we use a\nprotocol. In order to model the CPU, we're using an <code>associated type</code>,\nso that the actual type can define the CPU:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Computer {\n\n     <span class=\"keyword\">associatedtype</span> ProcessorType: <span class=\"type\">CPU</span>\n\n     <span class=\"keyword\">var</span> processor: <span class=\"type\">ProcessorType</span> { <span class=\"keyword\">get</span> }\n\n     <span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>Based on this, we can now define a couple of systems:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> PowerMacG5: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">let</span> processor = <span class=\"type\">PowerPC</span>()\n\n     <span class=\"keyword\">let</span> processorCount = <span class=\"number\">2</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Xbox360: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">let</span> processor = <span class=\"type\">PowerPC</span>()\n\n     <span class=\"keyword\">let</span> processorCount = <span class=\"number\">1</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> MacPro: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">let</span> processor = <span class=\"type\">X86</span>()\n\n     <span class=\"keyword\">let</span> processorCount = <span class=\"number\">1</span>\n\n}\n</code></pre></code></pre>\n<p>Now that we have all this, we'd like to perform a computation on all\n<strong>PowerPC</strong> based computers. I.e. something like:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> powerComputers = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>()]\n</code></pre></code></pre>\n<p>However, what would be the type of this? We can't use the <code>Computer</code>\nprotocol, as it contains <code>associated types</code>. However, the\n<code>associated types</code> for the PowerMacG5 <strong>and</strong> the Xbox360 <strong>are</strong> the\nsame, so in terms of types, Swift ought to understand that those things\nare kinda similar. However, there's no way to (easily) express this in\nthe type system; both <strong>PowerMacG5</strong> and <strong>Xbox360</strong> are not the correct\ntypes for the array:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// None of those work</span>\n\n<span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">PowerMacG5</span>] = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>]\n\n<span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">Xbox360</span>] = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>]\n\n<span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">Computer</span>] = [<span class=\"type\">PowerMacG5</span>(), <span class=\"type\">Xbox360</span>]\n</code></pre></code></pre>\n<p>Type erasure is a solution for this. The idea is to box the actual type\ninto a generic wrapper so that Swift can coalesce around wrapper + type.\nThe solution we're aiming for would look like this in the end:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">AnyComputer</span>&lt;<span class=\"type\">PowerPC</span>&gt;] = [<span class=\"type\">AnyComputer</span>(<span class=\"type\">PowerMacG5</span>()), <span class=\"type\">AnyComputer</span>(<span class=\"type\">Xbox360</span>())]\n</code></pre></code></pre>\n<p>Now we would have our <strong>shared</strong> type, in this case it is\n<code>AnyComputer&lt;CPU&gt;</code>. Where does this mystic <code>AnyComputer</code> come from? We\nhave to build it ourselves. This is a multi-step process, and requires\nquite a bit of boilerplate. We will start simple and expand step by\nstep. This solution requires multiple types.</p>\n<h1>An Abstract Class</h1>\n<p>In essense, what we're going to build, is a generic wrapper (or box)\nthat hosts a type conforming to a <code>protocol</code> with an <code>associated type</code>.\nIt does so by implementing the requirements of the <code>protocol</code> and\nforwarding all invocations to the boxed type.</p>\n<p>The first new type we need for that is a base <code>class</code> that acts as a\nabstract class:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> AnyComputerBase&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">var</span> processor: <span class=\"type\">Processor</span> {\n\n         <span class=\"call\">fatalError</span>()\n\n     }\n\n     <span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> {\n\n         <span class=\"call\">fatalError</span>()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This <code>class</code> should never be initialized, as it only provides an\nabstract template of what subclasses should implement. While other\nlanguages (like Java) allow explicitly marking classes as abstract,\nSwift doesn't offer us a way to do so. One solution to this is adding a\n<code>fileprivate init</code> to this <code>class</code>. However as that requires subclasses\nto be in the same file as this superclass, we can also just make the\nwhole <code>class</code> <code>private</code> with an even better result. Now, other parts of\nthe code won't even know about the existence of <code>AnyComputerBase</code> or\neven <code>initialize</code> it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private class</span> AnyComputerBase&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n...\n\n}\n</code></pre></code></pre>\n<p>Why do we even need this, and what does it do? As you can see, it just\nimplements the <code>Computer</code> <code>protocol</code> by implementing the requirements\nand doing nothing in there. The more important part is that it moves the\n<code>associated type</code> from the protocol into a generic type for the <code>class</code>:\n<code>AnyComputerBase&lt;Processor: CPU&gt;</code>.</p>\n<p>Swift automatically figures out that <code>Processor</code> is the <code>typealias</code> for\n<code>Computer.ProcessorType</code>. However, when in doubt you can also add an\nextra typealias:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> AnyComputerBase&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n   <span class=\"keyword\">typealias</span> ProcessorType = <span class=\"type\">Processor</span>\n\n   ...\n\n}\n</code></pre></code></pre>\n<h1>A Box Type</h1>\n<p>The next step is the most difficult to understand part of type erasure,\nwhich means that after this, it'll be easy. We will introduce another\n<code>private</code> type. This will be the actual box that houses our original\ntype (the XBox360 or the PowerMac G5). Let's start by having a look at\nthe code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private class</span> AnyComputerBox&lt;ConcreteComputer: <span class=\"type\">Computer</span>&gt;: \n\n         <span class=\"type\">AnyComputerBase</span>&lt;<span class=\"type\">ConcreteComputer</span>.<span class=\"type\">ProcessorType</span>&gt; \n\n{\n\n     <span class=\"keyword\">private let</span> internalComputer: <span class=\"type\">ConcreteComputer</span>\n\n     <span class=\"keyword\">override var</span> processor: <span class=\"type\">ConcreteComputer</span>.<span class=\"type\">ProcessorType</span> {\n\n         <span class=\"keyword\">return</span> internalComputer.<span class=\"property\">processor</span>\n\n     }\n\n     <span class=\"keyword\">override var</span> processorCount: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">return</span> internalComputer.<span class=\"property\">processorCount</span>\n\n     }\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> computer: <span class=\"type\">ConcreteComputer</span>) {\n\n         internalComputer = computer\n\n     }\n\n}\n</code></pre></code></pre>\n<p>The most important concept here can be found in the very first line:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private class</span> AnyComputerBox&lt;ConcreteComputer: <span class=\"type\">Computer</span>&gt;: \n\n         <span class=\"type\">AnyComputerBase</span>&lt;<span class=\"type\">ConcreteComputer</span>.<span class=\"type\">ProcessorType</span>&gt;\n</code></pre></code></pre>\n<p>Here, we define a new type <code>AnyComputerBox</code> which is generic over\n<strong>any</strong> computer (<code>ConcreteComputer</code>). This new type, then, is a\nsubclass of our earlier abstract class <code>AnyComputerBase</code>. Remember that\n<code>AnyComputerBase</code> made the original <code>ProcessorType</code> of the <code>Computer</code>\nprotocol generic by adding it as a generic parameter <code>CPU</code>. Now, our new\nbox has a <strong>different</strong> generic type (<code>Computer</code>) and provides only its\n<code>associated type</code> <strong>ProcessorType</strong> to the abstract superclass. In a\nsimpler explanation, this is what happens (in a mock language):</p>\n<ol>\n<li><code>Computer&lt;CPU&gt;</code></li>\n<li><code>AnyComputerBase&lt;Processor: CPU&gt;: Computer&lt;CPU&gt; where Computer.CPU = Processor</code></li>\n<li><code>AnyComputerBox&lt;ConcreteComputer: Computer&gt;: AnyComputerBase&lt;ConcreteComputer.ProcessorType&gt;</code></li>\n</ol>\n<p>So the box (<code>AnyComputerBox</code>) subclasses the abstract class and forwards\nin the <code>Processor</code> type via its own generic <code>Computer</code> type which also\nhas a <code>ProcessorType</code>.</p>\n<p>Why do we do this? It makes the box generic over any computer so that\n<strong>any</strong> computer can be boxed into it.</p>\n<p>The rest of the <code>class</code> is simple. There's an <code>internal</code> computer\n<code>internalComputer</code> which is the actual type conforming to the <code>Computer</code>\n<code>protocol</code>. We're also overriding the two classes that are required by\nthe protocol and forwarding the implementations of the\n<code>internalComputer</code>. Finally we have an initializer with a new\n<code>ConcreteComputer</code> (i.e. the <code>Computer</code> protocol).</p>\n<h1>Puttting it all together</h1>\n<p>In the next and final step, we're building the actual type that will be\nused as the proverbial type eraser. Just as before, lets have a look at\nthe code first:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> AnyComputer&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">private let</span> box: <span class=\"type\">AnyComputerBase</span>&lt;<span class=\"type\">Processor</span>&gt;\n\n     <span class=\"keyword\">var</span> processor: <span class=\"type\">Processor</span> {\n\n         <span class=\"keyword\">return</span> box.<span class=\"property\">processor</span>\n\n     }\n\n     <span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">return</span> box.<span class=\"property\">processorCount</span>\n\n     }\n\n     <span class=\"keyword\">init</span>&lt;Concrete: <span class=\"type\">Computer</span>&gt;(<span class=\"keyword\">_</span> computer: <span class=\"type\">Concrete</span>) \n\n         <span class=\"keyword\">where</span> <span class=\"type\">Concrete</span>.<span class=\"type\">ProcessorType</span> == <span class=\"type\">Processor</span> {\n\n       box = <span class=\"type\">AnyComputerBox</span>(computer)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This <code>AnyComputer</code> conforms to the <code>Computer</code> protocol and is generic\nover the <code>CPU</code> type that the protocol requires. Once again, we implement\nthe protocol requirements (<code>processor</code>, and <code>processorCount</code>) and\nforward to a boxed type. This time we're forwarding to\n<code>private let box: AnyComputerBase&lt;Processor&gt;</code>. This <code>box</code> is set in the\ninitializer where most of the magic happens:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>&lt;Concrete: <span class=\"type\">Computer</span>&gt;(<span class=\"keyword\">_</span> computer: <span class=\"type\">Concrete</span>) \n\n     <span class=\"keyword\">where</span> <span class=\"type\">Concrete</span>.<span class=\"type\">ProcessorType</span> == <span class=\"type\">Processor</span> {\n\n   box = <span class=\"type\">AnyComputerBox</span>(computer)\n\n}\n</code></pre></code></pre>\n<p>The problem with protocols with <code>associated types</code> is that you can't\nuse them as property types. Here, <code>init</code> requires any type conforming to\nthe <code>Computer</code> protocol. This is done by having a method-generic type\n<code>Concrete</code> that requires <code>Computer</code> conformance. Even more, we also add\na constraint that makes sure that the generic <code>Processor</code> type of the\nnew <code>AnyComputer</code> class is the same type as the <code>associated type</code> of the\n<code>Concrete</code> <code>Computer</code> type.</p>\n<p>And now comes the kicker: Since we cannot set a property as being of\ntype <code>Computer</code> we, instead, have a property that is of\n<code>AnyComputerBase</code> with a generic type for the <code>Processor</code>. As our\n<code>AnyComputerBox</code> type is a subclass of <code>AnyComputerBase</code> we can\nliterally put <strong>any</strong> box (that is a subclass of <code>AnyComputerBase</code> into\nthis property. In this case, we're creating a new box with the\n<code>Concrete</code> <code>Computer</code>.</p>\n<p>Then we return the implementations of the contents of the box (i.e. the\nactual <code>Concrete</code> <code>Computer</code>) in our <code>Computer</code> implementations:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">return</span> box.<span class=\"property\">processorCount</span>\n\n}\n</code></pre></code></pre>\n<h2>Using It</h2>\n<p>With all this machinery in place, we can finally use this in order to\nhave different types (which share an associated type) in one container:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">AnyComputer</span>&lt;<span class=\"type\">PowerPC</span>&gt;] = \n\n     [<span class=\"type\">AnyComputer</span>(<span class=\"type\">PowerMacG5</span>()), <span class=\"type\">AnyComputer</span>(<span class=\"type\">Xbox360</span>())]\n</code></pre></code></pre>\n<h1>Conclusion</h1>\n<p><code>Associated types</code> are a powerful concept however they come with a fair\nshare of difficulties. Most notably, as soon as you introduce an\n<code>associated type</code> you can't use it like you'd use normal full types.\nThis article provided several patterns that make it a bit easier to\nhandle <code>associated type</code> problems in your codebase. Each of these\npatterns has downsides though. In general, if you intend to use\n<code>associated types</code> in a <code>protocol</code>, one of the best solutions is to try\nto only use the types that implement this <code>protocol</code> instead of the\n<code>protocol</code> itself. Because then you don't even need those patterns.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/result_types.md":["772e6be8e0ab5170",{"identifier":"913f845c","filename":"result_types.md","info":{"title":"Result Types","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-result-types.html","content":"<h1>Result Types</h1>\n<p>Enums are also frequently used to map the result of JSON parsing into\nthe Swift type system. Here's a short example of this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> JSON {\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONString</span>(<span class=\"type\">Swift</span>.<span class=\"type\">String</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONNumber</span>(<span class=\"type\">Double</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONObject</span>([<span class=\"type\">String</span> : <span class=\"type\">JSONValue</span>])\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONArray</span>([<span class=\"type\">JSONValue</span>])\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONBool</span>(<span class=\"type\">Bool</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONNull</span>\n\n}\n</code></pre></code></pre>\n<p>Similarly, if you're parsing something else, you may use the very same\nstructure to convert your parsing results into Swift types. This also\nmakes perfect sense to only do it during the parsing / processing step\nand then taking the <code>JSON enum</code> representation and converting it into\none of your application's internal <code>class</code> or <code>struct</code> types.</p>\n","raw_content":"[frontMatter]\ntitle = \"Result Types\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Result Types\n\nEnums are also frequently used to map the result of JSON parsing into\nthe Swift type system. Here\\'s a short example of this:\n\n``` Swift\nenum JSON {\n    case JSONString(Swift.String)\n    case JSONNumber(Double)\n    case JSONObject([String : JSONValue])\n    case JSONArray([JSONValue])\n    case JSONBool(Bool)\n    case JSONNull\n}\n```\n\nSimilarly, if you\\'re parsing something else, you may use the very same\nstructure to convert your parsing results into Swift types. This also\nmakes perfect sense to only do it during the parsing / processing step\nand then taking the `JSON enum` representation and converting it into\none of your application\\'s internal `class` or `struct` types.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/working_around_associated_type_issues/self.md":["eb58991fffa94865",{"identifier":"f57e6cf7","filename":"self.md","info":{"title":"Associated Types and Self","tags":["box","associated","self"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-associated-types-and-self.html","content":"<h1>Associated Types and Self</h1>\n<p>Another vector which can introduce <code>associated types</code> into your codebase\nis the usage of <code>Self</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Example {\n\n   <span class=\"comment\">/// Indirect Associated Type</span>\n\n   <span class=\"keyword\">var</span> builder: <span class=\"type\">Self</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"comment\">/// Indirect Associated Type</span>\n\n   <span class=\"keyword\">func</span> makeSomething(with example: <span class=\"type\">Self</span>)\n\n}\n\n<span class=\"keyword\">var</span> myExamples: [<span class=\"type\">Example</span>] = []\n</code></pre></code></pre>\n<p>As you can see in the example above, using <code>Self</code> as a method parameter\nor using <code>Self</code> as a property type automatically introduces an\n<code>associated type</code> (like we saw with <code>Equatable</code>, earlier).</p>\n<p>The most helpful note here is that once you use a <code>method</code> instead of a\n<code>property</code> in order to return something of type <code>Self</code> you will not opt\nin to an <code>associated type</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Example {\n\n   <span class=\"comment\">/// No Indirect Associated Type</span>\n\n   <span class=\"keyword\">func</span> builder() -&gt; <span class=\"type\">Self</span>\n\n}\n\n<span class=\"keyword\">var</span> myExamples: [<span class=\"type\">Example</span>] = []\n</code></pre></code></pre>\n<p>This example works fine. No <code>indirect associated</code> type is introduced.</p>\n","raw_content":"[frontMatter]\ntitle = \"Associated Types and Self\"\ntags = [\"box\", \"associated\", \"self\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Associated Types and Self\n\nAnother vector which can introduce `associated types` into your codebase\nis the usage of `Self`:\n\n``` Swift\nprotocol Example {\n  /// Indirect Associated Type\n  var builder: Self { get }\n  /// Indirect Associated Type\n  func makeSomething(with example: Self)\n}\nvar myExamples: [Example] = []\n```\n\nAs you can see in the example above, using `Self` as a method parameter\nor using `Self` as a property type automatically introduces an\n`associated type` (like we saw with `Equatable`, earlier).\n\nThe most helpful note here is that once you use a `method` instead of a\n`property` in order to return something of type `Self` you will not opt\nin to an `associated type`:\n\n``` Swift\nprotocol Example {\n  /// No Indirect Associated Type\n  func builder() -> Self\n}\nvar myExamples: [Example] = []\n```\n\nThis example works fine. No `indirect associated` type is introduced.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/dynamically_update_touchbar.md":["b8810b432d7f942c",{"identifier":"99a06e5b","filename":"dynamically_update_touchbar.md","info":{"title":"How do I dynamically update the touchbar?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-dynamically-update-the-touchbar.html","content":"<p>The documentation states that you just need to call <code>setNeedsTouchBarUpdate()</code> in order for the touch bar to be updated. However, as of beta 2, this does not work yet. A reliable way of achieving this is to just reset the <code>touchBar</code> property on <code>UIResponder</code> subclasses (like <code>UIViewController</code>) with the updated touchbar:</p>\n<pre class=\"Swift\"><code>     <span class=\"comment\">// Adding `self.` everywhere to make it clear where it lives in this example</span>\n\n     <span class=\"keyword\">@objc func</span> doChangeState(sender: <span class=\"type\">Any</span>) {\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">state</span> = <span class=\"keyword\">self</span>.<span class=\"property\">state</span> + <span class=\"number\">1</span>\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">touchBar</span> = <span class=\"keyword\">self</span>.<span class=\"call\">makeTouchBar</span>()\n\n     }\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I dynamically update the touchbar?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nThe documentation states that you just need to call `setNeedsTouchBarUpdate()` in order for the touch bar to be updated. However, as of beta 2, this does not work yet. A reliable way of achieving this is to just reset the `touchBar` property on `UIResponder` subclasses (like `UIViewController`) with the updated touchbar:\n\n```swift\n    // Adding `self.` everywhere to make it clear where it lives in this example\n    @objc func doChangeState(sender: Any) {\n        self.state = self.state + 1\n        self.touchBar = self.makeTouchBar()\n    }\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/a_simple_problem.md":["58749252b44d5e5c",{"identifier":"79e2d700","filename":"a_simple_problem.md","info":{"title":"A Simple Problem","tags":["map","compactMap","filter"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-a-simple-problem.html","content":"<h1>A simple Problem</h1>\n<p>Consider this problem: You're getting a list of persons from a JSON\nendpoint. You'd like to know the average age from all people living in\nCalifornia. The parsed data looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> persons: [[<span class=\"type\">String</span>: <span class=\"type\">Any</span>]] = [[\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Carl</span> <span class=\"type\">Saxon</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"New</span> <span class=\"type\">York</span>, <span class=\"type\">NY</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">44</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Travis</span> <span class=\"type\">Downing</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"El</span> <span class=\"type\">Segundo</span>, <span class=\"type\">CA</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">34</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Liz</span> <span class=\"type\">Parker</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"San</span> <span class=\"type\">Francisco</span>, <span class=\"type\">CA</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">32</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"John</span> <span class=\"type\">Newden</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"New</span> <span class=\"type\">Jersey</span>, <span class=\"type\">NY</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">21</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Hector</span> <span class=\"type\">Simons</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"San</span> <span class=\"type\">Diego</span>, <span class=\"type\">CA</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">37</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Brian</span> <span class=\"type\">Neo</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">27</span>]]\n</code></pre></code></pre>\n<p>Note the last entry, which omits a <code>city</code> for the person in question.\nThose cases have to be silently ignored.</p>\n<p>The expected result in the example would be 3 persons , as we have three\npersons from California. Let's try to implement this in Swift in terms\nof <code>compactMap</code> and <code>filter</code>. The <code>compactMap</code> is used instead of <code>map</code> as\n<code>compactMap</code> automatically ignores empty optionals. So\n<code>compactMap([0, nil, 1, 2, nil])</code> results in <code>[0, 1, 2]</code>. This eases the\nhandling of persons without a proper city.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> infoFromState(state: <span class=\"type\">String</span>, persons: [[<span class=\"type\">String</span>: <span class=\"type\">Any</span>]]) \n\n      -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">return</span> persons.<span class=\"call\">compactMap</span>( { $0[\\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>]?.<span class=\"call\">componentsSeparatedByString</span>(\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>).<span class=\"property\">last</span> })\n\n            .<span class=\"call\">filter</span>({$0 == state})\n\n            .<span class=\"dotAccess\">count</span>\n\n}\n\n<span class=\"call\">infoFromState</span>(state: \\<span class=\"string\">\"CA</span>\\<span class=\"string\">\"</span>, persons: persons)\n</code></pre></code></pre>\n<p>That's simple enough.</p>\n<p>However, now consider the following complication: You'd like to know\nhow many of those persons live in California, and you'd like to know\ntheir average age. If we try upgrading the above example, we soon\nrealize that his is a slightly harder problem.</p>\n<p>There are various\nsolutions, but they all seem to not fit well with functional constructs.\nA loop-based approach feels much simpler.</p>\n<p>When we think about why this does fit, we realize it is because the\nshape of the data changes. <code>map</code>, <code>compactMap</code>, and <code>filter</code> all keep the\nshape of the data similar. Array goes in, array goes out. The amount and\nthe contents of the array may change, but the array-shape stays. The\nproblem above, however, requires us to change the shape to a <code>struct</code> or\n<code>tuple</code> with an <strong>Integer average</strong> and an <strong>Integer sum</strong>.</p>\n<p>These are the kind of problems where you can apply <code>reduce</code>.\nSo what is reduce? Lets have a look.</p>\n","raw_content":"[frontMatter]\ntitle = \"A Simple Problem\"\ntags = [\"map\", \"compactMap\", \"filter\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# A simple Problem\n\nConsider this problem: You\\'re getting a list of persons from a JSON\nendpoint. You\\'d like to know the average age from all people living in\nCalifornia. The parsed data looks like this:\n\n``` Swift\nlet persons: [[String: Any]] = [[\"name\": \"Carl Saxon\", \"city\": \"New York, NY\", \"age\": 44],\n [\"name\": \"Travis Downing\", \"city\": \"El Segundo, CA\", \"age\": 34],\n [\"name\": \"Liz Parker\", \"city\": \"San Francisco, CA\", \"age\": 32],\n [\"name\": \"John Newden\", \"city\": \"New Jersey, NY\", \"age\": 21],\n [\"name\": \"Hector Simons\", \"city\": \"San Diego, CA\", \"age\": 37],\n [\"name\": \"Brian Neo\", \"age\": 27]]\n```\n\nNote the last entry, which omits a `city` for the person in question.\nThose cases have to be silently ignored.\n\nThe expected result in the example would be 3 persons , as we have three\npersons from California. Let\\'s try to implement this in Swift in terms\nof `compactMap` and `filter`. The `compactMap` is used instead of `map` as\n`compactMap` automatically ignores empty optionals. So\n`compactMap([0, nil, 1, 2, nil])` results in `[0, 1, 2]`. This eases the\nhandling of persons without a proper city.\n\n``` Swift\nfunc infoFromState(state: String, persons: [[String: Any]]) \n     -> Int {\n    return persons.compactMap( { $0[\"city\"]?.componentsSeparatedByString(\", \").last })\n           .filter({$0 == state})\n           .count\n}\ninfoFromState(state: \"CA\", persons: persons)\n```\n\nThat\\'s simple enough.\n\nHowever, now consider the following complication: You\\'d like to know\nhow many of those persons live in California, and you\\'d like to know\ntheir average age. If we try upgrading the above example, we soon\nrealize that his is a slightly harder problem. \n\nThere are various\nsolutions, but they all seem to not fit well with functional constructs.\nA loop-based approach feels much simpler.\n\nWhen we think about why this does fit, we realize it is because the\nshape of the data changes. `map`, `compactMap`, and `filter` all keep the\nshape of the data similar. Array goes in, array goes out. The amount and\nthe contents of the array may change, but the array-shape stays. The\nproblem above, however, requires us to change the shape to a `struct` or\n`tuple` with an **Integer average** and an **Integer sum**.\n\nThese are the kind of problems where you can apply `reduce`.\nSo what is reduce? Lets have a look.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/touchbar.md":["e026a7c7d2e9302e",{"identifier":"5cb1c606","filename":"touchbar.md","info":{"title":"How do I add TouchBar support?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-add-touchbar-support.html","content":"<h2>Preparations</h2>\n<p>Note that in <em>Beta 2</em> you need to manually import a special bridging header if you want to use touchbars. <a href=\"firststeps/bridgingheader.md\">Here's how to do it</a>.</p>\n<p>With that out of the way, lets have a brief look at touchbars. <a href=\"https://developer.apple.com/documentation/appkit/nstouchbar\">Apple's documentation for the <code>NSTouchBar</code> class is fantastic</a> and it would be a waste to try to replicate all that documentation here. Also, touchbars in Catalyst apps work just like the AppKit touchbars. So all the available <code>NSTouchBar</code> tutorials work just as well for your iPad app.</p>\n<p>In brief, touchbars work as follows: Each controller in the <a href=\"how/responder_chain.md\">responder chain</a> is asked whether he has a touchbar that he wants to display via the <code>func makeTouchBar() -&gt; NSTouchBar?</code> method on <code>UIResponder</code> (or <code>NSResponder</code>). The higher up items in the responder chain have priority. Within that method, you return a fully configured touchbar with a proper <code>NSTouchBarDelegate</code> set. The <code>NSTouchBarDelegate</code> allows you to configure the touchbar to your hearts contents. Here's a simple example:</p>\n<p>Make sure to remember that touchbars only appear for objects that conform to <code>UIResponder</code> and are in the <a href=\"how/responder_chain.md\">responder chain</a>. A good place for this code is your <code>UIViewController</code> that is currently being displayed.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Define the items we want to display in the touch bar via specific identifiers, so UIKit can track them</span>\n\n<span class=\"keyword\">let</span> <span class=\"type\">MyButtonTouchBarIdentifier</span> = <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"MyButton</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"keyword\">class</span> MyViewController: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">override func</span> makeTouchBar() -&gt; <span class=\"type\">NSTouchBar</span>? {\n\n         <span class=\"keyword\">let</span> touchBar = <span class=\"type\">NSTouchBar</span>()\n\n         touchBar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n         touchBar.<span class=\"property\">defaultItemIdentifiers</span> = [<span class=\"type\">MyButtonTouchBarIdentifier</span>,\n\n                                            <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">otherItemsProxy</span>]\n\n         <span class=\"keyword\">return</span> touchBar\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> buttonPressed(sender: <span class=\"type\">NSTouchBarItem</span>) {\n\n     }\n\n}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">MacSplitViewController</span>: <span class=\"type\">NSTouchBarDelegate</span> {\n\n\n\n     <span class=\"keyword\">func</span> touchBar(<span class=\"keyword\">_</span> touchBar: <span class=\"type\">NSTouchBar</span>, makeItemForIdentifier identifier: <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>) -&gt; <span class=\"type\">NSTouchBarItem</span>? {\n\n         <span class=\"keyword\">switch</span> identifier {\n\n         <span class=\"keyword\">case</span> <span class=\"type\">MyButtonTouchBarIdentifier</span>:\n\n             <span class=\"keyword\">return</span> <span class=\"type\">NSButtonTouchBarItem</span>.<span class=\"keyword\">init</span>(identifier: identifier,\n\n                                              title: \\<span class=\"string\">\"Press</span> <span class=\"type\">Me</span>\\<span class=\"string\">\"</span>,\n\n                                              target: <span class=\"keyword\">self</span>,\n\n                                              action: <span class=\"keyword\">#selector</span>(<span class=\"keyword\">self</span>.<span class=\"property\">buttonPressed</span>))\n\n         <span class=\"keyword\">default</span>: <span class=\"keyword\">return nil</span>\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<h2>Using Apple HIG TouchBar Images</h2>\n<p>Apple has a very nice set of default touchbar images outlined here:</p>\n<ul>\n<li>https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/</li>\n<li>https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc</li>\n</ul>\n<p>These currently can't be used in Catalyst apps (FB6312494).</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I add TouchBar support?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\n## Preparations\n\nNote that in *Beta 2* you need to manually import a special bridging header if you want to use touchbars. [Here's how to do it](firststeps/bridgingheader.md).\n\nWith that out of the way, lets have a brief look at touchbars. [Apple's documentation for the `NSTouchBar` class is fantastic](https://developer.apple.com/documentation/appkit/nstouchbar) and it would be a waste to try to replicate all that documentation here. Also, touchbars in Catalyst apps work just like the AppKit touchbars. So all the available `NSTouchBar` tutorials work just as well for your iPad app.\n\nIn brief, touchbars work as follows: Each controller in the [responder chain](how/responder_chain.md) is asked whether he has a touchbar that he wants to display via the `func makeTouchBar() -> NSTouchBar?` method on `UIResponder` (or `NSResponder`). The higher up items in the responder chain have priority. Within that method, you return a fully configured touchbar with a proper `NSTouchBarDelegate` set. The `NSTouchBarDelegate` allows you to configure the touchbar to your hearts contents. Here's a simple example:\n\nMake sure to remember that touchbars only appear for objects that conform to `UIResponder` and are in the [responder chain](how/responder_chain.md). A good place for this code is your `UIViewController` that is currently being displayed.\n\n``` swift\n// Define the items we want to display in the touch bar via specific identifiers, so UIKit can track them\nlet MyButtonTouchBarIdentifier = NSTouchBarItem.Identifier(rawValue: \"MyButton\")\n\nclass MyViewController: UIViewController {\n    override func makeTouchBar() -> NSTouchBar? {\n        let touchBar = NSTouchBar()\n        touchBar.delegate = self\n        touchBar.defaultItemIdentifiers = [MyButtonTouchBarIdentifier,\n                                           NSTouchBarItem.Identifier.otherItemsProxy]\n        return touchBar\n    }\n\n    @objc func buttonPressed(sender: NSTouchBarItem) {\n    }\n}\nextension MacSplitViewController: NSTouchBarDelegate {\n\n    func touchBar(_ touchBar: NSTouchBar, makeItemForIdentifier identifier: NSTouchBarItem.Identifier) -> NSTouchBarItem? {\n        switch identifier {\n        case MyButtonTouchBarIdentifier:\n            return NSButtonTouchBarItem.init(identifier: identifier,\n                                             title: \"Press Me\",\n                                             target: self,\n                                             action: #selector(self.buttonPressed))\n        default: return nil\n        }\n    }\n}\n```\n\n## Using Apple HIG TouchBar Images\n\nApple has a very nice set of default touchbar images outlined here:\n\n- https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/\n- https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc\n\nThese currently can't be used in Catalyst apps (FB6312494).\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/associated_types_trouble.md":["07f94635445bc333",{"identifier":"5ad45756","filename":"associated_types_trouble.md","info":{"title":"Associated Types Trouble","tags":["box","associated","protocol"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-associated-types-trouble.html","content":"<h1>Associated Types Trouble</h1>\n<p>The classic example of <code>associated types</code> trouble certainly is the\nfollowing Swift error message:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">protocol</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>Bookmarkable<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span> can only be used as a generic constraint because it has Self </span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">or</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> associated type requirements</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">var</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> bookmarks: <span class=\"techoukeyword techoucontrol techouregexp techouset techoubegin techoushell\">[</span>Bookmarkable<span class=\"techoukeyword techoucontrol techouregexp techouset techouend techoushell\">]</span></span>\n</span></code></pre></code></pre>\n<p>This happens once your type conforms to a protocol which conforms to\n<code>Equatable</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Bookmarkable: <span class=\"type\">Equatable</span> {\n\n}\n\n\n\n<span class=\"keyword\">struct</span> User {\n\n     <span class=\"keyword\">var</span> bookmarks: [<span class=\"type\">Bookmarkable</span>]\n\n}\n</code></pre></code></pre>\n<p>Here, the problem is that <code>Equatable</code> contains a method <code>==</code> which has\ntwo paramters of type <code>Self</code>. Protocol Methods with <code>Self</code> parameters\nautomatically opt in to <code>associated types</code>.</p>\n<p>Let's investigate several patterns that allow\nyou to work your way around the <code>associated type</code> requirement or that\nshow how such a type can be handled.</p>\n","raw_content":"[frontMatter]\ntitle = \"Associated Types Trouble\"\ntags = [\"box\", \"associated\", \"protocol\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Associated Types Trouble\n\nThe classic example of `associated types` trouble certainly is the\nfollowing Swift error message:\n\n``` bash\nprotocol 'Bookmarkable' can only be used as a generic constraint because it has Self \nor associated type requirements\nvar bookmarks: [Bookmarkable]\n```\n\nThis happens once your type conforms to a protocol which conforms to\n`Equatable`:\n\n``` Swift\nprotocol Bookmarkable: Equatable {\n}\n\nstruct User {\n    var bookmarks: [Bookmarkable]\n}\n```\n\nHere, the problem is that `Equatable` contains a method `==` which has\ntwo paramters of type `Self`. Protocol Methods with `Self` parameters\nautomatically opt in to `associated types`.\n\nLet's investigate several patterns that allow\nyou to work your way around the `associated type` requirement or that\nshow how such a type can be handled.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/optionals/extending_optionals.md":["a53475cde388f7ba",{"identifier":"29c87ba6","filename":"extending_optionals.md","info":{"title":"Useful Optional Extensions","tags":["optionals","extension"],"keywords":["swift","protocol","optional","optionals","extensions"],"category":[],"created":"2018-01-10 10:30:30","description":"Several helpful extensions to the Optional type in order to simplify using it.","description_html":"<p>Several helpful extensions to the Optional type in order to simplify using it.</p>\n","published":true,"slug":"2018-01-10-optional-extensions.html","meta":{"swift_version":"5.0"},"created_timestamp":1515580230,"date":"2018-01-10T10:30:30","date_info":{"year":2018,"month":1,"day":10,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2018-01-10-optional-extensions.html","content":"<p><code>Optionals</code> are a staple of Swift. I guess everybody will agree that\nthey are a huge boon insofar as they force us to properly handle edge\ncases. The <code>Optional</code> language feature alone removes a whole category of\nbugs from the development process.</p>\n<p>However, the API surface of Swift's optional is rather limited. The\n<a href=\"https://developer.apple.com/documentation/swift/optional#topics\">Swift documentation lists just a\ncouple</a>\nof methods / properties on <code>Optional</code> - if we ignore <code>customMirror</code> and\n<code>debugDescription</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> unsafelyUnwrapped: <span class=\"type\">Wrapped</span> { <span class=\"keyword\">get</span> } \n\n<span class=\"keyword\">func</span> map&lt;U&gt;(<span class=\"keyword\">_</span> transform: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">U</span>) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">U</span>? \n\n<span class=\"keyword\">func</span> flatMap&lt;U&gt;(<span class=\"keyword\">_</span> transform: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">U</span>?) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">U</span>? \n</code></pre></code></pre>\n<p>The reason why optionals are still very useful even though they have\nsuch a small amount of methods is that the Swift syntax makes up for it\nvia features such as <a href=\"lnk::optional\">optional\nchaining</a>,\n<a href=\"lnk::switch\">pattern\nmatching</a>,\n<code>if let</code> or <code>guard let</code>. In some situations, though, this manifests\nitself in unnecessary line noise. Sometimes, a very succinct method will\nlet you express a concept in one short line of code instead of multiple\nlines of combined <code>if let</code> statements.</p>\n<p>I've sifted through Swift Projects on Github as well as the optional\nimplementations of other languages such as Rust, Scala, or C# in order\nto find a couple of useful additions to <code>Optional</code>. Below are 14 useful\n<code>Optional</code> extensions. I'll describe them by category and then give a\ncouple of examples per category. Finally, I'll write a more involved\nexample that uses several extensions at once.</p>\n<h1>Emptiness</h1>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Returns true if the optional is empty</span>\n\n     <span class=\"keyword\">var</span> isNone: <span class=\"type\">Bool</span> {\n\n         <span class=\"keyword\">return self</span> == .<span class=\"dotAccess\">none</span>\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns true if the optional is not empty</span>\n\n     <span class=\"keyword\">var</span> isSome: <span class=\"type\">Bool</span> {\n\n         <span class=\"keyword\">return self</span> != .<span class=\"dotAccess\">none</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Those are the most basic additions to the optional type. The\nimplementation could also use a <code>switch</code> pattern match instead, but the\n<code>nil</code> comparison is much shorter. What I like about these additions is\nthat they move the concept of an empty optional being nil away from your\ncode. This might just as well be an implementation detail. Using\n<code>optional.isSome</code> feels much cleaner and less noisy than\n<code>if optional == nil</code>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Compare</span>\n\n<span class=\"keyword\">guard</span> leftButton != <span class=\"keyword\">nil</span>, rightButton != <span class=\"keyword\">nil else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Missing</span> <span class=\"type\">Interface Builder</span> connections\\<span class=\"string\">\"</span>) }\n\n\n\n<span class=\"comment\">// With</span>\n\n<span class=\"keyword\">guard</span> leftButton.<span class=\"property\">isSome</span>, rightButton.<span class=\"property\">isSome</span> <span class=\"keyword\">else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Missing</span> <span class=\"type\">Interface Builder</span> connections\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<h1>Or</h1>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Return the value of the Optional or the `default` parameter</span>\n\n     <span class=\"comment\">/// - param: The value to return if the optional is empty</span>\n\n     <span class=\"keyword\">func</span> or(<span class=\"keyword\">_ default</span>: <span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">return self</span> ?? `default`\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the unwrapped value of the optional *or*</span>\n\n     <span class=\"comment\">/// the result of an expression `else`</span>\n\n     <span class=\"comment\">/// I.e. optional.or(else: print(\\\"Arrr\\\"))</span>\n\n     <span class=\"keyword\">func</span> or(else: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">return self</span> ?? `else`()\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the unwrapped value of the optional *or*</span>\n\n     <span class=\"comment\">/// the result of calling the closure `else`</span>\n\n     <span class=\"comment\">/// I.e. optional.or(else: {</span> \n\n     <span class=\"comment\">/// ... do a lot of stuff</span>\n\n     <span class=\"comment\">/// })</span>\n\n     <span class=\"keyword\">func</span> or(else: () -&gt; <span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">return self</span> ?? `else`()\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the unwrapped contents of the optional if it is not empty</span>\n\n     <span class=\"comment\">/// If it is empty, throws exception `throw`</span>\n\n     <span class=\"keyword\">func</span> or(throw exception: <span class=\"type\">Error</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">guard let</span> unwrapped = <span class=\"keyword\">self else</span> { <span class=\"keyword\">throw</span> exception }\n\n         <span class=\"keyword\">return</span> unwrapped\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> <span class=\"keyword\">where</span> <span class=\"type\">Wrapped</span> == <span class=\"type\">Error</span> {\n\n     <span class=\"comment\">/// Only perform `else` if the optional has a non-empty error value</span>\n\n     <span class=\"keyword\">func</span> or(<span class=\"keyword\">_</span> else: (<span class=\"type\">Error</span>) -&gt; <span class=\"type\">Void</span>) {\n\n         <span class=\"keyword\">guard let</span> error = <span class=\"keyword\">self else</span> { <span class=\"keyword\">return</span> }\n\n         `else`(error)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Another abstraction on the <code>isNone / isSome</code> concept is being able to\nspecify instructions to be performed when the invariant doesn't hold.\nThis saves us from having to write out <code>if</code> or <code>guard</code> branches and\ninstead codifies the logic into a simple-to-understand method.</p>\n<p>This concept is so useful, that it is defined in three distinct\nfunctions.</p>\n<h2>Default Value</h2>\n<p>The first one returns the wrapped value of the optional or a default\nvalue:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\n<span class=\"call\">print</span>(optional.<span class=\"call\">or</span>(<span class=\"number\">10</span>)) <span class=\"comment\">// Prints 10</span>\n</code></pre></code></pre>\n<h2>Default Closure</h2>\n<p>The second one is very similar to the first one, however it allows to\nreturn a default value from a closure instead.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\noptional.<span class=\"call\">or</span>(else: secretValue * <span class=\"number\">32</span>) \n</code></pre></code></pre>\n<p>Since this uses the <code>@autoclosure</code> parameter we could actually use just\nthe second <code>or</code> implementation. Then, using a just a default value would\nautomatically be converted into a closure returning the value. However,\nI prefer having two separate implementations as that allows users to\nalso write closures with more complex logic.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> cachedUserCount: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\n...\n\n<span class=\"keyword\">return</span> cachedUserCount.<span class=\"call\">or</span>(else: {\n\n    <span class=\"keyword\">let</span> db = <span class=\"call\">database</span>()\n\n    db.<span class=\"call\">prefetch</span>()\n\n    <span class=\"keyword\">guard</span> db.<span class=\"property\">failures</span>.<span class=\"property\">isEmpty</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"number\">0</span> }\n\n    <span class=\"keyword\">return</span> db.<span class=\"property\">amountOfUsers</span>\n\n})\n</code></pre></code></pre>\n<p>A really nice use case for <code>or</code> is code where you only want to set a\nvalue on an optional if it is empty:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if</span> databaseController == <span class=\"keyword\">nil</span> {\n\n   databaseController = <span class=\"type\">DatabaseController</span>(config: config)\n\n}\n</code></pre></code></pre>\n<p>This can be replaced with the much nicer:</p>\n<pre class=\"Swift\"><code>databaseController = databaseController.<span class=\"call\">or</span>(<span class=\"type\">DatabaseController</span>(config: config)\n</code></pre></code></pre>\n<h2>Throw an error</h2>\n<p>This is a very useful addition as it allows to merge the chasm between\nOptionals and Error Handling in Swift. Depending on the code that\nyou're using, a method or function may express invalid behaviour by\nreturning an empty optional (imagine accessing a non-existing key in a\n<code>Dictionary</code>) or by throwing an <code>Error</code>. Combining these two oftentimes\nleads to a lot of unnecessary line noise:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> buildCar() <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Car</span> {\n\n   <span class=\"keyword\">let</span> tires = <span class=\"keyword\">try</span> machine1.<span class=\"call\">createTires</span>()\n\n   <span class=\"keyword\">let</span> windows = <span class=\"keyword\">try</span> machine2.<span class=\"call\">createWindows</span>()\n\n   <span class=\"keyword\">guard let</span> motor = externalMachine.<span class=\"call\">deliverMotor</span>() <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">throw</span> <span class=\"type\">MachineError</span>.<span class=\"property\">motor</span>\n\n   }\n\n   <span class=\"keyword\">let</span> trunk = <span class=\"keyword\">try</span> machine3.<span class=\"call\">createTrunk</span>()\n\n   <span class=\"keyword\">if let</span> car = manufacturer.<span class=\"call\">buildCar</span>(tires, windows,  motor, trunk) {\n\n     <span class=\"keyword\">return</span> car\n\n   } <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">throw</span> <span class=\"type\">MachineError</span>.<span class=\"property\">manufacturer</span>\n\n   }\n\n}\n</code></pre></code></pre>\n<p>In this example, we're building a car by combining internal and\nexternal code. The external code (<code>external_machine</code> and <code>manufacturer</code>)\nchoose to use optionals instead of error handling. This makes the code\nunnecessary complicated. Our <code>or(throw:)</code> function makes this much more\nreadable:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> build_car() <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Car</span> {\n\n   <span class=\"keyword\">let</span> tires = <span class=\"keyword\">try</span> machine1.<span class=\"call\">createTires</span>()\n\n   <span class=\"keyword\">let</span> windows = <span class=\"keyword\">try</span> machine2.<span class=\"call\">createWindows</span>()\n\n   <span class=\"keyword\">let</span> motor = <span class=\"keyword\">try</span> externalMachine.<span class=\"call\">deliverMotor</span>().<span class=\"call\">or</span>(throw: <span class=\"type\">MachineError</span>.<span class=\"property\">motor</span>)\n\n   <span class=\"keyword\">let</span> trunk = <span class=\"keyword\">try</span> machine3.<span class=\"call\">createTrunk</span>()\n\n   <span class=\"keyword\">return try</span> manufacturer.<span class=\"call\">buildCar</span>(tires, windows,  motor, trunk).<span class=\"call\">or</span>(throw: <span class=\"type\">MachineError</span>.<span class=\"property\">manufacturer</span>)\n\n}\n</code></pre></code></pre>\n<h2>Handling Errors</h2>\n<p>The code from the <strong>Throw an error</strong> section above becomes even more\nuseful when you include the following free function that was proposed by\n<a href=\"https://github.com/doozMen\">Stijn Willems on Github</a>. Thanks for the\nsuggestion!</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> should(<span class=\"keyword\">_</span> do: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Error</span>? {\n\n     <span class=\"keyword\">do</span> {\n\n         <span class=\"keyword\">try</span> `do`()\n\n         <span class=\"keyword\">return nil</span>\n\n     } <span class=\"keyword\">catch let</span> error {\n\n         <span class=\"keyword\">return</span> error\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This free function (alternatively, you could make it a class method on\noptional) will perform a <code>do {} catch {}</code> block and return an error if\nand only if the closure `do` resulted in an error. Take, the following\nSwift code as an example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">do</span> {\n\n   <span class=\"keyword\">try</span> <span class=\"call\">throwingFunction</span>()\n\n} <span class=\"keyword\">catch let</span> error {\n\n   <span class=\"call\">print</span>(error)\n\n}\n</code></pre></code></pre>\n<p>This is one of the basic tennets of error handling in Swift, and it\nintroduces quite a lot of line noise. With the free function above, you\ncan reduce it to this simple on-liner:</p>\n<pre class=\"Swift\"><code><span class=\"call\">should</span> { <span class=\"keyword\">try</span> throwingFunction) }.<span class=\"call\">or</span>(<span class=\"call\">print</span>($0))\n</code></pre></code></pre>\n<p>I feel that there're many situations where such a one-liner for error\nhandling would be very beneficient.</p>\n<h2>Map</h2>\n<p>As we saw above, <code>map</code> and <code>flatMap</code> are the only methods that Swift\noffers on Optionals. However, even those can be improved a bit to be\nmore versatile in many situations. There're two additional variations\non <code>map</code> that allow defining a default value similar to how the <code>or</code>\nvariants above are implemented:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Maps the output *or* returns the default value if the optional is nil</span>\n\n     <span class=\"comment\">/// - parameter fn: The function to map over the value</span>\n\n     <span class=\"comment\">/// - parameter or: The value to use if the optional is empty</span>\n\n     <span class=\"keyword\">func</span> map&lt;T&gt;(<span class=\"keyword\">_</span> fn: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>, default: <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">return try</span> <span class=\"call\">map</span>(fn) ?? `default`\n\n     }\n\n\n\n     <span class=\"comment\">/// Maps the output *or* returns the result of calling `else`</span>\n\n     <span class=\"comment\">/// - parameter fn: The function to map over the value</span>\n\n     <span class=\"comment\">/// - parameter else: The function to call if the optional is empty</span>\n\n     <span class=\"keyword\">func</span> map&lt;T&gt;(<span class=\"keyword\">_</span> fn: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>, else: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">return try</span> <span class=\"call\">map</span>(fn) ?? `else`()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>The first one will allow you to <code>map</code> the contents of an optional to a\nnew type <code>T</code>. If the optional is empty, you can define a <code>default</code> value\nthat should be used instead:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional1: <span class=\"type\">String</span>? = \\<span class=\"string\">\"appventure</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> optional2: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>\n\n\n\n<span class=\"comment\">// Without</span>\n\n<span class=\"call\">print</span>(optional1.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }) ?? <span class=\"number\">0</span>)\n\n<span class=\"call\">print</span>(optional2.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }) ?? <span class=\"number\">0</span>)\n\n\n\n<span class=\"comment\">// With</span> \n\n<span class=\"call\">print</span>(optional1.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>)) <span class=\"comment\">// prints 10</span>\n\n<span class=\"call\">print</span>(optional2.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>)) <span class=\"comment\">// prints 0</span>\n</code></pre></code></pre>\n<p>The changes are minimal, but we're moving away from having to use the\n<code>??</code> operator and can instead express the operation more clearly with\nthe <code>default</code> keyword.</p>\n<p>The second variant is very similar. The main difference is that it\naccepts (again) a closure returning value <code>T</code> instead of value <code>T</code>.\nHere's a brief example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>\n\n<span class=\"call\">print</span>(optional.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }, else: { \\<span class=\"string\">\"default</span>\\<span class=\"string\">\"</span>.<span class=\"property\">count</span> })\n</code></pre></code></pre>\n<h1>Combining Optionals</h1>\n<p>This category contains four functions that allow you to define relations\nbetween multiple optionals.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Tries to unwrap `self` and if that succeeds continues to unwrap the parameter `optional`</span>\n\n     <span class=\"comment\">/// and returns the result of that.</span>\n\n     <span class=\"keyword\">func</span> and&lt;B&gt;(<span class=\"keyword\">_</span> optional: <span class=\"type\">B</span>?) -&gt; <span class=\"type\">B</span>? {\n\n         <span class=\"keyword\">guard self</span> != <span class=\"keyword\">nil else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return</span> optional\n\n     }\n\n\n\n     <span class=\"comment\">/// Executes a closure with the unwrapped result of an optional.</span>\n\n     <span class=\"comment\">/// This allows chaining optionals together.</span>\n\n     <span class=\"keyword\">func</span> and&lt;T&gt;(then: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>?) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">T</span>? {\n\n         <span class=\"keyword\">guard let</span> unwrapped = <span class=\"keyword\">self else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return try</span> <span class=\"call\">then</span>(unwrapped)\n\n     }\n\n\n\n     <span class=\"comment\">/// Zips the content of this optional with the content of another</span>\n\n     <span class=\"comment\">/// optional `other` only if both optionals are not empty</span>\n\n     <span class=\"keyword\">func</span> zip2&lt;A&gt;(with other: <span class=\"type\">Optional</span>&lt;<span class=\"type\">A</span>&gt;) -&gt; (<span class=\"type\">Wrapped</span>, <span class=\"type\">A</span>)? {\n\n         <span class=\"keyword\">guard let</span> first = <span class=\"keyword\">self</span>, <span class=\"keyword\">let</span> second = other <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return</span> (first, second)\n\n     }\n\n\n\n     <span class=\"comment\">/// Zips the content of this optional with the content of another</span>\n\n     <span class=\"comment\">/// optional `other` only if both optionals are not empty</span>\n\n     <span class=\"keyword\">func</span> zip3&lt;A, B&gt;(with other: <span class=\"type\">Optional</span>&lt;<span class=\"type\">A</span>&gt;, another: <span class=\"type\">Optional</span>&lt;<span class=\"type\">B</span>&gt;) -&gt; (<span class=\"type\">Wrapped</span>, <span class=\"type\">A</span>, <span class=\"type\">B</span>)? {\n\n         <span class=\"keyword\">guard let</span> first = <span class=\"keyword\">self</span>,\n\n               <span class=\"keyword\">let</span> second = other,\n\n               <span class=\"keyword\">let</span> third = another <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return</span> (first, second, third)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>These four functions all share that they take an additional optional as\na parameter and return another optional value. However, they're all\nquite different in what they achieve.</p>\n<h2>Dependencies</h2>\n<p><code>and&lt;B&gt;(_ optional)</code> is useful if the unpacking of an optional is only\nrequired as a invariant for unpacking another optional:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Compare</span>\n\n<span class=\"keyword\">if</span> user != <span class=\"keyword\">nil</span>, <span class=\"keyword\">let</span> account = <span class=\"call\">userAccount</span>() ...\n\n\n\n<span class=\"comment\">// With</span>\n\n<span class=\"keyword\">if let</span> account = user.<span class=\"call\">and</span>(<span class=\"call\">userAccount</span>()) ...\n</code></pre></code></pre>\n<p>In the example above, we're not interested in the unwrapped contents of\nthe <code>user</code> optional. We just need to make sure that there <strong>is</strong> a valid\nuser before we call the <code>userAccount</code> function. While this relationship\nis kinda codified in the <code>user != nil</code> line, I personally feel that the\n<code>and</code> makes it more clear.</p>\n<h2>Chaining</h2>\n<p><code>and&lt;T&gt;(then:)</code> is another very useful function. It allows to chain\noptionals together so that the output of unpacking optional <code>A</code> becomes\nthe input of producing optional <code>B</code>. Lets start with a simple example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> UserDatabase {\n\n   <span class=\"keyword\">func</span> current() -&gt; <span class=\"type\">User</span>?\n\n   <span class=\"keyword\">func</span> spouse(of user: <span class=\"type\">User</span>) -&gt; <span class=\"type\">User</span>?\n\n   <span class=\"keyword\">func</span> father(of user: <span class=\"type\">User</span>) -&gt; <span class=\"type\">User</span>?\n\n   <span class=\"keyword\">func</span> childrenCount(of user: <span class=\"type\">User</span>) -&gt; <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> database: <span class=\"type\">UserDatabase</span> = ...\n\n\n\n<span class=\"comment\">// Imagine we want to know the children of the following relationship:</span>\n\n<span class=\"comment\">// Man -&gt; Spouse -&gt; Father -&gt; Father -&gt; Spouse -&gt; children</span>\n\n\n\n<span class=\"comment\">// Without</span>\n\n<span class=\"keyword\">let</span> childrenCount: <span class=\"type\">Int</span>\n\n<span class=\"keyword\">if let</span> user = database.<span class=\"call\">current</span>(), \n\n    <span class=\"keyword\">let</span> father1 = database.<span class=\"call\">father</span>(user),\n\n    <span class=\"keyword\">let</span> father2 = database.<span class=\"call\">father</span>(father1),\n\n    <span class=\"keyword\">let</span> spouse = database.<span class=\"call\">spouse</span>(father2),\n\n    <span class=\"keyword\">let</span> children = database.<span class=\"call\">childrenCount</span>(father2) {\n\n   childrenCount = children\n\n} <span class=\"keyword\">else</span> {\n\n   childrenCount = <span class=\"number\">0</span>\n\n}\n\n\n\n<span class=\"comment\">// With</span>\n\n<span class=\"keyword\">let</span> children = database.<span class=\"call\">current</span>().<span class=\"call\">and</span>(then: { database.<span class=\"call\">spouse</span>($0) })\n\n      .<span class=\"call\">and</span>(then: { database.<span class=\"call\">father</span>($0) })\n\n      .<span class=\"call\">and</span>(then: { database.<span class=\"call\">spouse</span>($0) })\n\n      .<span class=\"call\">and</span>(then: { database.<span class=\"call\">childrenCount</span>($0) })\n\n      .<span class=\"call\">or</span>(<span class=\"number\">0</span>)\n</code></pre></code></pre>\n<p>There're a lot of improvements when using the version with <code>and(then)</code>.\nFirst of all, you don't have to come up with superfluous temporary\nvariable names (user, father1, father2, spouse, children). Second, we\nclearly have less code. Also, using the <code>or(0)</code> instead of a complicated\n<code>let childrenCount</code> is so much easier to read.</p>\n<p>Finally, the original Swift example can easily lead to logic errors. You\nmay not have noticed, but there's a bug in the example. When writing\nlines like that, copy paste errors can easily be introduced. Do you see\nthe error?</p>\n<p>Yeah, the <code>children</code> property should be created by calling\n<code>database.childrenCount(spouse)</code> but I wrote\n<code>database.childrenCount(father2)</code> instead. It is difficult to spot\nerrors like that. The <code>and(then:)</code> example makes it much easier because\nit always relies on the same variable name <code>$0</code>.</p>\n<h2>Zipping</h2>\n<p>This is another variation on an existing Swift concept. The <code>zip</code> method\non optional will allow us to combine multiple optionals and unwrap them\ntogether or not at all. I've just provided implementations for <code>zip2</code>\nand <code>zip3</code> but nothing prevents you from going up to <code>zip22</code> (Well,\nmaybe sanity and compiler speed).</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Lets start again with a normal Swift example</span>\n\n<span class=\"keyword\">func</span> buildProduct() -&gt; <span class=\"type\">Product</span>? {\n\n   <span class=\"keyword\">if let</span> var1 = machine1.<span class=\"call\">makeSomething</span>(),\n\n     <span class=\"keyword\">let</span> var2 = machine2.<span class=\"call\">makeAnotherThing</span>(),\n\n     <span class=\"keyword\">let</span> var3 = machine3.<span class=\"call\">createThing</span>() {\n\n     <span class=\"keyword\">return</span> finalMachine.<span class=\"call\">produce</span>(var1, var2, var3)\n\n   } <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">return nil</span>\n\n   }\n\n}\n\n\n\n<span class=\"comment\">// The alternative using our extensions</span>\n\n<span class=\"keyword\">func</span> buildProduct() -&gt; <span class=\"type\">Product</span>? {\n\n   <span class=\"keyword\">return</span> machine1.<span class=\"call\">makeSomething</span>()\n\n      .<span class=\"call\">zip3</span>(machine2.<span class=\"call\">makeAnotherThing</span>(), machine3.<span class=\"call\">createThing</span>())\n\n      .<span class=\"call\">map</span> { finalMachine.<span class=\"call\">produce</span>($0.<span class=\"number\">1</span>, $0.<span class=\"number\">2</span>, $0.<span class=\"number\">3</span>) }\n\n}\n</code></pre></code></pre>\n<p>Less code, clearer code, more beautiful code. However, as a downside,\nthis code is also more involved. The reader has to know and understand\n<code>zip</code> in order to easily grasp it.</p>\n<h2>On</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Executes the closure `some` if and only if the optional has a value</span>\n\n     <span class=\"keyword\">func</span> on(some: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> {\n\n         <span class=\"keyword\">if self</span> != <span class=\"keyword\">nil</span> { <span class=\"keyword\">try</span> <span class=\"call\">some</span>() }\n\n     }\n\n\n\n     <span class=\"comment\">/// Executes the closure `none` if and only if the optional has no value</span>\n\n     <span class=\"keyword\">func</span> on(none: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> {\n\n         <span class=\"keyword\">if self</span> == <span class=\"keyword\">nil</span> { <span class=\"keyword\">try</span> <span class=\"call\">none</span>() }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>These two short methods will allow you to perform side effects if an\noptional is empty or not. In contrast to the already discussed methods,\nthese ignore the contents of the optional. So <code>on(some:)</code> will only\nexecute the closure <code>some</code> if the optional is not empty but the closure\n<code>some</code> will not get the unwrapped contents of the optional.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Logout if there is no user anymore</span>\n\n<span class=\"keyword\">self</span>.<span class=\"property\">user</span>.<span class=\"call\">on</span>(none: { <span class=\"type\">AppCoordinator</span>.<span class=\"property\">shared</span>.<span class=\"call\">logout</span>() })\n\n\n\n<span class=\"comment\">/// self.user is not empty when we are connected to the network</span>\n\n<span class=\"keyword\">self</span>.<span class=\"property\">user</span>.<span class=\"call\">on</span>(some: { <span class=\"type\">AppCoordinator</span>.<span class=\"property\">shared</span>.<span class=\"call\">unlock</span>() })\n</code></pre></code></pre>\n<h2>Various</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Returns the unwrapped value of the optional only if</span>\n\n     <span class=\"comment\">/// - The optional has a value</span>\n\n     <span class=\"comment\">/// - The value satisfies the predicate `predicate`</span>\n\n     <span class=\"keyword\">func</span> filter(<span class=\"keyword\">_</span> predicate: (<span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Wrapped</span>? {\n\n         <span class=\"keyword\">guard let</span> unwrapped = <span class=\"keyword\">self</span>,\n\n             <span class=\"call\">predicate</span>(unwrapped) <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return self</span>\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the wrapped value or crashes with `fatalError(message)`</span>\n\n     <span class=\"keyword\">func</span> expect(<span class=\"keyword\">_</span> message: <span class=\"type\">String</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">guard let</span> value = <span class=\"keyword\">self else</span> { <span class=\"call\">fatalError</span>(message) }\n\n         <span class=\"keyword\">return</span> value\n\n     }\n\n}\n</code></pre></code></pre>\n<h3>Filter</h3>\n<p>This is a simple method which works like an additional guard to only\nunwrap the optional if it satisfies a predictate. Here's an example.\nImagine we want to upgrade all our old users to a premium account for\nsticking with us for a long time:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Only affect old users with id &lt; 1000</span>\n\n<span class=\"comment\">// Normal Swift</span>\n\n<span class=\"keyword\">if let</span> aUser = user, user.<span class=\"property\">id</span> &lt; <span class=\"number\">1000</span> { aUser.<span class=\"call\">upgradeToPremium</span>() }\n\n\n\n<span class=\"comment\">// Using `filter`</span>\n\nuser.<span class=\"call\">filter</span>({ $0.<span class=\"property\">id</span> &lt; <span class=\"number\">1000</span> })?.<span class=\"call\">upgradeToPremium</span>()\n</code></pre></code></pre>\n<p>Here, <code>user.filter</code> feels like a much more natural implementation. Also,\nit only implements what already exists for Swift's collections.</p>\n<h3>Expect</h3>\n<p>This is one of my favorites. Also, I shamelessly stole it from Rust.\nI'm trying very hard to never force unwrap anything in my codebase.\nSimilar for implicitly unwrapped optionals.</p>\n<p>However, this is tricky when working with interface builder outlets. A\ncommon pattern that I observed can be seen in the following function:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> updateLabel() {\n\n   <span class=\"keyword\">guard let</span> label = valueLabel <span class=\"keyword\">else</span> {\n\n     <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"valueLabel</span> not connected <span class=\"keyword\">in</span> <span class=\"type\">IB</span>\\<span class=\"string\">\"</span>)\n\n   }\n\n   label.<span class=\"property\">text</span> = state.<span class=\"property\">title</span>\n\n}\n</code></pre></code></pre>\n<p>The alternative solution, obviously, would be to just to force unwrap\nthe label, as that leads to a crash just like <code>fatalError</code>. Then, I'd\nhave to insert <code>!</code> though, also it wouldn't give me a nice succinct\ndescription of what actually is wrong. The better alternative here is to\nuse <code>expect</code> as implemented above:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> updateLabel() {\n\n   valueLabel.<span class=\"call\">expect</span>(\\<span class=\"string\">\"valueLabel</span> not connected <span class=\"keyword\">in</span> <span class=\"type\">IB</span>\\<span class=\"string\">\"</span>).<span class=\"property\">text</span> = state.<span class=\"property\">title</span>\n\n}\n</code></pre></code></pre>\n<h1>Example</h1>\n<p>So now that we've seen a couple of (hopefully) useful <code>Optional</code>\nextensions, I'll set up an example to better see how some of these\nextensions can be combined to simplify optional handling. First, we need\na bit of context. Forgive me for the rather unconventional and\nimpossible example:</p>\n<p>You're working in the 80s at a shareware distributor. A lot of student\nprogrammers are working for you and writing new shareware apps and games\nevery month. You need to keep track of how many were sold. For that, you\nrecieve an XML file from accounting and you need to parse it and insert\nit into the database (isn't it awesome how in this version of the 80s\nthere's Swift to love but also XML to hate?). Your software system has\nan XML parser and a database (both written in 6502 ASM of course) that\nimplement the following protocols:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> XMLImportNode {\n\n     <span class=\"keyword\">func</span> firstChild(with tag: <span class=\"type\">String</span>) -&gt; <span class=\"type\">XMLImportNode</span>?\n\n     <span class=\"keyword\">func</span> children(with tag: <span class=\"type\">String</span>) -&gt; [<span class=\"type\">XMLImportNode</span>]\n\n     <span class=\"keyword\">func</span> attribute(with name: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span>?\n\n}\n\n\n\n<span class=\"keyword\">typealias</span> DatabaseUser = <span class=\"type\">String</span>\n\n<span class=\"keyword\">typealias</span> DatabaseSoftware = <span class=\"type\">String</span>\n\n<span class=\"keyword\">protocol</span> Database {\n\n     <span class=\"keyword\">func</span> user(for id: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">DatabaseUser</span>\n\n     <span class=\"keyword\">func</span> software(for id: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">DatabaseSoftware</span>\n\n     <span class=\"keyword\">func</span> insertSoftware(user: <span class=\"type\">DatabaseUser</span>, name: <span class=\"type\">String</span>, id: <span class=\"type\">String</span>, type: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n     <span class=\"keyword\">func</span> updateSoftware(software: <span class=\"type\">DatabaseSoftware</span>, amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n}\n</code></pre></code></pre>\n<p>A typical file looks like this (behold the almighty XML):</p>\n<pre class=\"XML\"><code><span class=\"techoutext techouxml\"><span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">users</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">user</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span><span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>158<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n  <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">software</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n   <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">package</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">type</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>game<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>Maniac Mansion<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>4332<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">amount</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>30<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n   <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">package</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">type</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>game<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>Doom<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>1337<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">amount</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>50<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n   <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">package</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">type</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>game<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>Warcraft 2<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>1000<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">amount</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>10<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n  <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">software</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">user</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">users</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n</span></code></pre></code></pre>\n<p>Our original Swift code to parse the XML looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> ParseError: <span class=\"type\">Error</span> {\n\n     <span class=\"keyword\">case</span> msg(<span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"keyword\">func</span> parseGamesFromXML(from root: <span class=\"type\">XMLImportNode</span>, into database: <span class=\"type\">Database</span>) <span class=\"keyword\">throws</span> {\n\n     <span class=\"keyword\">guard let</span> users = root.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"users</span>\\<span class=\"string\">\"</span>)?.<span class=\"call\">children</span>(with: \\<span class=\"string\">\"user</span>\\<span class=\"string\">\"</span>) <span class=\"keyword\">else</span> {\n\n         <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"No</span> <span class=\"type\">Users</span>\\<span class=\"string\">\"</span>)\n\n     }\n\n     <span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> users {\n\n         <span class=\"keyword\">guard let</span> software = user.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"software</span>\\<span class=\"string\">\"</span>)?\n\n                 .<span class=\"call\">children</span>(with: \\<span class=\"string\">\"package</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> userId = user.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> dbUser = <span class=\"keyword\">try</span>? database.<span class=\"call\">user</span>(for: userId)\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">User</span>\\<span class=\"string\">\"</span>) }\n\n         <span class=\"keyword\">for</span> package <span class=\"keyword\">in</span> software {\n\n             <span class=\"keyword\">guard let</span> type = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>),\n\n             type == \\<span class=\"string\">\"game</span>\\<span class=\"string\">\"</span>,\n\n             <span class=\"keyword\">let</span> name = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> softwareId = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> amountString = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"amount</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">Package</span>\\<span class=\"string\">\"</span>) }\n\n             <span class=\"keyword\">if let</span> existing = <span class=\"keyword\">try</span>? database.<span class=\"call\">software</span>(for: softwareId) {\n\n                 <span class=\"keyword\">try</span> database.<span class=\"call\">updateSoftware</span>(software: existing, \n\n                                               amount: <span class=\"type\">Int</span>(amountString) ?? <span class=\"number\">0</span>)\n\n             } <span class=\"keyword\">else</span> {\n\n                 <span class=\"keyword\">try</span> database.<span class=\"call\">insertSoftware</span>(user: dbUser, name: name, \n\n                                               id: softwareId, \n\n                                             type: type, \n\n                                           amount: <span class=\"type\">Int</span>(amountString) ?? <span class=\"number\">0</span>)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Lets apply what we learned above:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> parseGamesFromXML(from root: <span class=\"type\">XMLImportNode</span>, into database: <span class=\"type\">Database</span>) <span class=\"keyword\">throws</span> {\n\n     <span class=\"keyword\">for</span> user <span class=\"keyword\">in try</span> root.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"users</span>\\<span class=\"string\">\"</span>)\n\n                     .<span class=\"call\">or</span>(throw: <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"No</span> <span class=\"type\">Users</span>\\<span class=\"string\">\"</span>)).<span class=\"call\">children</span>(with: \\<span class=\"string\">\"user</span>\\<span class=\"string\">\"</span>) {\n\n         <span class=\"keyword\">let</span> dbUser = <span class=\"keyword\">try</span> user.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>)\n\n                     .<span class=\"call\">and</span>(then: { <span class=\"keyword\">try</span>? database.<span class=\"call\">user</span>(for: $0) })\n\n                     .<span class=\"call\">or</span>(throw: <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">User</span>\\<span class=\"string\">\"</span>))\n\n         <span class=\"keyword\">for</span> package <span class=\"keyword\">in</span> (user.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"software</span>\\<span class=\"string\">\"</span>)?\n\n                     .<span class=\"call\">children</span>(with: \\<span class=\"string\">\"package</span>\\<span class=\"string\">\"</span>)).<span class=\"call\">or</span>([]) {\n\n             <span class=\"keyword\">guard</span> (package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>)).<span class=\"call\">filter</span>({ $0 == \\<span class=\"string\">\"game</span>\\<span class=\"string\">\"</span> }).<span class=\"property\">isSome</span>\n\n                 <span class=\"keyword\">else</span> { <span class=\"keyword\">continue</span> }\n\n             <span class=\"keyword\">try</span> package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>)\n\n                 .<span class=\"call\">zip3</span>(with: package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>), \n\n                    another: package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"amount</span>\\<span class=\"string\">\"</span>))\n\n                 .<span class=\"call\">map</span>({ (tuple) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n                     <span class=\"keyword\">switch try</span>? database.<span class=\"call\">software</span>(for: tuple.<span class=\"number\">1</span>) {\n\n                     <span class=\"keyword\">case let</span> e?: <span class=\"keyword\">try</span> database.<span class=\"call\">updateSoftware</span>(software: e, \n\n                                                                amount: <span class=\"type\">Int</span>(tuple.<span class=\"number\">2</span>).<span class=\"call\">or</span>(<span class=\"number\">0</span>))\n\n                     <span class=\"keyword\">default</span>: <span class=\"keyword\">try</span> database.<span class=\"call\">insertSoftware</span>(user: dbUser, name: tuple.<span class=\"number\">0</span>, \n\n                                                            id: tuple.<span class=\"number\">1</span>, type: \\<span class=\"string\">\"game</span>\\<span class=\"string\">\"</span>, \n\n                                                        amount: <span class=\"type\">Int</span>(tuple.<span class=\"number\">2</span>).<span class=\"call\">or</span>(<span class=\"number\">0</span>))\n\n                     }\n\n                 }, or: { <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">Package</span>\\<span class=\"string\">\"</span>) })\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>If we look at this, then there're two things that immediately come to\nmind:</p>\n<ol>\n<li>Less Code</li>\n<li>More Complicated Looking Code</li>\n</ol>\n<p>I deliberately went into overdrive when utilizing the various <code>Optional</code>\nextensions. Some of them fit better while others seem to be a bit\nmisplaced. However, the key is not to solely rely on these extensions\n(like I did above) when using optionals but instead to mix and match\nwhere it makes most sense. Compare the two implementations and consider\nwhich from the second example you'd rather implement with Swift's\nnative features and which feel better when using the <code>Optional</code>\nextensions.</p>\n","raw_content":"[frontMatter]\ndescription = \"Several helpful extensions to the Optional type in order to simplify using it.\"\ntitle = \"Useful Optional Extensions\"\ncreated = \"2018-01-10\"\npublished = true\nkeywords = [\"swift\", \"protocol\", \"optional\", \"optionals\", \"extensions\"]\nslug = \"2018-01-10-optional-extensions.html\"\ntags = [\"optionals\", \"extension\"]\n\n[meta]\nswift_version = \"5.0\"\n---\n\n`Optionals` are a staple of Swift. I guess everybody will agree that\nthey are a huge boon insofar as they force us to properly handle edge\ncases. The `Optional` language feature alone removes a whole category of\nbugs from the development process.\n\nHowever, the API surface of Swift\\'s optional is rather limited. The\n[Swift documentation lists just a\ncouple](https://developer.apple.com/documentation/swift/optional#topics)\nof methods / properties on `Optional` - if we ignore `customMirror` and\n`debugDescription`:\n\n``` Swift\nvar unsafelyUnwrapped: Wrapped { get } \nfunc map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U? \nfunc flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U? \n```\n\nThe reason why optionals are still very useful even though they have\nsuch a small amount of methods is that the Swift syntax makes up for it\nvia features such as [optional\nchaining](lnk::optional),\n[pattern\nmatching](lnk::switch),\n`if let` or `guard let`. In some situations, though, this manifests\nitself in unnecessary line noise. Sometimes, a very succinct method will\nlet you express a concept in one short line of code instead of multiple\nlines of combined `if let` statements.\n\nI\\'ve sifted through Swift Projects on Github as well as the optional\nimplementations of other languages such as Rust, Scala, or C\\# in order\nto find a couple of useful additions to `Optional`. Below are 14 useful\n`Optional` extensions. I\\'ll describe them by category and then give a\ncouple of examples per category. Finally, I\\'ll write a more involved\nexample that uses several extensions at once.\n\n# Emptiness\n\n``` Swift\nextension Optional {\n    /// Returns true if the optional is empty\n    var isNone: Bool {\n        return self == .none\n    }\n\n    /// Returns true if the optional is not empty\n    var isSome: Bool {\n        return self != .none\n    }\n}\n```\n\nThose are the most basic additions to the optional type. The\nimplementation could also use a `switch` pattern match instead, but the\n`nil` comparison is much shorter. What I like about these additions is\nthat they move the concept of an empty optional being nil away from your\ncode. This might just as well be an implementation detail. Using\n`optional.isSome` feels much cleaner and less noisy than\n`if optional == nil`:\n\n``` Swift\n// Compare\nguard leftButton != nil, rightButton != nil else { fatalError(\"Missing Interface Builder connections\") }\n\n// With\nguard leftButton.isSome, rightButton.isSome else { fatalError(\"Missing Interface Builder connections\") }\n```\n\nOr\n==\n\n``` Swift\nextension Optional {\n    /// Return the value of the Optional or the `default` parameter\n    /// - param: The value to return if the optional is empty\n    func or(_ default: Wrapped) -> Wrapped {\n        return self ?? `default`\n    }\n\n    /// Returns the unwrapped value of the optional *or*\n    /// the result of an expression `else`\n    /// I.e. optional.or(else: print(\"Arrr\"))\n    func or(else: @autoclosure () -> Wrapped) -> Wrapped {\n        return self ?? `else`()\n    }\n\n    /// Returns the unwrapped value of the optional *or*\n    /// the result of calling the closure `else`\n    /// I.e. optional.or(else: { \n    /// ... do a lot of stuff\n    /// })\n    func or(else: () -> Wrapped) -> Wrapped {\n        return self ?? `else`()\n    }\n\n    /// Returns the unwrapped contents of the optional if it is not empty\n    /// If it is empty, throws exception `throw`\n    func or(throw exception: Error) throws -> Wrapped {\n        guard let unwrapped = self else { throw exception }\n        return unwrapped\n    }\n}\n\nextension Optional where Wrapped == Error {\n    /// Only perform `else` if the optional has a non-empty error value\n    func or(_ else: (Error) -> Void) {\n        guard let error = self else { return }\n        `else`(error)\n    }\n}\n```\n\nAnother abstraction on the `isNone / isSome` concept is being able to\nspecify instructions to be performed when the invariant doesn\\'t hold.\nThis saves us from having to write out `if` or `guard` branches and\ninstead codifies the logic into a simple-to-understand method.\n\nThis concept is so useful, that it is defined in three distinct\nfunctions.\n\n## Default Value\n\nThe first one returns the wrapped value of the optional or a default\nvalue:\n\n``` Swift\nlet optional: Int? = nil\nprint(optional.or(10)) // Prints 10\n```\n\n## Default Closure\n\nThe second one is very similar to the first one, however it allows to\nreturn a default value from a closure instead.\n\n``` Swift\nlet optional: Int? = nil\noptional.or(else: secretValue * 32) \n```\n\nSince this uses the `@autoclosure` parameter we could actually use just\nthe second `or` implementation. Then, using a just a default value would\nautomatically be converted into a closure returning the value. However,\nI prefer having two separate implementations as that allows users to\nalso write closures with more complex logic.\n\n``` Swift\nlet cachedUserCount: Int? = nil\n...\nreturn cachedUserCount.or(else: {\n   let db = database()\n   db.prefetch()\n   guard db.failures.isEmpty else { return 0 }\n   return db.amountOfUsers\n})\n```\n\nA really nice use case for `or` is code where you only want to set a\nvalue on an optional if it is empty:\n\n``` Swift\nif databaseController == nil {\n  databaseController = DatabaseController(config: config)\n}\n```\n\nThis can be replaced with the much nicer:\n\n``` Swift\ndatabaseController = databaseController.or(DatabaseController(config: config)\n```\n\n## Throw an error\n\nThis is a very useful addition as it allows to merge the chasm between\nOptionals and Error Handling in Swift. Depending on the code that\nyou\\'re using, a method or function may express invalid behaviour by\nreturning an empty optional (imagine accessing a non-existing key in a\n`Dictionary`) or by throwing an `Error`. Combining these two oftentimes\nleads to a lot of unnecessary line noise:\n\n``` Swift\nfunc buildCar() throws -> Car {\n  let tires = try machine1.createTires()\n  let windows = try machine2.createWindows()\n  guard let motor = externalMachine.deliverMotor() else {\n    throw MachineError.motor\n  }\n  let trunk = try machine3.createTrunk()\n  if let car = manufacturer.buildCar(tires, windows,  motor, trunk) {\n    return car\n  } else {\n    throw MachineError.manufacturer\n  }\n}\n```\n\nIn this example, we\\'re building a car by combining internal and\nexternal code. The external code (`external_machine` and `manufacturer`)\nchoose to use optionals instead of error handling. This makes the code\nunnecessary complicated. Our `or(throw:)` function makes this much more\nreadable:\n\n``` Swift\nfunc build_car() throws -> Car {\n  let tires = try machine1.createTires()\n  let windows = try machine2.createWindows()\n  let motor = try externalMachine.deliverMotor().or(throw: MachineError.motor)\n  let trunk = try machine3.createTrunk()\n  return try manufacturer.buildCar(tires, windows,  motor, trunk).or(throw: MachineError.manufacturer)\n}\n```\n\n## Handling Errors\n\nThe code from the **Throw an error** section above becomes even more\nuseful when you include the following free function that was proposed by\n[Stijn Willems on Github](https://github.com/doozMen). Thanks for the\nsuggestion!\n\n``` Swift\nfunc should(_ do: () throws -> Void) -> Error? {\n    do {\n        try `do`()\n        return nil\n    } catch let error {\n        return error\n    }\n}\n```\n\nThis free function (alternatively, you could make it a class method on\noptional) will perform a `do {} catch {}` block and return an error if\nand only if the closure \\`do\\` resulted in an error. Take, the following\nSwift code as an example:\n\n``` Swift\ndo {\n  try throwingFunction()\n} catch let error {\n  print(error)\n}\n```\n\nThis is one of the basic tennets of error handling in Swift, and it\nintroduces quite a lot of line noise. With the free function above, you\ncan reduce it to this simple on-liner:\n\n``` Swift\nshould { try throwingFunction) }.or(print($0))\n```\n\nI feel that there\\'re many situations where such a one-liner for error\nhandling would be very beneficient.\n\n## Map\n\nAs we saw above, `map` and `flatMap` are the only methods that Swift\noffers on Optionals. However, even those can be improved a bit to be\nmore versatile in many situations. There\\'re two additional variations\non `map` that allow defining a default value similar to how the `or`\nvariants above are implemented:\n\n``` Swift\nextension Optional {\n    /// Maps the output *or* returns the default value if the optional is nil\n    /// - parameter fn: The function to map over the value\n    /// - parameter or: The value to use if the optional is empty\n    func map<T>(_ fn: (Wrapped) throws -> T, default: T) rethrows -> T {\n        return try map(fn) ?? `default`\n    }\n\n    /// Maps the output *or* returns the result of calling `else`\n    /// - parameter fn: The function to map over the value\n    /// - parameter else: The function to call if the optional is empty\n    func map<T>(_ fn: (Wrapped) throws -> T, else: () throws -> T) rethrows -> T {\n        return try map(fn) ?? `else`()\n    }\n}\n```\n\nThe first one will allow you to `map` the contents of an optional to a\nnew type `T`. If the optional is empty, you can define a `default` value\nthat should be used instead:\n\n``` Swift\nlet optional1: String? = \"appventure\"\nlet optional2: String? = nil\n\n// Without\nprint(optional1.map({ $0.count }) ?? 0)\nprint(optional2.map({ $0.count }) ?? 0)\n\n// With \nprint(optional1.map({ $0.count }, default: 0)) // prints 10\nprint(optional2.map({ $0.count }, default: 0)) // prints 0\n```\n\nThe changes are minimal, but we\\'re moving away from having to use the\n`??` operator and can instead express the operation more clearly with\nthe `default` keyword.\n\nThe second variant is very similar. The main difference is that it\naccepts (again) a closure returning value `T` instead of value `T`.\nHere\\'s a brief example:\n\n``` Swift\nlet optional: String? = nil\nprint(optional.map({ $0.count }, else: { \"default\".count })\n```\n\n# Combining Optionals\n\nThis category contains four functions that allow you to define relations\nbetween multiple optionals.\n\n``` Swift\nextension Optional {\n    /// Tries to unwrap `self` and if that succeeds continues to unwrap the parameter `optional`\n    /// and returns the result of that.\n    func and<B>(_ optional: B?) -> B? {\n        guard self != nil else { return nil }\n        return optional\n    }\n\n    /// Executes a closure with the unwrapped result of an optional.\n    /// This allows chaining optionals together.\n    func and<T>(then: (Wrapped) throws -> T?) rethrows -> T? {\n        guard let unwrapped = self else { return nil }\n        return try then(unwrapped)\n    }\n\n    /// Zips the content of this optional with the content of another\n    /// optional `other` only if both optionals are not empty\n    func zip2<A>(with other: Optional<A>) -> (Wrapped, A)? {\n        guard let first = self, let second = other else { return nil }\n        return (first, second)\n    }\n\n    /// Zips the content of this optional with the content of another\n    /// optional `other` only if both optionals are not empty\n    func zip3<A, B>(with other: Optional<A>, another: Optional<B>) -> (Wrapped, A, B)? {\n        guard let first = self,\n              let second = other,\n              let third = another else { return nil }\n        return (first, second, third)\n    }\n}\n```\n\nThese four functions all share that they take an additional optional as\na parameter and return another optional value. However, they\\'re all\nquite different in what they achieve.\n\n## Dependencies\n\n`and<B>(_ optional)` is useful if the unpacking of an optional is only\nrequired as a invariant for unpacking another optional:\n\n``` Swift\n// Compare\nif user != nil, let account = userAccount() ...\n\n// With\nif let account = user.and(userAccount()) ...\n```\n\nIn the example above, we\\'re not interested in the unwrapped contents of\nthe `user` optional. We just need to make sure that there **is** a valid\nuser before we call the `userAccount` function. While this relationship\nis kinda codified in the `user != nil` line, I personally feel that the\n`and` makes it more clear.\n\n## Chaining\n\n`and<T>(then:)` is another very useful function. It allows to chain\noptionals together so that the output of unpacking optional `A` becomes\nthe input of producing optional `B`. Lets start with a simple example:\n\n``` Swift\nprotocol UserDatabase {\n  func current() -> User?\n  func spouse(of user: User) -> User?\n  func father(of user: User) -> User?\n  func childrenCount(of user: User) -> Int\n}\n\nlet database: UserDatabase = ...\n\n// Imagine we want to know the children of the following relationship:\n// Man -> Spouse -> Father -> Father -> Spouse -> children\n\n// Without\nlet childrenCount: Int\nif let user = database.current(), \n   let father1 = database.father(user),\n   let father2 = database.father(father1),\n   let spouse = database.spouse(father2),\n   let children = database.childrenCount(father2) {\n  childrenCount = children\n} else {\n  childrenCount = 0\n}\n\n// With\nlet children = database.current().and(then: { database.spouse($0) })\n     .and(then: { database.father($0) })\n     .and(then: { database.spouse($0) })\n     .and(then: { database.childrenCount($0) })\n     .or(0)\n```\n\nThere\\'re a lot of improvements when using the version with `and(then)`.\nFirst of all, you don\\'t have to come up with superfluous temporary\nvariable names (user, father1, father2, spouse, children). Second, we\nclearly have less code. Also, using the `or(0)` instead of a complicated\n`let childrenCount` is so much easier to read.\n\nFinally, the original Swift example can easily lead to logic errors. You\nmay not have noticed, but there\\'s a bug in the example. When writing\nlines like that, copy paste errors can easily be introduced. Do you see\nthe error?\n\nYeah, the `children` property should be created by calling\n`database.childrenCount(spouse)` but I wrote\n`database.childrenCount(father2)` instead. It is difficult to spot\nerrors like that. The `and(then:)` example makes it much easier because\nit always relies on the same variable name `$0`.\n\n## Zipping\n\nThis is another variation on an existing Swift concept. The `zip` method\non optional will allow us to combine multiple optionals and unwrap them\ntogether or not at all. I\\'ve just provided implementations for `zip2`\nand `zip3` but nothing prevents you from going up to `zip22` (Well,\nmaybe sanity and compiler speed).\n\n``` Swift\n// Lets start again with a normal Swift example\nfunc buildProduct() -> Product? {\n  if let var1 = machine1.makeSomething(),\n    let var2 = machine2.makeAnotherThing(),\n    let var3 = machine3.createThing() {\n    return finalMachine.produce(var1, var2, var3)\n  } else {\n    return nil\n  }\n}\n\n// The alternative using our extensions\nfunc buildProduct() -> Product? {\n  return machine1.makeSomething()\n     .zip3(machine2.makeAnotherThing(), machine3.createThing())\n     .map { finalMachine.produce($0.1, $0.2, $0.3) }\n}\n```\n\nLess code, clearer code, more beautiful code. However, as a downside,\nthis code is also more involved. The reader has to know and understand\n`zip` in order to easily grasp it.\n\nOn\n--\n\n``` Swift\nextension Optional {\n    /// Executes the closure `some` if and only if the optional has a value\n    func on(some: () throws -> Void) rethrows {\n        if self != nil { try some() }\n    }\n\n    /// Executes the closure `none` if and only if the optional has no value\n    func on(none: () throws -> Void) rethrows {\n        if self == nil { try none() }\n    }\n}\n```\n\nThese two short methods will allow you to perform side effects if an\noptional is empty or not. In contrast to the already discussed methods,\nthese ignore the contents of the optional. So `on(some:)` will only\nexecute the closure `some` if the optional is not empty but the closure\n`some` will not get the unwrapped contents of the optional.\n\n``` Swift\n/// Logout if there is no user anymore\nself.user.on(none: { AppCoordinator.shared.logout() })\n\n/// self.user is not empty when we are connected to the network\nself.user.on(some: { AppCoordinator.shared.unlock() })\n```\n\n## Various\n\n``` Swift\nextension Optional {\n    /// Returns the unwrapped value of the optional only if\n    /// - The optional has a value\n    /// - The value satisfies the predicate `predicate`\n    func filter(_ predicate: (Wrapped) -> Bool) -> Wrapped? {\n        guard let unwrapped = self,\n            predicate(unwrapped) else { return nil }\n        return self\n    }\n\n    /// Returns the wrapped value or crashes with `fatalError(message)`\n    func expect(_ message: String) -> Wrapped {\n        guard let value = self else { fatalError(message) }\n        return value\n    }\n}\n```\n\n### Filter\n\nThis is a simple method which works like an additional guard to only\nunwrap the optional if it satisfies a predictate. Here\\'s an example.\nImagine we want to upgrade all our old users to a premium account for\nsticking with us for a long time:\n\n``` Swift\n// Only affect old users with id < 1000\n// Normal Swift\nif let aUser = user, user.id < 1000 { aUser.upgradeToPremium() }\n\n// Using `filter`\nuser.filter({ $0.id < 1000 })?.upgradeToPremium()\n```\n\nHere, `user.filter` feels like a much more natural implementation. Also,\nit only implements what already exists for Swift\\'s collections.\n\n### Expect\n\nThis is one of my favorites. Also, I shamelessly stole it from Rust.\nI\\'m trying very hard to never force unwrap anything in my codebase.\nSimilar for implicitly unwrapped optionals.\n\nHowever, this is tricky when working with interface builder outlets. A\ncommon pattern that I observed can be seen in the following function:\n\n``` Swift\nfunc updateLabel() {\n  guard let label = valueLabel else {\n    fatalError(\"valueLabel not connected in IB\")\n  }\n  label.text = state.title\n}\n```\n\nThe alternative solution, obviously, would be to just to force unwrap\nthe label, as that leads to a crash just like `fatalError`. Then, I\\'d\nhave to insert `!` though, also it wouldn\\'t give me a nice succinct\ndescription of what actually is wrong. The better alternative here is to\nuse `expect` as implemented above:\n\n``` Swift\nfunc updateLabel() {\n  valueLabel.expect(\"valueLabel not connected in IB\").text = state.title\n}\n```\n\n# Example\n\nSo now that we\\'ve seen a couple of (hopefully) useful `Optional`\nextensions, I\\'ll set up an example to better see how some of these\nextensions can be combined to simplify optional handling. First, we need\na bit of context. Forgive me for the rather unconventional and\nimpossible example:\n\nYou\\'re working in the 80s at a shareware distributor. A lot of student\nprogrammers are working for you and writing new shareware apps and games\nevery month. You need to keep track of how many were sold. For that, you\nrecieve an XML file from accounting and you need to parse it and insert\nit into the database (isn\\'t it awesome how in this version of the 80s\nthere\\'s Swift to love but also XML to hate?). Your software system has\nan XML parser and a database (both written in 6502 ASM of course) that\nimplement the following protocols:\n\n``` Swift\nprotocol XMLImportNode {\n    func firstChild(with tag: String) -> XMLImportNode?\n    func children(with tag: String) -> [XMLImportNode]\n    func attribute(with name: String) -> String?\n}\n\ntypealias DatabaseUser = String\ntypealias DatabaseSoftware = String\nprotocol Database {\n    func user(for id: String) throws -> DatabaseUser\n    func software(for id: String) throws -> DatabaseSoftware\n    func insertSoftware(user: DatabaseUser, name: String, id: String, type: String, amount: Int) throws\n    func updateSoftware(software: DatabaseSoftware, amount: Int) throws\n}\n```\n\nA typical file looks like this (behold the almighty XML):\n\n``` XML\n<users>\n <user name=\"\" id=\"158\">\n  <software>\n   <package type=\"game\" name=\"Maniac Mansion\" id=\"4332\" amount=\"30\" />\n   <package type=\"game\" name=\"Doom\" id=\"1337\" amount=\"50\" />\n   <package type=\"game\" name=\"Warcraft 2\" id=\"1000\" amount=\"10\" />\n  </software>\n </user>\n</users>\n```\n\nOur original Swift code to parse the XML looks like this:\n\n``` Swift\nenum ParseError: Error {\n    case msg(String)\n}\n\nfunc parseGamesFromXML(from root: XMLImportNode, into database: Database) throws {\n    guard let users = root.firstChild(with: \"users\")?.children(with: \"user\") else {\n        throw ParseError.msg(\"No Users\")\n    }\n    for user in users {\n        guard let software = user.firstChild(with: \"software\")?\n                .children(with: \"package\"),\n            let userId = user.attribute(with: \"id\"),\n            let dbUser = try? database.user(for: userId)\n            else { throw ParseError.msg(\"Invalid User\") }\n        for package in software {\n            guard let type = package.attribute(with: \"type\"),\n            type == \"game\",\n            let name = package.attribute(with: \"name\"),\n            let softwareId = package.attribute(with: \"id\"),\n            let amountString = package.attribute(with: \"amount\")\n            else { throw ParseError.msg(\"Invalid Package\") }\n            if let existing = try? database.software(for: softwareId) {\n                try database.updateSoftware(software: existing, \n                                              amount: Int(amountString) ?? 0)\n            } else {\n                try database.insertSoftware(user: dbUser, name: name, \n                                              id: softwareId, \n                                            type: type, \n                                          amount: Int(amountString) ?? 0)\n            }\n        }\n    }\n}\n```\n\nLets apply what we learned above:\n\n``` Swift\nfunc parseGamesFromXML(from root: XMLImportNode, into database: Database) throws {\n    for user in try root.firstChild(with: \"users\")\n                    .or(throw: ParseError.msg(\"No Users\")).children(with: \"user\") {\n        let dbUser = try user.attribute(with: \"id\")\n                    .and(then: { try? database.user(for: $0) })\n                    .or(throw: ParseError.msg(\"Invalid User\"))\n        for package in (user.firstChild(with: \"software\")?\n                    .children(with: \"package\")).or([]) {\n            guard (package.attribute(with: \"type\")).filter({ $0 == \"game\" }).isSome\n                else { continue }\n            try package.attribute(with: \"name\")\n                .zip3(with: package.attribute(with: \"id\"), \n                   another: package.attribute(with: \"amount\"))\n                .map({ (tuple) -> Void in\n                    switch try? database.software(for: tuple.1) {\n                    case let e?: try database.updateSoftware(software: e, \n                                                               amount: Int(tuple.2).or(0))\n                    default: try database.insertSoftware(user: dbUser, name: tuple.0, \n                                                           id: tuple.1, type: \"game\", \n                                                       amount: Int(tuple.2).or(0))\n                    }\n                }, or: { throw ParseError.msg(\"Invalid Package\") })\n        }\n    }\n}\n```\n\nIf we look at this, then there\\'re two things that immediately come to\nmind:\n\n1.  Less Code\n2.  More Complicated Looking Code\n\nI deliberately went into overdrive when utilizing the various `Optional`\nextensions. Some of them fit better while others seem to be a bit\nmisplaced. However, the key is not to solely rely on these extensions\n(like I did above) when using optionals but instead to mix and match\nwhere it makes most sense. Compare the two implementations and consider\nwhich from the second example you\\'d rather implement with Swift\\'s\nnative features and which feel better when using the `Optional`\nextensions.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/intro.md":["3aecd01283b41a23",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Catalyst Guide Introduction","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-catalyst-guide-introduction.html","content":"<p>Catalyst is one of the major new features of iOS 13 and macOS 15. It allows you to take your iPad app, and, with the activation of a single checkbox, add a macOS target.</p>\n<p><img src=\"/img-content/catalyst/catalyst_checkbox.png\" alt=\"\" /></p>\n<p>For very simple projects, this works great, but there are multiple issues that might run in to. Here is a brief selection:</p>\n<ul>\n<li>Deprecated iOS classes, such as <code>AddressBookUI</code> or <code>UIWebView</code> are not supported anymore</li>\n<li>Some iOS classes, such as ARKit are not available on macOS</li>\n<li>Some iOS classes, such as StoreKit, have slightly different API</li>\n<li>The macOS API integrations such as <code>NSToolBar</code> or <code>NSMenuBar</code> are currently quite limited</li>\n<li>Problems with signing</li>\n</ul>\n<p>This guide is a very detailed developer explanation of Catalyst and all the issues that you can run into in the current beta. It will be updated as new macOS betas are released.</p>\n<h2>Contents of this Guide</h2>\n<p>This guide will initially <a href=\"rel::intro.md\">give a short introduction into Catalyst</a> Next, <a href=\"rel::firststeps/intro.md\">we will iterate over the first steps to support the various features that make an iPad app a good macOS citizen</a>. Finally, we will <a href=\"rel::how/intro.md\">go through a long <em>How Do I ...</em> list</a> of not-so-obvious things you might run into while working on Catalyst. As a sort of Appendix, <a href=\"rel::issues/issues.md\">we have a list of currently known issues</a> you might run into. This is helpful to keep you from trying to hunt down a bug that's not yours.</p>\n","raw_content":"[frontMatter]\ntitle = \"Catalyst Guide Introduction\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nCatalyst is one of the major new features of iOS 13 and macOS 15. It allows you to take your iPad app, and, with the activation of a single checkbox, add a macOS target.\n\n![](/img-content/catalyst/catalyst_checkbox.png)\n\nFor very simple projects, this works great, but there are multiple issues that might run in to. Here is a brief selection:\n\n\n- Deprecated iOS classes, such as `AddressBookUI` or `UIWebView` are not supported anymore\n- Some iOS classes, such as ARKit are not available on macOS\n- Some iOS classes, such as StoreKit, have slightly different API\n- The macOS API integrations such as `NSToolBar` or `NSMenuBar` are currently quite limited\n- Problems with signing\n\nThis guide is a very detailed developer explanation of Catalyst and all the issues that you can run into in the current beta. It will be updated as new macOS betas are released.\n\n## Contents of this Guide\n\nThis guide will initially [give a short introduction into Catalyst](rel::intro.md) Next, [we will iterate over the first steps to support the various features that make an iPad app a good macOS citizen](rel::firststeps/intro.md). Finally, we will [go through a long *How Do I ...* list](rel::how/intro.md) of not-so-obvious things you might run into while working on Catalyst. As a sort of Appendix, [we have a list of currently known issues](rel::issues/issues.md) you might run into. This is helpful to keep you from trying to hunt down a bug that's not yours.\n\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/anykeypath.md":["a31642ca7901339a",{"identifier":"52b77ca9","filename":"anykeypath.md","info":{"title":"AnyKeyPath","tags":["keypath","anykeypath","root","type-erase","erase"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-anykeypath.html","content":"<h1>AnyKeyPath</h1>\n<p>The last <code>KeyPath</code> type that we have to tackle is the <code>AnyKeyPath</code>. It doesn't have a type-parameter for either <code>Root</code> or <code>Value</code> as it is completely type-erased. If you read the chapter to <code>PartialKeyPath</code>, you will easily grep this one as well. This type is really useful once you intend to write code that just stores general keypaths from differently typed objects. Here is a small bit of example code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPaths: [<span class=\"type\">AnyKeyPath</span>] = [\n\n   \\<span class=\"type\">User</span>.<span class=\"property\">username</span>,\n\n   \\<span class=\"type\">String</span>.<span class=\"property\">count</span>,\n\n   \\<span class=\"type\">Presentation</span>.<span class=\"property\">title</span>\n\n]\n</code></pre></code></pre>\n<p>We will see more (and better!) usecases for this type later on in this guide, however here is a very simple example of where it could be useful.</p>\n<p>You're writing a game and you have different entities / types: Animals, Monsters, Players, and Objects. Each of them have a <code>health</code> property (even objects. If you hit a tree long enough, it will break). You need an easy way to debug the health of all entities that are currently on screen. You can just collect them into an array of <code>AnyKeyPath</code> and print them out:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> observeHealth(entity: <span class=\"type\">Any</span>, <span class=\"keyword\">_</span> keypath: <span class=\"type\">AnyKeyPath</span>) { ... }\n\n<span class=\"call\">observeHealth</span>(entity: monster1, \\<span class=\"type\">Dragon</span>.<span class=\"property\">health</span>)\n\n<span class=\"call\">observeHealth</span>(entity: stone255, \\<span class=\"type\">Stone</span>.<span class=\"property\">integrity</span>)\n\n<span class=\"call\">observeHealth</span>(entity: player2, \\<span class=\"type\">Player</span>.<span class=\"property\">health</span>)\n</code></pre></code></pre>\n<p>This tackles the last one of our keypaths. You might have wondered though, what good are those type-erased keypaths given that you can't modify properties. After all they're all read-only! Not necessarily, because Swift allows you to type-cast them at runtime.</p>\n","raw_content":"[frontMatter]\ntitle = \"AnyKeyPath\"\ntags = [\"keypath\", \"anykeypath\", \"root\", \"type-erase\", \"erase\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# AnyKeyPath\n\nThe last `KeyPath` type that we have to tackle is the `AnyKeyPath`. It doesn't have a type-parameter for either `Root` or `Value` as it is completely type-erased. If you read the chapter to `PartialKeyPath`, you will easily grep this one as well. This type is really useful once you intend to write code that just stores general keypaths from differently typed objects. Here is a small bit of example code:\n\n``` Swift\nlet keyPaths: [AnyKeyPath] = [\n  \\User.username,\n  \\String.count,\n  \\Presentation.title\n]\n```\n\nWe will see more (and better!) usecases for this type later on in this guide, however here is a very simple example of where it could be useful.\n\nYou're writing a game and you have different entities / types: Animals, Monsters, Players, and Objects. Each of them have a `health` property (even objects. If you hit a tree long enough, it will break). You need an easy way to debug the health of all entities that are currently on screen. You can just collect them into an array of `AnyKeyPath` and print them out:\n\n``` Swift\nfunc observeHealth(entity: Any, _ keypath: AnyKeyPath) { ... }\nobserveHealth(entity: monster1, \\Dragon.health)\nobserveHealth(entity: stone255, \\Stone.integrity)\nobserveHealth(entity: player2, \\Player.health)\n```\n\nThis tackles the last one of our keypaths. You might have wondered though, what good are those type-erased keypaths given that you can't modify properties. After all they're all read-only! Not necessarily, because Swift allows you to type-cast them at runtime.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/custom_mirrors/collections.md":["f749d8631ef4dfe0",{"identifier":"4800086a","filename":"collections.md","info":{"title":"Collections","tags":["reflection"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-collections.html","content":"<h1>Collections</h1>\n<p>In order to</p>\n<p>The first special <code>init</code> is tailor-made for collections:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>&lt;Subject, C&gt;(<span class=\"keyword\">_</span> subject: <span class=\"type\">Subject</span>, children: <span class=\"type\">C</span>, displayStyle: <span class=\"type\">Mirror</span>.<span class=\"type\">DisplayStyle</span>? = <span class=\"keyword\">nil</span>, ancestorRepresentation: <span class=\"type\">Mirror</span>.<span class=\"type\">AncestorRepresentation</span> = .<span class=\"dotAccess\">generated</span>) <span class=\"keyword\">where</span> <span class=\"type\">C</span> : <span class=\"type\">Collection</span>, <span class=\"type\">C</span>.<span class=\"type\">Element</span> == <span class=\"type\">Mirror</span>.<span class=\"type\">Child</span>\n</code></pre></code></pre>\n<p>Compared to the <code>init(reflecting:)</code> initializer above, this one allows\nus to define much more details about the reflection process.</p>\n<ul>\n<li>It only works for collections</li>\n<li>We can set the subject to be reflected <strong>and</strong> the children of the\nsubject (the collection contents)</li>\n</ul>\n","raw_content":"[frontMatter]\ntitle = \"Collections\"\ntags = [\"reflection\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Collections\n\nIn order to \n\nThe first special `init` is tailor-made for collections:\n\n``` Swift\ninit<Subject, C>(_ subject: Subject, children: C, displayStyle: Mirror.DisplayStyle? = nil, ancestorRepresentation: Mirror.AncestorRepresentation = .generated) where C : Collection, C.Element == Mirror.Child\n```\n\nCompared to the `init(reflecting:)` initializer above, this one allows\nus to define much more details about the reflection process.\n\n-   It only works for collections\n-   We can set the subject to be reflected **and** the children of the\n    subject (the collection contents)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/conclusion.md":["e8f317aab6d0aab1",{"identifier":"c97953ae","filename":"conclusion.md","info":{"title":"Conclusion","tags":["keypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-conclusion.html","content":"<h1>Conclusion</h1>\n<p>We've seen how the Swift <code>KeyPath</code> type can be used to define abstractions that would otherwise not be possible with just protocols or generics. As with everything in Swift, the beauty is how you can combine the different patterns, be it <code>KeyPath</code>, or <code>protocol</code>, or <code>generics</code> and use them to solve problems in new and exciting kind of ways. With each release, Swift introduces more and better features that help us do this. KeyPaths are one of those nice additions that simplify development in many ways.</p>\n","raw_content":"[frontMatter]\ntitle = \"Conclusion\"\ntags = [\"keypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Conclusion\n\nWe've seen how the Swift `KeyPath` type can be used to define abstractions that would otherwise not be possible with just protocols or generics. As with everything in Swift, the beauty is how you can combine the different patterns, be it `KeyPath`, or `protocol`, or `generics` and use them to solve problems in new and exciting kind of ways. With each release, Swift introduces more and better features that help us do this. KeyPaths are one of those nice additions that simplify development in many ways.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/diving_in/enum_values.md":["86b013b8024b408f",{"identifier":"b67b05f5","filename":"enum_values.md","info":{"title":"Enum values","tags":["enum"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-enum-values.html","content":"<h1>Enum values</h1>\n<p>Sometimes may want to have a value assigned to each <code>enum</code> case.\nThis is useful if the <code>enum</code> itself indeed relates to something which\ncan be expressed in a different type. <strong>C</strong> allows you to assign numbers\nto <code>enum cases</code>. Swift gives you much more flexibility here:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// A pretty useless enum</span>\n\n<span class=\"keyword\">enum</span> Binary {\n\n   <span class=\"keyword\">case</span> zero = <span class=\"number\">0</span>\n\n   <span class=\"keyword\">case</span> one = <span class=\"number\">1</span>\n\n}\n\n\n\n<span class=\"comment\">// You can also map to strings</span>\n\n<span class=\"keyword\">enum</span> House: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">case</span> baratheon = \\<span class=\"string\">\"Ours</span> <span class=\"keyword\">is</span> the <span class=\"type\">Fury</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> greyjoy = \\<span class=\"string\">\"We</span> <span class=\"type\">Do Not Sow</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> martell = \\<span class=\"string\">\"Unbowed</span>, <span class=\"type\">Unbent</span>, <span class=\"type\">Unbroken</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> stark = \\<span class=\"string\">\"Winter</span> <span class=\"keyword\">is</span> <span class=\"type\">Coming</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> tully = \\<span class=\"string\">\"Family</span>, <span class=\"type\">Duty</span>, <span class=\"type\">Honor</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> tyrell = \\<span class=\"string\">\"Growing</span> <span class=\"type\">Strong</span>\\<span class=\"string\">\"</span>\n\n}\n\n\n\n<span class=\"comment\">// Or to floating point (also note the fancy unicode in enum cases)</span>\n\n<span class=\"keyword\">enum</span> Constants: <span class=\"type\">Double</span> {\n\n     <span class=\"keyword\">case</span> π = <span class=\"number\">3.14159</span>\n\n     <span class=\"keyword\">case</span> e = <span class=\"number\">2.71828</span>\n\n     <span class=\"keyword\">case</span> φ = <span class=\"number\">1.61803398874</span>\n\n     <span class=\"keyword\">case</span> λ = <span class=\"number\">1.30357</span>\n\n}\n</code></pre></code></pre>\n<p>For <code>String</code> and <code>Int</code> types, you can even omit the values and the Swift\ncompiler will do the right thing:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// mercury = 1, venus = 2, ... neptune = 8</span>\n\n<span class=\"keyword\">enum</span> Planet: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">case</span> mercury = <span class=\"number\">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune\n\n}\n\n\n\n<span class=\"comment\">// north = \\\"north\\\", ... west = \\\"west\\\"</span>\n\n<span class=\"keyword\">enum</span> CompassPoint: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">case</span> north, south, east, west\n\n}\n</code></pre></code></pre>\n<p>Swift supports the following types for the value of an enum:</p>\n<ul>\n<li>Integer</li>\n<li>Floating Point</li>\n<li>String</li>\n<li>Boolean</li>\n</ul>\n<p>You can support more types <a href=\"lnk::enum-custom-data-types\">by implementing a specific protocol</a>.</p>\n<p>If you want to access the values, you can do so with the <code>rawValue</code>\nproperty:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> bestHouse = <span class=\"type\">House</span>.<span class=\"property\">stark</span>\n\n<span class=\"call\">print</span>(bestHouse.<span class=\"property\">rawValue</span>)\n\n<span class=\"comment\">// prints \\\"Winter is coming\\\"</span>\n</code></pre></code></pre>\n<p>However, there may also be a situation where you want to construct an\n<code>enum case</code> from an existing raw value. In that case, there's a special\ninitializer for enums:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Movement: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">case</span> left = <span class=\"number\">0</span>\n\n     <span class=\"keyword\">case</span> right = <span class=\"number\">1</span>\n\n     <span class=\"keyword\">case</span> top = <span class=\"number\">2</span>\n\n     <span class=\"keyword\">case</span> bottom = <span class=\"number\">3</span>\n\n}\n\n<span class=\"comment\">// creates a movement.Right case, as the raw value for that is 1</span>\n\n<span class=\"keyword\">let</span> rightMovement = <span class=\"type\">Movement</span>(rawValue: <span class=\"number\">1</span>)\n</code></pre></code></pre>\n<p>If you use the <code>rawValue</code> initializer, keep in mind that it is a\n<a href=\"lnk::failable-initializer\">failable\ninitializer</a>,\ni.e. you get back an\n<a href=\"lnk::optional\">Optional</a>,\nas the value you're using may not map to any case at all, say if you\nwere to write <code>Movement(rawValue: 42)</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Enum values\"\ntags = [\"enum\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Enum values\n\nSometimes may want to have a value assigned to each `enum` case.\nThis is useful if the `enum` itself indeed relates to something which\ncan be expressed in a different type. **C** allows you to assign numbers\nto `enum cases`. Swift gives you much more flexibility here:\n\n``` Swift\n// A pretty useless enum\nenum Binary {\n  case zero = 0\n  case one = 1\n}\n\n// You can also map to strings\nenum House: String {\n    case baratheon = \"Ours is the Fury\"\n    case greyjoy = \"We Do Not Sow\"\n    case martell = \"Unbowed, Unbent, Unbroken\"\n    case stark = \"Winter is Coming\"\n    case tully = \"Family, Duty, Honor\"\n    case tyrell = \"Growing Strong\"\n}\n\n// Or to floating point (also note the fancy unicode in enum cases)\nenum Constants: Double {\n    case π = 3.14159\n    case e = 2.71828\n    case φ = 1.61803398874\n    case λ = 1.30357\n}\n```\n\nFor `String` and `Int` types, you can even omit the values and the Swift\ncompiler will do the right thing:\n\n``` Swift\n// mercury = 1, venus = 2, ... neptune = 8\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n\n// north = \"north\", ... west = \"west\"\nenum CompassPoint: String {\n    case north, south, east, west\n}\n```\n\nSwift supports the following types for the value of an enum:\n\n-   Integer\n-   Floating Point\n-   String\n-   Boolean\n\nYou can support more types [by implementing a specific protocol](lnk::enum-custom-data-types).\n\nIf you want to access the values, you can do so with the `rawValue`\nproperty:\n\n``` Swift\nlet bestHouse = House.stark\nprint(bestHouse.rawValue)\n// prints \"Winter is coming\"\n```\n\nHowever, there may also be a situation where you want to construct an\n`enum case` from an existing raw value. In that case, there\\'s a special\ninitializer for enums:\n\n``` Swift\nenum Movement: Int {\n    case left = 0\n    case right = 1\n    case top = 2\n    case bottom = 3\n}\n// creates a movement.Right case, as the raw value for that is 1\nlet rightMovement = Movement(rawValue: 1)\n```\n\nIf you use the `rawValue` initializer, keep in mind that it is a\n[failable\ninitializer](lnk::failable-initializer),\ni.e. you get back an\n[Optional](lnk::optional),\nas the value you\\'re using may not map to any case at all, say if you\nwere to write `Movement(rawValue: 42)`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/fallthrough_break_labels.md":["000ea7651b62fc37",{"identifier":"6bcb4f70","filename":"fallthrough_break_labels.md","info":{"title":"Fallthrough, Break and Labels","tags":["pattern matching","switch","fallthrough","break","label"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-fallthrough-break-and-labels.html","content":"<h1>Fallthrough, Break and Labels</h1>\n<p>The following is not directly related to pattern matching but only\naffects the <code>switch</code> keyword, so I'll keep it brief. By default, and\nunlike C/C++/Objective-C, <code>switch</code> <code>cases</code> do not fall through into the\nnext case which is why in Swift, you don't need to write <code>break</code> for\nevery case. If you never used <code>Objective-C</code> or <code>C</code> and this confuses you,\nhere's a short example that would print &quot;1, 2, 3&quot;:</p>\n<pre class=\"C\"><code><span class=\"techousource techouc\"><span class=\"techoucomment techoublock techouc\"><span class=\"techoupunctuation techoudefinition techoucomment techouc\">/*</span> This is C Code <span class=\"techoupunctuation techoudefinition techoucomment techouc\">*/</span></span>\n<span class=\"techoukeyword techoucontrol techouc\">switch</span> <span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span><span class=\"techouconstant techounumeric techouc\">2</span><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span> <span class=\"techoumeta techoublock techouc\"><span class=\"techoupunctuation techousection techoublock techoubegin techouc\">{</span>\n<span class=\"techoukeyword techoucontrol techouc\">case</span> <span class=\"techouconstant techounumeric techouc\">1</span><span class=\"techoupunctuation techouseparator techouc\">:</span> <span class=\"techoumeta techoufunction-call techouc\"><span class=\"techousupport techoufunction techouC99 techouc\">printf</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoustring techouquoted techoudouble techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&quot;</span>1<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&quot;</span></span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n<span class=\"techoukeyword techoucontrol techouc\">case</span> <span class=\"techouconstant techounumeric techouc\">2</span><span class=\"techoupunctuation techouseparator techouc\">:</span> <span class=\"techoumeta techoufunction-call techouc\"><span class=\"techousupport techoufunction techouC99 techouc\">printf</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoustring techouquoted techoudouble techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&quot;</span>2<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&quot;</span></span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n<span class=\"techoukeyword techoucontrol techouc\">case</span> <span class=\"techouconstant techounumeric techouc\">3</span><span class=\"techoupunctuation techouseparator techouc\">:</span> <span class=\"techoumeta techoufunction-call techouc\"><span class=\"techousupport techoufunction techouC99 techouc\">printf</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoustring techouquoted techoudouble techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&quot;</span>3<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&quot;</span></span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n<span class=\"techoupunctuation techousection techoublock techouend techouc\">}</span></span>\n</span></code></pre></code></pre>\n<p>You would need to use  <code>case 1: printf(&quot;1&quot;); break;</code> in order to not\nautomatically fall through into the next case.</p>\n<h2>Fallthrough</h2>\n<p>In Swift, it is the other way around. If you actually want to\nfall through into the other case, you can opt into this behaviour with the\n<code>fallthrough</code> keyword.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> <span class=\"number\">5</span> {\n\n<span class=\"keyword\">case</span> <span class=\"number\">5</span>:\n\n  <span class=\"call\">print</span>(\\<span class=\"string\">\"Is</span> <span class=\"number\">5</span>\\<span class=\"string\">\"</span>)\n\n  <span class=\"keyword\">fallthrough</span>\n\n<span class=\"keyword\">default</span>:\n\n  <span class=\"call\">print</span>(\\<span class=\"string\">\"Is</span> a number\\<span class=\"string\">\"</span>)\n\n}\n\n<span class=\"comment\">// Will print: \\\"Is 5\\\" \\\"Is a number\\\"</span>\n</code></pre></code></pre>\n<p>This only works, if your <code>switch</code> cases do not establish <code>let</code>\nvariables, because then Swift would not know what to do.</p>\n<h2>Break</h2>\n<p>You can use <code>break</code> to break out of a switch statement\nearly. Why would you do that if there's no default fallthrough? For\nexample if you can only realize within the <code>case</code> that a certain\nrequirement is not met and you can't execute the <code>case</code> any further:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> userType = \\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> userID = <span class=\"number\">10</span>\n\n<span class=\"keyword\">switch</span> (userType, userID)  {\n\n<span class=\"keyword\">case</span> (\\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">_</span>):\n\n   <span class=\"keyword\">guard let</span> userData = <span class=\"call\">getSystemUser</span>(userID) \n\n      <span class=\"keyword\">else</span> { <span class=\"keyword\">break</span> }\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"user</span> info: \\(userData)\\<span class=\"string\">\"</span>)\n\n   <span class=\"call\">insertIntoRemoteDB</span>(userData)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n\n... more code that needs to be executed\n</code></pre></code></pre>\n<p>Here, we don't want to call <code>insertIntoRemoteData</code> when the result from\n<code>getSystemUser</code> is <code>nil</code>. Of course, you could just use an <code>if let</code>\nhere, but if multiple of those cases come together, you quickly end up\nwith a bunch of horrifyingly ugly nested <code>if lets</code>.</p>\n<h2>Labels</h2>\n<p>But what if you execute your switch in a <code>while</code> loop and you want to\nbreak out of the loop, not the <code>switch</code>? For those cases, Swift allows\nyou to define <code>labels</code> to <code>break</code> or <code>continue</code> to:</p>\n<pre class=\"Swift\"><code>gameLoop: <span class=\"keyword\">while true</span> {\n\n   <span class=\"keyword\">switch</span> state() {\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">waiting</span>: <span class=\"keyword\">continue</span> gameLoop\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">done</span>: <span class=\"call\">calculateNextState</span>()\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">gameOver</span>: <span class=\"keyword\">break</span> gameLoop\n\n   }\n\n}\n</code></pre></code></pre>\n<p>See how we explicitly tell Swift in the <code>gameOver</code> case that it should\nnot break out of the <code>switch</code> statement but should break out of the <code>gameLoop</code>\ninstead.</p>\n<p>We've discussed the syntax and implementation details of <code>switch</code> and\npattern matching. Now, let us have a look at some interesting (more or\nless) real world examples.</p>\n","raw_content":"[frontMatter]\ntitle = \"Fallthrough, Break and Labels\"\ntags = [\"pattern matching\", \"switch\", \"fallthrough\", \"break\", \"label\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Fallthrough, Break and Labels\n\nThe following is not directly related to pattern matching but only\naffects the `switch` keyword, so I\\'ll keep it brief. By default, and\nunlike C/C++/Objective-C, `switch` `cases` do not fall through into the\nnext case which is why in Swift, you don\\'t need to write `break` for\nevery case. If you never used `Objective-C` or `C` and this confuses you,\nhere's a short example that would print \"1, 2, 3\":\n\n``` C\n/* This is C Code */\nswitch (2) {\ncase 1: printf(\"1\");\ncase 2: printf(\"2\");\ncase 3: printf(\"3\");\n}\n```\n\nYou would need to use  `case 1: printf(\"1\"); break;` in order to not \nautomatically fall through into the next case.\n\n## Fallthrough\n\nIn Swift, it is the other way around. If you actually want to\nfall through into the other case, you can opt into this behaviour with the\n`fallthrough` keyword.\n\n``` Swift\nswitch 5 {\ncase 5:\n print(\"Is 5\")\n fallthrough\ndefault:\n print(\"Is a number\")\n}\n// Will print: \"Is 5\" \"Is a number\"\n```\n\nThis only works, if your `switch` cases do not establish `let`\nvariables, because then Swift would not know what to do.\n\n## Break\n\nYou can use `break` to break out of a switch statement\nearly. Why would you do that if there\\'s no default fallthrough? For\nexample if you can only realize within the `case` that a certain\nrequirement is not met and you can\\'t execute the `case` any further:\n\n``` Swift\nlet userType = \"system\"\nlet userID = 10\nswitch (userType, userID)  {\ncase (\"system\", _):\n  guard let userData = getSystemUser(userID) \n     else { break }\n  print(\"user info: \\(userData)\")\n  insertIntoRemoteDB(userData)\ndefault: ()\n}\n... more code that needs to be executed\n```\n\nHere, we don\\'t want to call `insertIntoRemoteData` when the result from\n`getSystemUser` is `nil`. Of course, you could just use an `if let`\nhere, but if multiple of those cases come together, you quickly end up\nwith a bunch of horrifyingly ugly nested `if lets`.\n\n## Labels\n\nBut what if you execute your switch in a `while` loop and you want to\nbreak out of the loop, not the `switch`? For those cases, Swift allows\nyou to define `labels` to `break` or `continue` to:\n\n``` Swift\ngameLoop: while true {\n  switch state() {\n  case .waiting: continue gameLoop\n  case .done: calculateNextState()\n  case .gameOver: break gameLoop\n  }\n}\n```\n\nSee how we explicitly tell Swift in the `gameOver` case that it should\nnot break out of the `switch` statement but should break out of the `gameLoop`\ninstead.\n\nWe\\'ve discussed the syntax and implementation details of `switch` and\npattern matching. Now, let us have a look at some interesting (more or\nless) real world examples.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/associated_types.md":["87ec8be4d1dcac03",{"identifier":"f9d5b7dc","filename":"associated_types.md","info":{"title":"Associated Types","tags":["associated","protocol"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"talk":"https://www.youtube.com/watch?v=P_ifSjia9mE","swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-associated-types.html","content":"<h1>Associated Types</h1>\n<p>Swift is a powerful language with a very powerful type system. Among the\nfeatures that define said type system are <code>associated types</code>. They can\nbe defined on a <code>protocol</code> to allow implementors of the <code>protocol</code> to\nspecialize certain types in a generic way:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Example {\n\n   <span class=\"keyword\">associatedtype</span> Value\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">Value</span> { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>In the snippet above, any type that implements the <code>Example</code> protocol\nhas to define the <code>Value</code> type. Protocols with <code>associated types</code> can be\nunderstood as <strong>unfinished types</strong>. Compared to regular protocols, which\ncan be used within Swift like normal types, those protocols can only be\nused as a generic constraint. This means that once your type requires an\n<code>associated type</code>, using it suddenly becomes much more complicated.</p>\n<p>The example below shows an example of <strong><strong>finishing</strong></strong> a type. By\nexplicitly telling the compiler that the <code>Value</code> type is <code>Int</code> it is now\nable to understand <code>ImplementExample</code> fully.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ImplementExample: <span class=\"type\">Example</span> {\n\n   <span class=\"keyword\">typealias</span> Value = <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Associated types are useful for a certain kind of problems where\nsubclassing and composition does allow you to build the right kind of\nabstractions. However, this is a seperate\ntopic. The topic of this article, on the other hand, is what to do when\nyou end up with associated types trouble.</p>\n","raw_content":"[frontMatter]\ntitle = \"Associated Types\"\ntags = [\"associated\", \"protocol\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\ntalk = \"https://www.youtube.com/watch?v=P_ifSjia9mE\"\n---\n\n# Associated Types\n\nSwift is a powerful language with a very powerful type system. Among the\nfeatures that define said type system are `associated types`. They can\nbe defined on a `protocol` to allow implementors of the `protocol` to\nspecialize certain types in a generic way:\n\n``` Swift\nprotocol Example {\n  associatedtype Value\n  var value: Value { get }\n}\n```\n\nIn the snippet above, any type that implements the `Example` protocol\nhas to define the `Value` type. Protocols with `associated types` can be\nunderstood as **unfinished types**. Compared to regular protocols, which\ncan be used within Swift like normal types, those protocols can only be\nused as a generic constraint. This means that once your type requires an\n`associated type`, using it suddenly becomes much more complicated.\n\nThe example below shows an example of ****finishing**** a type. By\nexplicitly telling the compiler that the `Value` type is `Int` it is now\nable to understand `ImplementExample` fully.\n\n``` Swift\nstruct ImplementExample: Example {\n  typealias Value = Int\n}\n```\n\nAssociated types are useful for a certain kind of problems where\nsubclassing and composition does allow you to build the right kind of\nabstractions. However, this is a seperate\ntopic. The topic of this article, on the other hand, is what to do when\nyou end up with associated types trouble.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/wildcard_pattern.md":["53aa1600a0319c3e",{"identifier":"2afe898b","filename":"wildcard_pattern.md","info":{"title":"Wildcard Pattern","tags":["pattern matching","switch","wildcard"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-wildcard-pattern.html","content":"<h1>Wildcard Pattern</h1>\n<p>The wildcard pattern ignores the value to be matched against. In this\ncase any value is possible. This is the same pattern as <code>let _ = fn()</code>\nwhere the <code>_</code> indicates that you don't wish to further use this value.\nThe interesting part is that this matches all values including <code>nil</code>.</p>\n<p>You can also match <a href=\"lnk::optional\">optionals</a> by appending a <code>?</code> to make it <code>_?</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> p: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>\n\n<span class=\"keyword\">switch</span> p {\n\n<span class=\"comment\">// Any value is possible, but only if the optional has a value</span>\n\n<span class=\"keyword\">case _</span>?: print (\\<span class=\"string\">\"Has</span> <span class=\"type\">String</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"comment\">// Only match the empty optional case</span>\n\n<span class=\"keyword\">case nil</span>: print (\\<span class=\"string\">\"No</span> <span class=\"type\">String</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>As you've seen in the trading example, it also allows you to omit the\ndata you don't need from matching <code>enums</code> or <code>tuples</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> (<span class=\"number\">15</span>, \\<span class=\"string\">\"example</span>\\<span class=\"string\">\"</span>, <span class=\"number\">3.14</span>) {\n\n<span class=\"comment\">// We're only interested in the last value</span>\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> pi): print (\\<span class=\"string\">\"pi</span>: \\(pi)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Wildcard Pattern\"\ntags = [\"pattern matching\", \"switch\", \"wildcard\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Wildcard Pattern\n\nThe wildcard pattern ignores the value to be matched against. In this\ncase any value is possible. This is the same pattern as `let _ = fn()`\nwhere the `_` indicates that you don\\'t wish to further use this value.\nThe interesting part is that this matches all values including `nil`. \n\nYou can also match [optionals](lnk::optional) by appending a `?` to make it `_?`:\n\n``` Swift\nlet p: String? = nil\nswitch p {\n// Any value is possible, but only if the optional has a value\ncase _?: print (\"Has String\")\n// Only match the empty optional case\ncase nil: print (\"No String\")\n}\n```\n\nAs you\\'ve seen in the trading example, it also allows you to omit the\ndata you don\\'t need from matching `enums` or `tuples`:\n\n``` Swift\nswitch (15, \"example\", 3.14) {\n// We're only interested in the last value\ncase (_, _, let pi): print (\"pi: \\(pi)\")\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/diving_in/recap.md":["84c46e9a411a32cc",{"identifier":"9426c3d4","filename":"recap.md","info":{"title":"Recap","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-recap.html","content":"<h1>Recap</h1>\n<p>Lets have another look at the explanation we gave at the beginning and see if it became clearer\nnow.</p>\n<blockquote>\n<p>Enums declare types with finite sets of possible states and\naccompanying values. With nesting, methods, associated values, and\npattern matching, however, enums can define any hierarchically\norganized data.</p>\n</blockquote>\n<p>The definition is a lot clearer now. Indeed, if we add associated values\nand nesting, an <code>enum case</code> is like a closed, simplified <code>struct</code>. The\nadvantage over structs being the ability to encode categorization and\nhierachy:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Struct Example</span>\n\n<span class=\"keyword\">struct</span> Point { <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span> }\n\n<span class=\"keyword\">struct</span> Rect { <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span> }\n\n\n\n<span class=\"comment\">// Enum Example</span>\n\n<span class=\"keyword\">enum</span> GeometricEntity {\n\n    <span class=\"keyword\">case</span> point(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n    <span class=\"keyword\">case</span> rect(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>The addition of methods and static methods allow us to attach\nfunctionality to an <code>enum</code> without having to resort to free functions</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// C-Like example</span>\n\n<span class=\"keyword\">enum</span> Trade {\n\n    <span class=\"keyword\">case</span> buy\n\n    <span class=\"keyword\">case</span> sell\n\n}\n\n<span class=\"keyword\">func</span> order(trade: <span class=\"type\">Trade</span>)\n\n\n\n<span class=\"comment\">// Swift Enum example</span>\n\n<span class=\"keyword\">enum</span> Trade {\n\n    <span class=\"keyword\">case</span> buy\n\n    <span class=\"keyword\">case</span> sell\n\n    <span class=\"keyword\">func</span> order() {}\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Recap\"\ntags = []\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Recap\n\nLets have another look at the explanation we gave at the beginning and see if it became clearer\nnow.\n\n> Enums declare types with finite sets of possible states and\n> accompanying values. With nesting, methods, associated values, and\n> pattern matching, however, enums can define any hierarchically\n> organized data.\n\nThe definition is a lot clearer now. Indeed, if we add associated values\nand nesting, an `enum case` is like a closed, simplified `struct`. The\nadvantage over structs being the ability to encode categorization and\nhierachy:\n\n``` Swift\n// Struct Example\nstruct Point { let x: Int, y: Int }\nstruct Rect { let x: Int, y: Int, width: Int, height: Int }\n\n// Enum Example\nenum GeometricEntity {\n   case point(x: Int, y: Int)\n   case rect(x: Int, y: Int, width: Int, height: Int)\n}\n```\n\nThe addition of methods and static methods allow us to attach\nfunctionality to an `enum` without having to resort to free functions\n\n``` Swift\n// C-Like example\nenum Trade {\n   case buy\n   case sell\n}\nfunc order(trade: Trade)\n\n// Swift Enum example\nenum Trade {\n   case buy\n   case sell\n   func order() {}\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/keypath.md":["5c359ff9e0a1c585",{"identifier":"18592bb0","filename":"keypath.md","info":{"title":"KeyPath","tags":["keypath","readonly"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-keypath.html","content":"<h2>KeyPath&lt;Root, Value&gt;</h2>\n<p>We've seen this <code>KeyPath</code> before. What we did not really talk about yet is that this <code>KeyPath</code> is <strong>read only</strong>. You can't use it to modify properties, only to read properties. They're automatically used for accessing immutable properties or instances. Here're a couple of examples of these read-only keypaths:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ImmutableUser {\n\n   <span class=\"comment\">// `let` properties are immutable</span>\n\n   <span class=\"keyword\">let</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> firstUser = <span class=\"type\">ImmutableUser</span>(username: \\<span class=\"string\">\"Shinji</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// This will fail</span>\n\nfirstUser[keyPath: \\<span class=\"type\">ImmutableUser</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ikari</span>\\<span class=\"string\">\"</span>\n\n\n\n<span class=\"comment\">// Prints: KeyPath&lt;ImmutableUser, String&gt;</span>\n\n<span class=\"call\">print</span>(<span class=\"call\">type</span>(of: \\<span class=\"type\">ImmutableUser</span>.<span class=\"property\">username</span>))\n</code></pre></code></pre>\n<p>In this example, we could not edit the <code>firstUser</code>, because the <code>username</code> property was a <code>let</code> it was immutable. Just like <code>firstUser.username = &quot;Ikari&quot;</code> also would not have worked.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> MutableUser {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> firstUser = <span class=\"type\">MutableUser</span>(username: \\<span class=\"string\">\"Shinji</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// This will work fine</span>\n\nfirstUser[keyPath: \\<span class=\"type\">MutableUser</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ikari</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>Here, it works fine, because</p>\n<ul>\n<li><code>firstUser</code> is a <code>var</code> type</li>\n<li><code>MutableUser.username</code> is a <code>var</code> type</li>\n</ul>\n<p>So, if <code>KeyPath</code> is read-only and in this second example we could actually write to <code>firstUser</code>, then what is the type of <code>\\MutableUser.username</code> here?</p>\n","raw_content":"[frontMatter]\ntitle = \"KeyPath\"\ntags = [\"keypath\", \"readonly\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n## KeyPath<Root, Value>\n\nWe've seen this `KeyPath` before. What we did not really talk about yet is that this `KeyPath` is **read only**. You can't use it to modify properties, only to read properties. They're automatically used for accessing immutable properties or instances. Here're a couple of examples of these read-only keypaths:\n\n``` Swift\nstruct ImmutableUser {\n  // `let` properties are immutable\n  let username: String\n}\nvar firstUser = ImmutableUser(username: \"Shinji\")\n\n// This will fail\nfirstUser[keyPath: \\ImmutableUser.username] = \"Ikari\"\n\n// Prints: KeyPath<ImmutableUser, String>\nprint(type(of: \\ImmutableUser.username))\n```\n\nIn this example, we could not edit the `firstUser`, because the `username` property was a `let` it was immutable. Just like `firstUser.username = \"Ikari\"` also would not have worked.\n\n``` Swift\nstruct MutableUser {\n  var username: String\n}\nvar firstUser = MutableUser(username: \"Shinji\")\n\n// This will work fine\nfirstUser[keyPath: \\MutableUser.username] = \"Ikari\"\n```\n\nHere, it works fine, because \n- `firstUser` is a `var` type\n- `MutableUser.username` is a `var` type\n\nSo, if `KeyPath` is read-only and in this second example we could actually write to `firstUser`, then what is the type of `\\MutableUser.username` here?\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2015-06-19-swift-try-catch-asynchronous-closures.md":["5cf1792233692bd5",{"identifier":"5cae4309","filename":"2015-06-19-swift-try-catch-asynchronous-closures.md","info":{"title":"Using try / catch in Swift with asynchronous closures","tags":["try","catch"],"keywords":["swift","try","catch","errortype","closure","async","result","feature"],"category":["Language","All"],"created":"2015-06-19 10:30:30","description":"Swift's `try` / `catch` error handling is great. However, you can't use it in an async context. This article briefly explains which options you have if you intend to use Error Handling asynchronously","description_html":"<p>Swift's <code>try</code> / <code>catch</code> error handling is great. However, you can't use it in an async context. This article briefly explains which options you have if you intend to use Error Handling asynchronously</p>\n","published":true,"slug":"2015-06-19-swift-try-catch-asynchronous-closures.html","meta":{"swift_version":"5.0"},"created_timestamp":1434709830,"date":"2015-06-19T10:30:30","date_info":{"year":2015,"month":6,"day":19,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2015-06-19-swift-try-catch-asynchronous-closures.html","content":"<p>With Swift 2.0, Apple introduced a new error handling model with the\n<code>try</code>, <code>throw</code>, and <code>catch</code> keywords. Given the sub par state of error\nhandling in Swift 1.0, this was a welcome addition. It works basically\nas follows (simplified example):</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// We define a struct conforming to the new ErrorType</span>\n\n<span class=\"keyword\">enum</span> OurError : <span class=\"type\">ErrorType</span> {\n\n     <span class=\"keyword\">case</span> divisionError\n\n}\n\n<span class=\"keyword\">func</span> divide(a: <span class=\"type\">Int</span>, b: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">if</span> b == <span class=\"number\">0</span> {\n\n         <span class=\"keyword\">throw</span> <span class=\"type\">OurError</span>.<span class=\"property\">divisionError</span>\n\n     }\n\n     <span class=\"keyword\">return</span> a / b\n\n}\n\n<span class=\"keyword\">do</span> {\n\n     <span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span> <span class=\"call\">divide</span>(a: <span class=\"number\">50</span>, b: <span class=\"number\">10</span>)\n\n} <span class=\"keyword\">catch let</span> error {\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"Could</span> not divide\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>This is a nice and flexible way of structuring possible errors types and\nhandling them. <strong>In synchronous code</strong>.</p>\n<p>But what about asynchronous operations?</p>\n<h1>An asynchronous operation</h1>\n<p>Imagine the following operation as an example of any kind of\nasynchronous operation where there is a delay between the initiation of\na computation and the result of the computation. In Objective-C land,\nthis is solved with delegates, blocks or (though rarely) NSInvocation,\nin Swift the typical solution is a closure.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> asynchronousWork(completion: (r: [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]?) -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Void</span> {\n\n   <span class=\"comment\">// do work</span>\n\n   ...\n\n   <span class=\"call\">completion</span>(someValue)\n\n}\n</code></pre></code></pre>\n<p>How do you handle errors in these situations? We can expect, that within\nthe <code>asynchronousWork</code> function most error handling will be via\ntry/catch. So one possible solution that comes to mind is handling the\nerrors in there, and only forwarding the result, if there is one:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> asynchronousWork(completion: (result: [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]?) -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Void</span> {\n\n     <span class=\"type\">URLConnection</span>.<span class=\"call\">sendAsynchronousRequest</span>(request, queue: queue) { \n\n       (response, data, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n         <span class=\"keyword\">guard let</span> data = data <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"keyword\">do</span> {\n\n             <span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span> <span class=\"type\">JSONSerialization</span>.<span class=\"type\">JSONObjectWithData</span>(data, options: []) <span class=\"keyword\">as</span>? [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]\n\n             <span class=\"call\">completion</span>(r: result)\n\n         } <span class=\"keyword\">catch _</span> {\n\n             <span class=\"call\">completion</span>(r: <span class=\"keyword\">nil</span>)\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"comment\">// Call</span>\n\n<span class=\"call\">asynchronousWork</span> { (result) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">guard let</span> result = result <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span>}\n\n     <span class=\"call\">print</span>(result)\n\n}\n</code></pre></code></pre>\n<h1>Result Types</h1>\n<p>However, this is rather fragile, as it will not gives us any information\nabout the error in question. In Swift 1.0, when such a structure\npresented itself, people usually implemented a Result type which can be\neither the result of the computation, or the error:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Result {\n\n     <span class=\"keyword\">case</span> success(r: [<span class=\"type\">String</span>: <span class=\"type\">Any</span>])\n\n     <span class=\"keyword\">case</span> failure(e: <span class=\"type\">ErrorType</span>)\n\n}\n</code></pre></code></pre>\n<h1>Swift 5 Result</h1>\n<p>Swift 5 now contains a <code>Result</code> type in the standard library. It is similar to the one we used above. This\nmeans the names of the two cases are also <code>success</code> and <code>failure</code>. The name of the type is <code>Result</code>.</p>\n<p>Given this enum, we can then change the code as follows:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> asynchronousWork(completion: (result: <span class=\"type\">Result</span>) -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Void</span> {\n\n     <span class=\"type\">URLConnection</span>.<span class=\"call\">sendAsynchronousRequest</span>(request, queue: queue) { \n\n        (response, data, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n         <span class=\"keyword\">guard let</span> data = data <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"keyword\">do</span> {\n\n             <span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span> <span class=\"type\">JSONSerialization</span>.<span class=\"type\">JSONObjectWithData</span>(data, options: []) \n\n                 <span class=\"keyword\">as</span>? [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]\n\n             <span class=\"call\">completion</span>(r: <span class=\"type\">Result</span>.<span class=\"call\">success</span>(r: result))\n\n         } <span class=\"keyword\">catch let</span> error {\n\n             <span class=\"call\">completion</span>(r: <span class=\"type\">Result</span>.<span class=\"call\">failure</span>(e: error))\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"comment\">// Call</span>\n\n<span class=\"call\">asynchronousWork</span> { (result: <span class=\"type\">Result</span>) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">switch</span> r {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">success</span>(<span class=\"keyword\">let</span> successValue): <span class=\"call\">print</span>(successValue)\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">failure</span>(<span class=\"keyword\">let</span> error): <span class=\"call\">print</span>(\\<span class=\"string\">\"Error</span>\\<span class=\"string\">\"</span>, error)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Much nicer. When we look closely, though, there is a bit of overhead. We\nhave to define a ResultType enum and encapsulate our data in it. What's\nmore, if Result enums were the way Apple intends things to be, surely we\nwould have one in the standard library.</p>\n<p>Instead, we do have try / catch, a construct which is incompatible with\nthe task at hand because you can't catch something that happens at some\npoint in the future. I.e:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">func</span> asynchronousWork(completion: (result: <span class=\"type\">Result</span>) -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span> {\n\n}\n</code></pre></code></pre>\n<p>This can't throw, because the function returns before the computation\nhas even begun.</p>\n<h1>A solution with an inner closure</h1>\n<p>However, a nice way to solve this is by encapsulating the error into a\nthrowable closure. See for yourself:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">func</span> asynchronousWork(completion: (inner: () <span class=\"keyword\">throws</span> -&gt; [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]) -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Void</span> {\n\n     <span class=\"type\">URLConnection</span>.<span class=\"call\">sendAsynchronousRequest</span>(request, queue: queue) { \n\n         (response, data, error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n         <span class=\"keyword\">guard let</span> data = data <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"keyword\">do</span> {\n\n             <span class=\"keyword\">guard let</span> result = <span class=\"keyword\">try</span> <span class=\"type\">JSONSerialization</span>.<span class=\"type\">JSONObjectWithData</span>(data, options: []) \n\n                 <span class=\"keyword\">as</span>? [<span class=\"type\">String</span>: <span class=\"type\">Any</span>] <span class=\"keyword\">else</span> {\n\n                 <span class=\"call\">completion</span>(inner: { <span class=\"keyword\">throw</span> <span class=\"type\">OurError</span>.<span class=\"type\">InvalidJSONType</span> })\n\n             }\n\n             <span class=\"call\">completion</span>(inner: { <span class=\"keyword\">return</span> result })\n\n         } <span class=\"keyword\">catch let</span> error {\n\n             <span class=\"call\">completion</span>(inner: { <span class=\"keyword\">throw</span> error })\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"comment\">// Call</span>\n\n<span class=\"call\">asynchronousWork</span> { (inner: () <span class=\"keyword\">throws</span> -&gt; [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">do</span> {\n\n         <span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span> <span class=\"call\">inner</span>()\n\n     } <span class=\"keyword\">catch let</span> error {\n\n         <span class=\"call\">print</span>(error)\n\n     }\n\n}\n\n\n</code></pre></code></pre>\n<p>We successfully performed the asynchronous work while maintaining the\npossibility to catch the error in our calling function's completion\nblock and being able to match different error types - all without having\nto resort to enums or switches. How did we do this?</p>\n<p>As you can see, the trick is that the asynchronousWork function takes an\nadditional closure called 'inner' of the type\n<code>() throws -&gt; [String: Any]</code>. This closure will either provide the result\nof the computation, or it will throw. The closure itself is being\nconstructed during the computation by one of two means:</p>\n<ul>\n<li>In case of an error: <code>inner: {throw error}</code></li>\n<li>In case of success: <code>inner: {return result}</code></li>\n</ul>\n<p>This is a simple and flexible way of throwing errors up a closure chain\nwithout any additional means. Much like <code>rethrow</code> but for asynchronous\noperations.</p>\n<p>We also had to add an additional error for the case where our JSON was\nnot of the <code>[String: Any]</code> type.</p>\n<h1>Addendum</h1>\n<p>The only downside of this setup is that it can't be used with any\nasynchronous operation which takes a completion block. You will need to\nhave access to the operation in order to rewrite it to not call the\ncompletion block with the result but instead call a completion block\nwith an inner closure. So you can't use it with specific functionality\nfrom external libraries, but it is a good approach for your own code,\nframeworks, and libraries, if you like the idea of using the try/catch\napproach natively without having to resort to abstraction containers.</p>\n","raw_content":"[frontMatter]\ndescription = \"Swift's `try` / `catch` error handling is great. However, you can't use it in an async context. This article briefly explains which options you have if you intend to use Error Handling asynchronously\"\ntitle = \"Using try / catch in Swift with asynchronous closures\"\ncreated = \"2015-06-19\"\npublished = true\nkeywords = [\"swift\", \"try\", \"catch\", \"errortype\", \"closure\", \"async\", \"result\", \"feature\"]\nslug = \"2015-06-19-swift-try-catch-asynchronous-closures.html\"\ntags = [\"try\", \"catch\"]\ncategory = [\"Language\", \"All\"]\n\n[meta]\nswift_version = \"5.0\"\n---\n\nWith Swift 2.0, Apple introduced a new error handling model with the\n`try`, `throw`, and `catch` keywords. Given the sub par state of error\nhandling in Swift 1.0, this was a welcome addition. It works basically\nas follows (simplified example):\n\n``` Swift\n// We define a struct conforming to the new ErrorType\nenum OurError : ErrorType {\n    case divisionError\n}\nfunc divide(a: Int, b: Int) throws -> Int {\n    if b == 0 {\n        throw OurError.divisionError\n    }\n    return a / b\n}\ndo {\n    let result = try divide(a: 50, b: 10)\n} catch let error {\n    print(\"Could not divide\")\n}\n```\n\nThis is a nice and flexible way of structuring possible errors types and\nhandling them. **In synchronous code**.\n\nBut what about asynchronous operations?\n\n# An asynchronous operation\n\nImagine the following operation as an example of any kind of\nasynchronous operation where there is a delay between the initiation of\na computation and the result of the computation. In Objective-C land,\nthis is solved with delegates, blocks or (though rarely) NSInvocation,\nin Swift the typical solution is a closure.\n\n``` Swift\nfunc asynchronousWork(completion: (r: [String: Any]?) -> Void) -> Void {\n  // do work\n  ...\n  completion(someValue)\n}\n```\n\nHow do you handle errors in these situations? We can expect, that within\nthe `asynchronousWork` function most error handling will be via\ntry/catch. So one possible solution that comes to mind is handling the\nerrors in there, and only forwarding the result, if there is one:\n\n``` Swift\nfunc asynchronousWork(completion: (result: [String: Any]?) -> Void) -> Void {\n    URLConnection.sendAsynchronousRequest(request, queue: queue) { \n      (response, data, error) -> Void in\n        guard let data = data else { return }\n        do {\n            let result = try JSONSerialization.JSONObjectWithData(data, options: []) as? [String: Any]\n            completion(r: result)\n        } catch _ {\n            completion(r: nil)\n        }\n    }\n}\n\n// Call\nasynchronousWork { (result) -> Void in\n    guard let result = result else { return}\n    print(result)\n}\n```\n\n# Result Types\n\nHowever, this is rather fragile, as it will not gives us any information\nabout the error in question. In Swift 1.0, when such a structure\npresented itself, people usually implemented a Result type which can be\neither the result of the computation, or the error:\n\n``` Swift\nenum Result {\n    case success(r: [String: Any])\n    case failure(e: ErrorType)\n}\n```\n\n# Swift 5 Result\n\nSwift 5 now contains a `Result` type in the standard library. It is similar to the one we used above. This\nmeans the names of the two cases are also `success` and `failure`. The name of the type is `Result`.\n\nGiven this enum, we can then change the code as follows:\n\n``` Swift\nfunc asynchronousWork(completion: (result: Result) -> Void) -> Void {\n    URLConnection.sendAsynchronousRequest(request, queue: queue) { \n       (response, data, error) -> Void in\n        guard let data = data else { return }\n        do {\n            let result = try JSONSerialization.JSONObjectWithData(data, options: []) \n                as? [String: Any]\n            completion(r: Result.success(r: result))\n        } catch let error {\n            completion(r: Result.failure(e: error))\n        }\n    }\n}\n\n// Call\nasynchronousWork { (result: Result) -> Void in\n    switch r {\n    case .success(let successValue): print(successValue)\n    case .failure(let error): print(\"Error\", error)\n    }\n}\n```\n\nMuch nicer. When we look closely, though, there is a bit of overhead. We\nhave to define a ResultType enum and encapsulate our data in it. What\\'s\nmore, if Result enums were the way Apple intends things to be, surely we\nwould have one in the standard library.\n\nInstead, we do have try / catch, a construct which is incompatible with\nthe task at hand because you can\\'t catch something that happens at some\npoint in the future. I.e:\n\n``` Swift\n\nfunc asynchronousWork(completion: (result: Result) -> Void) throws -> Void {\n}\n```\n\nThis can\\'t throw, because the function returns before the computation\nhas even begun.\n\n# A solution with an inner closure\n\nHowever, a nice way to solve this is by encapsulating the error into a\nthrowable closure. See for yourself:\n\n``` Swift\n\nfunc asynchronousWork(completion: (inner: () throws -> [String: Any]) -> Void) -> Void {\n    URLConnection.sendAsynchronousRequest(request, queue: queue) { \n        (response, data, error) -> Void in\n        guard let data = data else { return }\n        do {\n            guard let result = try JSONSerialization.JSONObjectWithData(data, options: []) \n                as? [String: Any] else {\n                completion(inner: { throw OurError.InvalidJSONType })\n            }\n            completion(inner: { return result })\n        } catch let error {\n            completion(inner: { throw error })\n        }\n    }\n}\n\n// Call\nasynchronousWork { (inner: () throws -> [String: Any]) -> Void in\n    do {\n        let result = try inner()\n    } catch let error {\n        print(error)\n    }\n}\n\n```\n\nWe successfully performed the asynchronous work while maintaining the\npossibility to catch the error in our calling function\\'s completion\nblock and being able to match different error types - all without having\nto resort to enums or switches. How did we do this?\n\nAs you can see, the trick is that the asynchronousWork function takes an\nadditional closure called \\'inner\\' of the type\n`() throws -> [String: Any]`. This closure will either provide the result\nof the computation, or it will throw. The closure itself is being\nconstructed during the computation by one of two means:\n\n-   In case of an error: `inner: {throw error}`\n-   In case of success: `inner: {return result}`\n\nThis is a simple and flexible way of throwing errors up a closure chain\nwithout any additional means. Much like `rethrow` but for asynchronous\noperations.\n\nWe also had to add an additional error for the case where our JSON was\nnot of the `[String: Any]` type.\n\n# Addendum\n\nThe only downside of this setup is that it can\\'t be used with any\nasynchronous operation which takes a completion block. You will need to\nhave access to the operation in order to rewrite it to not call the\ncompletion block with the result but instead call a completion block\nwith an inner closure. So you can\\'t use it with specific functionality\nfrom external libraries, but it is a good approach for your own code,\nframeworks, and libraries, if you like the idea of using the try/catch\napproach natively without having to resort to abstraction containers.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/introduction.md":["4cb35d5dc1b330ac",{"identifier":"f90b081e","filename":"introduction.md","info":{"title":"Introduction","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-introduction.html","content":"<h1>Introduction</h1>\n<p>When and how to use enums in Swift? This is a detailed practical\noverview of all the possibilities enums can offer you.</p>\n<p>Similarly to the <a href=\"lnk::switch\"><code>switch</code>\nstatement</a>,\n<code>enum</code>'s in Swift may at first glance look like a slightly improved\nvariant of the well known <strong>C</strong> <code>enum</code> statement. I.e. a type that\nallows you to define that something is &quot;one of something more\ngeneral&quot;. However, the particular design\ndecisions behind Swift's enums allow it to be used in a much wider\nrange of practical scenarios than plain <strong>C</strong> enums. In particular,\nthey're great tools to clearly manifest the intentions of your code.</p>\n<p>In this post, we'll first look at the syntax and possibilities of using\n<code>enum</code>, and will then use them in a variety of (hopefully) practical,\nreal world scenarios to give a better idea of how and when to use them.\nWe'll also look a bit at how enums are being used in the Swift Standard\nlibrary.</p>\n<p>Before we dive in, here's a definition of what <code>enums</code> can be. We'll\nrevisit this definition later on:</p>\n<p>&quot;Enums declare types with finite sets of possible states and\naccompanying values. With nesting, methods, associated values, and\npattern matching, however, enums can define any hierarchically organized\ndata.&quot;</p>\n<p>First, though, what are <code>enums</code>?</p>\n","raw_content":"[frontMatter]\ntitle = \"Introduction\"\ntags = []\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n---\n\n# Introduction\n\nWhen and how to use enums in Swift? This is a detailed practical\noverview of all the possibilities enums can offer you.\n\nSimilarly to the [`switch`\nstatement](lnk::switch),\n`enum`\\'s in Swift may at first glance look like a slightly improved\nvariant of the well known **C** `enum` statement. I.e. a type that\nallows you to define that something is \\\"one of something more\ngeneral\\\". However, the particular design\ndecisions behind Swift\\'s enums allow it to be used in a much wider\nrange of practical scenarios than plain **C** enums. In particular,\nthey\\'re great tools to clearly manifest the intentions of your code.\n\nIn this post, we\\'ll first look at the syntax and possibilities of using\n`enum`, and will then use them in a variety of (hopefully) practical,\nreal world scenarios to give a better idea of how and when to use them.\nWe\\'ll also look a bit at how enums are being used in the Swift Standard\nlibrary.\n\nBefore we dive in, here\\'s a definition of what `enums` can be. We\\'ll\nrevisit this definition later on:\n\n\\\"Enums declare types with finite sets of possible states and\naccompanying values. With nesting, methods, associated values, and\npattern matching, however, enums can define any hierarchically organized\ndata.\\\"\n\nFirst, though, what are `enums`?\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/type_casting.md":["3414224900333684",{"identifier":"a4e35c31","filename":"type_casting.md","info":{"title":"Type-Casting KeyPaths","tags":["keypath","type","casting","type-casting","as","anykeypath","partialkeypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-typecasting-keypaths.html","content":"<h1>Type-Casting KeyPaths</h1>\n<p>As we've seen before, Swift offers <code>PartialKeyPath&lt;Root&gt;</code> and <code>AnyKeyPath</code> as a way to generalize <code>KeyPath</code> handling. While this makes it easier to store these keypaths in generic functions and arrays, it makes it much harder to actually use them. There's not much we can do with them - except for printing maybe - which is why most of our usage examples were about printing.</p>\n<p>Type-casting changes this. It allows you to cast a type-erased <code>KeyPath</code> back into (for example) a <code>WritableKeyPath</code> in a totally type-safe manner. Observe the magic:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span> = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n\n<span class=\"keyword\">var</span> user = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Hello</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"keyword\">if let</span> writableUsername = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt; {\n\n    user[keyPath: writableUsername] = \\<span class=\"string\">\"World</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>In this example, you saw how we converted an <code>AnyKeyPath</code> back into a <code>WritableKeyPath&lt;User, String&gt;</code>. The important part is that <code>as?</code> returns on optional. So if the <code>KeyPath</code> is not of type <code>&lt;User, String&gt;</code> nothing would happen as the expression would return <code>nil</code>. Therefore, in order to work with multiple types (<code>String</code>, <code>Int</code>, <code>Float</code>, etc), you need more than one <code>if</code> statement. Preferrably a <a href=\"lnk::switch\"><code>switch</code></a> statement.</p>\n<p>In this example, we're using <code>switch</code> to identify the specific type of the <code>keyPath</code> and then perform a different operation depending on the type.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span> = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n\n<span class=\"keyword\">switch</span> keyPath {\n\n<span class=\"keyword\">case let</span> a <span class=\"keyword\">as</span> <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">Yeah</span>, <span class=\"type\">String</span>&gt;:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"String</span>\\<span class=\"string\">\"</span> + xxx[keyPath: a])\n\n<span class=\"keyword\">case let</span> a <span class=\"keyword\">as</span> <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">Yeah</span>, <span class=\"type\">Int</span>&gt;:\n\n     <span class=\"call\">print</span>(<span class=\"number\">1</span> + xxx[keyPath: a])\n\n<span class=\"keyword\">default</span>:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"Unknown</span> keypath type\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Type-Casting KeyPaths\"\ntags = [\"keypath\", \"type\", \"casting\", \"type-casting\", \"as\", \"anykeypath\", \"partialkeypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Type-Casting KeyPaths\n\nAs we've seen before, Swift offers `PartialKeyPath<Root>` and `AnyKeyPath` as a way to generalize `KeyPath` handling. While this makes it easier to store these keypaths in generic functions and arrays, it makes it much harder to actually use them. There's not much we can do with them - except for printing maybe - which is why most of our usage examples were about printing. \n\nType-casting changes this. It allows you to cast a type-erased `KeyPath` back into (for example) a `WritableKeyPath` in a totally type-safe manner. Observe the magic:\n\n``` Swift\nlet keyPath: AnyKeyPath = \\User.username\nvar user = User(username: \"Hello\")\n\nif let writableUsername = keyPath as? WritableKeyPath<User, String> {\n   user[keyPath: writableUsername] = \"World\"\n}\n```\n\nIn this example, you saw how we converted an `AnyKeyPath` back into a `WritableKeyPath<User, String>`. The important part is that `as?` returns on optional. So if the `KeyPath` is not of type `<User, String>` nothing would happen as the expression would return `nil`. Therefore, in order to work with multiple types (`String`, `Int`, `Float`, etc), you need more than one `if` statement. Preferrably a [`switch`](lnk::switch) statement.\n\nIn this example, we're using `switch` to identify the specific type of the `keyPath` and then perform a different operation depending on the type.\n\n``` Swift\nlet keyPath: AnyKeyPath = \\User.username\nswitch keyPath {\ncase let a as KeyPath<Yeah, String>:\n    print(\"String\" + xxx[keyPath: a])\ncase let a as KeyPath<Yeah, Int>:\n    print(1 + xxx[keyPath: a])\ndefault:\n    print(\"Unknown keypath type\")\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/advanced_practical_enum_examples/complete_book.html":["e3b0c44298fc1c14",{"identifier":"4266","filename":"complete_book.html","info":{"title":"Advanced and Practical Enum usage in Swift","tags":[],"keywords":["feature","swift","enum","algebraic","caseclass","union","case","switch","pattern","simple","practical","advanced","example"],"category":[],"created":"2015-10-17 10:30:30","description":"When and how to use enums in Swift? This is a detailed practical overview of all the possibilities enums can offer you.","description_html":"<p>When and how to use enums in Swift? This is a detailed practical overview of all the possibilities enums can offer you.</p>\n","published":true,"slug":"2015-10-17-advanced-practical-enum-examples.html","meta":{"swift_version":"5.1","short_code":"<pre class='Swift'><code><span class='source swift'><span class='apvstorage apvtype swift'>enum</span> Either<span class='apvkeyword apvoperator apvcomparative swift'>&lt;</span>A, B<span class='apvkeyword apvoperator apvcomparative swift'>&gt;</span> {<br/> &nbsp;<span class='apvkeyword apvcontrol apvswitch swift'>case</span> <span class='apvkeyword apvother swift'>left</span>(A), <span class='apvkeyword apvother swift'>right</span>(B)<br/>} </span></code></pre></code></pre>","short_title":"🚦 Enums"},"created_timestamp":1445077830,"date":"2015-10-17T10:30:30","date_info":{"year":2015,"month":10,"day":17,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/advanced_practical_enum_examples/complete_book.html","content":"<h1>Introduction</h1>\n<p>When and how to use enums in Swift? This is a detailed practical\noverview of all the possibilities enums can offer you.</p>\n<p>Similarly to the <a href=\"lnk::switch\"><code>switch</code>\nstatement</a>,\n<code>enum</code>'s in Swift may at first glance look like a slightly improved\nvariant of the well known <strong>C</strong> <code>enum</code> statement. I.e. a type that\nallows you to define that something is &quot;one of something more\ngeneral&quot;. However, the particular design\ndecisions behind Swift's enums allow it to be used in a much wider\nrange of practical scenarios than plain <strong>C</strong> enums. In particular,\nthey're great tools to clearly manifest the intentions of your code.</p>\n<p>In this post, we'll first look at the syntax and possibilities of using\n<code>enum</code>, and will then use them in a variety of (hopefully) practical,\nreal world scenarios to give a better idea of how and when to use them.\nWe'll also look a bit at how enums are being used in the Swift Standard\nlibrary.</p>\n<p>Before we dive in, here's a definition of what <code>enums</code> can be. We'll\nrevisit this definition later on:</p>\n<p>&quot;Enums declare types with finite sets of possible states and\naccompanying values. With nesting, methods, associated values, and\npattern matching, however, enums can define any hierarchically organized\ndata.&quot;</p>\n<p>First, though, what are <code>enums</code>?</p>\n<h1>Diving In</h1>\n<p>A short overview of how to define and use enums.</p>\n<p>We're working on a game, and the player can move in four directions. So\nour player movement is restricted. He can only go right or left. You could model\nthat in the following manner:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if</span> movement == \\<span class=\"string\">\"left</span>\\<span class=\"string\">\"</span> { ... }\n\n<span class=\"keyword\">else if</span> movement == \\<span class=\"string\">\"right</span>\\<span class=\"string\">\"</span> { ...}\n</code></pre></code></pre>\n<p>However this is dangerous, what if we have a typo in our code and\n<code>movement</code> is neither <code>left</code> nor <code>right</code> but <code>leeft</code>?. Wouldn't it be cool\nif the compiler would point out if we have a typo like that? You could just write:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> moveLeft = <span class=\"number\">0</span>\n\n<span class=\"keyword\">let</span> moveRight = <span class=\"number\">1</span>\n\n<span class=\"keyword\">if</span> movement == moveLeft { ... }\n\n<span class=\"keyword\">else if</span> movement == moveRight { ... }\n</code></pre></code></pre>\n<p>This would solve our problem of typos in the code, but if we had more movements,\nit would be an easy bug to forget to handle all the movements. Imagine somebody\nextends the code in a couple of months and adds two new movements:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> moveUp = <span class=\"number\">0</span>\n\n<span class=\"keyword\">let</span> moveDown = <span class=\"number\">1</span>\n</code></pre></code></pre>\n<p>This developer forgets to update the <code>if</code> logic, though, so now we have more\nmovements but we forgot to handle them. Wouldn't it be great if the compiler would\ntell us if we forgot to handle all the cases of our movements? That's what the <code>enum</code>\ntype is for:</p>\n<h2>Defining Basic Enums</h2>\n<p><code>Enum</code>s tell Swift that a particular set of <code>cases</code> belong together. Our movement\n<code>enum</code> could look like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Movement {\n\n<span class=\"keyword\">case</span> left\n\n<span class=\"keyword\">case</span> right\n\n}\n</code></pre></code></pre>\n<p>It is considered proper style in Swift to always use lowercase for the enum <code>case</code> name</p>\n<p>Swift's <a href=\"lnk::switch\">switch</a> allows you to handle all the states of an <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> myMovement = <span class=\"type\">Movement</span>.<span class=\"property\">left</span>\n\n<span class=\"keyword\">switch</span> myMovement {\n\n<span class=\"keyword\">case</span> <span class=\"type\">Movement</span>.<span class=\"property\">left</span>: player.<span class=\"call\">goLeft</span>()\n\n<span class=\"keyword\">case</span> <span class=\"type\">Movement</span>.<span class=\"property\">right</span>: player.<span class=\"call\">goRight</span>()\n\n}\n</code></pre></code></pre>\n<p>If we would add another <code>case</code> (such as <code>up</code>), then the compiler would complain.</p>\n<p>There's also a really nice shortcut in Swift. Since the compiler knows that <code>myMovement</code> is\nof type <code>Movement</code> you don't have to write that out explicitly. This also works:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> myMovement {\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">left</span>: player.<span class=\"call\">goLeft</span>()\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">right</span>: player.<span class=\"call\">goRight</span>()\n\n}\n</code></pre></code></pre>\n<p>It is considered good style to not write out the <code>enum</code> name. Theyre may be situations where you have to do it in order to please the Compiler though.</p>\n<h2>Handling Enums</h2>\n<p>Besides the <code>switch</code> statement above, Swift also offers many more ways of handling <code>enum</code> types. Many of which can be found in our <a href=\"lnk::switch\">Pattern Matching Guide</a>, some of the will also be handled in this guide on <code>enum</code>.</p>\n<h1>Enum values</h1>\n<p>Sometimes may want to have a value assigned to each <code>enum</code> case.\nThis is useful if the <code>enum</code> itself indeed relates to something which\ncan be expressed in a different type. <strong>C</strong> allows you to assign numbers\nto <code>enum cases</code>. Swift gives you much more flexibility here:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// A pretty useless enum</span>\n\n<span class=\"keyword\">enum</span> Binary {\n\n   <span class=\"keyword\">case</span> zero = <span class=\"number\">0</span>\n\n   <span class=\"keyword\">case</span> one = <span class=\"number\">1</span>\n\n}\n\n\n\n<span class=\"comment\">// You can also map to strings</span>\n\n<span class=\"keyword\">enum</span> House: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">case</span> baratheon = \\<span class=\"string\">\"Ours</span> <span class=\"keyword\">is</span> the <span class=\"type\">Fury</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> greyjoy = \\<span class=\"string\">\"We</span> <span class=\"type\">Do Not Sow</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> martell = \\<span class=\"string\">\"Unbowed</span>, <span class=\"type\">Unbent</span>, <span class=\"type\">Unbroken</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> stark = \\<span class=\"string\">\"Winter</span> <span class=\"keyword\">is</span> <span class=\"type\">Coming</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> tully = \\<span class=\"string\">\"Family</span>, <span class=\"type\">Duty</span>, <span class=\"type\">Honor</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> tyrell = \\<span class=\"string\">\"Growing</span> <span class=\"type\">Strong</span>\\<span class=\"string\">\"</span>\n\n}\n\n\n\n<span class=\"comment\">// Or to floating point (also note the fancy unicode in enum cases)</span>\n\n<span class=\"keyword\">enum</span> Constants: <span class=\"type\">Double</span> {\n\n     <span class=\"keyword\">case</span> π = <span class=\"number\">3.14159</span>\n\n     <span class=\"keyword\">case</span> e = <span class=\"number\">2.71828</span>\n\n     <span class=\"keyword\">case</span> φ = <span class=\"number\">1.61803398874</span>\n\n     <span class=\"keyword\">case</span> λ = <span class=\"number\">1.30357</span>\n\n}\n</code></pre></code></pre>\n<p>For <code>String</code> and <code>Int</code> types, you can even omit the values and the Swift\ncompiler will do the right thing:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// mercury = 1, venus = 2, ... neptune = 8</span>\n\n<span class=\"keyword\">enum</span> Planet: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">case</span> mercury = <span class=\"number\">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune\n\n}\n\n\n\n<span class=\"comment\">// north = \\\"north\\\", ... west = \\\"west\\\"</span>\n\n<span class=\"keyword\">enum</span> CompassPoint: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">case</span> north, south, east, west\n\n}\n</code></pre></code></pre>\n<p>Swift supports the following types for the value of an enum:</p>\n<ul>\n<li>Integer</li>\n<li>Floating Point</li>\n<li>String</li>\n<li>Boolean</li>\n</ul>\n<p>You can support more types <a href=\"lnk::enum-custom-data-types\">by implementing a specific protocol</a>.</p>\n<p>If you want to access the values, you can do so with the <code>rawValue</code>\nproperty:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> bestHouse = <span class=\"type\">House</span>.<span class=\"property\">stark</span>\n\n<span class=\"call\">print</span>(bestHouse.<span class=\"property\">rawValue</span>)\n\n<span class=\"comment\">// prints \\\"Winter is coming\\\"</span>\n</code></pre></code></pre>\n<p>However, there may also be a situation where you want to construct an\n<code>enum case</code> from an existing raw value. In that case, there's a special\ninitializer for enums:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Movement: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">case</span> left = <span class=\"number\">0</span>\n\n     <span class=\"keyword\">case</span> right = <span class=\"number\">1</span>\n\n     <span class=\"keyword\">case</span> top = <span class=\"number\">2</span>\n\n     <span class=\"keyword\">case</span> bottom = <span class=\"number\">3</span>\n\n}\n\n<span class=\"comment\">// creates a movement.Right case, as the raw value for that is 1</span>\n\n<span class=\"keyword\">let</span> rightMovement = <span class=\"type\">Movement</span>(rawValue: <span class=\"number\">1</span>)\n</code></pre></code></pre>\n<p>If you use the <code>rawValue</code> initializer, keep in mind that it is a\n<a href=\"lnk::failable-initializer\">failable\ninitializer</a>,\ni.e. you get back an\n<a href=\"lnk::optional\">Optional</a>,\nas the value you're using may not map to any case at all, say if you\nwere to write <code>Movement(rawValue: 42)</code>.</p>\n<h1>Nesting Enums</h1>\n<p>If you have specific sub type requirements, you can also logically nest\nenums in an enum. This allows you to contain specific information on\nyour enum case within the actual enum. Imagine a character in an RPG.\nEach character can have a weapon, all characters have access to the same\nset of weapons. All other instances in the game do not have access to\nthose weapons (they're trolls, they just have clubs).</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character {\n\n   <span class=\"keyword\">enum</span> Weapon {\n\n     <span class=\"keyword\">case</span> bow\n\n     <span class=\"keyword\">case</span> sword\n\n     <span class=\"keyword\">case</span> lance\n\n     <span class=\"keyword\">case</span> dagger\n\n   }\n\n   <span class=\"keyword\">enum</span> Helmet {\n\n     <span class=\"keyword\">case</span> wooden\n\n     <span class=\"keyword\">case</span> iron\n\n     <span class=\"keyword\">case</span> diamond\n\n   }\n\n   <span class=\"keyword\">case</span> thief\n\n   <span class=\"keyword\">case</span> warrior\n\n   <span class=\"keyword\">case</span> knight\n\n}\n</code></pre></code></pre>\n<p>Now you have a hierachical system to describe the various items that\nyour character has access to.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> character = <span class=\"type\">Character</span>.<span class=\"property\">thief</span>\n\n<span class=\"keyword\">let</span> weapon = <span class=\"type\">Character</span>.<span class=\"type\">Weapon</span>.<span class=\"property\">bow</span>\n\n<span class=\"keyword\">let</span> helmet = <span class=\"type\">Character</span>.<span class=\"type\">Helmet</span>.<span class=\"property\">iron</span>\n</code></pre></code></pre>\n<p>If you add initializers for the nested <code>enum</code> types, you can still benefit from not having\nto type out the the long description. Imagine a function that calculates how strong a\ncharacter is, based on the character, the weapon, and the helmet:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> strength(of character: <span class=\"type\">Character</span>, \n\n      with weapon: <span class=\"type\">Character</span>.<span class=\"property\">weapon</span>, \n\n      and armor: <span class=\"type\">Character</span>.<span class=\"type\">Helmet</span>) {\n\n      <span class=\"keyword\">return</span> <span class=\"number\">0</span>\n\n}\n\n\n\n<span class=\"comment\">// You can still call it like this:</span>\n\n<span class=\"call\">strength</span>(of: .<span class=\"dotAccess\">thief</span>, with: .<span class=\"dotAccess\">bow</span>, and: .<span class=\"dotAccess\">wooden</span>)\n</code></pre></code></pre>\n<p>This is still really clear and easy to understand.</p>\n<h1>Containing Enums</h1>\n<p>In a similar vein, you can also embed enums in <code>structs</code> or <code>classes</code>.\nContinuing with our previous example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Character {\n\n    <span class=\"keyword\">enum</span> CharacterType {\n\n     <span class=\"keyword\">case</span> thief\n\n     <span class=\"keyword\">case</span> warrior\n\n     <span class=\"keyword\">case</span> knight\n\n   }\n\n   <span class=\"keyword\">enum</span> Weapon {\n\n     <span class=\"keyword\">case</span> bow\n\n     <span class=\"keyword\">case</span> sword\n\n     <span class=\"keyword\">case</span> lance\n\n     <span class=\"keyword\">case</span> dagger\n\n   }\n\n   <span class=\"keyword\">let</span> type: <span class=\"type\">CharacterType</span>\n\n   <span class=\"keyword\">let</span> weapon: <span class=\"type\">Weapon</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> warrior = <span class=\"type\">Character</span>(type: .<span class=\"dotAccess\">warrior</span>, weapon: .<span class=\"dotAccess\">sword</span>)\n</code></pre></code></pre>\n<p>This really helps in keeping related information together.</p>\n<h1>Associated Values</h1>\n<p>Associated values are a fantastic way of attaching additional\ninformation to an <code>enum case</code>. Say you're writing a trading engine, and\nthere're two different possible trade types. <code>buy</code> and <code>sell</code>. Each of\nthem would be for a specific stock and amount:</p>\n<h3>Simple Example</h3>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy\n\n     <span class=\"keyword\">case</span> sell\n\n}\n\n<span class=\"keyword\">func</span> trade(tradeType: <span class=\"type\">Trade</span>, stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>) {}\n</code></pre></code></pre>\n<p>However, the stock and amount clearly belong to the trade in question,\nhaving them as separate parameters feels unclean. You could embed it\ninto a <code>struct</code>, but associated values allow for a much cleaner\nsolution:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n}\n\n<span class=\"keyword\">func</span> trade(type: <span class=\"type\">Trade</span>) {}\n</code></pre></code></pre>\n<p>This defines two cases, <code>buy</code> and <code>sell</code>. Each of these cases has additional\nvalues attached to it: The <code>stock</code> and amount to buy / sell. These cases cannot exist\nwithout these additional values. You can't do this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"property\">buy</span>\n</code></pre></code></pre>\n<p>You always have to initialize these cases <strong>with the associated</strong> values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(\\<span class=\"string\">\"APPL</span>\\<span class=\"string\">\"</span>, <span class=\"number\">500</span>)\n</code></pre></code></pre>\n<h3>Pattern Matching</h3>\n<p>If you want to access this information, again, <a href=\"lnk::switch\">pattern matching comes\nto the\nrescue</a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(stock: \\<span class=\"string\">\"AAPL</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">500</span>)\n\n\n\n<span class=\"keyword\">if case let</span> <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(stock, amount) = trade {\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"buy</span> \\(amount) of \\(stock)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>Here, you're telling the Swift compiler the following:\n&quot;If the <code>trade</code> is of type <code>Trade.buy</code> with the two values <code>stock</code> and <code>amount</code>, then <code>let</code> those\ntwo variables exist with the values&quot;. You kinda have to read this <code>if</code> line from right to left.</p>\n<p>There's an alternative way of writing this with two <code>let</code> statements:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if case</span> <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(<span class=\"keyword\">let</span> stock, <span class=\"keyword\">let</span> amount) = trade {\n\n   ...\n\n}\n</code></pre></code></pre>\n<h3>Labels</h3>\n<p>Associated values do not require labels. You can just denote the types you'd like to see in your <code>enum case</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n    <span class=\"keyword\">case</span> buy(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)\n\n    <span class=\"keyword\">case</span> sell(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)\n\n}\n\n\n\n<span class=\"comment\">// Initialize without labels</span>\n\n<span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"call\">sell</span>(\\<span class=\"string\">\"APPL</span>\\<span class=\"string\">\"</span>, <span class=\"number\">500</span>)\n</code></pre></code></pre>\n<p>If you don't add labels, you also don't write them out when creating a case.\nIf you add them, though, you'll have to always type them out when creating\nyour enum cases.</p>\n<h3>Use Case Examples</h3>\n<p>Associated Values can be used in a variety of ways. What follows is a list of short examples in\nno particular order.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Cases can have different values</span>\n\n<span class=\"keyword\">enum</span> UserAction {\n\n   <span class=\"keyword\">case</span> openURL(url: <span class=\"type\">NSURL</span>)\n\n   <span class=\"keyword\">case</span> switchProcess(processId: <span class=\"type\">UInt32</span>)\n\n   <span class=\"keyword\">case</span> restart(time: <span class=\"type\">NSDate</span>?, intoCommandLine: <span class=\"type\">Bool</span>)\n\n}\n\n\n\n<span class=\"comment\">// Or imagine you're implementing a powerful text editor that allows you to have</span>\n\n<span class=\"comment\">// multiple selections, like Sublime Text here:</span>\n\n<span class=\"comment\">// https://www.youtube.com/watch?v=i2SVJa2EGIw</span>\n\n<span class=\"keyword\">enum</span> Selection {\n\n   <span class=\"keyword\">case</span> none\n\n   <span class=\"keyword\">case</span> single(<span class=\"type\">Range</span>&lt;<span class=\"type\">Int</span>&gt;)\n\n   <span class=\"keyword\">case</span> multiple([<span class=\"type\">Range</span>&lt;<span class=\"type\">Int</span>&gt;])\n\n}\n\n\n\n<span class=\"comment\">// Or mapping different types of identifier codes</span>\n\n<span class=\"keyword\">enum</span> Barcode {\n\n     <span class=\"keyword\">case</span> <span class=\"type\">UPCA</span>(numberSystem: <span class=\"type\">Int</span>, manufacturer: <span class=\"type\">Int</span>, product: <span class=\"type\">Int</span>, check: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">QRCode</span>(productCode: <span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"comment\">// Or, imagine you're wrapping a C library, like the Kqeue BSD/Darwin notification</span>\n\n<span class=\"comment\">// system: https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</span>\n\n<span class=\"keyword\">enum</span> KqueueEvent {\n\n     <span class=\"keyword\">case</span> userEvent(identifier: <span class=\"type\">UInt</span>, fflags: [<span class=\"type\">UInt32</span>], data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> readFD(fd: <span class=\"type\">UInt</span>, data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> writeFD(fd: <span class=\"type\">UInt</span>, data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> vnodeFD(fd: <span class=\"type\">UInt</span>, fflags: [<span class=\"type\">UInt32</span>], data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> errorEvent(code: <span class=\"type\">UInt</span>, message: <span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"comment\">// Finally, all user-wearable items in an RPG could be mapped with one</span>\n\n<span class=\"comment\">// enum, that encodes for each item the additional armor and weight</span>\n\n<span class=\"comment\">// Now, adding a new material like 'Diamond' is just one line of code and we'll have the option to add several new Diamond-Crafted wearables.</span>\n\n<span class=\"keyword\">enum</span> Wearable {\n\n     <span class=\"keyword\">enum</span> Weight: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">1</span>\n\n         <span class=\"keyword\">case</span> mid = <span class=\"number\">4</span>\n\n         <span class=\"keyword\">case</span> heavy = <span class=\"number\">10</span>\n\n     }\n\n     <span class=\"keyword\">enum</span> Armor: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">2</span>\n\n         <span class=\"keyword\">case</span> strong = <span class=\"number\">8</span>\n\n         <span class=\"keyword\">case</span> heavy = <span class=\"number\">20</span>\n\n     }\n\n     <span class=\"keyword\">case</span> helmet(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n     <span class=\"keyword\">case</span> breastplate(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n     <span class=\"keyword\">case</span> shield(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n}\n\n<span class=\"keyword\">let</span> woodenHelmet = <span class=\"type\">Wearable</span>.<span class=\"call\">helmet</span>(weight: .<span class=\"dotAccess\">light</span>, armor: .<span class=\"dotAccess\">light</span>)\n</code></pre></code></pre>\n<h1>Methods and Properties</h1>\n<p>Swift <code>enum</code> types can have methods and properties attached to them. This works exactly like you'd do it for\n<code>class</code> or <code>struct</code> types. Here is a very simple example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Transportation {\n\n   <span class=\"keyword\">case</span> car(<span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> train(<span class=\"type\">Int</span>)\n\n\n\n   <span class=\"keyword\">func</span> distance() -&gt; <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">car</span>(<span class=\"keyword\">let</span> miles): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(miles) miles by car\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">train</span>(<span class=\"keyword\">let</span> miles): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(miles) miles by train\\<span class=\"string\">\"</span>\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>The main difference to <code>struct</code> or <code>class</code> types is that you can <code>switch</code> on <code>self</code> within the method\nin order to calculate the output.</p>\n<p>Here is another, more involved, example where we use the <code>enum values</code> to determine the numerical attributes of a character in a method.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Wearable {\n\n     <span class=\"keyword\">enum</span> Weight: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">1</span>\n\n     }\n\n     <span class=\"keyword\">enum</span> Armor: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">2</span>\n\n     }\n\n     <span class=\"keyword\">case</span> helmet(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n\n\n     <span class=\"keyword\">func</span> attributes() -&gt; (weight: <span class=\"type\">Int</span>, armor: <span class=\"type\">Int</span>) {\n\n        <span class=\"keyword\">switch self</span> {\n\n        <span class=\"keyword\">case</span> .<span class=\"dotAccess\">helmet</span>(<span class=\"keyword\">let</span> w, <span class=\"keyword\">let</span> a): \n\n           <span class=\"keyword\">return</span> (weight: w.<span class=\"property\">rawValue</span> * <span class=\"number\">2</span>, armor: a.<span class=\"property\">rawValue</span> * <span class=\"number\">4</span>)\n\n        }\n\n     }\n\n}\n\n<span class=\"keyword\">let</span> woodenHelmetProps = <span class=\"type\">Wearable</span>.<span class=\"call\">helmet</span>(weight: .<span class=\"dotAccess\">light</span>, armor: .<span class=\"dotAccess\">light</span>)\n\n     .<span class=\"call\">attributes</span>()\n</code></pre></code></pre>\n<h3>Properties</h3>\n<p>Enums don't allow for adding stored properties. This means the following does not work:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">case</span> iPad\n\n   <span class=\"keyword\">case</span> iPhone\n\n   \n\n   <span class=\"keyword\">let</span> introduced: <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Here, we'd like to store an Apple device together with the year when\nit was introduced. However, this does not compile.</p>\n<p>Even though you can't add actual stored properties to an <code>enum</code>, you\ncan still create computed properties. Their contents, of course, can be\nbased on the <strong>enum value</strong> or <strong>enum associated value</strong>. They're read-only though.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">case</span> iPad,\n\n   <span class=\"keyword\">case</span> iPhone\n\n\n\n   <span class=\"keyword\">var</span> introduced: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">iPhone</span>: <span class=\"keyword\">return</span> <span class=\"number\">2007</span>\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">iPad</span>: <span class=\"keyword\">return</span> <span class=\"number\">2010</span>\n\n      }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>This works great as the year of the introduction of an Apple device never changes.\nYou couldn't use this if you'd like to store mutable / changing information. In those cases\nyou'd always use <code>associated values</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character {\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> warior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>Also, you can always still add properties for easy retrieval of the <code>associated value</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Character</span> {\n\n   <span class=\"keyword\">var</span> level: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">wizard</span>(<span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> level): <span class=\"keyword\">return</span> level\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">warior</span>(<span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> level): <span class=\"keyword\">return</span> level\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<h3>Static Methods</h3>\n<p>You can also have static methods on <code>enums</code>, i.e. in order to create an\n<code>enum</code> from a non-value type.</p>\n<p>Static methods are methods you can call on the name of the type instead of\na specific instance of the type. In this example we add a static method\nto our <code>enum Device</code> which returns the most recently released device:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">static var</span> newestDevice: <span class=\"type\">Device</span> {\n\n     <span class=\"keyword\">return</span> .<span class=\"dotAccess\">appleWatch</span>\n\n   }\n\n\n\n   <span class=\"keyword\">case</span> iPad,\n\n   <span class=\"keyword\">case</span> iPhone\n\n   <span class=\"keyword\">case</span> appleWatch\n\n}\n</code></pre></code></pre>\n<h3>Mutating Methods</h3>\n<p>Methods can be declared <code>mutating</code>. They're then allowed to change the\n<code>case</code> of the underlying <code>self</code> parameter. Imagine a lamp that has three states:\n<code>off</code>, <code>low</code>, <code>bright</code> where <code>low</code> is low light and <code>bright</code> a very strong light.\nWe want a function called <code>next</code> that switches to the next state:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> TriStateSwitch {\n\n     <span class=\"keyword\">case</span> off, low, bright\n\n     <span class=\"keyword\">mutating func</span> next() {\n\n         <span class=\"keyword\">switch self</span> {\n\n         <span class=\"keyword\">case</span> .<span class=\"dotAccess\">off</span>:\n\n             <span class=\"keyword\">self</span> = low\n\n         <span class=\"keyword\">case</span> .<span class=\"dotAccess\">low</span>:\n\n             <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">bright</span>\n\n         <span class=\"keyword\">case</span> high:\n\n             <span class=\"keyword\">self</span> = off\n\n         }\n\n     }\n\n}\n\n<span class=\"keyword\">var</span> ovenLight = <span class=\"type\">TriStateSwitch</span>.<span class=\"property\">low</span>\n\novenLight.<span class=\"call\">next</span>()\n\n<span class=\"comment\">// ovenLight is now equal to .bright</span>\n\novenLight.<span class=\"call\">next</span>()\n\n<span class=\"comment\">// ovenLight is now equal to .off</span>\n</code></pre></code></pre>\n<p>Before we look at advanced <code>enum</code> usage, we'll do a brief recap of what we've\nlearned in this section so far.</p>\n<h1>Recap</h1>\n<p>Lets have another look at the explanation we gave at the beginning and see if it became clearer\nnow.</p>\n<blockquote>\n<p>Enums declare types with finite sets of possible states and\naccompanying values. With nesting, methods, associated values, and\npattern matching, however, enums can define any hierarchically\norganized data.</p>\n</blockquote>\n<p>The definition is a lot clearer now. Indeed, if we add associated values\nand nesting, an <code>enum case</code> is like a closed, simplified <code>struct</code>. The\nadvantage over structs being the ability to encode categorization and\nhierachy:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Struct Example</span>\n\n<span class=\"keyword\">struct</span> Point { <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span> }\n\n<span class=\"keyword\">struct</span> Rect { <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span> }\n\n\n\n<span class=\"comment\">// Enum Example</span>\n\n<span class=\"keyword\">enum</span> GeometricEntity {\n\n    <span class=\"keyword\">case</span> point(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n    <span class=\"keyword\">case</span> rect(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>The addition of methods and static methods allow us to attach\nfunctionality to an <code>enum</code> without having to resort to free functions</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// C-Like example</span>\n\n<span class=\"keyword\">enum</span> Trade {\n\n    <span class=\"keyword\">case</span> buy\n\n    <span class=\"keyword\">case</span> sell\n\n}\n\n<span class=\"keyword\">func</span> order(trade: <span class=\"type\">Trade</span>)\n\n\n\n<span class=\"comment\">// Swift Enum example</span>\n\n<span class=\"keyword\">enum</span> Trade {\n\n    <span class=\"keyword\">case</span> buy\n\n    <span class=\"keyword\">case</span> sell\n\n    <span class=\"keyword\">func</span> order() {}\n\n}\n</code></pre></code></pre>\n<h1>Advanced Enum Usage</h1>\n<p>The <code>enum</code> type is one of Swift's most distinctive features. We already saw a lot of different use cases. However, There's much more that enums can do.</p>\n<p>They can be used with protocols, just like other Swift types, they can have extensions, they can be generic, and much more. This chapter will introduce these interesting <code>enum</code> features.</p>\n<p>We will start by having a look at conforming enums to protocols.</p>\n<h1>Protocols</h1>\n<p>We already mentioned the similarity between the <code>struct</code> and <code>enum</code> types. In\naddition to the ability to add methods, Swift also allows you to use\n<strong>Protocols</strong> and <strong>Protocol Extensions</strong> with enums.</p>\n<p>Swift protocols define an interface that types can\nconform to. In this case our <code>enum</code> can conform to it. For a start,\nlet's take a protocol from the Swift standard library.</p>\n<p><code>CustomStringConvertible</code> is a type with a customized textual\nrepresentation suitable for printing purposes:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> CustomStringConvertible {\n\n   <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>It has only one requirement, namely a <strong>getter</strong> for a string. We can\nimplement this on an enum quite easily:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade: <span class=\"type\">CustomStringConvertible</span> {\n\n    <span class=\"keyword\">case</span> buy, sell\n\n    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> {\n\n        <span class=\"keyword\">switch self</span> {\n\n        <span class=\"keyword\">case</span> .<span class=\"dotAccess\">buy</span>: <span class=\"keyword\">return</span> \\<span class=\"string\">\"We</span>'re buying something\\<span class=\"string\">\"</span>\n\n        <span class=\"keyword\">case</span> .<span class=\"dotAccess\">sell</span>: <span class=\"keyword\">return</span> \\<span class=\"string\">\"We</span>'re selling something\\<span class=\"string\">\"</span>\n\n        }\n\n    }\n\n}\n</code></pre></code></pre>\n<p>Some protocol implementations may need internal state handling to cope\nwith the requirements. Imagine a protocol that manages a bank account:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> AccountCompatible {\n\n   <span class=\"keyword\">var</span> remainingFunds: <span class=\"type\">Int</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"keyword\">mutating func</span> addFunds(amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n   <span class=\"keyword\">mutating func</span> removeFunds(amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n}\n</code></pre></code></pre>\n<p>You could easily fulfill this protocol with a <code>struct</code>, but in the\ncontext of your application, an <code>enum</code> is the more sensible approach.</p>\n<p>However, you can't add properties like <code>var remainingFunds: Int</code> to an\n<code>enum</code>, so how would you model that? The answer is actually easy, you\ncan use associated values for this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Account {\n\n   <span class=\"keyword\">case</span> empty\n\n   <span class=\"keyword\">case</span> funds(remaining: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> credit(amount: <span class=\"type\">Int</span>)\n\n\n\n   <span class=\"keyword\">var</span> remainingFunds: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">empty</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">funds</span>(<span class=\"keyword\">let</span> remaining): <span class=\"keyword\">return</span> remaining\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">credit</span>(<span class=\"keyword\">let</span> amount): <span class=\"keyword\">return</span> amount\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>To keep things clean, we can then define the required protocol functions\nin a protocol extension on the <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Account</span>: <span class=\"type\">AccountCompatible</span> {\n\n\n\n   <span class=\"keyword\">mutating func</span> addFunds(amount: <span class=\"type\">Int</span>) {\n\n     <span class=\"keyword\">var</span> newAmount = amount\n\n     <span class=\"keyword\">if case let</span> .<span class=\"call\">funds</span>(remaining) = <span class=\"keyword\">self</span> {\n\n       newAmount += remaining\n\n     }\n\n     <span class=\"keyword\">if</span> newAmount &lt; <span class=\"number\">0</span> {\n\n       <span class=\"keyword\">self</span> = .<span class=\"call\">credit</span>(newAmount)\n\n     } <span class=\"keyword\">else if</span> newAmount == <span class=\"number\">0</span> {\n\n       <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">empty</span>\n\n     } <span class=\"keyword\">else</span> {\n\n       <span class=\"keyword\">self</span> = .<span class=\"call\">funds</span>(remaining: newAmount)\n\n     }\n\n   }\n\n\n\n   <span class=\"keyword\">mutating func</span> removeFunds(amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span> {\n\n     <span class=\"keyword\">try self</span>.<span class=\"call\">addFunds</span>(amount * -<span class=\"number\">1</span>)\n\n   }\n\n\n\n}\n\n\n\n<span class=\"keyword\">var</span> account = <span class=\"type\">Account</span>.<span class=\"call\">funds</span>(remaining: <span class=\"number\">20</span>)\n\n<span class=\"keyword\">try</span>? account.<span class=\"call\">addFunds</span>(amount:<span class=\"number\">10</span>)\n\n<span class=\"keyword\">try</span>? account.<span class=\"call\">removeFunds</span>(amount:<span class=\"number\">15</span>)\n</code></pre></code></pre>\n<p>As you can see, we implemented all the protocol requirements by storing\nour values within our <code>enum cases</code>. A very nifty side effect of this is,\nthat now you can test for an empty account with a simple pattern match\nall over your code base. You don't have to see whether the\n<code>remainingFunds</code> are zero.</p>\n<p>We're also implementing the protocol in an extension. We'll learn more about\nextensions on <code>enum</code> types in the next chapter.</p>\n<h1>Extensions</h1>\n<p>Take the following <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Entity {\n\n     <span class=\"keyword\">case</span> soldier(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> tank(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> player(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>As we just saw, enums can also be extended. There're two use cases for this.\nYou've already seen the first one: Conforming to a <code>protocol</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Entity</span>: <span class=\"type\">CustomStringConvertible</span> {\n\n   <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">soldier</span>(x, y): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(x), \\(y)\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">tank</span>(x, y): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(x), \\(y)\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">player</span>(x, y): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(x), \\(y)\\<span class=\"string\">\"</span>\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>The other use case\nis keeping <code>enum cases</code> and <code>methods</code> separate, so that a\nreader of your code can easily digest the <code>enum</code> and afterwards\nread the methods.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Entity</span> {\n\n    <span class=\"keyword\">mutating func</span> move(dist: <span class=\"type\">CGVector</span>) {}\n\n    <span class=\"keyword\">mutating func</span> attack() {}\n\n}\n</code></pre></code></pre>\n<h2>Extending</h2>\n<p>Extensions also allow you to add useful code to existing <code>enum</code> types. Either from the Swift standard library, or from third party frameworks, or from yourself if you happen to have a big codebase.</p>\n<p>For example, we can extend the standard library <code>Optional</code> type in order to add useful extensions. If you'd like to learn more about this, <a href=\"lnk::optional\">we have an article that explains this in more detail.</a></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Returns true if the optional is empty</span>\n\n     <span class=\"keyword\">var</span> isNone: <span class=\"type\">Bool</span> {\n\n         <span class=\"keyword\">return self</span> == .<span class=\"dotAccess\">none</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Another example would be addign a convenience extension to one of your own <code>enum</code> types that is <code>fileprivate</code> so that you'd use it only within a specific file:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">fileprivate extension</span> <span class=\"type\">Entity</span> {\n\n   <span class=\"keyword\">mutating func</span> replace(to: <span class=\"type\">Entity</span>) {\n\n     <span class=\"keyword\">self</span> = entity\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Here, we have an extension to your <code>Entity</code> that allows to replace it with a different entity. This would only be used deep within your game engine which is why the scope is limited to one file.</p>\n<h1>Generic Enums</h1>\n<p>Enums can also be defined over generic parameters. You'd use them to\nadapt the associated values of an enum. The simplest example comes\nstraight from the Swift standard library, namely the <a href=\"lnk::optional\"><code>Optional</code> type</a>.\nYou probably mostly use it with <strong>optional chaining</strong> (<code>?</code>), <code>if let</code>,\n<code>guard let</code>, or <code>switch</code>, but syntactically you can also use Optionals\nlike so:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> aValue = <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt;.<span class=\"call\">some</span>(<span class=\"number\">5</span>)\n\n<span class=\"keyword\">let</span> noValue = <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt;.<span class=\"property\">none</span>\n\n<span class=\"keyword\">if</span> noValue == <span class=\"type\">Optional</span>.<span class=\"property\">none</span> { <span class=\"call\">print</span>(\\<span class=\"string\">\"No</span> value\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<p>This is the direct usage of an Optional without any of the syntactic\nsugar that Swift adds in order to make your life a tremendous amount\neasier. If you look at the code above, you can probably guess that\ninternally the <code>Optional</code> is defined as follows <sup class=\"footnote-reference\"><a href=\"#5\">1</a></sup>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Simplified implementation of Swift's Optional</span>\n\n<span class=\"keyword\">enum</span> MyOptional&lt;T&gt; {\n\n   <span class=\"keyword\">case</span> some(<span class=\"type\">T</span>)\n\n   <span class=\"keyword\">case</span> none\n\n}\n</code></pre></code></pre>\n<p>What's special here is, that the enum's <strong>associated values</strong> take the\ntype of the generic parameter <code>T</code>, so that optionals can be built for\nany kind you wish to return.</p>\n<p>Enums can have multiple generic parameters. Take the well-known\n<strong>Either</strong> type which is not part of Swift's standard library but\nimplemented in many open source libraries as well as prevalent in other\nfunctional programming languages like Haskell or F#. The idea is that\ninstead of just returning a value or no value (née Optional) you'd\nreturn either one of two different values.</p>\n<p>For example, if you parse user input, the user could enter a name or a number,\nin that case the type of <code>Either</code> would be <code>Either&lt;String, Int&gt;</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Either&lt;T1, T2&gt; {\n\n   <span class=\"keyword\">case</span> left(<span class=\"type\">T1</span>)\n\n   <span class=\"keyword\">case</span> right(<span class=\"type\">T2</span>)\n\n}\n</code></pre></code></pre>\n<p>Finally, all the type constraints that work on classes and structs in\nSwift also work on enums. Here, we have a type <code>Bag</code> that is either empty\nor contains an array of elements. Those elements <strong>have</strong> to be <code>Equatable</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Bag&lt;T: <span class=\"type\">Sequence</span>&gt; <span class=\"keyword\">where</span> <span class=\"type\">T</span>.<span class=\"type\">Iterator</span>.<span class=\"type\">Element</span>==<span class=\"type\">Equatable</span> {\n\n     <span class=\"keyword\">case</span> empty\n\n     <span class=\"keyword\">case</span> full(contents: [<span class=\"type\">T</span>)]\n\n}\n</code></pre></code></pre>\n<h1>Recursive / Indirect Types</h1>\n<p>Indirect types allow\nyou to define enums where the associated value of a <code>case</code> is the very\nsame enum again.</p>\n<p>As an example, consider that you want to define a file\nsystem representations with files and folders containing files. If\n<strong>File</strong> and <strong>Folder</strong> were enum cases, then the <strong>Folder</strong> case would\nneed to have an array of <strong>File</strong> cases as it's <code>associated value</code>. Since\nthis is a recursive operation, the compiler has to make special\npreparations for it. Quoting from the Swift documentation:</p>\n<blockquote>\n<p>Enums and cases can be marked indirect, which causes the associated\nvalue for the enum to be stored indirectly, allowing for recursive\ndata structures to be defined.</p>\n</blockquote>\n<p>So to implement our <strong>FileNode</strong> <code>enum</code>, we'd have to write it like\nthis:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> FileNode {\n\n   <span class=\"keyword\">case</span> file(name: <span class=\"type\">String</span>)\n\n   <span class=\"keyword\">indirect case</span> folder(name: <span class=\"type\">String</span>, files: [<span class=\"type\">FileNode</span>])\n\n}\n</code></pre></code></pre>\n<p>The <code>indirect</code> keyword tells the compiler to handle this <code>enum case</code>\nindirectly. You can also add the keyword for the whole enum. <a href=\"http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/\">As an\nexample imagine mapping a binary\ntree</a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">indirect enum</span> Tree&lt;Element: <span class=\"type\">Comparable</span>&gt; {\n\n     <span class=\"keyword\">case</span> empty\n\n     <span class=\"keyword\">case</span> node(<span class=\"type\">Tree</span>&lt;<span class=\"type\">Element</span>&gt;,<span class=\"type\">Element</span>,<span class=\"type\">Tree</span>&lt;<span class=\"type\">Element</span>&gt;)\n\n}\n</code></pre></code></pre>\n<p>This is a very powerful feature that allows you to map complex\nrelationships in a very clean way with an enum.</p>\n<h1>Custom Data Types</h1>\n<p>If we neglect <code>associated values</code>, then the value of an enum can only be\nan Integer, Floating Point, String, or Boolean. If you need to support\nsomething else, you can do so by implementing the\n<code>ExpressibleByStringLiteral</code> protocol which allows the type in question to\nbe serialized to and from String.</p>\n<p>As an example, imagine you'd like to store the different screen sizes\nof iOS devices in an enum:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Devices: <span class=\"type\">CGSize</span> {\n\n    <span class=\"keyword\">case</span> iPhone3GS = <span class=\"type\">CGSize</span>(width: <span class=\"number\">320</span>, height: <span class=\"number\">480</span>)\n\n    <span class=\"keyword\">case</span> iPhone5 = <span class=\"type\">CGSize</span>(width: <span class=\"number\">320</span>, height: <span class=\"number\">568</span>)\n\n    <span class=\"keyword\">case</span> iPhone6 = <span class=\"type\">CGSize</span>(width: <span class=\"number\">375</span>, height: <span class=\"number\">667</span>)\n\n    <span class=\"keyword\">case</span> iPhone6Plus = <span class=\"type\">CGSize</span>(width: <span class=\"number\">414</span>, height: <span class=\"number\">736</span>)\n\n}\n</code></pre></code></pre>\n<p>However, this doesn't compile because <code>CGSize</code> is not a <code>literal</code> and can't be\nused as an enum value. Instead, what you need to do is add a type\nextension for the <code>ExpressibleByStringLiteral</code> protocol.</p>\n<p>The protocol\nrequires us to implement an initializer that receives a <code>String</code>. Next, we need to\ntake this <code>String</code> an convert it into a <code>CGSize</code>. Not any <code>String</code> can be a <code>CGSize</code>.\nSo if the value is wrong, we will crash with an error as this code will be executed\nby Swift during application startup. Our string format for sizes is: <code>width,height</code></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">CGSize</span>: <span class=\"type\">ExpressibleByStringLiteral</span> {\n\n     <span class=\"keyword\">public init</span>(stringLiteral value: <span class=\"type\">String</span>) {\n\n         <span class=\"keyword\">let</span> components = rawValue.<span class=\"call\">split</span>(separator: \\<span class=\"string\">\"</span>,\\<span class=\"string\">\"</span>)\n\n         <span class=\"keyword\">guard</span> components.<span class=\"property\">count</span> == <span class=\"number\">2</span>,\n\n             <span class=\"keyword\">let</span> width = <span class=\"type\">Int</span>(components[<span class=\"number\">0</span>]),\n\n             <span class=\"keyword\">let</span> height = <span class=\"type\">Int</span>(components[<span class=\"number\">1</span>])\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">Format</span> \\(value)\\<span class=\"string\">\"</span>) }\n\n         <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(width: size.<span class=\"property\">width</span>, height: size.<span class=\"property\">height</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Now, we can write our <code>enum</code>, with one downside though: The initial\nvalues have to be written as a String, since that's what the enum will\nuse (remember, we complied with <code>ExpressibleByStringLiteral</code>, so that the\n<strong>String</strong> can be converted to our <code>CGSize</code> type.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Devices: <span class=\"type\">CGSize</span> {\n\n    <span class=\"keyword\">case</span> iPhone3GS = \\<span class=\"string\">\"320</span>,<span class=\"number\">480</span>\\<span class=\"string\">\"</span>\n\n    <span class=\"keyword\">case</span> iPhone5 = \\<span class=\"string\">\"320</span>,<span class=\"number\">568</span>\\<span class=\"string\">\"</span>\n\n    <span class=\"keyword\">case</span> iPhone6 = \\<span class=\"string\">\"375</span>,<span class=\"number\">667</span>\\<span class=\"string\">\"</span>\n\n    <span class=\"keyword\">case</span> iPhone6Plus = \\<span class=\"string\">\"414</span>,<span class=\"number\">736</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>This, finally, allows us to use our <code>CGSize</code> enum. Keep in mind that in\norder to get the actual <code>CGSize</code> value, we have to access the <code>rawValue</code>\nof the enum.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> a = <span class=\"type\">Devices</span>.<span class=\"property\">iPhone5</span>\n\n<span class=\"keyword\">let</span> b = a.<span class=\"property\">rawValue</span>\n\n<span class=\"call\">print</span>(\\<span class=\"string\">\"the</span> phone size string <span class=\"keyword\">is</span> \\(a), width <span class=\"keyword\">is</span> \\(b.<span class=\"property\">width</span>), height <span class=\"keyword\">is</span> \\(b.<span class=\"property\">height</span>)\\<span class=\"string\">\"</span>)\n</code></pre></code></pre>\n<p>This works, because we explicitly told Swift that a <code>CGSize</code> can be created\nfrom any <code>String</code>.</p>\n<p>A different option to hook into custom types it the <code>RawRepresentable</code> protocol, we will tackle this next.</p>\n<h1>Comparing Enums</h1>\n<p>Just like need to compare strings (<code>&quot;world&quot; == &quot;hello&quot;</code>) or numbers you sometimes also need to compare enums. For very simple ones, like the following, this is easy as Swift takes care of it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Toggle {\n\n   <span class=\"keyword\">case</span> on, off\n\n}\n\n\n\n<span class=\"type\">Toggle</span>.<span class=\"property\">on</span> == <span class=\"type\">Toggle</span>.<span class=\"property\">off</span>\n</code></pre></code></pre>\n<p>But what if you have a more complex <code>enum</code> with <code>associated values</code> like this one?</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character {\n\n   <span class=\"keyword\">case</span> warrior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>, strength: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, magic: <span class=\"type\">Int</span>, spells: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>If you'd try to compare to instances of <code>Character</code> Swift would complain. By default, it doesn't know how to compare <code>enum</code> types that have <code>associated values</code>. However, you can explicitly tell Swift to just compare all the values of each <code>case</code> and if they're the same, then the types are <code>equal</code>. To do that, you'd just add an empty conformance to the <code>Equatable</code> protocol:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character: <span class=\"type\">Equatable</span> {\n\n   <span class=\"keyword\">case</span> warrior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>, strength: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, magic: <span class=\"type\">Int</span>, spells: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>Just this one addition <code>Equatable</code> will allow you to compare your types. This only works if all the values in your cases are also <code>Equatable</code>. This works in our example as <code>Int</code>, <code>String</code> and arrays of <code>String</code> are <code>Equatable</code> by default.</p>\n<p>If you have a custom type that doesn't conform to <code>Equatable</code>, the above will not work:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Weapon { \n\n   <span class=\"keyword\">let</span> name: <span class=\"type\">String</span> \n\n}\n\n\n\n<span class=\"keyword\">enum</span> Character: <span class=\"type\">Equatable</span> {\n\n   <span class=\"keyword\">case</span> warrior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>, strength: <span class=\"type\">Int</span>, weapon: <span class=\"type\">Weapon</span>)\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, magic: <span class=\"type\">Int</span>, spells: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>In this case, Swift will complain that <code>Character</code> does not conform to <code>Equatable</code>. So the solution here is to also conform <code>Weapon</code> to <code>Equatable</code>.</p>\n<p>If that is not an option, you an always implement a custom <code>Equatable</code> conformance:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Not Equatable Stock</span>\n\n<span class=\"keyword\">struct</span> Stock { ... }\n\n<span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">Stock</span>, amount: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">Stock</span>, amount: <span class=\"type\">Int</span>)\n\n}\n\n<span class=\"keyword\">func</span> ==(lhs: <span class=\"type\">Trade</span>, rhs: <span class=\"type\">Trade</span>) -&gt; <span class=\"type\">Bool</span> {\n\n    <span class=\"keyword\">switch</span> (lhs, rhs) {\n\n    <span class=\"keyword\">case let</span> (.<span class=\"call\">buy</span>(stock1, amount1), .<span class=\"dotAccess\">buy</span>(stock2, amount2))\n\n          <span class=\"keyword\">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:\n\n          <span class=\"keyword\">return true</span>\n\n    <span class=\"keyword\">case let</span> (.<span class=\"call\">sell</span>(stock1, amount1), .<span class=\"dotAccess\">sell</span>(stock2, amount2))\n\n          <span class=\"keyword\">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:\n\n          <span class=\"keyword\">return true</span>\n\n    <span class=\"keyword\">default</span>: <span class=\"keyword\">return false</span>\n\n    }\n\n}\n</code></pre></code></pre>\n<p>As you can see, we're comparing the two possible <code>enum cases</code> via a\nswitch, and only if the cases match (i.e. .buy &amp; .buy) will we compare\nthe actual associated values.</p>\n<h1>Custom Initializers</h1>\n<p>Imagine you'd want to initialize an <code>enum</code> with custom data. In our example\nwe have a <code>Device</code> enum that represents Apple devices and we'd like to\nalso initialize them with non-standard names. Here's the <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">case</span> appleWatch\n\n}\n</code></pre></code></pre>\n<p>Now if a user accidentally enters <code>iWatch</code> as their device, we still want to map this\nto the correct <code>AppleWatch</code> case. To do that, we will implement a custom initializer\nthat sets <code>self</code> to the correct type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device { \n\n     <span class=\"keyword\">case</span> appleWatch \n\n     <span class=\"keyword\">init</span>?(term: <span class=\"type\">String</span>) {\n\n       <span class=\"keyword\">if</span> term == \\<span class=\"string\">\"iWatch</span>\\<span class=\"string\">\"</span> {\n\n           <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">appleWatch</span>\n\n       } <span class=\"keyword\">else</span> {\n\n           <span class=\"keyword\">return nil</span>\n\n       }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>In the above example, we used a failable initializer. However, normal\ninitializers work just as well:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> NumberCategory {\n\n    <span class=\"keyword\">case</span> small\n\n    <span class=\"keyword\">case</span> medium\n\n    <span class=\"keyword\">case</span> big\n\n    <span class=\"keyword\">case</span> huge\n\n\n\n    <span class=\"keyword\">init</span>(number n: <span class=\"type\">Int</span>) {\n\n         <span class=\"keyword\">if</span> n &lt; <span class=\"number\">10000</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">small</span> }\n\n         <span class=\"keyword\">else if</span> n &lt; <span class=\"number\">1000000</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">medium</span> }\n\n         <span class=\"keyword\">else if</span> n &lt; <span class=\"number\">100000000</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">big</span> }\n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">huge</span> }\n\n    }\n\n}\n</code></pre></code></pre>\n<h1>Iterating over Enum Cases</h1>\n<p>Say you've created a nice new enum with several cases:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Drink: <span class=\"type\">String</span> {\n\n   <span class=\"keyword\">case</span> coke, beer, water, soda, lemonade, wine, vodka, gin\n\n}\n</code></pre></code></pre>\n<p>Now, you'd like to display all of those drinks at runtime in a list. You somehow want to run a <code>for-each</code> loop over all of your enum cases. The <code>enum</code> type does not offer this ability out-of-the-box. Instead, you have to explicitly tell the Swift compiler that you wish for your enum to be iterable. You do this by conforming to the empty <code>CaseIterable</code> protocol:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Drink: <span class=\"type\">String</span>, <span class=\"type\">CaseIterable</span> {\n\n   <span class=\"keyword\">case</span> coke, beer, water, soda, lemonade, wine, vodka, gin\n\n}\n</code></pre></code></pre>\n<p>Now, you can easily iterate over your <code>enum</code> with the new <code>allCases</code> property:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for</span> drink <span class=\"keyword\">in</span> <span class=\"type\">Drink</span>.<span class=\"property\">allCases</span> {\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"For</span> lunch <span class=\"type\">I</span> like to drink \\(drink)\\)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>This works only if your <code>enum</code> cases do not contain any associated values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Drink: <span class=\"type\">CaseIterable</span> {\n\n   <span class=\"keyword\">case</span> beer \n\n   <span class=\"keyword\">case</span> cocktail(ingredients: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>This code will not compile and the reason for that is simple. The Swift compiler does not know how to construct the <code>cocktail</code> case. And for good reason, should it be a Gin Tonic, or a Cuba libre? You wouldn't want the Swift compiler to decide that, but it has to! Because in order for you use <code>allCases</code> it will need to return an <code>enum</code> case including associated values.</p>\n<p>So there it is, <code>CaseIterable</code> is a great Swift feature, however keep in mind that it can only be used with simple <code>enum</code> cases.</p>\n<h1>Objective-C Support</h1>\n<p>Integer-based enums such as can be bridged to Objective-c via the <code>@objc</code> attribute:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">@objc enum</span> Bit: <span class=\"type\">Int</span> { \n\n   <span class=\"keyword\">case</span> zero = <span class=\"number\">0</span> \n\n   <span class=\"keyword\">case</span> one = <span class=\"number\">1</span>\n\n}\n</code></pre></code></pre>\n<p>However once you venture away from\nintegers (say <code>String</code>) or start using <code>associated values</code> you can't\nuse enums from within Objective-C.</p>\n<p>There is a manual way though. Add two methods to your\n<code>enum</code>, define a type replacement on the <code>@objc</code> side, and you can move\n<code>enums</code> back and forth just fine, without having to conform to private\nprotocols:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n}\n\n\n\n<span class=\"comment\">// This type could also exist in Objective-C code.</span>\n\n<span class=\"keyword\">@objc class</span> ObjcTrade: <span class=\"type\">NSObject</span> {\n\n     <span class=\"keyword\">var</span> type: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">var</span> stock: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> amount: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">init</span>(type: <span class=\"type\">Int</span>, stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>) {\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">type</span> = type\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">stock</span> = stock\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">amount</span> = amount\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Trade</span>  {\n\n\n\n     <span class=\"keyword\">func</span> toObjc() -&gt; <span class=\"type\">ObjcTrade</span> {\n\n         <span class=\"keyword\">switch self</span> {\n\n         <span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount):\n\n             <span class=\"keyword\">return</span> <span class=\"type\">ObjcTrade</span>(type: <span class=\"number\">0</span>, stock: stock, amount: amount)\n\n         <span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount):\n\n             <span class=\"keyword\">return</span> <span class=\"type\">ObjcTrade</span>(type: <span class=\"number\">1</span>, stock: stock, amount: amount)\n\n         }\n\n     }\n\n\n\n     <span class=\"keyword\">static func</span> fromObjc(source: <span class=\"type\">ObjcTrade</span>) -&gt; <span class=\"type\">Trade</span>? {\n\n         <span class=\"keyword\">switch</span> (source.<span class=\"property\">type</span>) {\n\n         <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(stock: source.<span class=\"property\">stock</span>, amount: source.<span class=\"property\">amount</span>)\n\n         <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"type\">Trade</span>.<span class=\"call\">sell</span>(stock: source.<span class=\"property\">stock</span>, amount: source.<span class=\"property\">amount</span>)\n\n         <span class=\"keyword\">default</span>: <span class=\"keyword\">return nil</span>\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This still has the downside that you need to mirror your <code>enum</code> via an\n<code>NSObject</code> based type on the Objective-C side (or you could just go and\nuse an <code>NSDictionary</code>), but if you ever end up in a situation where you\n<strong>need</strong> to access an enum with associated values from Objective-C, this\nis a way to do it.</p>\n<h1>Enums in the Standard Library test</h1>\n<p>Before we go on and explore various use cases for enums in your\nprojects, it might be tempting to see some of the enums being used in\nthe Swift standard library, so let's have a look.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit\"><strong>Bit</strong></a>\nThe <code>Bit</code> enum can have two possible values, <strong>One</strong>, and <strong>Zero</strong>. It\nis used as the <code>Index</code> type for <code>CollectionOfOne&lt;T&gt;</code>.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_\"><strong>FloatingPointClassification</strong></a>\nThis enum defines the set of possible IEEE 754 &quot;classes&quot;, like\n<code>NegativeInfinity</code>, <code>PositiveZero</code>, or <code>SignalingNaN</code>.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation\"><strong>Mirror.AncestorRepresentation</strong></a>,\nand\n<a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle\"><strong>Mirror.DisplayStyle</strong></a>\nThese two are used in the context of the Swift Reflection API.</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq\"><strong>Optional</strong></a>\nNot much to say here</p>\n<p><a href=\"https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process\"><strong>Process</strong></a>\nThe Process enum contains the command line arguments of the current\nprocess (<code>Process.argc</code>, <code>Process.arguments</code>). This is a particularly\ninteresting <code>enum</code> as it used to be a <code>struct</code> in Swift 1.0.</p>\n<h1>Practical Usecases</h1>\n<p>We've already seen a couple of useful <code>enums</code> in the previous feature\ndescriptions. Examples would be <code>Optional</code>, <code>Either</code>,\n<code>FileNode</code>, or the binary tree. However, there're many more scenarios\nwhere using an <code>enum</code> wins over a <code>struct</code> or <code>class</code>. Usually, if your\nproblem domain can be divided into a finite set of distinctive\ncategories, an <code>enum</code> may be the right choice. Even only two cases are a\nperfectly valid scenario for an enum, as the Optional and Either types\nshow.</p>\n<p>Here, then, are some more examples of practical <code>enum</code> usage to fuel\nyour creativity.</p>\n<h1>Error Handling</h1>\n<p>One of the prime examples of Enum usage in Swift is, of course, the new\nerror handling in Swift 2.0. Your throwing function can throw anything\nwhich conforms to the empty <code>ErrorType</code> protocol. As the Swift\ndocumentation succinctly observes:</p>\n<blockquote>\n<p>Swift enumerations are particularly well suited to modeling a group of\nrelated error conditions, with associated values allowing for\nadditional information about the nature of an error to be\ncommunicated.</p>\n</blockquote>\n<p>As an example, have a look at the popular <a href=\"https://github.com/thoughtbot/Argo\">JSON Decoding library\nArgo</a>. When their JSON Decoding\nfails, it can fail due to two primary reasons.</p>\n<ol>\n<li>The JSON Data lacks a key which the end model requires (say your\nmodel has a property <code>username</code> and somehow the JSON lacks that)</li>\n<li>There's a type mismatch. Say instead of a String the <code>username</code>\nproperty in the JSON contains an <code>NSNull</code> <sup class=\"footnote-reference\"><a href=\"#6\">1</a></sup>.</li>\n</ol>\n<p>In addition to that, Argo also includes a custom error for anything not\nfitting in these two categories above. Their <code>ErrorType enum</code> looks like\nthis:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> DecodeError: <span class=\"type\">Error</span> {\n\n   <span class=\"keyword\">case</span> typeMismatch(expected: <span class=\"type\">String</span>, actual: <span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> missingKey(<span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> custom(<span class=\"type\">String</span>)\n\n}\n</code></pre></code></pre>\n<p>All cases have associated values that contain additional information\nabout the error in question.</p>\n<p>A more general <code>ErrorType</code> for complete HTTP / REST API handling could\nlook like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> APIError : <span class=\"type\">Error</span> {\n\n     <span class=\"comment\">// Can't connect to the server (maybe offline?)</span>\n\n     <span class=\"keyword\">case</span> connectionError(error: <span class=\"type\">NSError</span>)\n\n     <span class=\"comment\">// The server responded with a non 200 status code</span>\n\n     <span class=\"keyword\">case</span> serverError(statusCode: <span class=\"type\">Int</span>, error: <span class=\"type\">NSError</span>)\n\n     <span class=\"comment\">// We got no data (0 bytes) back from the server</span>\n\n     <span class=\"keyword\">case</span> noDataError\n\n     <span class=\"comment\">// The server response can't be converted from JSON to a Dictionary</span>\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONSerializationError</span>(error: <span class=\"type\">Error</span>)\n\n     <span class=\"comment\">// The Argo decoding Failed</span>\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONMappingError</span>(converstionError: <span class=\"type\">DecodeError</span>)\n\n}\n</code></pre></code></pre>\n<p>This <code>ErrorType</code> implements the complete REST Stack up to the point\nwhere your app would get the completely decoded native <code>struct</code> or\n<code>class</code> object.</p>\n<p>More information on <code>ErrorType</code> and more <code>enum</code> examples in this context\ncan be found in the official documentation\n<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html\">here</a>.</p>\n<h1>Observer Pattern</h1>\n<p>There're various ways of modelling observation in Swift. If you include\n<code>@objc</code> compatibility, you can use <code>NotificationCenter</code> or <strong>KVO</strong>.\nEven if not, the <code>didSet</code> syntax makes it easy to implement simple\nobservation. Enums can be used here in order to make the type of change\nthat happens to the observed object clearer. Imagine collection\nobservation. If we think about it, we only have a couple of possible\ncases: One or more items are inserted, one or more items are deleted,\none or more items are updated. This sounds like a job for an enum:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Change {\n\n      <span class=\"keyword\">case</span> insertion(items: [<span class=\"type\">Item</span>])\n\n      <span class=\"keyword\">case</span> deletion(items: [<span class=\"type\">Item</span>])\n\n      <span class=\"keyword\">case</span> update(items: [<span class=\"type\">Item</span>])\n\n}\n</code></pre></code></pre>\n<p>Then, the observing object can receive the concrete information of what\nhappened in a very clean way. This could easily be extended by adding\n<strong>oldValue</strong> and <strong>newValue</strong>, too.</p>\n<h1>Status Codes</h1>\n<p>If you're working with an outside system which uses status codes (or\nerror codes) to convey information, like HTTP Status Codes, enums are\nobviously a great way to encode the information. <sup class=\"footnote-reference\"><a href=\"#7\">1</a></sup></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> HttpError: <span class=\"type\">String</span> {\n\n   <span class=\"keyword\">case</span> code400 = \\<span class=\"string\">\"Bad</span> <span class=\"type\">Request</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code401 = \\<span class=\"string\">\"Unauthorized</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code402 = \\<span class=\"string\">\"Payment</span> <span class=\"type\">Required</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code403 = \\<span class=\"string\">\"Forbidden</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code404 = \\<span class=\"string\">\"Not</span> <span class=\"type\">Found</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<h1>Result Types</h1>\n<p>Enums are also frequently used to map the result of JSON parsing into\nthe Swift type system. Here's a short example of this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> JSON {\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONString</span>(<span class=\"type\">Swift</span>.<span class=\"type\">String</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONNumber</span>(<span class=\"type\">Double</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONObject</span>([<span class=\"type\">String</span> : <span class=\"type\">JSONValue</span>])\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONArray</span>([<span class=\"type\">JSONValue</span>])\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONBool</span>(<span class=\"type\">Bool</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">JSONNull</span>\n\n}\n</code></pre></code></pre>\n<p>Similarly, if you're parsing something else, you may use the very same\nstructure to convert your parsing results into Swift types. This also\nmakes perfect sense to only do it during the parsing / processing step\nand then taking the <code>JSON enum</code> representation and converting it into\none of your application's internal <code>class</code> or <code>struct</code> types.</p>\n<h1>UIKit Identifiers</h1>\n<p>Enums can be used to map reuse identifiers or storyboard identifiers\nfrom stringly typed information to something the type checker can\nunderstand. Imagine a UITableView with different prototype cells:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> CellType: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">case</span> buttonValueCell = \\<span class=\"string\">\"ButtonValueCell</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> unitEditCell = \\<span class=\"string\">\"UnitEditCell</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> labelCell = \\<span class=\"string\">\"LabelCell</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> resultLabelCell = \\<span class=\"string\">\"ResultLabelCell</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<h1>Units</h1>\n<p>Units and unit conversion are another nice use case for enums. You can\nmap the units and their respective values and then add methods to do\nautomatic conversions. Here's an oversimplified example.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Liquid: <span class=\"type\">Float</span> {\n\n   <span class=\"keyword\">case</span> ml = <span class=\"number\">1.0</span>\n\n   <span class=\"keyword\">case</span> l = <span class=\"number\">1000.0</span>\n\n   <span class=\"keyword\">func</span> convert(amount: <span class=\"type\">Float</span>, to: <span class=\"type\">Liquid</span>) -&gt; <span class=\"type\">Float</span> {\n\n       <span class=\"keyword\">if self</span>.<span class=\"property\">rawValue</span> &lt; to.<span class=\"property\">rawValue</span> {\n\n          <span class=\"keyword\">return</span> (<span class=\"keyword\">self</span>.<span class=\"property\">rawValue</span> / to.<span class=\"property\">rawValue</span>) * amount\n\n       } <span class=\"keyword\">else</span> {\n\n          <span class=\"keyword\">return</span> (<span class=\"keyword\">self</span>.<span class=\"property\">rawValue</span> * to.<span class=\"property\">rawValue</span>) * amount\n\n       }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Another example of this would be Currency conversion. Also, mathematical\nsymbols (such as degrees vs radians) can benefit from this.</p>\n<h1>Games</h1>\n<p>Enums are a great use case for games, where many entities on screen\nbelong to a specific family of items (enemies, obstacles, textures,\n...). In comparison to native iOS or Mac apps, games oftentimes are a\ntabula rasa. Meaning you invent a new world with new relationships and\nnew kinds of objects, whereas on iOS or OSX you're using a well-defined\nworld of <code>UIButtons</code>, <code>UITableViews</code>, <code>UITableViewCells</code> or <code>NSStackView</code>.</p>\n<p>What's more, since Enums can conform to protocols, you can utilize\nprotocol extensions and protocol based programming to add functionality\nto the various enums that you defined for your game. Here's a short\nexample that tries to display such a hierarchy:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> FlyingBeast { <span class=\"keyword\">case</span> dragon, hippogriff, gargoyle }\n\n<span class=\"keyword\">enum</span> Horde { <span class=\"keyword\">case</span> ork, troll }\n\n<span class=\"keyword\">enum</span> Player { <span class=\"keyword\">case</span> mage, warrior, barbarian }\n\n<span class=\"keyword\">enum</span> NPC { <span class=\"keyword\">case</span> vendor, blacksmith }\n\n<span class=\"keyword\">enum</span> Element { <span class=\"keyword\">case</span> tree, fence, stone }\n\n\n\n<span class=\"keyword\">protocol</span> Hurtable {}\n\n<span class=\"keyword\">protocol</span> Killable {}\n\n<span class=\"keyword\">protocol</span> Flying {}\n\n<span class=\"keyword\">protocol</span> Attacking {}\n\n<span class=\"keyword\">protocol</span> Obstacle {}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">FlyingBeast</span>: <span class=\"type\">Hurtable</span>, <span class=\"type\">Killable</span>, <span class=\"type\">Flying</span>, <span class=\"type\">Attacking</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Horde</span>: <span class=\"type\">Hurtable</span>, <span class=\"type\">Killable</span>, <span class=\"type\">Attacking</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Player</span>: <span class=\"type\">Hurtable</span>, <span class=\"type\">Obstacle</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">NPC</span>: <span class=\"type\">Hurtable</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Element</span>: <span class=\"type\">Obstacle</span> {}\n</code></pre></code></pre>\n<h1>Stringly Typed Code</h1>\n<p>In bigger Xcode projects, you're quickly accumulating lots of resources\nwhich are accessed by string. We've already mentioned reuse identifiers\nand storyboard identifiers above, but there's also: Images, Segues,\nNibs, Fonts, and other resources. Oftentimes, those resources can be\ngrouped into several distinct sets. If that's the case, a <code>String</code>\ntyped <code>enum</code> is a good way of having the compiler check this for you.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> DetailViewImages: <span class=\"type\">String</span> {\n\n   <span class=\"keyword\">case</span> background = \\<span class=\"string\">\"bg1</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> sidebar = \\<span class=\"string\">\"sbg</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> actionButton1 = \\<span class=\"string\">\"btn1_1</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> actionButton2 = \\<span class=\"string\">\"btn2_1</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>For iOS users, <a href=\"https://github.com/mac-cain13/R.swift\">there's also R.swift which auto generates <code>structs</code> for\nmost of those use cases.</a>\nSometimes you may need more control though (or you may be on a Mac <sup class=\"footnote-reference\"><a href=\"#8\">1</a></sup>)</p>\n<h1>API Endpoints</h1>\n<p>Rest APIs are a great use case for enums. They're naturally grouped,\nthey're limited to a finite set of APIs, and they may have additional\nquery or named parameters which can be modelled through associated\nvalues.</p>\n<p>Take, for example, a look at a simplified version of the <a href=\"https://instagram.com/developer/endpoints/media/\"><strong>Instagram\nAPI</strong></a></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Instagram {\n\n   <span class=\"keyword\">enum</span> Media {\n\n     <span class=\"keyword\">case</span> popular\n\n     <span class=\"keyword\">case</span> shortcode(id: <span class=\"type\">String</span>)\n\n     <span class=\"keyword\">case</span> search(lat: <span class=\"type\">Float</span>, \n\n                 min_timestamp: <span class=\"type\">Int</span>, \n\n                 lng: <span class=\"type\">Float</span>, \n\n                 max_timestamp: <span class=\"type\">Int</span>, \n\n                 distance: <span class=\"type\">Int</span>)\n\n   }\n\n   <span class=\"keyword\">enum</span> Users {\n\n     <span class=\"keyword\">case</span> user(id: <span class=\"type\">String</span>)\n\n     <span class=\"keyword\">case</span> feed\n\n     <span class=\"keyword\">case</span> recent(id: <span class=\"type\">String</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p><a href=\"https://github.com/Moya/Moya\">Ash Furrow's <strong>Moya</strong> library</a> is based\naround this idea of using <code>enums</code> to map rest endpoints.</p>\n<h1>Linked Lists</h1>\n<p><a href=\"http://airspeedvelocity.net/tag/swift/\">Airspeed Velocity has a great writeup on how to implement a Linked List\nwith an <code>enum</code>.</a> Most of the\ncode in his post goes far beyond enums and touches a lot of interesting\ntopics <sup class=\"footnote-reference\"><a href=\"#9\">1</a></sup>, but the basis of his linked list looks kinda like this (I\nsimplified it a bit):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> List {\n\n     <span class=\"keyword\">case</span> end\n\n     <span class=\"keyword\">indirect case</span> node(<span class=\"type\">Int</span>, next: <span class=\"type\">List</span>)\n\n}\n</code></pre></code></pre>\n<p>Each <code>node case</code> points to the next case, and by using an <code>enum</code> instead\nof something else, you don't have to use an optional for the <code>next</code>\nvalue to signify the termination of the list.</p>\n<p>Airspeed Velocity also wrote a great post about the implementation of a\nred black tree with indirect Swift enums, so while you're already\nreading his blog, <a href=\"http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/\">you may just as well also read this\none.</a></p>\n<h1>Settings</h1>\n<p><a href=\"http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign%3DSwift%252BSandbox&amp;utm_medium%3Demail&amp;utm_source%3DSwift_Sandbox_12\">This is a very, very smart solution that Erica Sadun came up\nwith</a>.\nBasically whenever you'd use a dictionary of attribute keys as a way to\nconfigure an item, you'd instead use a <code>Set</code> of enums with associated\nvalues. That way, the type checker can confirm that your configuration\nvalues are of the correct type.</p>\n<p><a href=\"http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign%3DSwift%252BSandbox&amp;utm_medium%3Demail&amp;utm_source%3DSwift_Sandbox_12\">For more details, and proper examples, check out her original blog\npost.</a></p>\n<h1>Limitations</h1>\n<h2>Tuples</h2>\n<p>The biggest issue is, Tuple support.\nI love tuples, they make many things easier, but they're currently\nunder-documented and cannot be used in many scenarios. In terms of\nenums, you can't have tuples as the enum value:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Devices: (intro: <span class=\"type\">Int</span>, name: <span class=\"type\">String</span>) {\n\n   <span class=\"keyword\">case</span> iPhone = (intro: <span class=\"number\">2007</span>, name: \\<span class=\"string\">\"iPhone</span>\\<span class=\"string\">\"</span>)\n\n   <span class=\"keyword\">case</span> appleTV = (intro: <span class=\"number\">2006</span>, name: \\<span class=\"string\">\"Apple</span> <span class=\"type\">TV</span>\\<span class=\"string\">\"</span>)\n\n   <span class=\"keyword\">case</span> appleWatch = (intro: <span class=\"number\">2014</span>, name: \\<span class=\"string\">\"Apple</span> <span class=\"type\">Watch</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>This may not look like the best example, but once you start using enums,\nyou'll often end up in situations where you'd like to be able to do\nsomething like the above.</p>\n<h2>Default Associated Values</h2>\n<p>Another thing which you may run into is that associated values are\nalways types but you can't set a default value for those types. Imagine\nsuch an example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Characters {\n\n   <span class=\"keyword\">case</span> mage(health: <span class=\"type\">Int</span> = <span class=\"number\">70</span>, magic: <span class=\"type\">Int</span> = <span class=\"number\">100</span>, strength: <span class=\"type\">Int</span> = <span class=\"number\">30</span>)\n\n   <span class=\"keyword\">case</span> warrior(health: <span class=\"type\">Int</span> = <span class=\"number\">100</span>, magic: <span class=\"type\">Int</span> = <span class=\"number\">0</span>, strength: <span class=\"type\">Int</span> = <span class=\"number\">100</span>)\n\n   <span class=\"keyword\">case</span> neophyte(health: <span class=\"type\">Int</span> = <span class=\"number\">50</span>, magic: <span class=\"type\">Int</span> = <span class=\"number\">20</span>, strength: <span class=\"type\">Int</span> = <span class=\"number\">80</span>)\n\n}\n</code></pre></code></pre>\n<p>You could still create new cases with different values, but the default\nsettings for your character would be mapped.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2015-09-30-getting-iphone6s-foundry-from-swift.md":["ee6e3e5c1b541295",{"identifier":"80699779","filename":"2015-09-30-getting-iphone6s-foundry-from-swift.md","info":{"title":"Getting your iPhone 6s Chip Foundry from Swift","tags":[],"keywords":["swift","iphone6s","iphone","tsmc","samsung","gestalt","private","api","foundation"],"category":["Hands On","All"],"created":"2015-09-30 10:30:30","description":"This quickly explains how you use private apis from Swift in order to figure out the manufacturer of your fancy new iPhone 6S CPU","description_html":"<p>This quickly explains how you use private apis from Swift in order to figure out the manufacturer of your fancy new iPhone 6S CPU</p>\n","published":true,"slug":"2015-09-30-getting-iphone6s-foundry-from-swift.html","meta":{"feature_image":"https://appventure.me/img-content/2015-09-30-getting-iphone6s-foundry-from-swift-feature-image.jpg","swift_version":"5.0"},"created_timestamp":1443609030,"date":"2015-09-30T10:30:30","date_info":{"year":2015,"month":9,"day":30,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2015-09-30-getting-iphone6s-foundry-from-swift.html","content":"<p><a href=\"https://github.com/WDUK/A9ChipSource\">Here's a small Github project by\nWUD</a> which uses the private\n<a href=\"https://gist.github.com/Cykey/5216992\">libMobileGestalt</a> to identify\nthe manufacturer of the CPU in your fancy new iPhone 6S. Because, as you\nmay not know, this year Apple is sourcing the chips from two different\nfoundries: Samsung and TSMC. So which one did you get? You could, of\ncourse, just run the aforementioned GitHub project on your phone.\nHowever, that's all Objective-C and out of curiosity I wondered: How\nwould you pull that off in Swift?</p>\n<h1>Step One: Adding a header</h1>\n<p>The first obstacle is already a tricky one. <code>LibMobileGestalt</code> doesn't\noffer a header as it is a private library. So how do you tell Swift /\nthe linker that the function you want to call will indeed exist at\ncompile time. At first glance it seems that pure Swift doesn't offer\nany facilities for this (if you're impatient, there's another solution\nbelow ;-), so we can always resort back to the <a href=\"https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html\">Bridging\nHeader</a>\nthat Apple introduced to easily bridge the Swift and the Objective-C/C\nworlds. <a href=\"https://bohemianpolymorph.wordpress.com/2014/07/11/manually-adding-a-swift-bridging-header/\">Here\nis</a>\na short guide on how to add a bridging header to your project. Basically\nadd a new header file, and add the path to your target's Build Settings\nunder <code>Objective-C Bridging Header</code>.</p>\n<p>Then, add the following code to your header:</p>\n<pre class=\"C\"><code><span class=\"techousource techouc\"><span class=\"techoumeta techoupreprocessor techouc\"><span class=\"techoukeyword techoucontrol techouimport techouc\">#if</span> __cplusplus\n</span><span class=\"techoustorage techoumodifier techouc\">extern</span> <span class=\"techoustring techouquoted techoudouble techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&quot;</span>C<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&quot;</span></span> <span class=\"techoumeta techoublock techouc\"><span class=\"techoupunctuation techousection techoublock techoubegin techouc\">{</span>\n<span class=\"techoumeta techoublock techouc\"><span class=\"techoumeta techoupreprocessor techouc\"><span class=\"techoukeyword techoucontrol techouimport techouc\">#endif</span></span></span></span><span class=\"techoumeta techoublock techouc\">\n    CFPropertyListRef <span class=\"techoumeta techoufunction-call techouc\"><span class=\"techouvariable techoufunction techouc\">MGCopyAnswer</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\">CFStringRef property</span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n<span class=\"techoumeta techoupreprocessor techouc\"><span class=\"techoukeyword techoucontrol techouimport techouc\">#if</span></span></span> __cplusplus\n<span class=\"techoupunctuation techousection techoublock techouend techouc\">}</span>\n<span class=\"techoumeta techoupreprocessor techouc\"><span class=\"techoukeyword techoucontrol techouimport techouc\">#endif</span></span>\n</span></code></pre></code></pre>\n<p>But what if you're writing a pure Swift project and don't want to add\na bridging header? There's a mostly undocumented (<a href=\"https://news.ycombinator.com/item?id%3D10305664\">Thanks to someone on\nHN for pointing it out to\nme</a>) Swift attribute\ncalled <code>@asmname</code> that allows us to do something similar straight in\nSwift. <a href=\"http://www.russbishop.net/swift-don-t-do-this\">Russ Bishop has a post on this and much more you can do in this\nrealm.</a></p>\n<p>Using the <code>@asmname</code> keyword, the code looks like this (and you can\nremove the bridging header):</p>\n<p>With Swift 3, <code>@asmname</code> has been renamed to <code>@_silgen_name</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">@_silgen_name</span>(\\<span class=\"string\">\"MGCopyAnswer</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">func</span> MGCopyAnswer(<span class=\"keyword\">_</span>: <span class=\"type\">CFStringRef</span>) -&gt; <span class=\"type\">Optional</span>&lt;<span class=\"type\">Unmanaged</span>&lt;<span class=\"type\">CFPropertyListRef</span>&gt;&gt;;\n</code></pre></code></pre>\n<p>We're basically telling Swift that this function exists, and we're\ntelling it specifically what it requires and what it will return.</p>\n<h1>Step Two: Writing Swift</h1>\n<p>Next up, we want to write the Swift code to call this function, so\nlet's do it:</p>\n<pre class=\"Swift\"><code>chipInfo = <span class=\"type\">MGCopyAnswer</span>(\\<span class=\"string\">\"HardwarePlatform</span>\\<span class=\"string\">\"</span>)\n</code></pre></code></pre>\n<p>We might expect that the result of this is already the required\n<code>String</code>, but Swift is a safe language so first of all it is returning\nan <code>Optional</code> here, since the key in question (&quot;HardwarePlatform&quot;)\nmight not even exist. We first have to get the value out. To do that,\nwe'll use the new Swift 2 <code>guard</code> statement.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> chipInfo = <span class=\"type\">MGCopyAnswer</span>(\\<span class=\"string\">\"HardwarePlatform</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Could</span> not read hardware\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<p>If we look at the type of <code>chipInfo</code>, sadly, we still don't have a\n<code>String</code>. Instead, we're getting <code>Unmanaged&lt;CFPropertyList&gt;</code>. What's\nthat?</p>\n<p>The Apple Documentation has this to say about <code>Unmanaged</code>:</p>\n<blockquote>\n<p>A type for propagating an unmanaged object reference.</p>\n<p>When you use this type, you become partially responsible for keeping\nthe object alive.</p>\n</blockquote>\n<p>Of course, we're getting a value from the Core Foundation world where\nARC does not know how to manage the memory. Objective-C uses the\n<code>__bridge</code> keyword to manage this, and in Swift it smartly changes the\ntype so that we definitely don't forget that this variable's memory is\ncurrently not managed. <a href=\"http://nshipster.com/unmanaged/\">NSHipster</a>, and\n<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_Unmanaged_Structure/index.html\">Apple</a>\nhave more documentation for this. What we'll do is call the\n<code>takeRetainedValue</code> method:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> chipInfo = <span class=\"type\">MGCopyAnswer</span>(\\<span class=\"string\">\"HardwarePlatform</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Could</span> not read hardware\\<span class=\"string\">\"</span>) }\n\nchipInfo.<span class=\"call\">takeRetainedValue</span>()\n</code></pre></code></pre>\n<p>So, do we finally have a String? No, but we're close. We're getting a\n<code>CFPropertyList</code> object back. The Apple Documentation has this to say\nabout this type:</p>\n<blockquote>\n<p>CFPropertyListRef can be a reference to any of the property list\nobjects: CFData, CFString, CFArray, CFDictionary, CFDate, CFBoolean,\nand CFNumber.</p>\n</blockquote>\n<p>This means that if the result is indeed of type <code>CFString</code>, since\n<code>CFString</code> is toll-free-bridged to <code>NSString</code> and since <code>NSString</code> is\nbridged to Swift's <code>String</code>, we could just force cast this to the\n<code>String</code> type and be done with it. Swift is a safe language however, and\nwhen possible we should strive to do everything the safe way. So instead\nwe'll do an optional cast to String and if that works out, we can get\nthe actual String value out of the <code>Optional</code>.</p>\n<p>If we do it this way, it will not blow up when the contents of the\nreference are, say, a <code>CFDate</code> or a <code>CFBoolean</code>. This is particularly\neasy with <a href=\"lnk::switch\">Swift's Pattern Matching\nsyntax</a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> chipInfo = <span class=\"type\">MGCopyAnswer</span>(\\<span class=\"string\">\"HardwarePlatform</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Could</span> not read hardware\\<span class=\"string\">\"</span>) }\n\n\n\n<span class=\"keyword\">switch</span> chipInfo.<span class=\"call\">takeRetainedValue</span>() <span class=\"keyword\">as</span>? <span class=\"type\">String</span> {\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"s8000</span>\\<span class=\"string\">\"</span>?:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"Samsung</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"s8003</span>\\<span class=\"string\">\"</span>?:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"TSMC</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"Unknown</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>The question mark at the end of the two codes <strong>(&quot;s8000&quot;?)</strong> signifies\nthat we're not matching against a <code>String</code>, but against an\n<code>Optional&lt;String&gt;</code>.</p>\n<h1>Step Three: Add the Framework</h1>\n<p>There we are. Awesome it works. Except, it doesn't. You still have to\nadd the <code>libMobileGestalt.tbd</code> library and the <code>Core Foundation</code>\nframework to your project target's <code>Linked Frameworks and Libraries</code>.</p>\n<p>I've <a href=\"https://github.com/terhechte/SwiftiPhone6sChipFinder\">also created a small GitHub project that includes all\nthis</a> including\nthe correct library setup etc.</p>\n","raw_content":"[frontMatter]\ndescription = \"This quickly explains how you use private apis from Swift in order to figure out the manufacturer of your fancy new iPhone 6S CPU\"\ntitle = \"Getting your iPhone 6s Chip Foundry from Swift\"\ncreated = \"2015-09-30\"\npublished = true\nkeywords = [\"swift\", \"iphone6s\", \"iphone\", \"tsmc\", \"samsung\", \"gestalt\", \"private\", \"api\", \"foundation\"]\nslug = \"2015-09-30-getting-iphone6s-foundry-from-swift.html\"\ntags = []\ncategory = [\"Hands On\", \"All\"]\n\n[meta]\nswift_version = \"5.0\"\nfeature_image = \"https://appventure.me/img-content/2015-09-30-getting-iphone6s-foundry-from-swift-feature-image.jpg\"\n---\n\n[Here\\'s a small Github project by\nWUD](https://github.com/WDUK/A9ChipSource) which uses the private\n[libMobileGestalt](https://gist.github.com/Cykey/5216992) to identify\nthe manufacturer of the CPU in your fancy new iPhone 6S. Because, as you\nmay not know, this year Apple is sourcing the chips from two different\nfoundries: Samsung and TSMC. So which one did you get? You could, of\ncourse, just run the aforementioned GitHub project on your phone.\nHowever, that\\'s all Objective-C and out of curiosity I wondered: How\nwould you pull that off in Swift?\n\n# Step One: Adding a header\n\nThe first obstacle is already a tricky one. `LibMobileGestalt` doesn\\'t\noffer a header as it is a private library. So how do you tell Swift /\nthe linker that the function you want to call will indeed exist at\ncompile time. At first glance it seems that pure Swift doesn\\'t offer\nany facilities for this (if you\\'re impatient, there\\'s another solution\nbelow ;-), so we can always resort back to the [Bridging\nHeader](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)\nthat Apple introduced to easily bridge the Swift and the Objective-C/C\nworlds. [Here\nis](https://bohemianpolymorph.wordpress.com/2014/07/11/manually-adding-a-swift-bridging-header/)\na short guide on how to add a bridging header to your project. Basically\nadd a new header file, and add the path to your target\\'s Build Settings\nunder `Objective-C Bridging Header`.\n\nThen, add the following code to your header:\n\n``` C\n#if __cplusplus\nextern \"C\" {\n#endif\n    CFPropertyListRef MGCopyAnswer(CFStringRef property);\n#if __cplusplus\n}\n#endif\n```\n\nBut what if you\\'re writing a pure Swift project and don\\'t want to add\na bridging header? There\\'s a mostly undocumented ([Thanks to someone on\nHN for pointing it out to\nme](https://news.ycombinator.com/item?id%3D10305664)) Swift attribute\ncalled `@asmname` that allows us to do something similar straight in\nSwift. [Russ Bishop has a post on this and much more you can do in this\nrealm.](http://www.russbishop.net/swift-don-t-do-this)\n\nUsing the `@asmname` keyword, the code looks like this (and you can\nremove the bridging header):\n\nWith Swift 3, `@asmname` has been renamed to `@_silgen_name`.\n\n``` Swift\n@_silgen_name(\"MGCopyAnswer\")\nfunc MGCopyAnswer(_: CFStringRef) -> Optional<Unmanaged<CFPropertyListRef>>;\n```\n\nWe\\'re basically telling Swift that this function exists, and we\\'re\ntelling it specifically what it requires and what it will return.\n\n# Step Two: Writing Swift\n\nNext up, we want to write the Swift code to call this function, so\nlet\\'s do it:\n\n``` Swift\nchipInfo = MGCopyAnswer(\"HardwarePlatform\")\n```\n\nWe might expect that the result of this is already the required\n`String`, but Swift is a safe language so first of all it is returning\nan `Optional` here, since the key in question (\\\"HardwarePlatform\\\")\nmight not even exist. We first have to get the value out. To do that,\nwe\\'ll use the new Swift 2 `guard` statement.\n\n``` Swift\nguard let chipInfo = MGCopyAnswer(\"HardwarePlatform\")\n    else { fatalError(\"Could not read hardware\") }\n```\n\nIf we look at the type of `chipInfo`, sadly, we still don\\'t have a\n`String`. Instead, we\\'re getting `Unmanaged<CFPropertyList>`. What\\'s\nthat?\n\nThe Apple Documentation has this to say about `Unmanaged`:\n\n> A type for propagating an unmanaged object reference.\n>\n> When you use this type, you become partially responsible for keeping\n> the object alive.\n\nOf course, we\\'re getting a value from the Core Foundation world where\nARC does not know how to manage the memory. Objective-C uses the\n`__bridge` keyword to manage this, and in Swift it smartly changes the\ntype so that we definitely don\\'t forget that this variable\\'s memory is\ncurrently not managed. [NSHipster](http://nshipster.com/unmanaged/), and\n[Apple](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_Unmanaged_Structure/index.html)\nhave more documentation for this. What we\\'ll do is call the\n`takeRetainedValue` method:\n\n``` Swift\nguard let chipInfo = MGCopyAnswer(\"HardwarePlatform\")\n    else { fatalError(\"Could not read hardware\") }\nchipInfo.takeRetainedValue()\n```\n\nSo, do we finally have a String? No, but we\\'re close. We\\'re getting a\n`CFPropertyList` object back. The Apple Documentation has this to say\nabout this type:\n\n> CFPropertyListRef can be a reference to any of the property list\n> objects: CFData, CFString, CFArray, CFDictionary, CFDate, CFBoolean,\n> and CFNumber.\n\nThis means that if the result is indeed of type `CFString`, since\n`CFString` is toll-free-bridged to `NSString` and since `NSString` is\nbridged to Swift\\'s `String`, we could just force cast this to the\n`String` type and be done with it. Swift is a safe language however, and\nwhen possible we should strive to do everything the safe way. So instead\nwe\\'ll do an optional cast to String and if that works out, we can get\nthe actual String value out of the `Optional`.\n\nIf we do it this way, it will not blow up when the contents of the\nreference are, say, a `CFDate` or a `CFBoolean`. This is particularly\neasy with [Swift\\'s Pattern Matching\nsyntax](lnk::switch):\n\n``` Swift\nguard let chipInfo = MGCopyAnswer(\"HardwarePlatform\")\n    else { fatalError(\"Could not read hardware\") }\n\nswitch chipInfo.takeRetainedValue() as? String {\ncase \"s8000\"?:\n    print(\"Samsung\")\ncase \"s8003\"?:\n    print(\"TSMC\")\ndefault:\n    print(\"Unknown\")\n}\n```\n\nThe question mark at the end of the two codes **(\\\"s8000\\\"?)** signifies\nthat we\\'re not matching against a `String`, but against an\n`Optional<String>`.\n\n# Step Three: Add the Framework\n\nThere we are. Awesome it works. Except, it doesn\\'t. You still have to\nadd the `libMobileGestalt.tbd` library and the `Core Foundation`\nframework to your project target\\'s `Linked Frameworks and Libraries`.\n\nI\\'ve [also created a small GitHub project that includes all\nthis](https://github.com/terhechte/SwiftiPhone6sChipFinder) including\nthe correct library setup etc.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/more_examples/group_by.md":["6ca09224fa280c90",{"identifier":"bdbb6f10","filename":"group_by.md","info":{"title":"Group By","tags":["map","compactMap","filter","reduce","groupby"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-group-by.html","content":"<h1>Group By</h1>\n<p>Go over a list and return a new list with the previous list' items\ngrouped by a discriminator function. The function in question needs to\nreturn a <code>Hashable</code> type so that we can differentiate keys. The order of\nthe items will be preserved while the order of the groups won't\nnecessarily be preserved.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> groupby&lt;T, H: <span class=\"type\">Hashable</span>&gt;(<span class=\"keyword\">_</span> items: [<span class=\"type\">T</span>], f: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">H</span>) -&gt; [<span class=\"type\">H</span>: [<span class=\"type\">T</span>]] {\n\n    <span class=\"keyword\">return</span> items.<span class=\"call\">reduce</span>([:], { (<span class=\"keyword\">var</span> ac: [<span class=\"type\">H</span>: [<span class=\"type\">T</span>]], o: <span class=\"type\">T</span>) -&gt; [<span class=\"type\">H</span>: [<span class=\"type\">T</span>]] <span class=\"keyword\">in</span> \n\n        <span class=\"keyword\">let</span> h = <span class=\"call\">f</span>(o)\n\n        <span class=\"keyword\">if var</span> c = ac[h] {\n\n            c.<span class=\"call\">append</span>(o)\n\n            ac.<span class=\"call\">updateValue</span>(c, forKey: h)\n\n        } <span class=\"keyword\">else</span> {\n\n            ac.<span class=\"call\">updateValue</span>([o], forKey: h)\n\n        }\n\n        <span class=\"keyword\">return</span> ac\n\n    })\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">groupby</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>], f: { $0 % <span class=\"number\">3</span> }))\n\n<span class=\"comment\">// prints: [2: [2, 5, 8, 11], 0: [3, 6, 9, 12], 1: [1, 4, 7, 10]]</span>\n\n<span class=\"call\">print</span>(<span class=\"call\">groupby</span>([\\<span class=\"string\">\"Carl</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Cozy</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Bethlehem</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Belem</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Brand</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Zara</span>\\<span class=\"string\">\"</span>], f: { $0.<span class=\"property\">characters</span>.<span class=\"property\">first</span>! }))\n\n<span class=\"comment\">// prints: [\\\"C\\\" : [\\\"Carl\\\" , \\\"Cozy\\\"] , \\\"B\\\" : [\\\"Bethlehem\\\" , \\\"Belem\\\" , \\\"Brand\\\"] , \\\"Z\\\" : [\\\"Zara\\\"]]</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Group By\"\ntags = [\"map\", \"compactMap\", \"filter\", \"reduce\", \"groupby\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Group By\n\nGo over a list and return a new list with the previous list\\' items\ngrouped by a discriminator function. The function in question needs to\nreturn a `Hashable` type so that we can differentiate keys. The order of\nthe items will be preserved while the order of the groups won\\'t\nnecessarily be preserved.\n\n``` Swift\nfunc groupby<T, H: Hashable>(_ items: [T], f: (T) -> H) -> [H: [T]] {\n   return items.reduce([:], { (var ac: [H: [T]], o: T) -> [H: [T]] in \n       let h = f(o)\n       if var c = ac[h] {\n           c.append(o)\n           ac.updateValue(c, forKey: h)\n       } else {\n           ac.updateValue([o], forKey: h)\n       }\n       return ac\n   })\n}\nprint(groupby([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], f: { $0 % 3 }))\n// prints: [2: [2, 5, 8, 11], 0: [3, 6, 9, 12], 1: [1, 4, 7, 10]]\nprint(groupby([\"Carl\", \"Cozy\", \"Bethlehem\", \"Belem\", \"Brand\", \"Zara\"], f: { $0.characters.first! }))\n// prints: [\"C\" : [\"Carl\" , \"Cozy\"] , \"B\" : [\"Bethlehem\" , \"Belem\" , \"Brand\"] , \"Z\" : [\"Zara\"]]\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/intro.md":["f16a16effd24d2b0",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"A Short Introduction into Catalyst","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-a-short-introduction-into-catalyst.html","content":"<p>This is a short introduction into Catalyst. It will be extended constantly.</p>\n","raw_content":"[frontMatter]\ntitle = \"A Short Introduction into Catalyst\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nThis is a short introduction into Catalyst. It will be extended constantly.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/features.md":["a2708a8e0ccd71b5",{"identifier":"445e6d0d","filename":"features.md","info":{"title":"Features","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-features.html","content":"<p>Here's a bullet point guide on Catalyst:</p>\n<ul>\n<li>Run iPad apps on macOS</li>\n<li>macOS 13.0 only</li>\n<li>Supports most of iOS (i.e. no ARKit)</li>\n<li>Adds <a href=\"rel::how/sandbox.md\">macOS sandbox</a> support (and a <code>AppName.entitlements</code> file</li>\n<li>Uses <a href=\"rel::firststeps/preferences.md\">Settings.bundle</a> for automatic macOS Preferences</li>\n<li>You can build full-fledged macOS apps</li>\n<li>You can sell your apps outside of the Mac App Store</li>\n<li>Dynamic Type is disabled as it doesn't exist on macOS. Everything is <em>Large</em></li>\n<li>Your whole app, when run on macOS, is resized to 77% of the original size. That's all automatic and in the background</li>\n<li>A default menu bar for your app.</li>\n<li>Support for trackpad, mouse, and keyboard input.</li>\n<li>Support for window resizing and full-screen display.</li>\n<li>Mac-style scroll bars.</li>\n<li>Copy-and-paste support.</li>\n<li>Drag-and-drop support.</li>\n<li>Support for system Touch Bar controls.</li>\n</ul>\n<p>Apart from that, another major difference is that the Application Lifecycle behaves slightly different. We will look at that next.</p>\n","raw_content":"[frontMatter]\ntitle = \"Features\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nHere's a bullet point guide on Catalyst:\n\n\n- Run iPad apps on macOS\n- macOS 13.0 only\n- Supports most of iOS (i.e. no ARKit)\n- Adds [macOS sandbox](rel::how/sandbox.md) support (and a `AppName.entitlements` file\n- Uses [Settings.bundle](rel::firststeps/preferences.md) for automatic macOS Preferences\n- You can build full-fledged macOS apps\n- You can sell your apps outside of the Mac App Store\n- Dynamic Type is disabled as it doesn't exist on macOS. Everything is *Large*\n- Your whole app, when run on macOS, is resized to 77% of the original size. That's all automatic and in the background \n- A default menu bar for your app.\n- Support for trackpad, mouse, and keyboard input.\n- Support for window resizing and full-screen display.\n- Mac-style scroll bars.\n- Copy-and-paste support.\n- Drag-and-drop support.\n- Support for system Touch Bar controls.\n\nApart from that, another major difference is that the Application Lifecycle behaves slightly different. We will look at that next.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/keypaths/complete_book.html":["e3b0c44298fc1c14",{"identifier":"ac9f","filename":"complete_book.html","info":{"title":"Introduction to Swift Keypaths","tags":[],"keywords":["feature","keypath","anykeypath","writablekeypath","partialkeypath","referencewritablekeypath","root","value"],"category":[],"created":"2019-03-29 10:30:30","description":"Keypaths allow type-safe abstractions over properties that go beyond what can be done with protocols alone. This guide introduces by solving practical problems","description_html":"<p>Keypaths allow type-safe abstractions over properties that go beyond what can be done with protocols alone. This guide introduces by solving practical problems</p>\n","published":true,"slug":null,"meta":{"featured":"true","short_code":"<pre class='Swift'><code><span class='apvsource swift'>\\User<span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'>.</span>username</span></code></pre>","swift_version":"5.0","short_title":"🗝 KeyPaths"},"created_timestamp":1553855430,"date":"2019-03-29T10:30:30","date_info":{"year":2019,"month":3,"day":29,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/keypaths/complete_book.html","content":"<h1>KeyPaths in Swift</h1>\n<p>Lets talk KeyPaths. Modern KeyPaths. <strong>Swift KeyPaths</strong>. Not <code>Objective-C</code>'s  <code>valueForKeyPath: @&quot;controller.property&quot;</code>.</p>\n<p>These particular, modern, swifty, keypaths were added with Swift 4.2. They differ from the old <code>Objective-C</code> ones by being type-safe and composable.</p>\n<p>Not everyone is aware of the useful functionality that Swift's new keypaths offer. They're a great addition to your toolbelt because they allow you to find abstractions for problems where protocols alone are not sufficient.</p>\n<p>This guide will first introduce Swift's KeyPaths, then discuss the underlying theory, showcase their usefulness with practical examples, and finally list tips and tricks for applying them in daily work.</p>\n<p>Lets start with a very basic introduction.</p>\n<h1>KeyPaths 101</h1>\n<p>We will start with a very, very simple example. Below, we create a <code>User</code> type that has just one property, the username. Then, we initialize the user as <code>firstUser</code> and want to print out <code>firstUser</code>s <code>username</code>.</p>\n<p>Normally, we would do <code>print(firstUser.username)</code> but instead we're doing something else. Have a look:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> firstUser = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Player</span> <span class=\"number\">1</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"call\">print</span>(firstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>])\n</code></pre></code></pre>\n<p>You'll easily see the difference. Instead of using <code>firstUser.username</code> we're using a very weird syntax:</p>\n<pre class=\"Swift\"><code>firstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>]\n</code></pre></code></pre>\n<p>This tells Swift that we want to access the contents of the property <code>username</code> of the type <code>User</code> on the instance <code>firstUser</code>.</p>\n<p>It is comparable to dictionary access (<code>dict[&quot;Hello&quot;]</code>), only that you don't use <code>String</code> keys (&quot;Hello&quot;) but something type-safe. Namely, a Swift keypath.</p>\n<p>At first glance, this looks like an overly verbose version of direct access, so what else can it do? For one, we can abstract the access away. We can store the <code>KeyPath</code> in a variable:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> userKeyPath = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n\n\n\n<span class=\"call\">print</span>(firstUser[keyPath: userKeyPath])\n</code></pre></code></pre>\n<p>By doing so, we implement generic abstraction between the property and the type. But, what is the type of this <code>userKeyPath</code> variable? The full type signature looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n</code></pre></code></pre>\n<p><code>KeyPath</code> has two generic types:</p>\n<ol>\n<li>The <code>Root</code>. It is the <code>struct</code>, <code>class</code>, or <code>enum</code> whose property you want to have a <code>KeyPath</code> to. A <code>Person</code>, a <code>UIViewController</code>, a <code>String</code>, or something else</li>\n<li>This is the <code>Value</code>. It is a property on the <code>Root</code> type. For example a <code>Person</code>'s <code>name</code>, or a <code>UIViewController</code>'s <code>title</code>, or a <code>String</code>'s <code>count</code>.</li>\n</ol>\n<p>So in our example, the <code>Root</code> is <code>User</code>, and the <code>Value</code> is <code>String</code> because <code>username</code> is of type <code>String</code>. Here is an overview.</p>\n<p><img src=\"/img-content/keypaths_type_overview.gif\" alt=\"Setup\" /></p>\n<h1>Nesting</h1>\n<p>Obviously, you can also nest KeyPaths. Now, our <code>User</code> also has an <code>address</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Address {\n\n   <span class=\"keyword\">var</span> street: <span class=\"type\">String</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">var</span> address: <span class=\"type\">Address</span>\n\n}\n</code></pre></code></pre>\n<p>If we want to create a keypath to the amount of characters of the <code>street</code> of the user's address, we can simply do that like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">Int</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">address</span>.<span class=\"property\">street</span>.<span class=\"property\">count</span>\n</code></pre></code></pre>\n<p>As you can see, this is a <code>KeyPath</code> from <code>User</code> to <code>Int</code> because it points from the <code>User</code> to his address' street' count. <code>count</code>, finally, is a <code>Int</code> type.</p>\n<h1>Generic Types</h1>\n<p>We don't always have to spell out the two generic types <code>Root</code> and <code>Value</code>. We can, for example, write a generic function that works for any object with any property:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> accept&lt;MyRoot, MyValue&gt;(<span class=\"keyword\">_</span> object: <span class=\"type\">MyRoot</span>, keyPath: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">MyRoot</span>, <span class=\"type\">MyValue</span>&gt;) {\n\n   <span class=\"call\">print</span>(object[keyPath: keyPath])\n\n}\n</code></pre></code></pre>\n<p>Here, we introduce the generic types <code>MyRoot</code> and <code>MyValue</code> specifically for our <code>accept</code> function and also use them for our <code>KeyPath&lt;MyRoot, MyValue&gt;</code> definition. Now, we can use this function for different keypaths:</p>\n<pre class=\"Swift\"><code><span class=\"call\">accept</span>(user, keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>)\n\n<span class=\"call\">accept</span>(\\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>, keyPath: \\<span class=\"type\">String</span>.<span class=\"property\">count</span>)\n</code></pre></code></pre>\n<h1>Types of KeyPaths</h1>\n<p>We've already met our new friend, the <code>KeyPath</code>. However, the <code>KeyPath</code> will not be the only friend we meet in this guide. There're a couple more <code>KeyPath</code> types and they're core to what makes keypaths so very very useful. So without further ado, here they are.</p>\n<h2>KeyPath&lt;Root, Value&gt;</h2>\n<p>We've seen this <code>KeyPath</code> before. What we did not really talk about yet is that this <code>KeyPath</code> is <strong>read only</strong>. You can't use it to modify properties, only to read properties. They're automatically used for accessing immutable properties or instances. Here're a couple of examples of these read-only keypaths:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ImmutableUser {\n\n   <span class=\"comment\">// `let` properties are immutable</span>\n\n   <span class=\"keyword\">let</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> firstUser = <span class=\"type\">ImmutableUser</span>(username: \\<span class=\"string\">\"Shinji</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// This will fail</span>\n\nfirstUser[keyPath: \\<span class=\"type\">ImmutableUser</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ikari</span>\\<span class=\"string\">\"</span>\n\n\n\n<span class=\"comment\">// Prints: KeyPath&lt;ImmutableUser, String&gt;</span>\n\n<span class=\"call\">print</span>(<span class=\"call\">type</span>(of: \\<span class=\"type\">ImmutableUser</span>.<span class=\"property\">username</span>))\n</code></pre></code></pre>\n<p>In this example, we could not edit the <code>firstUser</code>, because the <code>username</code> property was a <code>let</code> it was immutable. Just like <code>firstUser.username = &quot;Ikari&quot;</code> also would not have worked.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> MutableUser {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> firstUser = <span class=\"type\">MutableUser</span>(username: \\<span class=\"string\">\"Shinji</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// This will work fine</span>\n\nfirstUser[keyPath: \\<span class=\"type\">MutableUser</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ikari</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>Here, it works fine, because</p>\n<ul>\n<li><code>firstUser</code> is a <code>var</code> type</li>\n<li><code>MutableUser.username</code> is a <code>var</code> type</li>\n</ul>\n<p>So, if <code>KeyPath</code> is read-only and in this second example we could actually write to <code>firstUser</code>, then what is the type of <code>\\MutableUser.username</code> here?</p>\n<h1>WritableKeyPath&lt;Root, Value&gt;</h1>\n<p>In <a href=\"javascript:prev()\">the earlier example</a>, our type was a <code>WritableKeyPath</code>. WritableKeyPaths are, as the name implies, keypaths that allow you to write information. They're formed for <code>var</code> properties on <code>var</code> instances.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> MutableUser {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> firstUser = <span class=\"type\">MutableUser</span>(username: \\<span class=\"string\">\"Shinji</span>\\<span class=\"string\">\"</span>)\n\n\n\nfirstUser[keyPath: \\<span class=\"type\">MutableUser</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ikari</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>If you want to have a keypath argument to a function that allows mutating the contents, <code>WritableKeyPath</code> is a good choice:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> modify(user: <span class=\"type\">User</span>, keyPath: <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt;) {\n\n   user[keyPath: keyPath] = \\<span class=\"string\">\"Hello</span> <span class=\"type\">World</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>There's another variant of the <code>WritableKeyPath</code>, which we will introduce next.</p>\n<h1>ReferenceWritableKeyPath</h1>\n<p>In the previous example code, we always defined <code>User</code> <code>struct</code> instances. Which meant that the actual instance we instantiated also had to be mutable (<code>var</code>):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> firstUser = <span class=\"type\">User</span>(username: <span class=\"type\">String</span>)\n\nfirstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ok</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>If this had be a <code>let firstUser</code>, it would not have worked, because <code>let</code> instances are immutable. However, if our <code>User</code> is a <code>class</code> type, we could still mutate it just fine:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span> = \\<span class=\"string\">\"Nothing</span>\\<span class=\"string\">\"</span>\n\n}\n\n<span class=\"keyword\">let</span> firstUser = <span class=\"type\">User</span>()\n\n<span class=\"comment\">// This works</span>\n\nfirstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Something</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>in The example above, the <code>username</code> property can still be modified because <code>User</code> is a <code>class</code>. Swift distinguishes between keypaths for <code>reference</code> (class) types and <code>value</code> types. Keypaths to reference types are of the type <code>ReferenceWritableKeyPath&lt;Root, Value&gt;</code>.</p>\n<p>It is important to note that <code>ReferenceWritableKeyPath</code>s are subclasses of <code>WritableKeyPath</code>, so any function that accepts a <code>WritableKeyPath</code> can also accept a <code>ReferenceWritableKeyPath</code>.</p>\n<p>The next <code>KeyPath</code> we want to look at is the <code>PartialKeyPath</code>, however, before we do so, we'll have a detour and look at a short example to better understand the need for it and to see some of what we've seen so far in action.</p>\n<h1>DebugPrinter Intermezzo</h1>\n<p>Now that we have our writable <code>KeyPath</code> types, we'd like to introduce a type that allows us to define the logging behaviour of an object. We'd like to define which properties should be printed when our debug print function is called. It will be a very simple example.</p>\n<p>We will actually start by looking at how we would invoke the code before we write it. This will make it easier to understand what is going on here. The class we will define is called <code>DebugPrinter</code> and it is used to dynamically change how to debug print and object at runtime.</p>\n<p>Say, if you will, that you're working on a Presentation app (aka something like Keynote). You have one structure that represents the current state of a presentation.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> Presentation {\n\n   <span class=\"keyword\">class</span> Slide {\n\n     <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> number: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">var</span> template: <span class=\"type\">Template</span>\n\n     <span class=\"keyword\">var</span> backgroundColor: <span class=\"type\">UIColor</span>\n\n     <span class=\"keyword\">var</span> content: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> leftImage: <span class=\"type\">UIImage</span>?\n\n     <span class=\"keyword\">var</span> rightImage: <span class=\"type\">UIImage</span>?\n\n   }\n\n   <span class=\"keyword\">var</span> currentSlide: <span class=\"type\">Slide</span>\n\n   <span class=\"keyword\">var</span> currentSlideIndex: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">var</span> slides: [<span class=\"type\">Slide</span>]\n\n   <span class=\"keyword\">var</span> title: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">var</span> startedPresenting: <span class=\"type\">Date</span>?\n\n   <span class=\"keyword\">var</span> isAnimating: <span class=\"type\">Bool</span>\n\n}\n</code></pre></code></pre>\n<p>Now, you'd like to define at runtime which of the properties of this type to print. For example depending on whether a user is currently presenting or editing slides. This is, how we would do that:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> state = <span class=\"type\">Presentation</span>(...) <span class=\"comment\">// we need a presentation instance</span>\n\n<span class=\"keyword\">let</span> printer = <span class=\"type\">DebugPrinter</span>(\\<span class=\"string\">\"State</span>\\<span class=\"string\">\"</span>, for: state)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">currentSlideIndex</span>, prefix: \\<span class=\"string\">\"Current</span>\\<span class=\"string\">\"</span>)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">isAnimating</span>)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">currentSlide</span>.<span class=\"property\">name</span>)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">currentSlide</span>.<span class=\"property\">leftImage</span>)\n\n\n\nprinter.<span class=\"call\">log</span>()\n</code></pre></code></pre>\n<p>So here, we first create a <code>printer</code> that holds a reference to our <code>state</code> (an instance of our <code>Presentation</code>). Next, we define which parts of the <code>animation</code> we want to print (including an optional prefix). Here, we want to print, for example, the current slide, whether we're currently animating, the name of the current slide and, finally, the optional image of the current slide.</p>\n<p>So, how would we implement this <code>DebugPrinter</code>? here is the code.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Dynamically define a debug description for an object</span>\n\n<span class=\"keyword\">class</span> DebugPrinter&lt;T&gt; <span class=\"keyword\">where</span> <span class=\"type\">T</span>: <span class=\"type\">AnyObject</span> {\n\n     <span class=\"comment\">/// 1</span>\n\n     <span class=\"keyword\">var</span> keyPaths: [(<span class=\"type\">String</span>?, <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">String</span>&gt;)] = []\n\n     <span class=\"keyword\">let</span> reference: <span class=\"type\">T</span>\n\n     <span class=\"keyword\">let</span> prefix: <span class=\"type\">String</span>\n\n\n\n     <span class=\"comment\">/// 2</span>\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> prefixString: <span class=\"type\">String</span>, for instance: <span class=\"type\">T</span>) {\n\n         reference = instance\n\n         prefix = prefixString\n\n     }\n\n\n\n     <span class=\"comment\">/// 3</span>\n\n     <span class=\"keyword\">func</span> addLog(<span class=\"keyword\">_</span> path: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">String</span>&gt;, prefix: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>) {\n\n         keyPaths.<span class=\"call\">append</span>((prefix, path))\n\n     }\n\n\n\n     <span class=\"comment\">/// 4</span>\n\n     <span class=\"keyword\">func</span> log() {\n\n         <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>: \\<span class=\"string\">\"</span>)\n\n         <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> keyPaths {\n\n           <span class=\"keyword\">if let</span> prefix = entry.<span class=\"number\">0</span> { <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>) }\n\n           <span class=\"call\">print</span>(reference[keyPath: entry.<span class=\"number\">1</span>], terminator: \\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>)\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>So lets go through step by step. First, we're creating a new <code>class</code> that is generic over the type <code>T</code> so that we can store keypaths of type <code>KeyPath&lt;T, String&gt;</code> in our <code>keyPaths</code> array [1]. Each keypath is stored in a <a href=\"lnk::tuple\">tuple</a> with an optional prefix.</p>\n<p>Then, we can initialize a <code>DebugPrinter</code> with a <code>prefix</code> <code>String</code> - which will be printed at the beginning of each future print invocation - and a reference to the actual instance we want to debug <code>T</code> [2].</p>\n<p>The <code>addLog</code> function, then, inserts a new <code>KeyPath</code> into our <code>keyPaths</code> array (again, including the optional <code>prefix</code>) [3].</p>\n<p>Finally, the <code>log</code> function, when called, iterates over all the keypaths and, for each of them, prints the contents of the <code>KeyPath</code> in our <code>reference</code> (including the prefix).</p>\n<p>Before you move on, have a brief look at the implementation of the <code>DebugPrinter</code> and at the usage example. Would this actually work?</p>\n<hr />\n<p>No, it actually doesn't. The problem is that our <code>Presentation</code> state has properties of various types: <code>currentSlideIndex: Int</code>, <code>title: String</code>, <code>leftImage: UIImage?</code>. However, our <code>DebugPrinter</code> only stores keypaths of the type <code>KeyPath&lt;T, String&gt;</code>. We could try to make the second parameter generic as well, but that still doesn't help, because it would be generic for the full instance of <code>DebugPrinter</code>, for example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> DebugPrinter&lt;Root, Value&gt; {\n\n   <span class=\"keyword\">var</span> keyPaths: [<span class=\"type\">KeyPath</span>&lt;<span class=\"type\">Root</span>, <span class=\"type\">Value</span>&gt;]\n\n}\n</code></pre></code></pre>\n<p>Here, our <code>KeyPath</code> still have to be of the same type. All <code>Int</code>, all <code>String</code>, etc. What we actually want is a keypath that doesn't care about the <code>Value</code> type! A KeyPath that just cares about the <code>Root</code> type (our <code>reference</code>). This is, what the <code>PartialKeyPath</code> is for. Lets have a look at it.</p>\n<h1>PartialKeyPath</h1>\n<p><code>PartialKeyPath</code> is a type-erased <code>KeyPath</code> that erases the <code>Value</code> type parameter.</p>\n<p>As we've seen in the previous chapter, sometimes you want to have a <code>KeyPath</code> that does not require a <code>Value</code> type parameter. That is, what the <code>PartialKeyPath</code> is for. Its type signature is <code>PartialKeyPath&lt;Root&gt;</code>. As you can see, there is no <code>Value</code> type anymore. This <code>KeyPath</code>, again, is read-only. However, it is very useful because it allows you to be much more flexible when storing keypaths in arrays or writing functions that accept keypaths. Here is a quick example:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Value would be `String`</span>\n\n<span class=\"keyword\">let</span> a: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">name</span>\n\n\n\n<span class=\"comment\">/// Value would be `Int`</span>\n\n<span class=\"keyword\">let</span> b: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n\n\n\n<span class=\"comment\">/// Value would be `Address`</span>\n\n<span class=\"keyword\">let</span> c: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">address</span>\n</code></pre></code></pre>\n<p>See how these totally different types (<code>KeyPath&lt;User, String&gt;, KeyPath&lt;User, Int&gt;, ...</code>) are actually stored with the same type, just <code>PartialKeyPath&lt;User&gt;</code>. We type-erase the <code>Value</code> parameter.</p>\n<p>This is useful because it allows you to call the same function with different types of keypaths:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> acceptKeyPath(<span class=\"keyword\">_</span> keyPath: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt;) {\n\n   ...\n\n}\n\n<span class=\"call\">acceptKeyPath</span>(\\<span class=\"type\">User</span>.<span class=\"property\">age</span>)\n\n<span class=\"call\">acceptKeyPath</span>(\\<span class=\"type\">User</span>.<span class=\"property\">username</span>)\n</code></pre></code></pre>\n<p>More importantly, it allows us to solve the issue we had with the <code>DebugPrinter</code> in the <a href=\"javascript:prev()\">previous code</a>. We can now implement is as follows:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Dynamically define a debug description for an object</span>\n\n<span class=\"keyword\">class</span> DebugPrinter&lt;T&gt; <span class=\"keyword\">where</span> <span class=\"type\">T</span>: <span class=\"type\">AnyObject</span> {\n\n     <span class=\"keyword\">var</span> keyPaths: [(<span class=\"type\">String</span>?, <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">T</span>&gt;)] = []\n\n     <span class=\"keyword\">let</span> reference: <span class=\"type\">T</span>\n\n     <span class=\"keyword\">let</span> prefix: <span class=\"type\">String</span>\n\n\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> prefixString: <span class=\"type\">String</span>, for instance: <span class=\"type\">T</span>) {\n\n         reference = instance\n\n         prefix = prefixString\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> addLog(<span class=\"keyword\">_</span> path: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">T</span>&gt;, prefix: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>) {\n\n         keyPaths.<span class=\"call\">append</span>((prefix, path))\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> log() {\n\n         <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>: \\<span class=\"string\">\"</span>)\n\n         <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> keyPaths {\n\n           <span class=\"keyword\">if let</span> prefix = entry.<span class=\"number\">0</span> { <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>) }\n\n           <span class=\"call\">print</span>(reference[keyPath: entry.<span class=\"number\">1</span>], terminator: \\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>)\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Just by replacing <code>KeyPath&lt;T, String&gt;</code> with <code>PartialKeyPath&lt;T&gt;</code> we could fix the issue with this code, and now it can be used with all types.</p>\n<p>Now, you're probably wondering whether there is a <code>KeyPath</code> type that also type-erases the <code>Root</code> type parameter, and in fact, there is! Next up, the appropriately named <code>AnyKeyPath</code>.</p>\n<h1>AnyKeyPath</h1>\n<p>The last <code>KeyPath</code> type that we have to tackle is the <code>AnyKeyPath</code>. It doesn't have a type-parameter for either <code>Root</code> or <code>Value</code> as it is completely type-erased. If you read the chapter to <code>PartialKeyPath</code>, you will easily grep this one as well. This type is really useful once you intend to write code that just stores general keypaths from differently typed objects. Here is a small bit of example code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPaths: [<span class=\"type\">AnyKeyPath</span>] = [\n\n   \\<span class=\"type\">User</span>.<span class=\"property\">username</span>,\n\n   \\<span class=\"type\">String</span>.<span class=\"property\">count</span>,\n\n   \\<span class=\"type\">Presentation</span>.<span class=\"property\">title</span>\n\n]\n</code></pre></code></pre>\n<p>We will see more (and better!) usecases for this type later on in this guide, however here is a very simple example of where it could be useful.</p>\n<p>You're writing a game and you have different entities / types: Animals, Monsters, Players, and Objects. Each of them have a <code>health</code> property (even objects. If you hit a tree long enough, it will break). You need an easy way to debug the health of all entities that are currently on screen. You can just collect them into an array of <code>AnyKeyPath</code> and print them out:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> observeHealth(entity: <span class=\"type\">Any</span>, <span class=\"keyword\">_</span> keypath: <span class=\"type\">AnyKeyPath</span>) { ... }\n\n<span class=\"call\">observeHealth</span>(entity: monster1, \\<span class=\"type\">Dragon</span>.<span class=\"property\">health</span>)\n\n<span class=\"call\">observeHealth</span>(entity: stone255, \\<span class=\"type\">Stone</span>.<span class=\"property\">integrity</span>)\n\n<span class=\"call\">observeHealth</span>(entity: player2, \\<span class=\"type\">Player</span>.<span class=\"property\">health</span>)\n</code></pre></code></pre>\n<p>This tackles the last one of our keypaths. You might have wondered though, what good are those type-erased keypaths given that you can't modify properties. After all they're all read-only! Not necessarily, because Swift allows you to type-cast them at runtime.</p>\n<h1>Type-Casting KeyPaths</h1>\n<p>As we've seen before, Swift offers <code>PartialKeyPath&lt;Root&gt;</code> and <code>AnyKeyPath</code> as a way to generalize <code>KeyPath</code> handling. While this makes it easier to store these keypaths in generic functions and arrays, it makes it much harder to actually use them. There's not much we can do with them - except for printing maybe - which is why most of our usage examples were about printing.</p>\n<p>Type-casting changes this. It allows you to cast a type-erased <code>KeyPath</code> back into (for example) a <code>WritableKeyPath</code> in a totally type-safe manner. Observe the magic:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span> = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n\n<span class=\"keyword\">var</span> user = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Hello</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"keyword\">if let</span> writableUsername = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt; {\n\n    user[keyPath: writableUsername] = \\<span class=\"string\">\"World</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>In this example, you saw how we converted an <code>AnyKeyPath</code> back into a <code>WritableKeyPath&lt;User, String&gt;</code>. The important part is that <code>as?</code> returns on optional. So if the <code>KeyPath</code> is not of type <code>&lt;User, String&gt;</code> nothing would happen as the expression would return <code>nil</code>. Therefore, in order to work with multiple types (<code>String</code>, <code>Int</code>, <code>Float</code>, etc), you need more than one <code>if</code> statement. Preferrably a <a href=\"lnk::switch\"><code>switch</code></a> statement.</p>\n<p>In this example, we're using <code>switch</code> to identify the specific type of the <code>keyPath</code> and then perform a different operation depending on the type.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span> = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n\n<span class=\"keyword\">switch</span> keyPath {\n\n<span class=\"keyword\">case let</span> a <span class=\"keyword\">as</span> <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">Yeah</span>, <span class=\"type\">String</span>&gt;:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"String</span>\\<span class=\"string\">\"</span> + xxx[keyPath: a])\n\n<span class=\"keyword\">case let</span> a <span class=\"keyword\">as</span> <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">Yeah</span>, <span class=\"type\">Int</span>&gt;:\n\n     <span class=\"call\">print</span>(<span class=\"number\">1</span> + xxx[keyPath: a])\n\n<span class=\"keyword\">default</span>:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"Unknown</span> keypath type\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<h1>KeyPath Composition</h1>\n<p>The last keypath concept that we should tackle is keypath composition: Swift allows you to dynamically combine <code>KeyPath</code> types at runtime if the types match up.</p>\n<p>In order to showcase this, we will go back to our <code>User</code> and <code>Address</code> struct:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">let</span> address: <span class=\"type\">Address</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Address {\n\n   <span class=\"keyword\">let</span> street: <span class=\"type\">String</span>\n\n}\n</code></pre></code></pre>\n<h3>Example</h3>\n<p>Based on this structure, we will take two different keypaths; first, one to the <code>address</code> property on the <code>User</code>, and then one on the <code>String</code> property on the <code>Address</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> addressKeyPath = \\<span class=\"type\">User</span>.<span class=\"property\">address</span>\n\n\n\n<span class=\"keyword\">let</span> streetKeyPath = \\<span class=\"type\">Address</span>.<span class=\"property\">street</span>\n</code></pre></code></pre>\n<p>Given these two variables, we can now compose them to manifest a new keypath at runtime that goes from <code>User</code> to the <code>street</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> newKeyPath = addressKeyPath.<span class=\"call\">appending</span>(path: streetKeyPath)\n</code></pre></code></pre>\n<p>Here, we created a new <code>KeyPath&lt;User, String&gt;</code> at runtime by joining a <code>KeyPath&lt;User, Address&gt;</code> and a <code>KeyPath&lt;Address, String&gt;</code>. However, what should Swift do if you try to merge a <code>KeyPath&lt;User, String&gt;</code> and a <code>KeyPath&lt;House, Int&gt;</code>. Obviously, there's no relationship between these types. Swift solves this by introducing laws of keypath composition. Lets have a look at them.</p>\n<h1>Laws of composition</h1>\n<h2>Appending type-erased keypaths</h2>\n<p>There're some additional constraints that need to hold in order to allow joining keypaths. In general, you can combine any type of keypath with any other types, except for the following combinations:</p>\n<h3>Impossible keypaths combinations</h3>\n<p>| <strong>First</strong>                | <strong>Second</strong>     |\n|--------------------------|----------------|\n| KeyPath                  | AnyKeyPath     |\n| KeyPath                  | PartialKeyPath |\n| WritableKeyPath          | AnyKeyPath     |\n| WritableKeyPath          | PartialKeyPath |\n| ReferenceWritableKeyPath | AnyKeyPath     |\n| ReferenceWritableKeyPath | PartialKeyPath |</p>\n<p>This is actually quite easy to remember. You can't append a <code>AnyKeyPath</code> or a <code>PartialKeyPath</code> to a non-type-erased <code>KeyPath</code> type.</p>\n<p>The rule is that the <code>KeyPath</code> to be appended has to have at least as many generic types as the type being appended to.</p>\n<h2>Appending to type-erased keypaths</h2>\n<p>The second rule is that appending anything to a type-erased keypath will return an optional keypath:</p>\n<h3>Keypaths combinations returning Optional</h3>\n<p>| <strong>First</strong>                | <strong>Second</strong>     |\n|--------------------------|----------------|\n| AnyKeyPath               | Anything       |\n| PartialKeyPath           | Anything       |</p>\n<h2>Appending invalid types</h2>\n<p>The third, and final, rule is that you can't append non-matching types. So, for example appending <code>KeyPath&lt;User, String&gt;</code> and <code>KeyPath&lt;Address, Int&gt;</code> will fail at compile time because the types don't match up.</p>\n<h1>Generic Settings</h1>\n<p>Our first practical example showcases how keypaths, protocols, and keypath composition work together to allow you to handle app settings in a generic manner. Here is the problem we're trying to solve, have a look at these different settings screens for our <code>Chat</code> app:</p>\n<p><img src=\"/img-content/keypaths_settings.gif\" alt=\"Image\" /></p>\n<p>Lets map those settings as a type:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">final class</span> ProfileSettings {\n\n   <span class=\"keyword\">var</span> displayName: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">var</span> shareUpdates: <span class=\"type\">Bool</span>\n\n}\n\n\n\n<span class=\"keyword\">final class</span> PrivacySettings {\n\n   <span class=\"keyword\">var</span> passcode: <span class=\"type\">Bool</span>\n\n   <span class=\"keyword\">var</span> addByID: <span class=\"type\">Bool</span>\n\n}\n\n\n\n<span class=\"keyword\">final class</span> Settings {\n\n   <span class=\"keyword\">var</span> profileSettings: <span class=\"type\">ProfileSettings</span>\n\n   <span class=\"keyword\">var</span> privacySettings: <span class=\"type\">PrivacySettings</span>\n\n}\n</code></pre></code></pre>\n<p>If we want to find a generic abstraction for these settings, it would be very difficult. That's because they're all so very different. Their types are <code>String, Bool</code>, <code>Bool, Bool</code>, and <code>ProfileSettings, PrivacySettings</code>.\nEven more, as we expand our settings they will become more and more different.\nLets try to find a nice solution for this by utilizing keypaths.</p>\n<h1>Settings Entries</h1>\n<p>Fundamentally, the first thing we need is a way to describe a particular settings entry. It is not sufficient to just know the value of the settings; we also need a title, a subtitle, maybe some help, or an icon. We will summarize this information into a <code>SettingsEntry</code> struct. This struct will also contain a keypath that points at the individual value this setting refers to.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> SettingsEntry {\n\n   <span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span>\n\n   <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">let</span> subtitle: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">let</span> icon: <span class=\"type\">UIImage</span>\n\n}\n</code></pre></code></pre>\n<p>For the sake of simplicity, we will use the following, shorter struct in the upcoming code examples:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> SettingsEntry {\n\n   <span class=\"keyword\">let</span> keyPath: <span class=\"type\">AnyKeyPath</span>\n\n   <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>\n\n}\n</code></pre></code></pre>\n<p>Note that the type of the keypath is <code>AnyKeyPath</code>. We have to do that because our types can be anything: <code>\\Settings.privacySettings</code>, <code>\\PrivacySettings.passcode</code>, or <code>\\ProfileSettings.displayName</code>.</p>\n<h1>A Settings Provider</h1>\n<p>Now that we have our <code>SettingsEntry</code> type, we need a way to provide all the settings entries that make up our UI. This is where protocols are a great solution. We want something that works for our different settings types (<code>Settings</code>, <code>ProfileSettings</code>, <code>PrivacySettings</code>), and protocols are made for just that. Our concrete protocol is defined to provide our applications with the specific settings for a type, so we will call it <code>SettingsProvider</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> SettingsProvider {\n\n   <span class=\"keyword\">var</span> settingsEntries: [<span class=\"type\">SettingsEntry</span>] { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>It is also a fairly simple protocol. The only thing it does is provide a <code>getter</code> to return an array of <code>SettingsEntry</code> types for one of our settings types. Lets implement it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Settings</span>: <span class=\"type\">SettingsProvider</span> {\n\n  <span class=\"keyword\">var</span> settingsEntries: [<span class=\"type\">SettingsEntry</span>] {\n\n   <span class=\"keyword\">return</span> [\n\n       <span class=\"type\">SettingsEntry</span>(\n\n           keyPath: \\<span class=\"type\">Settings</span>.<span class=\"property\">profileSettings</span>, \n\n             title: \\<span class=\"string\">\"Profile</span>\\<span class=\"string\">\"</span>),\n\n\n\n       <span class=\"type\">SettingsEntry</span>(\n\n           keyPath: \\<span class=\"type\">Settings</span>.<span class=\"property\">privacySettings</span>, \n\n             title: \\<span class=\"string\">\"Privacy</span>\\<span class=\"string\">\"</span>)\n\n   ]\n\n  }\n\n}\n</code></pre></code></pre>\n<p>Our first implementation is for our main parent <code>Settings</code> <code>class</code>. It has two properties that we'd like to be displayed in the settings, the <code>Profile Settings</code> and the <code>Privacy Settings</code>, which is why we're returning these two as <code>SettingsEntry</code> types.</p>\n<p>Next up, we will implement the <code>SettingsProvider</code> for our <code>ProfileSettings</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">ProfileSettings</span>: <span class=\"type\">SettingsProvider</span> {\n\n  <span class=\"keyword\">var</span> settingsEntries: [<span class=\"type\">SettingsEntry</span>] {\n\n   <span class=\"keyword\">return</span> [\n\n     <span class=\"type\">SettingsEntry</span>(\n\n        keyPath: \\<span class=\"type\">ProfileSettings</span>.<span class=\"property\">displayName</span>,\n\n          title: \\<span class=\"string\">\"Display</span> <span class=\"type\">Name</span>\\<span class=\"string\">\"</span>),\n\n\n\n     <span class=\"type\">SettingsEntry</span>(\n\n        keyPath: \\<span class=\"type\">ProfileSettings</span>.<span class=\"property\">shareUpdates</span>,\n\n          title: \\<span class=\"string\">\"Share</span> <span class=\"type\">Profile Media Updates</span>\\<span class=\"string\">\"</span>)\n\n   ]\n\n  }\n\n}\n</code></pre></code></pre>\n<p>Again, we return two settingsEntries, because this settings screen should display the <code>Display Name</code> and <code>Share Updates</code> setting. Finally, we obviously also need to implement our <code>SettingsProvider</code> for our <code>PrivacySettings</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">PrivacySettings</span>: <span class=\"type\">SettingsProvider</span> {\n\n  <span class=\"keyword\">var</span> settings: [<span class=\"type\">SettingsEntry</span>] {\n\n   <span class=\"keyword\">return</span> [\n\n     <span class=\"type\">SettingsEntry</span>(\n\n         keyPath: \\<span class=\"type\">PrivacySettings</span>.<span class=\"property\">addByID</span>, \n\n           title: \\<span class=\"string\">\"Allow</span> add me by <span class=\"type\">ID</span>\\<span class=\"string\">\"</span>),\n\n\n\n     <span class=\"type\">SettingsEntry</span>(\n\n         keyPath: \\<span class=\"type\">PrivacySettings</span>.<span class=\"property\">passcode</span>, \n\n           title: \\<span class=\"string\">\"Passcode</span> <span class=\"type\">Lock</span>\\<span class=\"string\">\"</span>)\n\n   ]\n\n  }\n\n}\n</code></pre></code></pre>\n<p>No surprises here.</p>\n<h1>Handling the Settings</h1>\n<p>The next part is crucial. What do we intend to do with these settings? The natural way would be to build a UI that displays them and allows the user to edit them. Another option would be to set settings to specific values. All of these things are possible. We will do something slightly simpler which still explains the basics of the code without requiring us to write a lot of UI code. In this example, we will iterate over the settings, print out their title and value, and will then change the value to <code>true</code> if it is <code>Bool</code>. However, as mentioned above, you can use the very same pattern to display these settings in a very nice UI.</p>\n<p>The first thing we need is a function we can call with our settings. This function needs to be generic. We should be able to call it with any type. To do this, it will only have one argument of the <code>SettingsProvider</code> type. However, later on, we will also need the specific type that implements the protocol, which is why we code this in a generic manner:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   ...\n\n}\n\n\n\n<span class=\"comment\">/// And lets call it</span>\n\n<span class=\"keyword\">let</span> appSettings = <span class=\"type\">Settings</span>()\n\n<span class=\"call\">editSettings</span>(appSettings)\n</code></pre></code></pre>\n<p>Since our <code>SettingsProvider</code> only really offers one property, the <code>settingsEntries</code> we will iterate over them:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     \n\n   }\n\n}\n</code></pre></code></pre>\n<p>Remember how we created settings entries for nested settings, such as <code>ProfileSettings</code> as well as the actual settings values, such as <code>PrivacySettings.passcode</code>? In this case, we have to disambigiuate, do we have an actual value that we want to print and edit, or do we have another, nested, settings provider? To do this, we will get the value of the current <code>KeyPath</code> from the <code>Provider</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: setting.<span class=\"property\">keyPath</span>]\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Here, we tell Swift to give us the value in the current <code>SettingsProvider</code> at the <code>KeyPath</code> <code>setting.keypath</code>. This doesn't really solve our problem, though. This value could still be a <code>Bool</code> type or a <code>PrivacySettings</code> type. We can't check whether the type is <code>PrivacySettings</code> because we want to be generic, work with any type. However, since all nested settings also <strong>have</strong> to implement the <code>SettingsProvider</code> protocol, we can simply test for this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: setting.<span class=\"property\">keyPath</span>]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Via the <code>value as? SettingsProvider</code> we're just asking Swift at runtime whether the <code>value</code> is actually a type we want to handle (such as <code>Bool</code>, or <code>String</code>) or another nested <code>SettingsProvider</code> that we'd like to iterate over. Which is precisely what we will do next, iterate over the provider again. However, since we may have another settings provider, and then another one, we would need to write more and more for loops:</p>\n<pre class=\"Swift\"><code>   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: setting.<span class=\"property\">keyPath</span>]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> nestedSetting <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settingsEntries</span> {\n\n         <span class=\"keyword\">let</span> value = provider[keyPath: nestedSetting.<span class=\"property\">keyPath</span>]\n\n         <span class=\"keyword\">if let</span> nestedNestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n           <span class=\"keyword\">for</span> nestedNestedSetting <span class=\"keyword\">in</span> nestedNestedProvider.<span class=\"property\">settingsEntries</span> {\n\n           ...\n\n           }\n\n         }\n\n       }\n\n     }\n\n   }\n</code></pre></code></pre>\n<p>This is truly terrible. Instead, we will move this iteration code into a inlined function <code>updateSetting</code> that can be called recursively. So, whenever we identify another nested provider, we will simply call the function again:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"comment\">// All subsequent iterations happen here</span>\n\n   <span class=\"keyword\">func</span> updateSetting(keyPath: <span class=\"type\">AnyKeyPath</span>, title: <span class=\"type\">String</span>) {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settings</span> {\n\n         <span class=\"comment\">// ??</span>\n\n       }\n\n     }\n\n   }\n\n\n\n   <span class=\"comment\">// The initial iteration</span>\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"call\">updateSetting</span>(keyPath: setting.<span class=\"property\">keyPath</span>, title: setting.<span class=\"property\">title</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Here, we moved the iteration code into its own function. It has two parameters, the <code>keyPath</code> of the value we want to test, and the title of the current setting. The keypath helps us to extract the value:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n</code></pre></code></pre>\n<p>The value is then tested for being another <code>SettingsProvider</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n  ...\n\n}\n</code></pre></code></pre>\n<p>But what do we do now? In the first step, here, the <code>keyPath</code> would be <code>\\Settings.profileSettings</code> and the <code>value</code> will be <code>ProfileSettings</code>.\nBut what do we do now? If we iterate over the <code>ProfileSettings</code> as a <code>SettingsProvider</code> we get two new SettingsEntries, one for <code>displayName</code>, and one for <code>shareUpdates</code>. However, our <code>updateSetting</code> function always calls <code>let value = provider[keyPath: keyPath]</code> on the original <code>provider</code>, the <code>Settings</code> class that was given as a parameter to the <code>editSettings</code> function. This makes sense, because we want to edit the contents of this <code>Settings</code> type.</p>\n<p>So we have a keypath to <code>\\Setting.profileSettings</code> and a keypath to <code>\\ProfileSettings.displayName</code> and we want to retrieve the value at <code>\\Setting.profileSettings.displayName</code>. We can use Swift's <code>KeyPath</code> composition!</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"comment\">// All subsequent iterations happen here</span>\n\n   <span class=\"keyword\">func</span> updateSetting(keyPath: <span class=\"type\">AnyKeyPath</span>, title: <span class=\"type\">String</span>) {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settings</span> {\n\n         <span class=\"comment\">// Join the keypaths</span>\n\n         <span class=\"keyword\">if let</span> joined = keyPath.<span class=\"call\">appending</span>(path: item.<span class=\"property\">keyPath</span>) {\n\n           <span class=\"call\">updateSetting</span>(keyPath: joined, title: item.<span class=\"property\">title</span>)\n\n         }\n\n       }\n\n     }\n\n   }\n\n\n\n   <span class=\"comment\">// The initial iteration</span>\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"call\">updateSetting</span>(keyPath: setting.<span class=\"property\">keyPath</span>, title: setting.<span class=\"property\">title</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>In the code above, the magic happens in the following three lines:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> joined = keyPath.<span class=\"call\">appending</span>(path: item.<span class=\"property\">keyPath</span>) {\n\n   <span class=\"call\">updateSetting</span>(keyPath: joined, title: item.<span class=\"property\">title</span>)\n\n}\n</code></pre></code></pre>\n<p>We take the original <code>keyPath</code> that was given to the <code>updateSettings</code> function first (i.e. <code>\\Setting.profileSettings</code>) and we take the <code>item.keyPath</code>, which is the keypath of the current item (i.e. <code>\\ProfileSettings.displayName</code>) and join them to <code>\\Setting.profileSettings.displayName</code>. Now we can use this <code>joined</code> keypath to retrieve the value of the <code>displayName</code> property of the <code>provider</code> instance and perform another iteration. By implementing it this way, we can easily support more nesting hierachies.</p>\n<p>So what happens when our <code>value</code> isn't another nested <code>SettingsProvider</code> but an actual value such as <code>String</code> or <code>Bool</code> (<code>displayName</code> or <code>shareUpdates</code>). Since we want to be able to change the value that is stored here (from <code>false</code> to <code>true</code>) we do a run-time cast from this <code>keyPath</code> to a <code>WritableKeyPath</code> to figure out if we have an editable value.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> writableKeypath = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;???, ???&gt; {\n\n}\n</code></pre></code></pre>\n<p>However, <code>WritableKeyPath</code> needs two types, the <code>Root</code> and the <code>Value</code>, what do we insert here? We don't know the type of the <code>Root</code> as we're iterating over <code>Settings</code>, <code>ProfileSettings</code>, <code>PrivacySettings</code>, etc, right? It could be anything. Actually, we do know the type of <code>Root</code>. Since our keypaths are joined (<code>\\Settings.profileSettings.displayName</code>) our root is <strong>always</strong> <code>Settings</code>. So we could write <code>WritableKeyPath&lt;Settings, ???&gt;</code> but now our function would not be generic anymore. If we look at the header of our original function, though, we see something interesting:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n...\n</code></pre></code></pre>\n<p>We actually do have our root type, as the <code>Provider</code> generic type to the <code>editSettings</code> function. So we can just write <code>WritableKeyPath&lt;Provider, ???&gt;</code>. The second type of our <code>WritableKeyPath</code> is also easy. If we want to edit boolean flags, it is <code>Bool</code>, and if we want to edit <code>Strings</code> it is .. well, <code>String</code>. Lets type this out:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>) {\n\n   <span class=\"comment\">// All subsequent iterations happen here</span>\n\n   <span class=\"keyword\">func</span> updateSetting(keyPath: <span class=\"type\">AnyKeyPath</span>, title: <span class=\"type\">String</span>) {\n\n     <span class=\"keyword\">let</span> value = provider[keyPath: keyPath]\n\n     <span class=\"keyword\">if let</span> nestedProvider = value <span class=\"keyword\">as</span>? <span class=\"type\">SettingsProvider</span> {\n\n       <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> nestedProvider.<span class=\"property\">settings</span> {\n\n         <span class=\"keyword\">if let</span> joined = keyPath.<span class=\"call\">appending</span>(path: item.<span class=\"property\">keyPath</span>) {\n\n           <span class=\"call\">updateSetting</span>(keyPath: joined, title: item.<span class=\"property\">title</span>)\n\n         }\n\n       }\n\n     } <span class=\"keyword\">else if let</span> writable = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">Provider</span>, <span class=\"type\">Bool</span>&gt; {\n\n       <span class=\"call\">print</span>(title)\n\n       provider[keyPath: writable] = <span class=\"keyword\">true</span>\n\n     }\n\n   }\n\n\n\n   <span class=\"comment\">// The initial iteration</span>\n\n   <span class=\"keyword\">for</span> setting <span class=\"keyword\">in</span> provider.<span class=\"property\">settingsEntries</span> {\n\n     <span class=\"call\">updateSetting</span>(keyPath: setting.<span class=\"property\">keyPath</span>, title: setting.<span class=\"property\">title</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>That's it! We cast the keypath to a writable variant, and then we can modify the contents of our <code>Settings</code> type (or nested types). Everything happens in these additional lines of code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> writable = keyPath <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">Provider</span>, <span class=\"type\">Bool</span>&gt; {\n\n       <span class=\"call\">print</span>(title)\n\n       provider[keyPath: writable] = <span class=\"keyword\">true</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Subsequently, we could easily extend these lines to also query for <code>WritableKeyPath&lt;Provider, String&gt;</code> or <code>WritableKeyPath&lt;Provider, Double&gt;</code>, etc.</p>\n<p>This is our final function. It allows us to handle app settings in a completely generic manner. It iterates over them, it can display them (we did not see that because the code size would have exploded), and it can edit them. Without ever knowing the actual shape of the settings type. It can also be used for structures other than settings. Any complex type can be iterated in this manner.</p>\n<p>However, this was only a small example of what you can do with keypaths. There is even more! Lets have a look.</p>\n<h1>Three tips for using KeyPaths</h1>\n<p>This chapter will highlight a couple of very useful tricks that you can keep in mind writing code in order to identify situations where keypaths are helpful.</p>\n<h1>1. Erase Types</h1>\n<p>We already saw this, but it is worth mentioning again. One reason why keypaths are so useful is because there're type-erased variants. As we saw in our practical example, the ability to temporarily go to <code>AnyKeyPath</code> offers many more opportunities. So, always remember these types:</p>\n<pre class=\"Swift\"><code><span class=\"type\">KeyPath</span>&lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n\n<span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">A</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n\n<span class=\"type\">AnyKeyPath</span> = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n</code></pre></code></pre>\n<h1>2. Cast Types Back</h1>\n<p>This is the opposite of what we just did. Instead of removing types, we're adding types back:</p>\n<pre class=\"Swift\"><code><span class=\"type\">AnyKeyPath</span> <span class=\"keyword\">as</span>? <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt;\n\n<span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; <span class=\"keyword\">as</span>? <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">Bool</span>&gt;\n</code></pre></code></pre>\n<p>Sometimes you might need to add generics in order to keep the necessary types around to perform the correct casting. An example of this was how we wrote</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings&lt;Provider: <span class=\"type\">SettingsProvider</span>&gt;(provider: <span class=\"type\">Provider</span>)\n</code></pre></code></pre>\n<p>instead of the simpler:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> editSettings(provider: <span class=\"type\">SettingsProvider</span>)\n</code></pre></code></pre>\n<p>The second version would work just as fine, but it would not allow us to use <code>Provider</code> as the <code>Root</code> type in our <code>WritableKeyPath&lt;Provider, Bool&gt;</code> cast.</p>\n<h1>3. KeyPaths conform to <code>Hashable</code></h1>\n<p>We did not see an example of this  yet, but it is one of my all-time favorite keypaths functions. Every <code>KeyPath</code> type is <code>Hashable</code> which means that it can be used as a key in a dictionary. One use case for this is storing meta information about properties in a dictionary. Here, we have a dictionary that maps from partial key paths to <code>String</code>. It stores two different keypaths (<code>username</code>, <code>age</code>) and their titles:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> meta: [<span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt;: <span class=\"type\">String</span>] = [\n\n   \\<span class=\"type\">User</span>.<span class=\"property\">username</span>: \\<span class=\"string\">\"Your</span> <span class=\"type\">Username</span>\\<span class=\"string\">\"</span>,\n\n   \\<span class=\"type\">User</span>.<span class=\"property\">age</span>: \\<span class=\"string\">\"Your</span> <span class=\"type\">Age</span>\\<span class=\"string\">\"</span>\n\n]\n</code></pre></code></pre>\n<p>We can now write a function <code>renderTitle</code> that will retrieve this meta information and print it out alongside the actual value:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> renderTitle(on: <span class=\"type\">User</span>, keyPath: <span class=\"type\">AnyKeyPath</span>) {\n\n   <span class=\"keyword\">if let</span> title = meta[keyPath] {\n\n     <span class=\"call\">print</span>(title, terminator: \\<span class=\"string\">\"</span>: \\<span class=\"string\">\"</span>)\n\n   }\n\n   <span class=\"call\">print</span>(on[keyPath: keyPath])\n\n}\n\n\n\n<span class=\"keyword\">let</span> myUser = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Jon</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">44</span>)\n\n\n\n<span class=\"call\">renderTitle</span>(on: myUser, keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">age</span>)\n</code></pre></code></pre>\n<p>This would print <code>Your Age: 44</code></p>\n<p>This pattern can be used for many more situations. Whenever you have information about a type, you can utilize it to store the information. Another example would be input validation.</p>\n<h1>Conclusion</h1>\n<p>We've seen how the Swift <code>KeyPath</code> type can be used to define abstractions that would otherwise not be possible with just protocols or generics. As with everything in Swift, the beauty is how you can combine the different patterns, be it <code>KeyPath</code>, or <code>protocol</code>, or <code>generics</code> and use them to solve problems in new and exciting kind of ways. With each release, Swift introduces more and better features that help us do this. KeyPaths are one of those nice additions that simplify development in many ways.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/generic_settings/settings_provider.md":["1f02d05b436aa645",{"identifier":"6d75c220","filename":"settings_provider.md","info":{"title":"Settings Provider","tags":["keypath","generics","protocol"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-settings-provider.html","content":"<h1>A Settings Provider</h1>\n<p>Now that we have our <code>SettingsEntry</code> type, we need a way to provide all the settings entries that make up our UI. This is where protocols are a great solution. We want something that works for our different settings types (<code>Settings</code>, <code>ProfileSettings</code>, <code>PrivacySettings</code>), and protocols are made for just that. Our concrete protocol is defined to provide our applications with the specific settings for a type, so we will call it <code>SettingsProvider</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> SettingsProvider {\n\n   <span class=\"keyword\">var</span> settingsEntries: [<span class=\"type\">SettingsEntry</span>] { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>It is also a fairly simple protocol. The only thing it does is provide a <code>getter</code> to return an array of <code>SettingsEntry</code> types for one of our settings types. Lets implement it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Settings</span>: <span class=\"type\">SettingsProvider</span> {\n\n  <span class=\"keyword\">var</span> settingsEntries: [<span class=\"type\">SettingsEntry</span>] {\n\n   <span class=\"keyword\">return</span> [\n\n       <span class=\"type\">SettingsEntry</span>(\n\n           keyPath: \\<span class=\"type\">Settings</span>.<span class=\"property\">profileSettings</span>, \n\n             title: \\<span class=\"string\">\"Profile</span>\\<span class=\"string\">\"</span>),\n\n\n\n       <span class=\"type\">SettingsEntry</span>(\n\n           keyPath: \\<span class=\"type\">Settings</span>.<span class=\"property\">privacySettings</span>, \n\n             title: \\<span class=\"string\">\"Privacy</span>\\<span class=\"string\">\"</span>)\n\n   ]\n\n  }\n\n}\n</code></pre></code></pre>\n<p>Our first implementation is for our main parent <code>Settings</code> <code>class</code>. It has two properties that we'd like to be displayed in the settings, the <code>Profile Settings</code> and the <code>Privacy Settings</code>, which is why we're returning these two as <code>SettingsEntry</code> types.</p>\n<p>Next up, we will implement the <code>SettingsProvider</code> for our <code>ProfileSettings</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">ProfileSettings</span>: <span class=\"type\">SettingsProvider</span> {\n\n  <span class=\"keyword\">var</span> settingsEntries: [<span class=\"type\">SettingsEntry</span>] {\n\n   <span class=\"keyword\">return</span> [\n\n     <span class=\"type\">SettingsEntry</span>(\n\n        keyPath: \\<span class=\"type\">ProfileSettings</span>.<span class=\"property\">displayName</span>,\n\n          title: \\<span class=\"string\">\"Display</span> <span class=\"type\">Name</span>\\<span class=\"string\">\"</span>),\n\n\n\n     <span class=\"type\">SettingsEntry</span>(\n\n        keyPath: \\<span class=\"type\">ProfileSettings</span>.<span class=\"property\">shareUpdates</span>,\n\n          title: \\<span class=\"string\">\"Share</span> <span class=\"type\">Profile Media Updates</span>\\<span class=\"string\">\"</span>)\n\n   ]\n\n  }\n\n}\n</code></pre></code></pre>\n<p>Again, we return two settingsEntries, because this settings screen should display the <code>Display Name</code> and <code>Share Updates</code> setting. Finally, we obviously also need to implement our <code>SettingsProvider</code> for our <code>PrivacySettings</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">PrivacySettings</span>: <span class=\"type\">SettingsProvider</span> {\n\n  <span class=\"keyword\">var</span> settings: [<span class=\"type\">SettingsEntry</span>] {\n\n   <span class=\"keyword\">return</span> [\n\n     <span class=\"type\">SettingsEntry</span>(\n\n         keyPath: \\<span class=\"type\">PrivacySettings</span>.<span class=\"property\">addByID</span>, \n\n           title: \\<span class=\"string\">\"Allow</span> add me by <span class=\"type\">ID</span>\\<span class=\"string\">\"</span>),\n\n\n\n     <span class=\"type\">SettingsEntry</span>(\n\n         keyPath: \\<span class=\"type\">PrivacySettings</span>.<span class=\"property\">passcode</span>, \n\n           title: \\<span class=\"string\">\"Passcode</span> <span class=\"type\">Lock</span>\\<span class=\"string\">\"</span>)\n\n   ]\n\n  }\n\n}\n</code></pre></code></pre>\n<p>No surprises here.</p>\n","raw_content":"[frontMatter]\ntitle = \"Settings Provider\"\ntags = [\"keypath\", \"generics\", \"protocol\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# A Settings Provider\n\nNow that we have our `SettingsEntry` type, we need a way to provide all the settings entries that make up our UI. This is where protocols are a great solution. We want something that works for our different settings types (`Settings`, `ProfileSettings`, `PrivacySettings`), and protocols are made for just that. Our concrete protocol is defined to provide our applications with the specific settings for a type, so we will call it `SettingsProvider`.\n\n``` Swift\nprotocol SettingsProvider {\n  var settingsEntries: [SettingsEntry] { get }\n}\n```\n\nIt is also a fairly simple protocol. The only thing it does is provide a `getter` to return an array of `SettingsEntry` types for one of our settings types. Lets implement it:\n\n``` Swift\nextension Settings: SettingsProvider {\n var settingsEntries: [SettingsEntry] {\n  return [\n      SettingsEntry(\n          keyPath: \\Settings.profileSettings, \n            title: \"Profile\"),\n\n      SettingsEntry(\n          keyPath: \\Settings.privacySettings, \n            title: \"Privacy\")\n  ]\n }\n}\n```\n\nOur first implementation is for our main parent `Settings` `class`. It has two properties that we'd like to be displayed in the settings, the `Profile Settings` and the `Privacy Settings`, which is why we're returning these two as `SettingsEntry` types.\n\nNext up, we will implement the `SettingsProvider` for our `ProfileSettings`:\n\n``` Swift\nextension ProfileSettings: SettingsProvider {\n var settingsEntries: [SettingsEntry] {\n  return [\n    SettingsEntry(\n       keyPath: \\ProfileSettings.displayName,\n         title: \"Display Name\"),\n\n    SettingsEntry(\n       keyPath: \\ProfileSettings.shareUpdates,\n         title: \"Share Profile Media Updates\")\n  ]\n }\n}\n```\n\nAgain, we return two settingsEntries, because this settings screen should display the `Display Name` and `Share Updates` setting. Finally, we obviously also need to implement our `SettingsProvider` for our `PrivacySettings`.\n\n``` Swift\nextension PrivacySettings: SettingsProvider {\n var settings: [SettingsEntry] {\n  return [\n    SettingsEntry(\n        keyPath: \\PrivacySettings.addByID, \n          title: \"Allow add me by ID\"),\n\n    SettingsEntry(\n        keyPath: \\PrivacySettings.passcode, \n          title: \"Passcode Lock\")\n  ]\n }\n}\n```\n\nNo surprises here.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/optionals/complete_book.html":["e3b0c44298fc1c14",{"identifier":"d529","filename":"complete_book.html","info":{"title":"Optionals","tags":[],"keywords":["feature","lisp","swift","optional","scala","simple","optionals","switch","chaining","for","pattern","matching","clojure","haskell"],"category":[],"created":"2015-08-20 10:30:30","description":"Best practices for handling Swift's `Optional` and extending them to make them much more approachable","description_html":"<p>Best practices for handling Swift's <code>Optional</code> and extending them to make them much more approachable</p>\n","published":true,"slug":null,"meta":{"swift_version":"5.1","short_title":"⁉️ Optionals","short_code":"<pre class='Swift'><code><span class='apvsource swift'>a?<span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'>.</span>b?<span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'>.</span>c? <span class='apvkeyword apvoperator apvcomparative swift'>==</span> <span class='apvconstant apvnil swift'>nil</span> </span></code></pre></code></pre>"},"created_timestamp":1440066630,"date":"2015-08-20T10:30:30","date_info":{"year":2015,"month":8,"day":20,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/optionals/complete_book.html","content":"<h1>What are Optionals</h1>\n<p>Optionals are one of the staple features of Swift. They're something that appears very, very often during normal iOS development. Much more often than other features such as enums or generics.</p>\n<p>However, if you're new to Swift and come from a different programming language such as Python, Ruby, or even Objective-C, then optionals can be daunting. This guide is split up into a basic introduction into <code>Optionals</code> for those new to the subject matter and an advanced guide that will showcase more advanced optional handling for more seasoned developers.</p>\n<p>Lets begin by briefly explaining why optionals are even needed.</p>\n<h1>Why Optionals are useful</h1>\n<p>Optionals aim to solve a problem related to something called &quot;null pointers&quot;. We don't want to go too much into the history here, instead, we will showcase a typical situation where optionals are needed.</p>\n<p>Imagine that you write your own User Defaults. We want to store a value <code>String</code> for a key <code>String</code> . We will ignore almost everything except for the one function <code>get</code> that allows us to get a <code>String</code> from the defaults.</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">struct</span> MyDefaults {\n\n   ...\n\n   <span class=\"comment\">/// A function that returns a `String`</span>\n\n   <span class=\"keyword\">func</span> get(key: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> {\n\n   }\n\n}\n\n\n</code></pre></code></pre>\n<p>The problem is what do we do when we don't have that value in our defaults? What would we return? Now, we could return an &quot;Empty&quot; string, but that wouldn't be right, would it? Imagine you'd save the username in the defaults. Next time the user starts his app he'd see an empty username.</p>\n<p>What you really want to do is express the notifion of &quot;Nothing&quot;. We kinda want to write something like the following:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> get(key: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> or <span class=\"type\">Nothing</span> {\n\n}\n\n\n</code></pre></code></pre>\n<p>This either gives us back a string or it gives us back nothing. This is fundamentally what optionals are good for. They explain to the Swift type system <em>and</em> to the user that a value can either be Something or Nothing. The implementation is also really simple. It is just an <code>enum</code> with two cases: <code>some</code> and <code>none</code>. Some, has the actual value. Here's a simplified version:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> MyOptional {\n\n   <span class=\"keyword\">case</span> some(<span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> none\n\n}\n</code></pre></code></pre>\n<p>That's it. Now, the actual Swift Optional is not limited to Strings, instead it uses <code>generics</code> in order to provide support for any kind of type. It kinda looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Optional&lt;Wrapped&gt;\n\n   <span class=\"keyword\">case</span> some(<span class=\"type\">Wrapped</span>)\n\n   <span class=\"keyword\">case</span> none\n</code></pre></code></pre>\n<p>So what do we do if we call a function that returns an optional? Since optionals are just simple enums, we can just use Swift's normal <code>enum</code> handling for this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optionalValue = <span class=\"call\">functionReturningOptional</span>()\n\n<span class=\"keyword\">switch</span> optionalValue {\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">some</span>(value): <span class=\"call\">print</span>(value)\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">none</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Nothing</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<h2>The types of Optionals</h2>\n<p>Thankfully, we don't have to spell out the long <code>Optional.some</code> all the time. Instead, Swift offers us a very brief alternative, which is just adding a questionmark <code>?</code> to a type. This will tell Swift that this type is an <code>Optional</code>. This means that the following two are equal:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> one: <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt; = <span class=\"type\">Optional</span>.<span class=\"call\">some</span>(<span class=\"number\">5</span>)\n\n<span class=\"keyword\">let</span> two: <span class=\"type\">Int</span>? = <span class=\"number\">5</span>\n</code></pre></code></pre>\n<p>This is usually the default Syntax for <code>Optionals</code> in Swift. You'll hardly see the other Syntax, but it is still good to know as you might stumble upon it from time to time.</p>\n<p>Also, if you want to create an empty optional, you can just use <code>nil</code> as a shorthand for the empty optional. Again, the following two lines are equal:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> one: <span class=\"type\">Int</span>? = <span class=\"type\">Optional</span>.<span class=\"property\">none</span>\n\n<span class=\"keyword\">let</span> two: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n</code></pre></code></pre>\n<p>You can only use <code>nil</code> if Swift can somehow infer the type of the Optional, so the next example does not work because Swift does not know what kind of <code>Optional</code> this is. Is this a <code>Int?</code> or a <code>Float?</code> or a <code>String?</code>. Swift can't find out:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> doesNotWork = <span class=\"keyword\">nil</span>\n</code></pre></code></pre>\n<p>Swift offers many ways of handling <code>Optional</code> types. Lets look at them next.</p>\n<h1>How to handle optionals</h1>\n<p>As we saw in the <a href=\"javascript:prev()\">previous</a> chapter, Optionals are\nreally just <code>enum</code> types. However, as they're deeply ingrained into\nthe language, Swift offers a lot of additional possibilities of\nhandling <code>Optionals</code>.</p>\n<h2>If Let</h2>\n<p>Certainly the most used one is the so-called if let. You're basically telling\nSwift &quot;If this optional value <code>myOptionalValue</code> actually contains a value, please give me the contained value\ninto the variable named <code>myUnwrappedValue</code>&quot;:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> myUnwrappedValue = myOptionalValue {\n\n   <span class=\"call\">print</span>(myUnwrappedValue)\n\n}\n</code></pre></code></pre>\n<p>If <code>myOptionalValue</code> is actually empty, then the <code>print</code> statement\nwould never be executed. As with any typical <code>if</code> statement, this\ncan also have an else expression:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> myUnwrappedValue = myOptionalValue {\n\n   <span class=\"call\">print</span>(myUnwrappedValue)\n\n} <span class=\"keyword\">else</span> {\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"No</span> <span class=\"type\">Value</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>You can also combine multiple <code>if let</code> statements if you need to handle\nmultiple <code>Optional</code> values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> firstValue = firstOptionalValue,\n\n    <span class=\"keyword\">let</span> secondValue = secondOptionalValue,\n\n    <span class=\"keyword\">let</span> thirdValue = <span class=\"call\">thirdOptionalValue</span> {\n\n    <span class=\"call\">print</span>(firstValue, secondValue, thirdValue)\n\n} \n</code></pre></code></pre>\n<p>Finally, you can mix and match the <code>if let</code> pattern with normal if expressions:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> firstValue = firstOptionalValue,\n\n    firstValue &gt; <span class=\"number\">10</span>\n\n    <span class=\"keyword\">let</span> secondValue = secondOptionalValue,\n\n    secondValue == \\<span class=\"string\">\"HTTP</span>\\<span class=\"string\">\"</span>,\n\n    <span class=\"keyword\">let</span> thirdValue = <span class=\"call\">thirdOptionalValue</span> {\n\n    <span class=\"call\">print</span>(firstValue, secondValue, thirdValue)\n\n} \n</code></pre></code></pre>\n<p>In this example, we only print the three values if the firstOptionalValue is not empty and has a value &gt; 10, and if the second optional value is not empty and has the value &quot;HTTP&quot; and if the third optional value is not empty.</p>\n<h2>Guard</h2>\n<p>Another nice feature of Swift are the <code>guard</code> statements. They're basically like inverted <code>if</code> statements. You usually use them at the beginning of a block of code to make sure that all your requirements are held. The main difference compared to <code>if let</code> is that you're required to leave the current scope (i.e. <code>return</code>, <code>continue</code>, or <code>break</code>) if the <code>guard</code> does not succeed. Lets look at this nonsensical function that tries to do addition with two <code>Optional</code> <code>Int</code> values. For that to work, we need to make sure that</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> addOptionals(firstNumber: <span class=\"type\">Int</span>?, secondNumber: <span class=\"type\">Int</span>?) -&gt; <span class=\"type\">Int</span>? {\n\n   <span class=\"keyword\">guard let</span> first = firstNumber, <span class=\"keyword\">let</span> second = secondNumber\n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n   <span class=\"keyword\">return</span> first + second\n\n}\n</code></pre></code></pre>\n<p>So here, we do the <code>guard let</code> in order to make sure that both <code>firstNumber</code> and <code>secondNumber</code> have a value, otherwise we can't really do the addition. So if one of them (or both) don't have a value, we return early in the <code>else { return nil}</code> block.</p>\n<p>Observe how with <code>if let</code> the code-to-be-executed is within the <code>if</code> braces, while with <code>guard let</code> it is not:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> a = b {\n\n   <span class=\"call\">print</span>(b)\n\n}\n\n\n\n<span class=\"keyword\">guard let</span> a = b <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n<span class=\"call\">print</span>(b)\n</code></pre></code></pre>\n<p>This makes it easier to follow the structure of code because your main code is not nested but only at the very left side of the function.</p>\n<h2>Switch</h2>\n<p>We already mentioned this in the <a href=\"javascript:previous()\">previous</a> chapter, but you can also use <code>switch</code> to handle <code>Optionals</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> myOptionalValue {\n\n<span class=\"keyword\">case let</span> value?: <span class=\"call\">print</span>(value)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>We have a whole guide on pattern matching with Swift where this is explained\nin much more detail.</p>\n<h2>Forced Unwrap</h2>\n<p>Sometimes, if you're absolutely sure that your <code>Optional</code> has a value, you can\nalso use the <code>forced unwrap</code>. This tells Swift to handle this <code>Optional</code> value as if\nit was a non-optional value.</p>\n<p>This works great, but it means that the optional has to have a value. If\nyou try a forced unwrap on an empty optional (i.e. nil) it will cause a\nruntime error (meaning, crash).</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> oneValue: <span class=\"type\">Int</span>? = <span class=\"number\">5</span>\n\n<span class=\"keyword\">let</span> twoValue: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\n\n\n<span class=\"call\">print</span>(oneValue!) <span class=\"comment\">// No Crash</span>\n\n<span class=\"call\">print</span>(twoValue!) <span class=\"comment\">// Crash</span>\n</code></pre></code></pre>\n<p>But wait, there's more. The next section in our guides discusses two additional methods of\nhandling optionals that are also really, really useful: Optional Chaining and Map.</p>\n<h1>Advanced Optionals</h1>\n<p>We've already seen the basics of handling optionals. However, there's much more you can do.\nIn this section we'll explore optionals even more and have a look at some advanced ways of\nhandling optionals</p>\n<h2>Optional Chaining</h2>\n<p>Now imagine your work on a relationship database, and your data are\nusers and their relations. So you'd have a Person and then the person\ncould have an optional child and the child could have an optional\nsibling and that sibling could have an optional child, and so on.</p>\n<p>Since all of these are <code>Person</code> types, we could model the type like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Person {\n\n   <span class=\"keyword\">var</span> child: <span class=\"type\">Person</span>?\n\n   <span class=\"keyword\">var</span> sibling: <span class=\"type\">Person</span>?\n\n   <span class=\"keyword\">var</span> father: <span class=\"type\">Person</span>?\n\n   <span class=\"keyword\">var</span> mother: <span class=\"type\">Person</span>?\n\n}\n</code></pre></code></pre>\n<p>All of our properties are optional because they can all be nil.\nNow imagine you'd like to find the following relative:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">person</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> child -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> sibling -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> child -<span class=\"techoukeyword techouoperator techouassignment techouredirection techoushell\">&gt;</span> mother</span>\n</span></code></pre></code></pre>\n<p>So, how would we do that with <code>if let</code> in Swift? Let us have a try:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> child = person.<span class=\"property\">child</span>,\n\n    <span class=\"keyword\">let</span> sibling = person.<span class=\"property\">sibling</span>,\n\n    <span class=\"keyword\">let</span> nextChild = person.<span class=\"property\">child</span>,\n\n    <span class=\"keyword\">let</span> mother = nextChild.<span class=\"call\">mother</span> {\n\n    <span class=\"call\">print</span>(mother)\n\n    }\n</code></pre></code></pre>\n<p>This is a lot of code and can quickly become confusing. Thankfully,\nSwift has another feature which lets us write this in a much simpler fashion.</p>\n<p>The idea being that in a chain of operations on optionals\n(such as Optional.child -&gt; Optional.silbing -&gt; Optional.child)\nif any of these operations returns nil, we stop executing the chain early.</p>\n<p>You represent this behaviour via a <code>?</code> before calling a method. Here is the\nprevious example implemented with the <code>optional chaining</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> mother = person.<span class=\"property\">child</span>?.<span class=\"property\">sibling</span>?.<span class=\"property\">child</span>?.<span class=\"property\">mother</span> {\n\n   <span class=\"call\">print</span>(mother)\n\n}\n</code></pre></code></pre>\n<p>We're basically telling Swift &quot;If the value of the child property of person is not\noptional, then please get me the sibling property from it&quot;. And we do the same again\nfor the next propery.</p>\n<p>This, also, works great for dictionaries where all return values are always optional.</p>\n<pre class=\"Swift\"><code>example[\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>]?[\\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>]?[\\<span class=\"string\">\"c</span>\\<span class=\"string\">\"</span>]\n</code></pre></code></pre>\n<p>By adding <code>?</code> in between each call / access, Swift will\nautomatically unwrap if there is a value, or stop the chain as soon\nas any one evaluates to nil.</p>\n<h2>Map</h2>\n<p>Consider the following code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> example() -&gt; <span class=\"type\">Int</span>? {<span class=\"keyword\">return</span> <span class=\"number\">10</span>}\n\n\n\n<span class=\"keyword\">if let</span> value = <span class=\"call\">example</span>() {\n\n     <span class=\"call\">storeInDatabase</span>(value * <span class=\"number\">2</span>)\n\n}\n</code></pre></code></pre>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">If we break down the logic, what we\\&#39;re really trying to achieve,\nwere it not for optionals, is the following:\n\n``` Swift\nstoreInDatabase(example() * 10)\n```\n\nOptionals are still very useful here, as they prevent us from the\ndanger of multiplying nil with 10 and trying to store that in the\ndatabase. But still, we have to admit that the optionals code looks\nmore convoluted. As you can imagine, there\\&#39;s a solution to this, of\ncourse.\n\nOptionals offer an implementation of the `map` function which will\ncall the value of an optional with a supplied closure if\nthe optional has a value.\n</span></code></pre></code></pre>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> px: <span class=\"type\">Int</span>? = <span class=\"number\">5</span>\n\n\n\n<span class=\"comment\">// This will print \\\"5\\\"</span>\n\npx.<span class=\"call\">map</span> { <span class=\"call\">print</span>($0) }\n\n\n\n<span class=\"comment\">// This will do nothing</span>\n\n<span class=\"keyword\">let</span> px: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\npx.<span class=\"call\">map</span> { <span class=\"call\">print</span>($0) }\n\n\n</code></pre></code></pre>\n<p>This lets us rewrite our example from above in terms of <code>map</code> as follows:</p>\n<pre class=\"Swift\"><code><span class=\"call\">example</span>().<span class=\"call\">map</span>({ number <span class=\"keyword\">in</span> \n\n   <span class=\"call\">storeInDatabase</span>(number * <span class=\"number\">2</span>) \n\n})\n</code></pre></code></pre>\n<p>What happens here is: When the return value of <code>example()</code> is not optional, then the closure\nwill be called the value as <code>number</code> and so we can call the <code>storeInDatabase</code> function with our number multiplied by two. If the return value of <code>example()</code> is empty, nothing will happen.</p>\n<p>With Swift's nice simplified closure syntax we can even simply this example to the following:</p>\n<pre class=\"Swift\"><code><span class=\"call\">example</span>().<span class=\"call\">map</span> { <span class=\"call\">storeInDatabase</span>($0 * <span class=\"number\">2</span>) }\n</code></pre></code></pre>\n<p><code>Optionals</code> are a staple of Swift. I guess everybody will agree that\nthey are a huge boon insofar as they force us to properly handle edge\ncases. The <code>Optional</code> language feature alone removes a whole category of\nbugs from the development process.</p>\n<p>However, the API surface of Swift's optional is rather limited. The\n<a href=\"https://developer.apple.com/documentation/swift/optional#topics\">Swift documentation lists just a\ncouple</a>\nof methods / properties on <code>Optional</code> - if we ignore <code>customMirror</code> and\n<code>debugDescription</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> unsafelyUnwrapped: <span class=\"type\">Wrapped</span> { <span class=\"keyword\">get</span> } \n\n<span class=\"keyword\">func</span> map&lt;U&gt;(<span class=\"keyword\">_</span> transform: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">U</span>) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">U</span>? \n\n<span class=\"keyword\">func</span> flatMap&lt;U&gt;(<span class=\"keyword\">_</span> transform: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">U</span>?) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">U</span>? \n</code></pre></code></pre>\n<p>The reason why optionals are still very useful even though they have\nsuch a small amount of methods is that the Swift syntax makes up for it\nvia features such as <a href=\"lnk::optional\">optional\nchaining</a>,\n<a href=\"lnk::switch\">pattern\nmatching</a>,\n<code>if let</code> or <code>guard let</code>. In some situations, though, this manifests\nitself in unnecessary line noise. Sometimes, a very succinct method will\nlet you express a concept in one short line of code instead of multiple\nlines of combined <code>if let</code> statements.</p>\n<p>I've sifted through Swift Projects on Github as well as the optional\nimplementations of other languages such as Rust, Scala, or C# in order\nto find a couple of useful additions to <code>Optional</code>. Below are 14 useful\n<code>Optional</code> extensions. I'll describe them by category and then give a\ncouple of examples per category. Finally, I'll write a more involved\nexample that uses several extensions at once.</p>\n<h1>Emptiness</h1>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Returns true if the optional is empty</span>\n\n     <span class=\"keyword\">var</span> isNone: <span class=\"type\">Bool</span> {\n\n         <span class=\"keyword\">return self</span> == .<span class=\"dotAccess\">none</span>\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns true if the optional is not empty</span>\n\n     <span class=\"keyword\">var</span> isSome: <span class=\"type\">Bool</span> {\n\n         <span class=\"keyword\">return self</span> != .<span class=\"dotAccess\">none</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Those are the most basic additions to the optional type. The\nimplementation could also use a <code>switch</code> pattern match instead, but the\n<code>nil</code> comparison is much shorter. What I like about these additions is\nthat they move the concept of an empty optional being nil away from your\ncode. This might just as well be an implementation detail. Using\n<code>optional.isSome</code> feels much cleaner and less noisy than\n<code>if optional == nil</code>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Compare</span>\n\n<span class=\"keyword\">guard</span> leftButton != <span class=\"keyword\">nil</span>, rightButton != <span class=\"keyword\">nil else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Missing</span> <span class=\"type\">Interface Builder</span> connections\\<span class=\"string\">\"</span>) }\n\n\n\n<span class=\"comment\">// With</span>\n\n<span class=\"keyword\">guard</span> leftButton.<span class=\"property\">isSome</span>, rightButton.<span class=\"property\">isSome</span> <span class=\"keyword\">else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Missing</span> <span class=\"type\">Interface Builder</span> connections\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<h1>Or</h1>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Return the value of the Optional or the `default` parameter</span>\n\n     <span class=\"comment\">/// - param: The value to return if the optional is empty</span>\n\n     <span class=\"keyword\">func</span> or(<span class=\"keyword\">_ default</span>: <span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">return self</span> ?? `default`\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the unwrapped value of the optional *or*</span>\n\n     <span class=\"comment\">/// the result of an expression `else`</span>\n\n     <span class=\"comment\">/// I.e. optional.or(else: print(\\\"Arrr\\\"))</span>\n\n     <span class=\"keyword\">func</span> or(else: <span class=\"keyword\">@autoclosure</span> () -&gt; <span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">return self</span> ?? `else`()\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the unwrapped value of the optional *or*</span>\n\n     <span class=\"comment\">/// the result of calling the closure `else`</span>\n\n     <span class=\"comment\">/// I.e. optional.or(else: {</span> \n\n     <span class=\"comment\">/// ... do a lot of stuff</span>\n\n     <span class=\"comment\">/// })</span>\n\n     <span class=\"keyword\">func</span> or(else: () -&gt; <span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">return self</span> ?? `else`()\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the unwrapped contents of the optional if it is not empty</span>\n\n     <span class=\"comment\">/// If it is empty, throws exception `throw`</span>\n\n     <span class=\"keyword\">func</span> or(throw exception: <span class=\"type\">Error</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">guard let</span> unwrapped = <span class=\"keyword\">self else</span> { <span class=\"keyword\">throw</span> exception }\n\n         <span class=\"keyword\">return</span> unwrapped\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> <span class=\"keyword\">where</span> <span class=\"type\">Wrapped</span> == <span class=\"type\">Error</span> {\n\n     <span class=\"comment\">/// Only perform `else` if the optional has a non-empty error value</span>\n\n     <span class=\"keyword\">func</span> or(<span class=\"keyword\">_</span> else: (<span class=\"type\">Error</span>) -&gt; <span class=\"type\">Void</span>) {\n\n         <span class=\"keyword\">guard let</span> error = <span class=\"keyword\">self else</span> { <span class=\"keyword\">return</span> }\n\n         `else`(error)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Another abstraction on the <code>isNone / isSome</code> concept is being able to\nspecify instructions to be performed when the invariant doesn't hold.\nThis saves us from having to write out <code>if</code> or <code>guard</code> branches and\ninstead codifies the logic into a simple-to-understand method.</p>\n<p>This concept is so useful, that it is defined in three distinct\nfunctions.</p>\n<h2>Default Value</h2>\n<p>The first one returns the wrapped value of the optional or a default\nvalue:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\n<span class=\"call\">print</span>(optional.<span class=\"call\">or</span>(<span class=\"number\">10</span>)) <span class=\"comment\">// Prints 10</span>\n</code></pre></code></pre>\n<h2>Default Closure</h2>\n<p>The second one is very similar to the first one, however it allows to\nreturn a default value from a closure instead.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\noptional.<span class=\"call\">or</span>(else: secretValue * <span class=\"number\">32</span>) \n</code></pre></code></pre>\n<p>Since this uses the <code>@autoclosure</code> parameter we could actually use just\nthe second <code>or</code> implementation. Then, using a just a default value would\nautomatically be converted into a closure returning the value. However,\nI prefer having two separate implementations as that allows users to\nalso write closures with more complex logic.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> cachedUserCount: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\n...\n\n<span class=\"keyword\">return</span> cachedUserCount.<span class=\"call\">or</span>(else: {\n\n    <span class=\"keyword\">let</span> db = <span class=\"call\">database</span>()\n\n    db.<span class=\"call\">prefetch</span>()\n\n    <span class=\"keyword\">guard</span> db.<span class=\"property\">failures</span>.<span class=\"property\">isEmpty</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"number\">0</span> }\n\n    <span class=\"keyword\">return</span> db.<span class=\"property\">amountOfUsers</span>\n\n})\n</code></pre></code></pre>\n<p>A really nice use case for <code>or</code> is code where you only want to set a\nvalue on an optional if it is empty:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if</span> databaseController == <span class=\"keyword\">nil</span> {\n\n   databaseController = <span class=\"type\">DatabaseController</span>(config: config)\n\n}\n</code></pre></code></pre>\n<p>This can be replaced with the much nicer:</p>\n<pre class=\"Swift\"><code>databaseController = databaseController.<span class=\"call\">or</span>(<span class=\"type\">DatabaseController</span>(config: config)\n</code></pre></code></pre>\n<h2>Throw an error</h2>\n<p>This is a very useful addition as it allows to merge the chasm between\nOptionals and Error Handling in Swift. Depending on the code that\nyou're using, a method or function may express invalid behaviour by\nreturning an empty optional (imagine accessing a non-existing key in a\n<code>Dictionary</code>) or by throwing an <code>Error</code>. Combining these two oftentimes\nleads to a lot of unnecessary line noise:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> buildCar() <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Car</span> {\n\n   <span class=\"keyword\">let</span> tires = <span class=\"keyword\">try</span> machine1.<span class=\"call\">createTires</span>()\n\n   <span class=\"keyword\">let</span> windows = <span class=\"keyword\">try</span> machine2.<span class=\"call\">createWindows</span>()\n\n   <span class=\"keyword\">guard let</span> motor = externalMachine.<span class=\"call\">deliverMotor</span>() <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">throw</span> <span class=\"type\">MachineError</span>.<span class=\"property\">motor</span>\n\n   }\n\n   <span class=\"keyword\">let</span> trunk = <span class=\"keyword\">try</span> machine3.<span class=\"call\">createTrunk</span>()\n\n   <span class=\"keyword\">if let</span> car = manufacturer.<span class=\"call\">buildCar</span>(tires, windows,  motor, trunk) {\n\n     <span class=\"keyword\">return</span> car\n\n   } <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">throw</span> <span class=\"type\">MachineError</span>.<span class=\"property\">manufacturer</span>\n\n   }\n\n}\n</code></pre></code></pre>\n<p>In this example, we're building a car by combining internal and\nexternal code. The external code (<code>external_machine</code> and <code>manufacturer</code>)\nchoose to use optionals instead of error handling. This makes the code\nunnecessary complicated. Our <code>or(throw:)</code> function makes this much more\nreadable:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> build_car() <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Car</span> {\n\n   <span class=\"keyword\">let</span> tires = <span class=\"keyword\">try</span> machine1.<span class=\"call\">createTires</span>()\n\n   <span class=\"keyword\">let</span> windows = <span class=\"keyword\">try</span> machine2.<span class=\"call\">createWindows</span>()\n\n   <span class=\"keyword\">let</span> motor = <span class=\"keyword\">try</span> externalMachine.<span class=\"call\">deliverMotor</span>().<span class=\"call\">or</span>(throw: <span class=\"type\">MachineError</span>.<span class=\"property\">motor</span>)\n\n   <span class=\"keyword\">let</span> trunk = <span class=\"keyword\">try</span> machine3.<span class=\"call\">createTrunk</span>()\n\n   <span class=\"keyword\">return try</span> manufacturer.<span class=\"call\">buildCar</span>(tires, windows,  motor, trunk).<span class=\"call\">or</span>(throw: <span class=\"type\">MachineError</span>.<span class=\"property\">manufacturer</span>)\n\n}\n</code></pre></code></pre>\n<h2>Handling Errors</h2>\n<p>The code from the <strong>Throw an error</strong> section above becomes even more\nuseful when you include the following free function that was proposed by\n<a href=\"https://github.com/doozMen\">Stijn Willems on Github</a>. Thanks for the\nsuggestion!</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> should(<span class=\"keyword\">_</span> do: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Error</span>? {\n\n     <span class=\"keyword\">do</span> {\n\n         <span class=\"keyword\">try</span> `do`()\n\n         <span class=\"keyword\">return nil</span>\n\n     } <span class=\"keyword\">catch let</span> error {\n\n         <span class=\"keyword\">return</span> error\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This free function (alternatively, you could make it a class method on\noptional) will perform a <code>do {} catch {}</code> block and return an error if\nand only if the closure `do` resulted in an error. Take, the following\nSwift code as an example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">do</span> {\n\n   <span class=\"keyword\">try</span> <span class=\"call\">throwingFunction</span>()\n\n} <span class=\"keyword\">catch let</span> error {\n\n   <span class=\"call\">print</span>(error)\n\n}\n</code></pre></code></pre>\n<p>This is one of the basic tennets of error handling in Swift, and it\nintroduces quite a lot of line noise. With the free function above, you\ncan reduce it to this simple on-liner:</p>\n<pre class=\"Swift\"><code><span class=\"call\">should</span> { <span class=\"keyword\">try</span> throwingFunction) }.<span class=\"call\">or</span>(<span class=\"call\">print</span>($0))\n</code></pre></code></pre>\n<p>I feel that there're many situations where such a one-liner for error\nhandling would be very beneficient.</p>\n<h2>Map</h2>\n<p>As we saw above, <code>map</code> and <code>flatMap</code> are the only methods that Swift\noffers on Optionals. However, even those can be improved a bit to be\nmore versatile in many situations. There're two additional variations\non <code>map</code> that allow defining a default value similar to how the <code>or</code>\nvariants above are implemented:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Maps the output *or* returns the default value if the optional is nil</span>\n\n     <span class=\"comment\">/// - parameter fn: The function to map over the value</span>\n\n     <span class=\"comment\">/// - parameter or: The value to use if the optional is empty</span>\n\n     <span class=\"keyword\">func</span> map&lt;T&gt;(<span class=\"keyword\">_</span> fn: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>, default: <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">return try</span> <span class=\"call\">map</span>(fn) ?? `default`\n\n     }\n\n\n\n     <span class=\"comment\">/// Maps the output *or* returns the result of calling `else`</span>\n\n     <span class=\"comment\">/// - parameter fn: The function to map over the value</span>\n\n     <span class=\"comment\">/// - parameter else: The function to call if the optional is empty</span>\n\n     <span class=\"keyword\">func</span> map&lt;T&gt;(<span class=\"keyword\">_</span> fn: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>, else: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">return try</span> <span class=\"call\">map</span>(fn) ?? `else`()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>The first one will allow you to <code>map</code> the contents of an optional to a\nnew type <code>T</code>. If the optional is empty, you can define a <code>default</code> value\nthat should be used instead:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional1: <span class=\"type\">String</span>? = \\<span class=\"string\">\"appventure</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> optional2: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>\n\n\n\n<span class=\"comment\">// Without</span>\n\n<span class=\"call\">print</span>(optional1.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }) ?? <span class=\"number\">0</span>)\n\n<span class=\"call\">print</span>(optional2.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }) ?? <span class=\"number\">0</span>)\n\n\n\n<span class=\"comment\">// With</span> \n\n<span class=\"call\">print</span>(optional1.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>)) <span class=\"comment\">// prints 10</span>\n\n<span class=\"call\">print</span>(optional2.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }, <span class=\"keyword\">default</span>: <span class=\"number\">0</span>)) <span class=\"comment\">// prints 0</span>\n</code></pre></code></pre>\n<p>The changes are minimal, but we're moving away from having to use the\n<code>??</code> operator and can instead express the operation more clearly with\nthe <code>default</code> keyword.</p>\n<p>The second variant is very similar. The main difference is that it\naccepts (again) a closure returning value <code>T</code> instead of value <code>T</code>.\nHere's a brief example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optional: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>\n\n<span class=\"call\">print</span>(optional.<span class=\"call\">map</span>({ $0.<span class=\"property\">count</span> }, else: { \\<span class=\"string\">\"default</span>\\<span class=\"string\">\"</span>.<span class=\"property\">count</span> })\n</code></pre></code></pre>\n<h1>Combining Optionals</h1>\n<p>This category contains four functions that allow you to define relations\nbetween multiple optionals.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Tries to unwrap `self` and if that succeeds continues to unwrap the parameter `optional`</span>\n\n     <span class=\"comment\">/// and returns the result of that.</span>\n\n     <span class=\"keyword\">func</span> and&lt;B&gt;(<span class=\"keyword\">_</span> optional: <span class=\"type\">B</span>?) -&gt; <span class=\"type\">B</span>? {\n\n         <span class=\"keyword\">guard self</span> != <span class=\"keyword\">nil else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return</span> optional\n\n     }\n\n\n\n     <span class=\"comment\">/// Executes a closure with the unwrapped result of an optional.</span>\n\n     <span class=\"comment\">/// This allows chaining optionals together.</span>\n\n     <span class=\"keyword\">func</span> and&lt;T&gt;(then: (<span class=\"type\">Wrapped</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">T</span>?) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">T</span>? {\n\n         <span class=\"keyword\">guard let</span> unwrapped = <span class=\"keyword\">self else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return try</span> <span class=\"call\">then</span>(unwrapped)\n\n     }\n\n\n\n     <span class=\"comment\">/// Zips the content of this optional with the content of another</span>\n\n     <span class=\"comment\">/// optional `other` only if both optionals are not empty</span>\n\n     <span class=\"keyword\">func</span> zip2&lt;A&gt;(with other: <span class=\"type\">Optional</span>&lt;<span class=\"type\">A</span>&gt;) -&gt; (<span class=\"type\">Wrapped</span>, <span class=\"type\">A</span>)? {\n\n         <span class=\"keyword\">guard let</span> first = <span class=\"keyword\">self</span>, <span class=\"keyword\">let</span> second = other <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return</span> (first, second)\n\n     }\n\n\n\n     <span class=\"comment\">/// Zips the content of this optional with the content of another</span>\n\n     <span class=\"comment\">/// optional `other` only if both optionals are not empty</span>\n\n     <span class=\"keyword\">func</span> zip3&lt;A, B&gt;(with other: <span class=\"type\">Optional</span>&lt;<span class=\"type\">A</span>&gt;, another: <span class=\"type\">Optional</span>&lt;<span class=\"type\">B</span>&gt;) -&gt; (<span class=\"type\">Wrapped</span>, <span class=\"type\">A</span>, <span class=\"type\">B</span>)? {\n\n         <span class=\"keyword\">guard let</span> first = <span class=\"keyword\">self</span>,\n\n               <span class=\"keyword\">let</span> second = other,\n\n               <span class=\"keyword\">let</span> third = another <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return</span> (first, second, third)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>These four functions all share that they take an additional optional as\na parameter and return another optional value. However, they're all\nquite different in what they achieve.</p>\n<h2>Dependencies</h2>\n<p><code>and&lt;B&gt;(_ optional)</code> is useful if the unpacking of an optional is only\nrequired as a invariant for unpacking another optional:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Compare</span>\n\n<span class=\"keyword\">if</span> user != <span class=\"keyword\">nil</span>, <span class=\"keyword\">let</span> account = <span class=\"call\">userAccount</span>() ...\n\n\n\n<span class=\"comment\">// With</span>\n\n<span class=\"keyword\">if let</span> account = user.<span class=\"call\">and</span>(<span class=\"call\">userAccount</span>()) ...\n</code></pre></code></pre>\n<p>In the example above, we're not interested in the unwrapped contents of\nthe <code>user</code> optional. We just need to make sure that there <strong>is</strong> a valid\nuser before we call the <code>userAccount</code> function. While this relationship\nis kinda codified in the <code>user != nil</code> line, I personally feel that the\n<code>and</code> makes it more clear.</p>\n<h2>Chaining</h2>\n<p><code>and&lt;T&gt;(then:)</code> is another very useful function. It allows to chain\noptionals together so that the output of unpacking optional <code>A</code> becomes\nthe input of producing optional <code>B</code>. Lets start with a simple example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> UserDatabase {\n\n   <span class=\"keyword\">func</span> current() -&gt; <span class=\"type\">User</span>?\n\n   <span class=\"keyword\">func</span> spouse(of user: <span class=\"type\">User</span>) -&gt; <span class=\"type\">User</span>?\n\n   <span class=\"keyword\">func</span> father(of user: <span class=\"type\">User</span>) -&gt; <span class=\"type\">User</span>?\n\n   <span class=\"keyword\">func</span> childrenCount(of user: <span class=\"type\">User</span>) -&gt; <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> database: <span class=\"type\">UserDatabase</span> = ...\n\n\n\n<span class=\"comment\">// Imagine we want to know the children of the following relationship:</span>\n\n<span class=\"comment\">// Man -&gt; Spouse -&gt; Father -&gt; Father -&gt; Spouse -&gt; children</span>\n\n\n\n<span class=\"comment\">// Without</span>\n\n<span class=\"keyword\">let</span> childrenCount: <span class=\"type\">Int</span>\n\n<span class=\"keyword\">if let</span> user = database.<span class=\"call\">current</span>(), \n\n    <span class=\"keyword\">let</span> father1 = database.<span class=\"call\">father</span>(user),\n\n    <span class=\"keyword\">let</span> father2 = database.<span class=\"call\">father</span>(father1),\n\n    <span class=\"keyword\">let</span> spouse = database.<span class=\"call\">spouse</span>(father2),\n\n    <span class=\"keyword\">let</span> children = database.<span class=\"call\">childrenCount</span>(father2) {\n\n   childrenCount = children\n\n} <span class=\"keyword\">else</span> {\n\n   childrenCount = <span class=\"number\">0</span>\n\n}\n\n\n\n<span class=\"comment\">// With</span>\n\n<span class=\"keyword\">let</span> children = database.<span class=\"call\">current</span>().<span class=\"call\">and</span>(then: { database.<span class=\"call\">spouse</span>($0) })\n\n      .<span class=\"call\">and</span>(then: { database.<span class=\"call\">father</span>($0) })\n\n      .<span class=\"call\">and</span>(then: { database.<span class=\"call\">spouse</span>($0) })\n\n      .<span class=\"call\">and</span>(then: { database.<span class=\"call\">childrenCount</span>($0) })\n\n      .<span class=\"call\">or</span>(<span class=\"number\">0</span>)\n</code></pre></code></pre>\n<p>There're a lot of improvements when using the version with <code>and(then)</code>.\nFirst of all, you don't have to come up with superfluous temporary\nvariable names (user, father1, father2, spouse, children). Second, we\nclearly have less code. Also, using the <code>or(0)</code> instead of a complicated\n<code>let childrenCount</code> is so much easier to read.</p>\n<p>Finally, the original Swift example can easily lead to logic errors. You\nmay not have noticed, but there's a bug in the example. When writing\nlines like that, copy paste errors can easily be introduced. Do you see\nthe error?</p>\n<p>Yeah, the <code>children</code> property should be created by calling\n<code>database.childrenCount(spouse)</code> but I wrote\n<code>database.childrenCount(father2)</code> instead. It is difficult to spot\nerrors like that. The <code>and(then:)</code> example makes it much easier because\nit always relies on the same variable name <code>$0</code>.</p>\n<h2>Zipping</h2>\n<p>This is another variation on an existing Swift concept. The <code>zip</code> method\non optional will allow us to combine multiple optionals and unwrap them\ntogether or not at all. I've just provided implementations for <code>zip2</code>\nand <code>zip3</code> but nothing prevents you from going up to <code>zip22</code> (Well,\nmaybe sanity and compiler speed).</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Lets start again with a normal Swift example</span>\n\n<span class=\"keyword\">func</span> buildProduct() -&gt; <span class=\"type\">Product</span>? {\n\n   <span class=\"keyword\">if let</span> var1 = machine1.<span class=\"call\">makeSomething</span>(),\n\n     <span class=\"keyword\">let</span> var2 = machine2.<span class=\"call\">makeAnotherThing</span>(),\n\n     <span class=\"keyword\">let</span> var3 = machine3.<span class=\"call\">createThing</span>() {\n\n     <span class=\"keyword\">return</span> finalMachine.<span class=\"call\">produce</span>(var1, var2, var3)\n\n   } <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">return nil</span>\n\n   }\n\n}\n\n\n\n<span class=\"comment\">// The alternative using our extensions</span>\n\n<span class=\"keyword\">func</span> buildProduct() -&gt; <span class=\"type\">Product</span>? {\n\n   <span class=\"keyword\">return</span> machine1.<span class=\"call\">makeSomething</span>()\n\n      .<span class=\"call\">zip3</span>(machine2.<span class=\"call\">makeAnotherThing</span>(), machine3.<span class=\"call\">createThing</span>())\n\n      .<span class=\"call\">map</span> { finalMachine.<span class=\"call\">produce</span>($0.<span class=\"number\">1</span>, $0.<span class=\"number\">2</span>, $0.<span class=\"number\">3</span>) }\n\n}\n</code></pre></code></pre>\n<p>Less code, clearer code, more beautiful code. However, as a downside,\nthis code is also more involved. The reader has to know and understand\n<code>zip</code> in order to easily grasp it.</p>\n<h2>On</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Executes the closure `some` if and only if the optional has a value</span>\n\n     <span class=\"keyword\">func</span> on(some: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> {\n\n         <span class=\"keyword\">if self</span> != <span class=\"keyword\">nil</span> { <span class=\"keyword\">try</span> <span class=\"call\">some</span>() }\n\n     }\n\n\n\n     <span class=\"comment\">/// Executes the closure `none` if and only if the optional has no value</span>\n\n     <span class=\"keyword\">func</span> on(none: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> {\n\n         <span class=\"keyword\">if self</span> == <span class=\"keyword\">nil</span> { <span class=\"keyword\">try</span> <span class=\"call\">none</span>() }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>These two short methods will allow you to perform side effects if an\noptional is empty or not. In contrast to the already discussed methods,\nthese ignore the contents of the optional. So <code>on(some:)</code> will only\nexecute the closure <code>some</code> if the optional is not empty but the closure\n<code>some</code> will not get the unwrapped contents of the optional.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Logout if there is no user anymore</span>\n\n<span class=\"keyword\">self</span>.<span class=\"property\">user</span>.<span class=\"call\">on</span>(none: { <span class=\"type\">AppCoordinator</span>.<span class=\"property\">shared</span>.<span class=\"call\">logout</span>() })\n\n\n\n<span class=\"comment\">/// self.user is not empty when we are connected to the network</span>\n\n<span class=\"keyword\">self</span>.<span class=\"property\">user</span>.<span class=\"call\">on</span>(some: { <span class=\"type\">AppCoordinator</span>.<span class=\"property\">shared</span>.<span class=\"call\">unlock</span>() })\n</code></pre></code></pre>\n<h2>Various</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Returns the unwrapped value of the optional only if</span>\n\n     <span class=\"comment\">/// - The optional has a value</span>\n\n     <span class=\"comment\">/// - The value satisfies the predicate `predicate`</span>\n\n     <span class=\"keyword\">func</span> filter(<span class=\"keyword\">_</span> predicate: (<span class=\"type\">Wrapped</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Wrapped</span>? {\n\n         <span class=\"keyword\">guard let</span> unwrapped = <span class=\"keyword\">self</span>,\n\n             <span class=\"call\">predicate</span>(unwrapped) <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n         <span class=\"keyword\">return self</span>\n\n     }\n\n\n\n     <span class=\"comment\">/// Returns the wrapped value or crashes with `fatalError(message)`</span>\n\n     <span class=\"keyword\">func</span> expect(<span class=\"keyword\">_</span> message: <span class=\"type\">String</span>) -&gt; <span class=\"type\">Wrapped</span> {\n\n         <span class=\"keyword\">guard let</span> value = <span class=\"keyword\">self else</span> { <span class=\"call\">fatalError</span>(message) }\n\n         <span class=\"keyword\">return</span> value\n\n     }\n\n}\n</code></pre></code></pre>\n<h3>Filter</h3>\n<p>This is a simple method which works like an additional guard to only\nunwrap the optional if it satisfies a predictate. Here's an example.\nImagine we want to upgrade all our old users to a premium account for\nsticking with us for a long time:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Only affect old users with id &lt; 1000</span>\n\n<span class=\"comment\">// Normal Swift</span>\n\n<span class=\"keyword\">if let</span> aUser = user, user.<span class=\"property\">id</span> &lt; <span class=\"number\">1000</span> { aUser.<span class=\"call\">upgradeToPremium</span>() }\n\n\n\n<span class=\"comment\">// Using `filter`</span>\n\nuser.<span class=\"call\">filter</span>({ $0.<span class=\"property\">id</span> &lt; <span class=\"number\">1000</span> })?.<span class=\"call\">upgradeToPremium</span>()\n</code></pre></code></pre>\n<p>Here, <code>user.filter</code> feels like a much more natural implementation. Also,\nit only implements what already exists for Swift's collections.</p>\n<h3>Expect</h3>\n<p>This is one of my favorites. Also, I shamelessly stole it from Rust.\nI'm trying very hard to never force unwrap anything in my codebase.\nSimilar for implicitly unwrapped optionals.</p>\n<p>However, this is tricky when working with interface builder outlets. A\ncommon pattern that I observed can be seen in the following function:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> updateLabel() {\n\n   <span class=\"keyword\">guard let</span> label = valueLabel <span class=\"keyword\">else</span> {\n\n     <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"valueLabel</span> not connected <span class=\"keyword\">in</span> <span class=\"type\">IB</span>\\<span class=\"string\">\"</span>)\n\n   }\n\n   label.<span class=\"property\">text</span> = state.<span class=\"property\">title</span>\n\n}\n</code></pre></code></pre>\n<p>The alternative solution, obviously, would be to just to force unwrap\nthe label, as that leads to a crash just like <code>fatalError</code>. Then, I'd\nhave to insert <code>!</code> though, also it wouldn't give me a nice succinct\ndescription of what actually is wrong. The better alternative here is to\nuse <code>expect</code> as implemented above:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> updateLabel() {\n\n   valueLabel.<span class=\"call\">expect</span>(\\<span class=\"string\">\"valueLabel</span> not connected <span class=\"keyword\">in</span> <span class=\"type\">IB</span>\\<span class=\"string\">\"</span>).<span class=\"property\">text</span> = state.<span class=\"property\">title</span>\n\n}\n</code></pre></code></pre>\n<h1>Example</h1>\n<p>So now that we've seen a couple of (hopefully) useful <code>Optional</code>\nextensions, I'll set up an example to better see how some of these\nextensions can be combined to simplify optional handling. First, we need\na bit of context. Forgive me for the rather unconventional and\nimpossible example:</p>\n<p>You're working in the 80s at a shareware distributor. A lot of student\nprogrammers are working for you and writing new shareware apps and games\nevery month. You need to keep track of how many were sold. For that, you\nrecieve an XML file from accounting and you need to parse it and insert\nit into the database (isn't it awesome how in this version of the 80s\nthere's Swift to love but also XML to hate?). Your software system has\nan XML parser and a database (both written in 6502 ASM of course) that\nimplement the following protocols:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> XMLImportNode {\n\n     <span class=\"keyword\">func</span> firstChild(with tag: <span class=\"type\">String</span>) -&gt; <span class=\"type\">XMLImportNode</span>?\n\n     <span class=\"keyword\">func</span> children(with tag: <span class=\"type\">String</span>) -&gt; [<span class=\"type\">XMLImportNode</span>]\n\n     <span class=\"keyword\">func</span> attribute(with name: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span>?\n\n}\n\n\n\n<span class=\"keyword\">typealias</span> DatabaseUser = <span class=\"type\">String</span>\n\n<span class=\"keyword\">typealias</span> DatabaseSoftware = <span class=\"type\">String</span>\n\n<span class=\"keyword\">protocol</span> Database {\n\n     <span class=\"keyword\">func</span> user(for id: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">DatabaseUser</span>\n\n     <span class=\"keyword\">func</span> software(for id: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">DatabaseSoftware</span>\n\n     <span class=\"keyword\">func</span> insertSoftware(user: <span class=\"type\">DatabaseUser</span>, name: <span class=\"type\">String</span>, id: <span class=\"type\">String</span>, type: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n     <span class=\"keyword\">func</span> updateSoftware(software: <span class=\"type\">DatabaseSoftware</span>, amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n}\n</code></pre></code></pre>\n<p>A typical file looks like this (behold the almighty XML):</p>\n<pre class=\"XML\"><code><span class=\"techoutext techouxml\"><span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">users</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">user</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span><span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>158<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n  <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">software</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n   <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">package</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">type</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>game<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>Maniac Mansion<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>4332<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">amount</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>30<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n   <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">package</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">type</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>game<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>Doom<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>1337<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">amount</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>50<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n   <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">package</span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">type</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>game<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">name</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>Warcraft 2<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">id</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>1000<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techouentity techouother techouattribute-name techoulocalname techouxml\">amount</span><span class=\"techoupunctuation techouseparator techoukey-value techouxml\">=</span><span class=\"techoustring techouquoted techoudouble techouxml\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouxml\">&quot;</span>10<span class=\"techoupunctuation techoudefinition techoustring techouend techouxml\">&quot;</span></span> <span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n  <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">software</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">user</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">users</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n</span></code></pre></code></pre>\n<p>Our original Swift code to parse the XML looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> ParseError: <span class=\"type\">Error</span> {\n\n     <span class=\"keyword\">case</span> msg(<span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"keyword\">func</span> parseGamesFromXML(from root: <span class=\"type\">XMLImportNode</span>, into database: <span class=\"type\">Database</span>) <span class=\"keyword\">throws</span> {\n\n     <span class=\"keyword\">guard let</span> users = root.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"users</span>\\<span class=\"string\">\"</span>)?.<span class=\"call\">children</span>(with: \\<span class=\"string\">\"user</span>\\<span class=\"string\">\"</span>) <span class=\"keyword\">else</span> {\n\n         <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"No</span> <span class=\"type\">Users</span>\\<span class=\"string\">\"</span>)\n\n     }\n\n     <span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> users {\n\n         <span class=\"keyword\">guard let</span> software = user.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"software</span>\\<span class=\"string\">\"</span>)?\n\n                 .<span class=\"call\">children</span>(with: \\<span class=\"string\">\"package</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> userId = user.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> dbUser = <span class=\"keyword\">try</span>? database.<span class=\"call\">user</span>(for: userId)\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">User</span>\\<span class=\"string\">\"</span>) }\n\n         <span class=\"keyword\">for</span> package <span class=\"keyword\">in</span> software {\n\n             <span class=\"keyword\">guard let</span> type = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>),\n\n             type == \\<span class=\"string\">\"game</span>\\<span class=\"string\">\"</span>,\n\n             <span class=\"keyword\">let</span> name = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> softwareId = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>),\n\n             <span class=\"keyword\">let</span> amountString = package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"amount</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">Package</span>\\<span class=\"string\">\"</span>) }\n\n             <span class=\"keyword\">if let</span> existing = <span class=\"keyword\">try</span>? database.<span class=\"call\">software</span>(for: softwareId) {\n\n                 <span class=\"keyword\">try</span> database.<span class=\"call\">updateSoftware</span>(software: existing, \n\n                                               amount: <span class=\"type\">Int</span>(amountString) ?? <span class=\"number\">0</span>)\n\n             } <span class=\"keyword\">else</span> {\n\n                 <span class=\"keyword\">try</span> database.<span class=\"call\">insertSoftware</span>(user: dbUser, name: name, \n\n                                               id: softwareId, \n\n                                             type: type, \n\n                                           amount: <span class=\"type\">Int</span>(amountString) ?? <span class=\"number\">0</span>)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Lets apply what we learned above:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> parseGamesFromXML(from root: <span class=\"type\">XMLImportNode</span>, into database: <span class=\"type\">Database</span>) <span class=\"keyword\">throws</span> {\n\n     <span class=\"keyword\">for</span> user <span class=\"keyword\">in try</span> root.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"users</span>\\<span class=\"string\">\"</span>)\n\n                     .<span class=\"call\">or</span>(throw: <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"No</span> <span class=\"type\">Users</span>\\<span class=\"string\">\"</span>)).<span class=\"call\">children</span>(with: \\<span class=\"string\">\"user</span>\\<span class=\"string\">\"</span>) {\n\n         <span class=\"keyword\">let</span> dbUser = <span class=\"keyword\">try</span> user.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>)\n\n                     .<span class=\"call\">and</span>(then: { <span class=\"keyword\">try</span>? database.<span class=\"call\">user</span>(for: $0) })\n\n                     .<span class=\"call\">or</span>(throw: <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">User</span>\\<span class=\"string\">\"</span>))\n\n         <span class=\"keyword\">for</span> package <span class=\"keyword\">in</span> (user.<span class=\"call\">firstChild</span>(with: \\<span class=\"string\">\"software</span>\\<span class=\"string\">\"</span>)?\n\n                     .<span class=\"call\">children</span>(with: \\<span class=\"string\">\"package</span>\\<span class=\"string\">\"</span>)).<span class=\"call\">or</span>([]) {\n\n             <span class=\"keyword\">guard</span> (package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>)).<span class=\"call\">filter</span>({ $0 == \\<span class=\"string\">\"game</span>\\<span class=\"string\">\"</span> }).<span class=\"property\">isSome</span>\n\n                 <span class=\"keyword\">else</span> { <span class=\"keyword\">continue</span> }\n\n             <span class=\"keyword\">try</span> package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>)\n\n                 .<span class=\"call\">zip3</span>(with: package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"id</span>\\<span class=\"string\">\"</span>), \n\n                    another: package.<span class=\"call\">attribute</span>(with: \\<span class=\"string\">\"amount</span>\\<span class=\"string\">\"</span>))\n\n                 .<span class=\"call\">map</span>({ (tuple) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n                     <span class=\"keyword\">switch try</span>? database.<span class=\"call\">software</span>(for: tuple.<span class=\"number\">1</span>) {\n\n                     <span class=\"keyword\">case let</span> e?: <span class=\"keyword\">try</span> database.<span class=\"call\">updateSoftware</span>(software: e, \n\n                                                                amount: <span class=\"type\">Int</span>(tuple.<span class=\"number\">2</span>).<span class=\"call\">or</span>(<span class=\"number\">0</span>))\n\n                     <span class=\"keyword\">default</span>: <span class=\"keyword\">try</span> database.<span class=\"call\">insertSoftware</span>(user: dbUser, name: tuple.<span class=\"number\">0</span>, \n\n                                                            id: tuple.<span class=\"number\">1</span>, type: \\<span class=\"string\">\"game</span>\\<span class=\"string\">\"</span>, \n\n                                                        amount: <span class=\"type\">Int</span>(tuple.<span class=\"number\">2</span>).<span class=\"call\">or</span>(<span class=\"number\">0</span>))\n\n                     }\n\n                 }, or: { <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"call\">msg</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">Package</span>\\<span class=\"string\">\"</span>) })\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>If we look at this, then there're two things that immediately come to\nmind:</p>\n<ol>\n<li>Less Code</li>\n<li>More Complicated Looking Code</li>\n</ol>\n<p>I deliberately went into overdrive when utilizing the various <code>Optional</code>\nextensions. Some of them fit better while others seem to be a bit\nmisplaced. However, the key is not to solely rely on these extensions\n(like I did above) when using optionals but instead to mix and match\nwhere it makes most sense. Compare the two implementations and consider\nwhich from the second example you'd rather implement with Swift's\nnative features and which feel better when using the <code>Optional</code>\nextensions.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2015-06-17-swift-method-overloading-by-protocol.md":["f1432ba700288a58",{"identifier":"5f3c9e46","filename":"2015-06-17-swift-method-overloading-by-protocol.md","info":{"title":"Generic method overloading by protocol in Swift","tags":["generics","protocols","overload"],"keywords":["swift","optional","simple","overloading","method","protocol","extensions","generics","feature"],"category":["Language","All"],"created":"2015-06-17 10:30:30","description":"See how you can even overload methods in a generic manner by using protocols","description_html":"<p>See how you can even overload methods in a generic manner by using protocols</p>\n","published":true,"slug":"2015-06-17-swift-method-overloading-by-protocol.html","meta":{"swift_version":"5.0"},"created_timestamp":1434537030,"date":"2015-06-17T10:30:30","date_info":{"year":2015,"month":6,"day":17,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2015-06-17-swift-method-overloading-by-protocol.html","content":"<p>In this article I wanted to delve into a nice generic abstraction in Swift. It resolves around method overloading, so\nwe will start with a small introduction into general method overloading in Swift.</p>\n<h1>Method Overloading in Swift</h1>\n<p>There're multiple ways to overload or override methods in Swift. I\ndon't want to go into the details here. If you're interested, <a href=\"http://sketchytech.blogspot.de/2014/09/swift-overriding-vs-overloading-xcode-6.html\">this\nblog post has a pretty good\noverview</a>.\nOne of the possible overloading mechanisms is by type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> Example {\n\n     <span class=\"keyword\">func</span> method(a : <span class=\"type\">String</span>) -&gt; <span class=\"type\">NSString</span> {\n\n         <span class=\"keyword\">return</span> a;\n\n     }\n\n     <span class=\"keyword\">func</span> method(a : <span class=\"type\">UInt</span>) -&gt; <span class=\"type\">NSString</span> {\n\n         <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>{\\(a)}\\<span class=\"string\">\"</span>\n\n     }\n\n}\n\n\n\n<span class=\"type\">Example</span>().<span class=\"call\">method</span>(a: \\<span class=\"string\">\"Foo</span>\\<span class=\"string\">\"</span>) <span class=\"comment\">// \\\"Foo\\\"</span>\n\n<span class=\"type\">Example</span>().<span class=\"call\">method</span>(a: <span class=\"number\">123</span>) <span class=\"comment\">// \\\"{123}\\\"</span>\n</code></pre></code></pre>\n<p>As you can see, you can call the same method name with different types,\nand during compile time the correct code path will be determined and\noptimized. So, unlike <code>Objective-C</code>, there's no runtime dynamic\ndispatch to figure out whether the argument to <code>method</code> is a String or a\nInt.</p>\n<p>This is certainly nice, but what if your setup is more complex, and you\ndon't know which kind of type you're getting in a generic function:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> DBStore&lt;T&gt; {\n\n     <span class=\"keyword\">func</span> store(a : <span class=\"type\">T</span>) {\n\n         store <span class=\"type\">T</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Now imagine that T can have different invariants. Let's say you have a\nprotocol 'Storeable' for objects which can be stored in your database,\nand another protocol 'Interim for objects which should only exist\ntemporarily in memory.</p>\n<h1>Generic Method Overloading by Protocol</h1>\n<p>You want to call 'store' on all your objects, without having to\ndynamically check the type to see if the object is Storeable or Interim.\nYou can simply do that by adding the protocol:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> DBStore&lt;T&gt; {\n\n     <span class=\"keyword\">func</span> store&lt;T: <span class=\"type\">Storeable</span>&gt;(a : <span class=\"type\">T</span>) {\n\n         store <span class=\"type\">T</span>\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> store&lt;T: <span class=\"type\">Interim</span>&gt;(a : <span class=\"type\">T</span>) {\n\n         compress <span class=\"type\">T</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Now, you can call the same method in your code, and the correct code\npath will be determined at compile time without any overhead.</p>\n<h1>Advanced Protocols</h1>\n<p>With this basic mechanism, you can do much more. as the Swift\ndocumentation points out, we can apply any kind of generic constraints\nin order to better structure our types.</p>\n<blockquote>\n<p>You can overload a generic function or initializer by providing\ndifferent constraints, requirements, or both on the type parameters in\nthe generic parameter clause. When you call an overloaded generic\nfunction or initializer, the compiler uses these constraints to\nresolve which overloaded function or initializer to invoke. (<a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/doc/uid/TP40014097-CH37-ID406\">Apple\nDocumentation</a>)</p>\n</blockquote>\n<p>Here're some examples:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"comment\">/// Call for all Storeable types which are also equatable</span>\n\n<span class=\"keyword\">func</span> store&lt;T: <span class=\"type\">Storeable</span> <span class=\"keyword\">where</span> <span class=\"type\">T</span>:<span class=\"type\">Equatable</span>&gt;(a : <span class=\"type\">T</span>) {\n\n     store <span class=\"type\">T</span>\n\n}\n\n\n\n<span class=\"comment\">/// Call only for collections, whose objects conform to Storeable</span>\n\n<span class=\"keyword\">func</span> store&lt;T: <span class=\"type\">Storeable</span>&gt;(a: [<span class=\"type\">T</span>]) {\n\n}\n\n\n\n<span class=\"comment\">/// Alternatively:</span>\n\n<span class=\"keyword\">func</span> store&lt;T <span class=\"keyword\">where</span> <span class=\"type\">T</span>.<span class=\"type\">Generator</span>.<span class=\"type\">Element</span>: <span class=\"type\">Storeable</span>&gt;(a: <span class=\"type\">T</span>) {\n\n}\n\n\n</code></pre></code></pre>\n<p>You can also extend your Structs and Classes from a different file, to\nadd additional functionality based on a value or object which is local\nto that class</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Objects which are stored in the cloud</span>\n\n<span class=\"keyword\">protocol</span> CloudStorable {\n\n}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">DBStore</span> {\n\n     <span class=\"keyword\">func</span> store&lt;T: <span class=\"type\">CloudStorable</span>&gt; {\n\n       <span class=\"comment\">// write your custom cloud store code</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>All in all this gives you great flexibility without the overhead of\ndynamic dispatch.</p>\n","raw_content":"[frontMatter]\ndescription = \"See how you can even overload methods in a generic manner by using protocols\"\ntitle = \"Generic method overloading by protocol in Swift\"\ncreated = \"2015-06-17\"\npublished = true\nkeywords = [\"swift\", \"optional\", \"simple\", \"overloading\", \"method\", \"protocol\", \"extensions\", \"generics\", \"feature\"]\nslug = \"2015-06-17-swift-method-overloading-by-protocol.html\"\ntags = [\"generics\", \"protocols\", \"overload\"]\ncategory = [\"Language\", \"All\"]\n\n[meta]\nswift_version = \"5.0\"\n---\n\nIn this article I wanted to delve into a nice generic abstraction in Swift. It resolves around method overloading, so\nwe will start with a small introduction into general method overloading in Swift.\n\n# Method Overloading in Swift\n\nThere\\'re multiple ways to overload or override methods in Swift. I\ndon\\'t want to go into the details here. If you\\'re interested, [this\nblog post has a pretty good\noverview](http://sketchytech.blogspot.de/2014/09/swift-overriding-vs-overloading-xcode-6.html).\nOne of the possible overloading mechanisms is by type:\n\n``` Swift\nclass Example {\n    func method(a : String) -> NSString {\n        return a;\n    }\n    func method(a : UInt) -> NSString {\n        return \"{\\(a)}\"\n    }\n}\n\nExample().method(a: \"Foo\") // \"Foo\"\nExample().method(a: 123) // \"{123}\"\n```\n\nAs you can see, you can call the same method name with different types,\nand during compile time the correct code path will be determined and\noptimized. So, unlike `Objective-C`, there\\'s no runtime dynamic\ndispatch to figure out whether the argument to `method` is a String or a\nInt.\n\nThis is certainly nice, but what if your setup is more complex, and you\ndon\\'t know which kind of type you\\'re getting in a generic function:\n\n``` Swift\nclass DBStore<T> {\n    func store(a : T) {\n        store T\n    }\n}\n```\n\nNow imagine that T can have different invariants. Let\\'s say you have a\nprotocol \\'Storeable\\' for objects which can be stored in your database,\nand another protocol \\'Interim for objects which should only exist\ntemporarily in memory.\n\n# Generic Method Overloading by Protocol\n\nYou want to call \\'store\\' on all your objects, without having to\ndynamically check the type to see if the object is Storeable or Interim.\nYou can simply do that by adding the protocol:\n\n``` Swift\nclass DBStore<T> {\n    func store<T: Storeable>(a : T) {\n        store T\n    }\n\n    func store<T: Interim>(a : T) {\n        compress T\n    }\n}\n```\nNow, you can call the same method in your code, and the correct code\npath will be determined at compile time without any overhead.\n\n# Advanced Protocols\n\nWith this basic mechanism, you can do much more. as the Swift\ndocumentation points out, we can apply any kind of generic constraints\nin order to better structure our types.\n\n> You can overload a generic function or initializer by providing\n> different constraints, requirements, or both on the type parameters in\n> the generic parameter clause. When you call an overloaded generic\n> function or initializer, the compiler uses these constraints to\n> resolve which overloaded function or initializer to invoke. ([Apple\n> Documentation](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GenericParametersAndArguments.html#//apple_ref/doc/uid/TP40014097-CH37-ID406))\n\nHere\\'re some examples:\n\n``` Swift\n\n/// Call for all Storeable types which are also equatable\nfunc store<T: Storeable where T:Equatable>(a : T) {\n    store T\n}\n\n/// Call only for collections, whose objects conform to Storeable\nfunc store<T: Storeable>(a: [T]) {\n}\n\n/// Alternatively:\nfunc store<T where T.Generator.Element: Storeable>(a: T) {\n}\n\n```\n\nYou can also extend your Structs and Classes from a different file, to\nadd additional functionality based on a value or object which is local\nto that class\n\n``` Swift\n// Objects which are stored in the cloud\nprotocol CloudStorable {\n}\n\nextension DBStore {\n    func store<T: CloudStorable> {\n      // write your custom cloud store code\n    }\n}\n```\n\nAll in all this gives you great flexibility without the overhead of\ndynamic dispatch.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/type_aliases.md":["b5670298c37d323b",{"identifier":"5ad8f00b","filename":"type_aliases.md","info":{"title":"Type Aliases","tags":["tuples","tupealias"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-type-aliases.html","content":"<h1>Type Aliases</h1>\n<p>In many of the earlier examples, we rewrote a certain tuple type like\n<code>(Int, Int, String)</code> multiple times. This, of course, is not necessary,\nas we could define a <code>typealias</code> for it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Example = (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">String</span>)\n\n<span class=\"keyword\">func</span> add(elm: <span class=\"type\">Example</span>) { }\n</code></pre></code></pre>\n<p>However, if you're using a certain tuple construction so often that you\nthink about adding a typealias for it, you might really be better off\ndefining a struct.</p>\n","raw_content":"[frontMatter]\ntitle = \"Type Aliases\"\ntags = [\"tuples\", \"tupealias\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Type Aliases\n\nIn many of the earlier examples, we rewrote a certain tuple type like\n`(Int, Int, String)` multiple times. This, of course, is not necessary,\nas we could define a `typealias` for it:\n\n``` Swift\ntypealias Example = (Int, Int, String)\nfunc add(elm: Example) { }\n```\n\nHowever, if you\\'re using a certain tuple construction so often that you\nthink about adding a typealias for it, you might really be better off\ndefining a struct.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/nest_touchbars.md":["35a960a9646bae27",{"identifier":"9dc49602","filename":"nest_touchbars.md","info":{"title":"How do I nest touchbars?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-nest-touchbars.html","content":"<p>If you have multiple view controllers in your <a href=\"how/responder_chain.md\">responder chain</a> that each want to insert something in your <code>NSTouchBar</code> you can simply define the outermost (highest priority) touchbar to host other touchbars alongside. You do that by adding the system default <code>NSTouchBarItem.Identifier.otherItemsProxy</code> to your list of <code>defaultItemIdentifiers</code>:</p>\n<pre class=\"Swift\"><code>     <span class=\"keyword\">override func</span> makeTouchBar() -&gt; <span class=\"type\">NSTouchBar</span>? {\n\n         <span class=\"keyword\">let</span> touchBar = <span class=\"type\">NSTouchBar</span>()\n\n         touchBar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n         touchBar.<span class=\"property\">defaultItemIdentifiers</span> = [<span class=\"type\">MyButtonTouchBarIdentifier</span>,\n\n                                            <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">otherItemsProxy</span>]\n\n         <span class=\"keyword\">return</span> touchBar\n\n     }\n</code></pre></code></pre>\n<p>Now, if, say, a child view controller would also implement <code>makeTouchBar</code>, its touchbar would be displayed next to our <code>MyButtonTouchBarIdentifier</code> button.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I nest touchbars?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nIf you have multiple view controllers in your [responder chain](how/responder_chain.md) that each want to insert something in your `NSTouchBar` you can simply define the outermost (highest priority) touchbar to host other touchbars alongside. You do that by adding the system default `NSTouchBarItem.Identifier.otherItemsProxy` to your list of `defaultItemIdentifiers`:\n\n``` swift\n    override func makeTouchBar() -> NSTouchBar? {\n        let touchBar = NSTouchBar()\n        touchBar.delegate = self\n        touchBar.defaultItemIdentifiers = [MyButtonTouchBarIdentifier,\n                                           NSTouchBarItem.Identifier.otherItemsProxy]\n        return touchBar\n    }\n```\n\nNow, if, say, a child view controller would also implement `makeTouchBar`, its touchbar would be displayed next to our `MyButtonTouchBarIdentifier` button.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swiftui/tutorial/intro.md":["72051bbed501bb1d",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Intro: A Shoe Designer","tags":["swiftui"],"keywords":[],"category":[],"created":"2019-06-12 21:01:50","description":"An app that designs shoes.","description_html":"<p>An app that designs shoes.</p>\n","published":true,"slug":null,"meta":{"feature_image":"/img-content/swiftui_article.jpg"},"created_timestamp":1560373310,"date":"2019-06-12T21:01:50","date_info":{"year":2019,"month":6,"day":12,"hour":21,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-6-12-intro-a-shoe-designer.html","content":"<p>In order to better understand how SwiftUI works, we will develop a simple tutorial app. We will continue adding features to this app in the next chapters. For now, the first thing we will build is a simple way for users to customize / design sneakers. In order to allow this, we need a preview of the current sneaker, a way to change the colors of the current sneaker, and a way to store the current sneaker.</p>\n<p>Here is a small GIF of what we are about to create.</p>\n<p><img src=\"/img-content/swiftui_tutorial_anim.gif\" width=\"30%\" /></p>\n<h2>The Model</h2>\n<p>Lets start with the model as it will help us shape the rest of the application. Currently, our model will only store the colors of the current sneaker. However, future chapters will also add the manufacturers name, shoe name, shoe model, etc. So in order to prepare for that we will have a more general <code>ShoeConfiguration</code> type that will contain a more distinct <code>ShoeColors</code> type. We will first have a look at this <code>ShoeColors</code> type.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ShoeColors {\n\n     <span class=\"comment\">/// Outline Color</span>\n\n     <span class=\"keyword\">var</span> outline: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Base Color</span>\n\n     <span class=\"keyword\">var</span> base: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Side Color</span>\n\n     <span class=\"keyword\">var</span> side: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Sole Color</span>\n\n     <span class=\"keyword\">var</span> sole: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Back Cage Color</span>\n\n     <span class=\"keyword\">var</span> cage: <span class=\"type\">Color</span>\n\n}\n</code></pre></code></pre>\n<p>Our configuration has colors for multiple parts of the shoe. The outline, the base color, the side color, and so on. Note that we're not using <code>UIColor</code> or <code>NSColor</code> or <code>CGColor</code>, or even <code>CIColor</code>; no, there's a new color type in SwiftUI. It has a limited set of default color defintions, but it is sufficient for our use case here.</p>\n<p>The next part is to have a configuration for our shoe. The colors will be just one part of the configuration. A first draft would look something like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> ShoeConfiguration {\n\n     \n\n     <span class=\"keyword\">var</span> shoeColors: <span class=\"type\">ShoeColors</span> \n\n     \n\n     <span class=\"keyword\">init</span>() {\n\n         shoeColors = <span class=\"type\">ShoeColors</span>(outline: .<span class=\"dotAccess\">black</span>, base: .<span class=\"dotAccess\">white</span>, side: .<span class=\"dotAccess\">orange</span>, sole: .<span class=\"dotAccess\">purple</span>, cage: .<span class=\"dotAccess\">gray</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>We're creating a simple <code>class</code> that acts as the configuration of one shoe. Currently, we're only hosting <code>shoeColors</code>, so there's not really much going on. What we do do, though, is to configure a default shoe in the initializer.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> SwiftUI\n\n<span class=\"keyword\">import</span> Combine\n\n\n\n<span class=\"keyword\">class</span> ShoeConfiguration: <span class=\"type\">BindableObject</span> {\n\n     \n\n     <span class=\"keyword\">struct</span> ShoeColors {\n\n         <span class=\"keyword\">var</span> outline: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> base: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> side: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> sole: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> cage: <span class=\"type\">Color</span>\n\n     }\n\n     \n\n     <span class=\"keyword\">var</span> shoeColors: <span class=\"type\">ShoeColors</span> {\n\n         <span class=\"keyword\">didSet</span> {\n\n             didChange.<span class=\"call\">send</span>(<span class=\"keyword\">self</span>)\n\n         }\n\n     }\n\n     \n\n     <span class=\"keyword\">var</span> didChange = <span class=\"type\">PassthroughSubject</span>&lt;<span class=\"type\">ShoeConfiguration</span>, <span class=\"type\">Never</span>&gt;()\n\n     \n\n     <span class=\"keyword\">init</span>() {\n\n         shoeColors = <span class=\"type\">ShoeColors</span>(outline: .<span class=\"dotAccess\">black</span>, base: .<span class=\"dotAccess\">white</span>, side: .<span class=\"dotAccess\">orange</span>, sole: .<span class=\"dotAccess\">purple</span>, cage: .<span class=\"dotAccess\">gray</span>)\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> ShoeView : <span class=\"type\">View</span> {\n\n     \n\n     <span class=\"keyword\">@Binding var</span> colors: <span class=\"type\">ShoeConfiguration</span>.<span class=\"type\">ShoeColors</span>\n\n     \n\n     <span class=\"keyword\">private func</span> colorParts() -&gt; [(name: <span class=\"type\">String</span>, color: <span class=\"type\">Color</span>)] {\n\n         <span class=\"keyword\">return</span> [\n\n             (\\<span class=\"string\">\"base</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">base</span>),\n\n             (\\<span class=\"string\">\"side</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">side</span>),\n\n             (\\<span class=\"string\">\"sole</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">sole</span>),\n\n             (\\<span class=\"string\">\"cage</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">cage</span>),\n\n             (\\<span class=\"string\">\"outline</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">outline</span>)\n\n         ]\n\n     }\n\n     \n\n     <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">ZStack</span> {\n\n             <span class=\"type\">ForEach</span>(<span class=\"call\">colorParts</span>().<span class=\"call\">identified</span>(by: \\.<span class=\"property\">name</span>)) { shoePart <span class=\"keyword\">in</span>\n\n                 <span class=\"type\">Image</span>(shoePart.<span class=\"property\">name</span>).<span class=\"call\">resizable</span>()\n\n                     .<span class=\"call\">renderingMode</span>(.<span class=\"dotAccess\">template</span>)\n\n                     .<span class=\"call\">foregroundColor</span>(shoePart.<span class=\"property\">color</span>)\n\n             }\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">func</span> scaledFrame(from geometry: <span class=\"type\">GeometryProxy</span>, scale: <span class=\"type\">CGFloat</span>) -&gt; <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"keyword\">self</span>.<span class=\"call\">frame</span>(width: geometry.<span class=\"property\">size</span>.<span class=\"property\">width</span> * scale, height: geometry.<span class=\"property\">size</span>.<span class=\"property\">height</span> * scale)\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> ColorPickerEntry : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">var</span> selected: <span class=\"type\">Bool</span>\n\n     <span class=\"keyword\">var</span> shoeColor: <span class=\"type\">Color</span>\n\n     \n\n     <span class=\"keyword\">private let</span> outerScale: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.7</span>\n\n     <span class=\"keyword\">private let</span> innerScale: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.5</span>\n\n     \n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">GeometryReader</span> { geometry <span class=\"keyword\">in</span>\n\n             <span class=\"type\">Group</span> {\n\n                 <span class=\"keyword\">if self</span>.<span class=\"property\">selected</span> {\n\n                     <span class=\"type\">Circle</span>().<span class=\"call\">fill</span>(<span class=\"keyword\">self</span>.<span class=\"property\">shoeColor</span>)\n\n                         .<span class=\"call\">overlay</span>(<span class=\"type\">Circle</span>().<span class=\"call\">stroke</span>(<span class=\"type\">Color</span>.<span class=\"property\">black</span>, lineWidth: <span class=\"number\">2.0</span>))\n\n                         .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">outerScale</span>)\n\n                 } <span class=\"keyword\">else</span> {\n\n                     <span class=\"type\">Circle</span>().<span class=\"call\">stroke</span>(<span class=\"type\">Color</span>.<span class=\"property\">gray</span>)\n\n                         .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">innerScale</span>)\n\n                         .<span class=\"call\">overlay</span>(<span class=\"type\">Circle</span>().<span class=\"call\">fill</span>(<span class=\"keyword\">self</span>.<span class=\"property\">shoeColor</span>)\n\n                             .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">innerScale</span>), alignment: .<span class=\"dotAccess\">center</span>)\n\n                         .<span class=\"call\">overlay</span>(<span class=\"type\">Circle</span>().<span class=\"call\">stroke</span>(<span class=\"type\">Color</span>.<span class=\"property\">gray</span>)\n\n                             .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">outerScale</span>))\n\n                 }\n\n             }.<span class=\"call\">frame</span>(width: geometry.<span class=\"property\">size</span>.<span class=\"property\">width</span>, height: geometry.<span class=\"property\">size</span>.<span class=\"property\">height</span>)\n\n         }\n\n     }\n\n}\n\n\n\n\n\n<span class=\"keyword\">struct</span> ColorPicker : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@Binding var</span> selectedColor: <span class=\"type\">Color</span>\n\n     <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span>(alignment: <span class=\"type\">HorizontalAlignment</span>.<span class=\"property\">center</span>, spacing: <span class=\"number\">0</span>) {\n\n             <span class=\"type\">Text</span>(name).<span class=\"call\">font</span>(.<span class=\"dotAccess\">body</span>)\n\n             <span class=\"type\">HStack</span> {\n\n                 <span class=\"type\">ForEach</span>([<span class=\"type\">Color</span>.<span class=\"property\">black</span>, <span class=\"type\">Color</span>.<span class=\"property\">white</span>, <span class=\"type\">Color</span>.<span class=\"property\">orange</span>, <span class=\"type\">Color</span>.<span class=\"property\">purple</span>, <span class=\"type\">Color</span>.<span class=\"property\">gray</span>].<span class=\"call\">identified</span>(by: \\.<span class=\"property\">hashValue</span>)) { color <span class=\"keyword\">in</span>\n\n                     <span class=\"type\">Button</span>(action: {\n\n                         <span class=\"keyword\">self</span>.<span class=\"property\">selectedColor</span> = color\n\n                     }) {\n\n                         <span class=\"type\">ColorPickerEntry</span>(selected: <span class=\"keyword\">self</span>.<span class=\"property\">selectedColor</span>.<span class=\"property\">hashValue</span> == color.<span class=\"property\">hashValue</span>, shoeColor: color)\n\n                             .<span class=\"call\">frame</span>(width: <span class=\"number\">38</span>, height: <span class=\"number\">38</span>)\n\n                     }\n\n                 }\n\n             }\n\n         }\n\n     }\n\n}\n\n\n\n\n\n<span class=\"keyword\">struct</span> ShoeConfigurator : <span class=\"type\">View</span> {\n\n     \n\n     <span class=\"keyword\">@ObjectBinding var</span> shoeConfiguration = <span class=\"type\">ShoeConfiguration</span>()\n\n     \n\n     <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span> {\n\n             <span class=\"type\">ShoeView</span>(colors: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>)\n\n                 .<span class=\"call\">frame</span>(width: <span class=\"number\">250</span>, height: <span class=\"number\">114</span>, alignment: .<span class=\"dotAccess\">center</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">base</span>,\n\n                         name: \\<span class=\"string\">\"Base</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">cage</span>,\n\n                         name: \\<span class=\"string\">\"Cage</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">side</span>,\n\n                         name: \\<span class=\"string\">\"Side</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">sole</span>,\n\n                         name: \\<span class=\"string\">\"Sole</span>\\<span class=\"string\">\"</span>)\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> ContentView : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@State private var</span> selection = <span class=\"number\">0</span>\n\n     \n\n     <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">ShoeConfigurator</span>()\n\n     }\n\n}\n\n\n\n<span class=\"preprocessing\">#if DEBUG</span>\n\n<span class=\"keyword\">struct</span> ContentView_Previews : <span class=\"type\">PreviewProvider</span> {\n\n     <span class=\"keyword\">static var</span> previews: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">ContentView</span>()\n\n     }\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n\n\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Intro: A Shoe Designer\"\ntags = [\"swiftui\"]\ncreated = \"2019-06-12 21:01:50\"\ndescription = \"An app that designs shoes.\"\npublished = true\n\n[meta]\nfeature_image = \"/img-content/swiftui_article.jpg\"\n\n---\n\nIn order to better understand how SwiftUI works, we will develop a simple tutorial app. We will continue adding features to this app in the next chapters. For now, the first thing we will build is a simple way for users to customize / design sneakers. In order to allow this, we need a preview of the current sneaker, a way to change the colors of the current sneaker, and a way to store the current sneaker. \n\nHere is a small GIF of what we are about to create.\n\n<img src=\"/img-content/swiftui_tutorial_anim.gif\" width=\"30%\" />\n\n## The Model\n\nLets start with the model as it will help us shape the rest of the application. Currently, our model will only store the colors of the current sneaker. However, future chapters will also add the manufacturers name, shoe name, shoe model, etc. So in order to prepare for that we will have a more general `ShoeConfiguration` type that will contain a more distinct `ShoeColors` type. We will first have a look at this `ShoeColors` type.\n\n``` swift\nstruct ShoeColors {\n    /// Outline Color\n    var outline: Color\n    /// Base Color\n    var base: Color\n    /// Side Color\n    var side: Color\n    /// Sole Color\n    var sole: Color\n    /// Back Cage Color\n    var cage: Color\n}\n```\n\nOur configuration has colors for multiple parts of the shoe. The outline, the base color, the side color, and so on. Note that we're not using `UIColor` or `NSColor` or `CGColor`, or even `CIColor`; no, there's a new color type in SwiftUI. It has a limited set of default color defintions, but it is sufficient for our use case here. \n\nThe next part is to have a configuration for our shoe. The colors will be just one part of the configuration. A first draft would look something like this:\n\n``` swift\nclass ShoeConfiguration {\n    \n    var shoeColors: ShoeColors \n    \n    init() {\n        shoeColors = ShoeColors(outline: .black, base: .white, side: .orange, sole: .purple, cage: .gray)\n    }\n}\n```\n\nWe're creating a simple `class` that acts as the configuration of one shoe. Currently, we're only hosting `shoeColors`, so there's not really much going on. What we do do, though, is to configure a default shoe in the initializer. \n\n``` swift\nimport SwiftUI\nimport Combine\n\nclass ShoeConfiguration: BindableObject {\n    \n    struct ShoeColors {\n        var outline: Color\n        var base: Color\n        var side: Color\n        var sole: Color\n        var cage: Color\n    }\n    \n    var shoeColors: ShoeColors {\n        didSet {\n            didChange.send(self)\n        }\n    }\n    \n    var didChange = PassthroughSubject<ShoeConfiguration, Never>()\n    \n    init() {\n        shoeColors = ShoeColors(outline: .black, base: .white, side: .orange, sole: .purple, cage: .gray)\n    }\n}\n\nstruct ShoeView : View {\n    \n    @Binding var colors: ShoeConfiguration.ShoeColors\n    \n    private func colorParts() -> [(name: String, color: Color)] {\n        return [\n            (\"base\", colors.base),\n            (\"side\", colors.side),\n            (\"sole\", colors.sole),\n            (\"cage\", colors.cage),\n            (\"outline\", colors.outline)\n        ]\n    }\n    \n    var body: some View {\n        ZStack {\n            ForEach(colorParts().identified(by: \\.name)) { shoePart in\n                Image(shoePart.name).resizable()\n                    .renderingMode(.template)\n                    .foregroundColor(shoePart.color)\n            }\n        }\n    }\n}\n\nextension View {\n    func scaledFrame(from geometry: GeometryProxy, scale: CGFloat) -> some View {\n        self.frame(width: geometry.size.width * scale, height: geometry.size.height * scale)\n    }\n}\n\nstruct ColorPickerEntry : View {\n    var selected: Bool\n    var shoeColor: Color\n    \n    private let outerScale: CGFloat = 0.7\n    private let innerScale: CGFloat = 0.5\n    \n    var body : some View {\n        GeometryReader { geometry in\n            Group {\n                if self.selected {\n                    Circle().fill(self.shoeColor)\n                        .overlay(Circle().stroke(Color.black, lineWidth: 2.0))\n                        .scaledFrame(from: geometry, scale: self.outerScale)\n                } else {\n                    Circle().stroke(Color.gray)\n                        .scaledFrame(from: geometry, scale: self.innerScale)\n                        .overlay(Circle().fill(self.shoeColor)\n                            .scaledFrame(from: geometry, scale: self.innerScale), alignment: .center)\n                        .overlay(Circle().stroke(Color.gray)\n                            .scaledFrame(from: geometry, scale: self.outerScale))\n                }\n            }.frame(width: geometry.size.width, height: geometry.size.height)\n        }\n    }\n}\n\n\nstruct ColorPicker : View {\n    @Binding var selectedColor: Color\n    var name: String\n    var body : some View {\n        VStack(alignment: HorizontalAlignment.center, spacing: 0) {\n            Text(name).font(.body)\n            HStack {\n                ForEach([Color.black, Color.white, Color.orange, Color.purple, Color.gray].identified(by: \\.hashValue)) { color in\n                    Button(action: {\n                        self.selectedColor = color\n                    }) {\n                        ColorPickerEntry(selected: self.selectedColor.hashValue == color.hashValue, shoeColor: color)\n                            .frame(width: 38, height: 38)\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nstruct ShoeConfigurator : View {\n    \n    @ObjectBinding var shoeConfiguration = ShoeConfiguration()\n    \n    var body: some View {\n        VStack {\n            ShoeView(colors: $shoeConfiguration.shoeColors)\n                .frame(width: 250, height: 114, alignment: .center)\n            ColorPicker(selectedColor: $shoeConfiguration.shoeColors.base,\n                        name: \"Base\")\n            ColorPicker(selectedColor: $shoeConfiguration.shoeColors.cage,\n                        name: \"Cage\")\n            ColorPicker(selectedColor: $shoeConfiguration.shoeColors.side,\n                        name: \"Side\")\n            ColorPicker(selectedColor: $shoeConfiguration.shoeColors.sole,\n                        name: \"Sole\")\n        }\n    }\n}\n\nstruct ContentView : View {\n    @State private var selection = 0\n    \n    var body: some View {\n        ShoeConfigurator()\n    }\n}\n\n#if DEBUG\nstruct ContentView_Previews : PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n#endif\n\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/type_erasure/a_box_type.md":["cc0c4adf87b35cfc",{"identifier":"963da5a1","filename":"a_box_type.md","info":{"title":"A Box Type","tags":["box","associated","generics","erasure"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-a-box-type.html","content":"<h1>A Box Type</h1>\n<p>The next step is the most difficult to understand part of type erasure,\nwhich means that after this, it'll be easy. We will introduce another\n<code>private</code> type. This will be the actual box that houses our original\ntype (the XBox360 or the PowerMac G5). Let's start by having a look at\nthe code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private class</span> AnyComputerBox&lt;ConcreteComputer: <span class=\"type\">Computer</span>&gt;: \n\n         <span class=\"type\">AnyComputerBase</span>&lt;<span class=\"type\">ConcreteComputer</span>.<span class=\"type\">ProcessorType</span>&gt; \n\n{\n\n     <span class=\"keyword\">private let</span> internalComputer: <span class=\"type\">ConcreteComputer</span>\n\n     <span class=\"keyword\">override var</span> processor: <span class=\"type\">ConcreteComputer</span>.<span class=\"type\">ProcessorType</span> {\n\n         <span class=\"keyword\">return</span> internalComputer.<span class=\"property\">processor</span>\n\n     }\n\n     <span class=\"keyword\">override var</span> processorCount: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">return</span> internalComputer.<span class=\"property\">processorCount</span>\n\n     }\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> computer: <span class=\"type\">ConcreteComputer</span>) {\n\n         internalComputer = computer\n\n     }\n\n}\n</code></pre></code></pre>\n<p>The most important concept here can be found in the very first line:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private class</span> AnyComputerBox&lt;ConcreteComputer: <span class=\"type\">Computer</span>&gt;: \n\n         <span class=\"type\">AnyComputerBase</span>&lt;<span class=\"type\">ConcreteComputer</span>.<span class=\"type\">ProcessorType</span>&gt;\n</code></pre></code></pre>\n<p>Here, we define a new type <code>AnyComputerBox</code> which is generic over\n<strong>any</strong> computer (<code>ConcreteComputer</code>). This new type, then, is a\nsubclass of our earlier abstract class <code>AnyComputerBase</code>. Remember that\n<code>AnyComputerBase</code> made the original <code>ProcessorType</code> of the <code>Computer</code>\nprotocol generic by adding it as a generic parameter <code>CPU</code>. Now, our new\nbox has a <strong>different</strong> generic type (<code>Computer</code>) and provides only its\n<code>associated type</code> <strong>ProcessorType</strong> to the abstract superclass. In a\nsimpler explanation, this is what happens (in a mock language):</p>\n<ol>\n<li><code>Computer&lt;CPU&gt;</code></li>\n<li><code>AnyComputerBase&lt;Processor: CPU&gt;: Computer&lt;CPU&gt; where Computer.CPU = Processor</code></li>\n<li><code>AnyComputerBox&lt;ConcreteComputer: Computer&gt;: AnyComputerBase&lt;ConcreteComputer.ProcessorType&gt;</code></li>\n</ol>\n<p>So the box (<code>AnyComputerBox</code>) subclasses the abstract class and forwards\nin the <code>Processor</code> type via its own generic <code>Computer</code> type which also\nhas a <code>ProcessorType</code>.</p>\n<p>Why do we do this? It makes the box generic over any computer so that\n<strong>any</strong> computer can be boxed into it.</p>\n<p>The rest of the <code>class</code> is simple. There's an <code>internal</code> computer\n<code>internalComputer</code> which is the actual type conforming to the <code>Computer</code>\n<code>protocol</code>. We're also overriding the two classes that are required by\nthe protocol and forwarding the implementations of the\n<code>internalComputer</code>. Finally we have an initializer with a new\n<code>ConcreteComputer</code> (i.e. the <code>Computer</code> protocol).</p>\n","raw_content":"[frontMatter]\ntitle = \"A Box Type\"\ntags = [\"box\", \"associated\", \"generics\", \"erasure\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# A Box Type\n\nThe next step is the most difficult to understand part of type erasure,\nwhich means that after this, it\\'ll be easy. We will introduce another\n`private` type. This will be the actual box that houses our original\ntype (the XBox360 or the PowerMac G5). Let\\'s start by having a look at\nthe code:\n\n``` Swift\nprivate class AnyComputerBox<ConcreteComputer: Computer>: \n        AnyComputerBase<ConcreteComputer.ProcessorType> \n{\n    private let internalComputer: ConcreteComputer\n    override var processor: ConcreteComputer.ProcessorType {\n        return internalComputer.processor\n    }\n    override var processorCount: Int {\n        return internalComputer.processorCount\n    }\n    init(_ computer: ConcreteComputer) {\n        internalComputer = computer\n    }\n}\n```\n\nThe most important concept here can be found in the very first line:\n\n``` Swift\nprivate class AnyComputerBox<ConcreteComputer: Computer>: \n        AnyComputerBase<ConcreteComputer.ProcessorType>\n```\n\nHere, we define a new type `AnyComputerBox` which is generic over\n**any** computer (`ConcreteComputer`). This new type, then, is a\nsubclass of our earlier abstract class `AnyComputerBase`. Remember that\n`AnyComputerBase` made the original `ProcessorType` of the `Computer`\nprotocol generic by adding it as a generic parameter `CPU`. Now, our new\nbox has a **different** generic type (`Computer`) and provides only its\n`associated type` **ProcessorType** to the abstract superclass. In a\nsimpler explanation, this is what happens (in a mock language):\n\n1.  `Computer<CPU>`\n2.  `AnyComputerBase<Processor: CPU>: Computer<CPU> where Computer.CPU = Processor`\n3.  `AnyComputerBox<ConcreteComputer: Computer>: AnyComputerBase<ConcreteComputer.ProcessorType>`\n\nSo the box (`AnyComputerBox`) subclasses the abstract class and forwards\nin the `Processor` type via its own generic `Computer` type which also\nhas a `ProcessorType`.\n\nWhy do we do this? It makes the box generic over any computer so that\n**any** computer can be boxed into it.\n\nThe rest of the `class` is simple. There\\'s an `internal` computer\n`internalComputer` which is the actual type conforming to the `Computer`\n`protocol`. We\\'re also overriding the two classes that are required by\nthe protocol and forwarding the implementations of the\n`internalComputer`. Finally we have an initializer with a new\n`ConcreteComputer` (i.e. the `Computer` protocol).\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/absolute_basics/creating_and_accessing_tuples.md":["4b384d2b04a6ee7f",{"identifier":"45e38249","filename":"creating_and_accessing_tuples.md","info":{"title":"Creating and Accessing Tuples","tags":["tuples"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-creating-and-accessing-tuples.html","content":"<h1>The absolute Basics</h1>\n<p>A tuple can combine different types into one. Where an array is a sequence\nof a certain type (<code>let x: [Int] = [1, 2, 3, 4, 5]</code>) a tuple can have\na different type for each element: <code>let x: (Int, Double, String) = (5, 2.0, &quot;Hey&quot;)</code>.</p>\n<p>Tuples are a very simple manner of grouping related data items together without having\nto create a struct.</p>\n<p>They are value types and even though they look like sequences they aren't.\nOne main difference is that you can't easily loop over the contents of a tuple.</p>\n<p>We'll start with a quick primer on how to create and use tuples.</p>\n<h1>Creating and Accessing Tuples</h1>\n<pre class=\"Swift\"><code><span class=\"comment\">// Constructing a simple tuple</span>\n\n<span class=\"keyword\">let</span> tuple1 = (<span class=\"number\">2</span>, <span class=\"number\">3</span>)\n\n<span class=\"keyword\">let</span> tuple2 = (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)\n\n\n\n<span class=\"comment\">// Constructing a named tuple</span>\n\n<span class=\"keyword\">let</span> tupl3 = (x: <span class=\"number\">5</span>, y: <span class=\"number\">3</span>)\n\n\n\n<span class=\"comment\">// Different types</span>\n\n<span class=\"keyword\">let</span> tuple4 = (name: \\<span class=\"string\">\"Carl</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">78</span>, pets: [\\<span class=\"string\">\"Bonny</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Houdon</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Miki</span>\\<span class=\"string\">\"</span>])\n\n\n</code></pre></code></pre>\n<p>Once you've created some tuples, you can access their elements:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Accessing tuple elements</span>\n\n<span class=\"keyword\">let</span> tuple5 = (<span class=\"number\">13</span>, <span class=\"number\">21</span>)\n\ntuple5.<span class=\"number\">0</span> <span class=\"comment\">// 13</span>\n\ntuple5.<span class=\"number\">1</span> <span class=\"comment\">// 21</span>\n\n\n\n<span class=\"comment\">// Access by name</span>\n\n<span class=\"keyword\">let</span> tuple6 = (x: <span class=\"number\">21</span>, y: <span class=\"number\">33</span>)\n\ntuple6.<span class=\"property\">x</span> <span class=\"comment\">// 21</span>\n\ntuple6.<span class=\"property\">y</span> <span class=\"comment\">// 33</span>\n</code></pre></code></pre>\n<p>Nice, so now you can create tuples and access their elements. But what would you\nuse them for? The use case we will discuss is for <code>pattern matching</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Creating and Accessing Tuples\"\ntags = [\"tuples\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# The absolute Basics\n\nA tuple can combine different types into one. Where an array is a sequence\nof a certain type (`let x: [Int] = [1, 2, 3, 4, 5]`) a tuple can have\na different type for each element: `let x: (Int, Double, String) = (5, 2.0, \"Hey\")`.\n\nTuples are a very simple manner of grouping related data items together without having\nto create a struct.\n\nThey are value types and even though they look like sequences they aren\\'t.\nOne main difference is that you can't easily loop over the contents of a tuple.\n\nWe\\'ll start with a quick primer on how to create and use tuples.\n\n# Creating and Accessing Tuples\n\n``` Swift\n// Constructing a simple tuple\nlet tuple1 = (2, 3)\nlet tuple2 = (2, 3, 4)\n\n// Constructing a named tuple\nlet tupl3 = (x: 5, y: 3)\n\n// Different types\nlet tuple4 = (name: \"Carl\", age: 78, pets: [\"Bonny\", \"Houdon\", \"Miki\"])\n\n```\n\nOnce you've created some tuples, you can access their elements:\n\n``` Swift\n// Accessing tuple elements\nlet tuple5 = (13, 21)\ntuple5.0 // 13\ntuple5.1 // 21\n\n// Access by name\nlet tuple6 = (x: 21, y: 33)\ntuple6.x // 21\ntuple6.y // 33\n```\n\nNice, so now you can create tuples and access their elements. But what would you \nuse them for? The use case we will discuss is for `pattern matching`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/directory_traversion.md":["80d7849f8d23e77d",{"identifier":"a3187646","filename":"directory_traversion.md","info":{"title":"Directory Traversion","tags":["pattern matching","switch","where"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-directory-traversion.html","content":"<h1>Directory Traversion</h1>\n<p>Imagine you want to traverse a file hierachy and find:</p>\n<ul>\n<li>all &quot;psd&quot; files from customer1 and customer2</li>\n<li>all &quot;blend&quot; files from customer2</li>\n<li>all &quot;jpeg&quot; files from all customers.</li>\n</ul>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> enumerator = <span class=\"type\">FileManager</span>.<span class=\"property\">default</span>.<span class=\"call\">enumeratorAtPath</span>(\\<span class=\"string\">\"</span>/customers/<span class=\"number\">2014</span>/\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n<span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> enumerator {\n\n     <span class=\"keyword\">switch</span> (url.<span class=\"property\">pathComponents</span>, url.<span class=\"property\">pathExtension</span>) {\n\n\n\n     <span class=\"comment\">// psd files from customer1, customer2</span>\n\n     <span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> f, \\<span class=\"string\">\"psd</span>\\<span class=\"string\">\"</span>) \n\n             <span class=\"keyword\">where</span> f.<span class=\"call\">contains</span>(\\<span class=\"string\">\"customer1</span>\\<span class=\"string\">\"</span>) || f.<span class=\"call\">contains</span>(\\<span class=\"string\">\"customer2</span>\\<span class=\"string\">\"</span>): <span class=\"call\">print</span>(url)\n\n\n\n     <span class=\"comment\">// blend files from customer2</span>\n\n     <span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> f, \\<span class=\"string\">\"blend</span>\\<span class=\"string\">\"</span>) \n\n             <span class=\"keyword\">where</span> f.<span class=\"call\">contains</span>(\\<span class=\"string\">\"customer2</span>\\<span class=\"string\">\"</span>): <span class=\"call\">print</span>(url)\n\n\n\n     <span class=\"comment\">// all jpg files</span>\n\n     <span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, \\<span class=\"string\">\"jpg</span>\\<span class=\"string\">\"</span>): <span class=\"call\">print</span>(url)\n\n\n\n     <span class=\"keyword\">default</span>: ()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Note that <code>contains</code> stops at the first match and doesn't traverse the\ncomplete path. Again, pattern matching lead to very succinct and\nreadable code.</p>\n","raw_content":"[frontMatter]\ntitle = \"Directory Traversion\"\ntags = [\"pattern matching\", \"switch\", \"where\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Directory Traversion\n\nImagine you want to traverse a file hierachy and find:\n\n-   all \\\"psd\\\" files from customer1 and customer2\n-   all \\\"blend\\\" files from customer2\n-   all \\\"jpeg\\\" files from all customers.\n\n``` Swift\nguard let enumerator = FileManager.default.enumeratorAtPath(\"/customers/2014/\")\n    else { return }\n\nfor url in enumerator {\n    switch (url.pathComponents, url.pathExtension) {\n\n    // psd files from customer1, customer2\n    case (let f, \"psd\") \n            where f.contains(\"customer1\") || f.contains(\"customer2\"): print(url)\n\n    // blend files from customer2\n    case (let f, \"blend\") \n            where f.contains(\"customer2\"): print(url)\n\n    // all jpg files\n    case (_, \"jpg\"): print(url)\n\n    default: ()\n    }\n}\n```\n\nNote that `contains` stops at the first match and doesn\\'t traverse the\ncomplete path. Again, pattern matching lead to very succinct and\nreadable code.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/units.md":["b024c0764e372c24",{"identifier":"c84cc9bf","filename":"units.md","info":{"title":"UIKit Identifiers","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-uikit-identifiers.html","content":"<h1>Units</h1>\n<p>Units and unit conversion are another nice use case for enums. You can\nmap the units and their respective values and then add methods to do\nautomatic conversions. Here's an oversimplified example.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Liquid: <span class=\"type\">Float</span> {\n\n   <span class=\"keyword\">case</span> ml = <span class=\"number\">1.0</span>\n\n   <span class=\"keyword\">case</span> l = <span class=\"number\">1000.0</span>\n\n   <span class=\"keyword\">func</span> convert(amount: <span class=\"type\">Float</span>, to: <span class=\"type\">Liquid</span>) -&gt; <span class=\"type\">Float</span> {\n\n       <span class=\"keyword\">if self</span>.<span class=\"property\">rawValue</span> &lt; to.<span class=\"property\">rawValue</span> {\n\n          <span class=\"keyword\">return</span> (<span class=\"keyword\">self</span>.<span class=\"property\">rawValue</span> / to.<span class=\"property\">rawValue</span>) * amount\n\n       } <span class=\"keyword\">else</span> {\n\n          <span class=\"keyword\">return</span> (<span class=\"keyword\">self</span>.<span class=\"property\">rawValue</span> * to.<span class=\"property\">rawValue</span>) * amount\n\n       }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Another example of this would be Currency conversion. Also, mathematical\nsymbols (such as degrees vs radians) can benefit from this.</p>\n","raw_content":"[frontMatter]\ntitle = \"UIKit Identifiers\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Units\n\nUnits and unit conversion are another nice use case for enums. You can\nmap the units and their respective values and then add methods to do\nautomatic conversions. Here\\'s an oversimplified example.\n\n``` Swift\nenum Liquid: Float {\n  case ml = 1.0\n  case l = 1000.0\n  func convert(amount: Float, to: Liquid) -> Float {\n      if self.rawValue < to.rawValue {\n         return (self.rawValue / to.rawValue) * amount\n      } else {\n         return (self.rawValue * to.rawValue) * amount\n      }\n  }\n}\n```\n\nAnother example of this would be Currency conversion. Also, mathematical\nsymbols (such as degrees vs radians) can benefit from this.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/custom_mirrors/classes_or_structs.md":["f7b58c0223c9b520",{"identifier":"f613c0bb","filename":"classes_or_structs.md","info":{"title":"Classes or Structs","tags":["reflection","mirror"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-classes-or-structs.html","content":"<h1>Classes or Structs</h1>\n<p>The second can be used for a <code>class</code> or a <code>struct</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>&lt;Subject&gt;(<span class=\"keyword\">_</span> subject: <span class=\"type\">Subject</span>, children: <span class=\"type\">KeyValuePairs</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">Any</span>&gt;, displayStyle: <span class=\"type\">Mirror</span>.<span class=\"type\">DisplayStyle</span>? = <span class=\"keyword\">nil</span>, ancestorRepresentation: <span class=\"type\">Mirror</span>.<span class=\"type\">AncestorRepresentation</span> = .<span class=\"dotAccess\">generated</span>)\n</code></pre></code></pre>\n<p>Interesting to note, here, is that you provide the children (i.e.\nproperties) of your subject as a <code>KeyValuePairs&lt;String, Any&gt;</code> which is a bit like\na dictionary only that it can be used directly as function parameters.</p>\n","raw_content":"[frontMatter]\ntitle = \"Classes or Structs\"\ntags = [\"reflection\", \"mirror\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Classes or Structs\n\nThe second can be used for a `class` or a `struct`.\n\n``` Swift\ninit<Subject>(_ subject: Subject, children: KeyValuePairs<String, Any>, displayStyle: Mirror.DisplayStyle? = nil, ancestorRepresentation: Mirror.AncestorRepresentation = .generated)\n```\n\nInteresting to note, here, is that you provide the children (i.e.\nproperties) of your subject as a `KeyValuePairs<String, Any>` which is a bit like\na dictionary only that it can be used directly as function parameters.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/variable_arguments.md":["fb976546725a3b1f",{"identifier":"d2f64d90","filename":"variable_arguments.md","info":{"title":"Variable Arguments","tags":["tuples","vararg","reduce"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-variable-arguments.html","content":"<h1>Variable Arguments</h1>\n<p>Varargs i.e. variable function arguments are a very useful technique for\nsituations where the number of function parameters is unknown.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// classic example</span>\n\n<span class=\"keyword\">func</span> sum(of numbers: <span class=\"type\">Int</span>...) -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"comment\">// add up all numbers with the + operator</span>\n\n     <span class=\"keyword\">return</span> numbers.<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, +)\n\n}\n\n\n\n<span class=\"keyword\">let</span> theSum = <span class=\"call\">sum</span>(of: <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>) <span class=\"comment\">// 24</span>\n</code></pre></code></pre>\n<p>A tuple can be useful here if your requirement goes beyond simple\nintegers. Take this function, which does a batch update of <code>n</code> entities\nin a database:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> batchUpdate(updates: (<span class=\"type\">String</span>, <span class=\"type\">Int</span>)...) {\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">db</span>.<span class=\"call\">begin</span>()\n\n     <span class=\"keyword\">for</span> (key, value) <span class=\"keyword\">in</span> updates {\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">db</span>.<span class=\"call\">set</span>(key, value)\n\n     }\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">db</span>.<span class=\"call\">end</span>()\n\n}\n\n\n\n<span class=\"call\">batchUpdate</span>(updates: (\\<span class=\"string\">\"tk1</span>\\<span class=\"string\">\"</span>, <span class=\"number\">5</span>), \n\n        (\\<span class=\"string\">\"tk7</span>\\<span class=\"string\">\"</span>, <span class=\"number\">9</span>), \n\n        (\\<span class=\"string\">\"tk21</span>\\<span class=\"string\">\"</span>, <span class=\"number\">44</span>), \n\n        (\\<span class=\"string\">\"tk88</span>\\<span class=\"string\">\"</span>, <span class=\"number\">12</span>))\n</code></pre></code></pre>\n<p>This pattern allows us to model the insertions in a very simple\nmanner without having to introduce additional struct types.</p>\n","raw_content":"[frontMatter]\ntitle = \"Variable Arguments\"\ntags = [\"tuples\", \"vararg\", \"reduce\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Variable Arguments\n\nVarargs i.e. variable function arguments are a very useful technique for\nsituations where the number of function parameters is unknown.\n\n``` Swift\n// classic example\nfunc sum(of numbers: Int...) -> Int {\n    // add up all numbers with the + operator\n    return numbers.reduce(0, +)\n}\n\nlet theSum = sum(of: 1, 2, 5, 7, 9) // 24\n```\n\nA tuple can be useful here if your requirement goes beyond simple\nintegers. Take this function, which does a batch update of `n` entities\nin a database:\n\n``` Swift\nfunc batchUpdate(updates: (String, Int)...) {\n    self.db.begin()\n    for (key, value) in updates {\n        self.db.set(key, value)\n    }\n    self.db.end()\n}\n\nbatchUpdate(updates: (\"tk1\", 5), \n       (\"tk7\", 9), \n       (\"tk21\", 44), \n       (\"tk88\", 12))\n```\n\nThis pattern allows us to model the insertions in a very simple\nmanner without having to introduce additional struct types.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/optionals.md":["8db65d77bda339bb",{"identifier":"2df1651b","filename":"optionals.md","info":{"title":"Optionals","tags":["pattern matching","switch","optional"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-optionals.html","content":"<h1>Optionals</h1>\n<p><a href=\"lnk::optional\">There're many ways to unwrap\noptionals,</a>\nand pattern matching is one of them. You've probably used that quite\nfrequently by now, nevertheless, here's a short example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> result: <span class=\"type\">String</span>? = <span class=\"call\">secretMethod</span>()\n\n<span class=\"keyword\">switch</span> result {\n\n<span class=\"keyword\">case nil</span>:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"is</span> nothing\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case let</span> a?:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(a) <span class=\"keyword\">is</span> a value\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>As you can see, <code>result</code> could be a string, but it could also be <code>nil</code>.\nIt's an <code>Optional</code>. By switching on result, we can figure out whether\nit is <code>.none</code> or whether it is an actual value. Even more, if it is a\nvalue, we can also bind this value to variable right away. In this case\n<code>a</code>. What's beautiful here, is the clearly visible distinction between\nthe two states, that the variable <code>result</code> can be in.</p>\n","raw_content":"[frontMatter]\ntitle = \"Optionals\"\ntags = [\"pattern matching\", \"switch\", \"optional\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Optionals\n\n[There\\'re many ways to unwrap\noptionals,](lnk::optional)\nand pattern matching is one of them. You\\'ve probably used that quite\nfrequently by now, nevertheless, here\\'s a short example:\n\n``` Swift\nvar result: String? = secretMethod()\nswitch result {\ncase nil:\n    print(\"is nothing\")\ncase let a?:\n    print(\"\\(a) is a value\")\n}\n```\n\nAs you can see, `result` could be a string, but it could also be `nil`.\nIt\\'s an `Optional`. By switching on result, we can figure out whether\nit is `.none` or whether it is an actual value. Even more, if it is a\nvalue, we can also bind this value to variable right away. In this case\n`a`. What\\'s beautiful here, is the clearly visible distinction between\nthe two states, that the variable `result` can be in.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/more_examples/intro.md":["dabbce981de4a989",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"More Examples","tags":[],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-more-examples.html","content":"<h1>More Examples</h1>\n<p>This was a short overview of the power behind the <code>reduce</code> method. It is\nparticularly helpful if you end up chaining a lot of functional methods\ntogether, <strong>or</strong> when output shape of your data differs from the input\nshape. We'll finish this guide with more reduce examples to give you\ninspirations for various use cases where reduce can easily be applied.</p>\n","raw_content":"[frontMatter]\ntitle = \"More Examples\"\ntags = []\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n---\n\n# More Examples\n\nThis was a short overview of the power behind the `reduce` method. It is\nparticularly helpful if you end up chaining a lot of functional methods\ntogether, **or** when output shape of your data differs from the input\nshape. We'll finish this guide with more reduce examples to give you\ninspirations for various use cases where reduce can easily be applied.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/type_matches.md":["9d33ff0d1899f8bc",{"identifier":"c56c1bab","filename":"type_matches.md","info":{"title":"Type Matches","tags":["pattern matching","switch","is","objc"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-type-matches.html","content":"<h1>Type Matches</h1>\n<p>Given Swift's strong type system, there's usually no need for runtime\ntype checks like it more often happens in Objective-C. However, when you\ninteract with legacy Objective-C code <a href=\"https://netguru.co/blog/objective-c-generics\">(which hasn't been updated to\nreflect simple generics\nyet)</a>, then you often end\nup with code that needs to check for types. Imagine getting an array of\nNSStrings and NSNumbers:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> u = <span class=\"type\">NSArray</span>(array: [<span class=\"type\">NSString</span>(string: \\<span class=\"string\">\"String1</span>\\<span class=\"string\">\"</span>), <span class=\"type\">NSNumber</span>(int: <span class=\"number\">20</span>), <span class=\"type\">NSNumber</span>(int: <span class=\"number\">40</span>)])\n</code></pre></code></pre>\n<p>When you go through this NSArray, you never know what kind of type you\nget. However, <code>switch</code> statements allow you to easily test for types\nhere:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> array {\n\n     <span class=\"keyword\">switch</span> item {\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">NSString</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"string</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">NSNumber</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"number</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">default</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"Unknown</span> type \\(item)\\<span class=\"string\">\"</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Type Matches\"\ntags = [\"pattern matching\", \"switch\", \"is\", \"objc\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Type Matches\n\nGiven Swift\\'s strong type system, there\\'s usually no need for runtime\ntype checks like it more often happens in Objective-C. However, when you\ninteract with legacy Objective-C code [(which hasn\\'t been updated to\nreflect simple generics\nyet)](https://netguru.co/blog/objective-c-generics), then you often end\nup with code that needs to check for types. Imagine getting an array of\nNSStrings and NSNumbers:\n\n``` Swift\nlet u = NSArray(array: [NSString(string: \"String1\"), NSNumber(int: 20), NSNumber(int: 40)])\n```\n\nWhen you go through this NSArray, you never know what kind of type you\nget. However, `switch` statements allow you to easily test for types\nhere:\n\n``` Swift\nfor item in array {\n    switch item {\n    case is NSString:\n        print(\"string\")\n    case is NSNumber:\n        print(\"number\")\n    default:\n        print(\"Unknown type \\(item)\")\n    }\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/pattern_matching/complete_book.html":["e3b0c44298fc1c14",{"identifier":"b405","filename":"complete_book.html","info":{"title":"Advanced Pattern Matching","tags":[],"keywords":["feature","lisp","swift","optional","scala","simple","optionals","switch","chaining","for","pattern","matching","clojure","haskell"],"category":[],"created":"2015-08-20 10:30:30","description":"In this post, we'll have a look at Pattern Matching in Swift in terms of the 'switch', 'for', 'if', and 'guard' keywords. We'll have a look at the basic syntax and at best practices and helpful examples.","description_html":"<p>In this post, we'll have a look at Pattern Matching in Swift in terms of the 'switch', 'for', 'if', and 'guard' keywords. We'll have a look at the basic syntax and at best practices and helpful examples.</p>\n","published":true,"slug":null,"meta":{"short_title":"🧩 Pattern Matching","featured":"true","short_code":"<pre class='Swift'><code><span class='apvsource swift'><span class='apvkeyword apvcontrol apvswitch swift'>case</span> (<span class='apvkeyword apvoperator apvtype-casting swift'>is</span> <span class='apvsupport apvtype swift'>Bool</span>, <span class='apvstorage apvtype swift'>let</span> x <span class='apvkeyword apvoperator apvtype-casting swift'>as</span> <span class='apvsupport apvtype swift'>Int</span>)<br/>&nbsp;&nbsp;&nbsp;&nbsp; <span class='apvkeyword apvcontrol apvswitch swift'>where</span> x <span class='apvkeyword apvoperator apvcomparative swift'>&gt;</span> <span class='apvconstant apvnumeric apvinteger apvdecimal swift'>10</span> </span></code></pre></code></pre>","swift_version":"5.1"},"created_timestamp":1440066630,"date":"2015-08-20T10:30:30","date_info":{"year":2015,"month":8,"day":20,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/pattern_matching/complete_book.html","content":"<h1>Introduction</h1>\n<p>Swift's <code>switch</code> statement bears little resemblance to the similarly named\nequivalent in C or Objective-C. Even though they share the same name,\nthe Swift version can do much, much more.</p>\n<p>In the\nfollowing guide, I will try to explain the various usages for these\nnew features in more detail.</p>\n<p>The main feature of <code>switch</code> is, of course, pattern matching: the ability\nto destructure values and match different switch cases based on correct\nmatch of the values to the cases.</p>\n<h2>Destructure</h2>\n<p>Destructuring means to take something of a certain structure and destructure it\ninto smaller items again. Imagaine you had a <code>lnk::tuple</code> variable <code>user</code> with the following value: <code>(firstname: &quot;Harry&quot;, lastname: &quot;Potter&quot;, age: 21, occupation: &quot;Wizard&quot;)</code></p>\n<p>Destructuring means taking this tuple and converting it into individual variables:</p>\n<pre class=\"Swift\"><code><span class=\"swift-keyword\">let</span> harry = (firstname: \\<span class=\"swift-string\">\"Harry</span>\\<span class=\"swift-string\">\"</span>, lastname: \\<span class=\"swift-string\">\"Potter</span>\\<span class=\"swift-string\">\"</span>, age: <span class=\"swift-number\">21</span>, occupation: \\<span class=\"swift-string\">\"Wizard</span>\\<span class=\"swift-string\">\"</span>)\n\n\n\n<span class=\"swift-keyword\">let</span> (name, surname, age, occupation) = harry\n\n<span class=\"swift-call\">print</span>(surname)\n</code></pre></code></pre>\n<p>Destructuring is a great method for handling the information in complex types. It is also a fundamental part of Swift's <code>switch</code> statement. The next step, then, is to have a look at <code>switch</code>:</p>\n<h2>A simple example</h2>\n<p>We wrote a game where both players have to take a quiz. After each question we evaluate\nwho won or lost. There're four states:</p>\n<ul>\n<li>Player 1 is correct</li>\n<li>Player 2 is correct</li>\n<li>Both were correct</li>\n<li>Both were wrong</li>\n</ul>\n<p>We can model this logic very nicely with a <code>switch</code> statement such as the following:</p>\n<pre class=\"Swift\"><code><span class=\"swift-keyword\">let</span> player1 = <span class=\"swift-keyword\">true</span>\n\n<span class=\"swift-keyword\">let</span> player2 = <span class=\"swift-keyword\">false</span>\n\n<span class=\"swift-keyword\">switch</span> (player1, player2) {\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">true</span>, <span class=\"swift-keyword\">false</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Player</span> <span class=\"swift-number\">1</span> won\\<span class=\"swift-string\">\"</span>)\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">false</span>, <span class=\"swift-keyword\">true</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Player</span> <span class=\"swift-number\">2</span> won\\<span class=\"swift-string\">\"</span>)\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">true</span>, <span class=\"swift-keyword\">true</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Draw</span>, both won\\<span class=\"swift-string\">\"</span>)\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">false</span>, <span class=\"swift-keyword\">false</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Draw</span>, both lost\\<span class=\"swift-string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>Here, we create a tuple <code>(player1, player2)</code> and then match each of\nthe possible cases.</p>\n<p>This was a very short introduction, now we will go into more detail.</p>\n<h1>A Trading Engine</h1>\n<p>So a Wall Street company contacts you, they need a new trading platform running\non iOS devices. As it is a trading platform, you define an <code>enum</code> for\ntrades.</p>\n<h2>First Draft</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trades {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>)\n\n}\n</code></pre></code></pre>\n<p>You were also handed the following API to handle trades. <strong>Notice how\nsell orders are just negative amounts</strong>.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/**</span>\n\n  - parameter stock: <span class=\"type\">The</span> stock name\n\n  - parameter amount: <span class=\"type\">The</span> amount, negative number = sell, positive = buy\n\n<span class=\"comment\">*/</span>\n\n<span class=\"keyword\">func</span> process(stock: <span class=\"type\">String</span>, <span class=\"keyword\">_</span> amount: <span class=\"type\">Int</span>) {\n\n     print (\\<span class=\"string\">\"</span>\\(amount) of \\(stock)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>The next step is to process those trades. You see the potential for\nusing pattern matching and write this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> aTrade = <span class=\"type\">Trades</span>.<span class=\"call\">buy</span>(stock: \\<span class=\"string\">\"APPL</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">200</span>, stockPrice: <span class=\"number\">115.5</span>)\n\n\n\n<span class=\"keyword\">switch</span> aTrade {\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">buy</span>(<span class=\"keyword\">let</span> stock, <span class=\"keyword\">let</span> amount, <span class=\"keyword\">_</span>):\n\n     <span class=\"call\">process</span>(stock, amount)\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">sell</span>(<span class=\"keyword\">let</span> stock, <span class=\"keyword\">let</span> amount, <span class=\"keyword\">_</span>):\n\n     <span class=\"call\">process</span>(stock, amount * -<span class=\"number\">1</span>)\n\n}\n\n<span class=\"comment\">// Prints \\\"buy 200 of APPL\\\"</span>\n</code></pre></code></pre>\n<p>Swift lets us conveniently only destructure / extract the information\nfrom the <code>enum</code> that we really want. In this case only the stock and the\namount.</p>\n<p>Awesome, you visit Wall Street to show of your fantastic trading\nplatform. However, as always, the reality is much more cumbersome than\nthe beautiful theory. Trades aren't trades you learn.</p>\n<ul>\n<li>You have to calculate in a fee which is different based on the\ntrader type.</li>\n<li>The smaller the institution the higher the fee.</li>\n<li>Also, bigger institutions get a higher priority.</li>\n</ul>\n<p>They also realized that you'll need a new API for this, so you were\nhanded this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> processSlow(stock: <span class=\"type\">String</span>, <span class=\"keyword\">_</span> amount: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> fee: <span class=\"type\">Float</span>) { <span class=\"call\">print</span>(\\<span class=\"string\">\"slow</span>\\<span class=\"string\">\"</span>) }\n\n<span class=\"keyword\">func</span> processFast(stock: <span class=\"type\">String</span>, <span class=\"keyword\">_</span> amount: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> fee: <span class=\"type\">Float</span>) { <span class=\"call\">print</span>(\\<span class=\"string\">\"fast</span>\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<h2>Trader Types</h2>\n<p>So you go back to the drawing board and add another <code>enum</code>. The trader\ntype is part of every trade, too.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> TraderType {\n\n<span class=\"keyword\">case</span> singleGuy\n\n<span class=\"keyword\">case</span> company\n\n} \n\n\n\n<span class=\"keyword\">enum</span> Trades {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>, type: <span class=\"type\">TraderType</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>, type: <span class=\"type\">TraderType</span>)\n\n}\n\n\n</code></pre></code></pre>\n<p>So, how do you best implement this new restriction? You could just have\nan <code>if</code> / <code>else</code> switch for buy and for sell, but that would lead to\nnested code which quickly lacks clarity - and who knows maybe these Wall\nStreet guys come up with further complications. So you define it instead\nas additional requirements on the pattern matches:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">let</span> aTrade = <span class=\"type\">Trades</span>.<span class=\"call\">sell</span>(stock: \\<span class=\"string\">\"GOOG</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">100</span>, stockPrice: <span class=\"number\">666.0</span>, type: <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>)\n\n\n\n<span class=\"keyword\">switch</span> aTrade {\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, amount, <span class=\"number\">2.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">2.0</span>)\n\n}\n</code></pre></code></pre>\n<p>The beauty of this is that there's a very succinct flow describing the\ndifferent possible combinations. Also, note how we changed\n<code>.buy(let stock, let amount)</code> into <code>let .buy(stock, amount)</code> in order to\nkeep things simpler. This will destructure the <code>enum</code> just as before,\nonly with less syntax.</p>\n<h2>Guards! Guards!</h2>\n<p>Once again you present your development to your Wall Street customer,\nand once again a new issue pops up (you really should have asked for a\nmore detailed project description).</p>\n<ul>\n<li>Sell orders exceeding a total value of $1.000.000 do always get\nfast handling, even if it's just a single guy.</li>\n<li>Buy orders under a total value of $1.000 do always get slow\nhandling.</li>\n</ul>\n<p>With traditional nested <code>if</code> syntax, this would already become a bit\nmessy. Not so with <code>switch</code>. Swift includes guards for <code>switch cases</code>\nwhich allow you to further restrict the possible matching of those\ncases.</p>\n<p>You only need to modify your <code>switch</code> a little bit to accommodate for\nthose new changes</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">let</span> aTrade = <span class=\"type\">Trades</span>.<span class=\"call\">buy</span>(stock: \\<span class=\"string\">\"GOOG</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">1000</span>, stockPrice: <span class=\"number\">666.0</span>, type: <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>)\n\n\n\n<span class=\"keyword\">switch</span> aTrade {\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, price, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>)\n\n     <span class=\"keyword\">where</span> price*<span class=\"type\">Float</span>(amount) &gt; <span class=\"number\">1000000</span>:\n\n     <span class=\"call\">processFast</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, price, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>)\n\n     <span class=\"keyword\">where</span> price*<span class=\"type\">Float</span>(amount) &lt; <span class=\"number\">1000</span>:\n\n     <span class=\"call\">processSlow</span>(stock, amount, <span class=\"number\">2.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, amount, <span class=\"number\">2.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">2.0</span>)\n\n}\n</code></pre></code></pre>\n<p>This code is quite structured, still rather easy to read, and wraps up\nthe complex cases quite well.</p>\n<p>That's it, we've successfully implemented our trading engine. However,\nthis solution still has a bit of repetition; we wonder if there're\npattern matching ways to improve upon that. So, let's look into pattern\nmatching a bit more.</p>\n<h1>Pattern Types</h1>\n<p>So now we've seen several patterns in action. But what's the syntax\nhere? Which other things can we match for? Swift distinguishes <strong>7</strong>\ndifferent patterns. We're going to have a quick look at each of them.</p>\n<p>All of those patterns can not only be used with the <code>switch</code> keyword,\nbut also with the <code>if</code>, <code>guard</code>, and <code>for</code> keywords. For details on\nthis, read on.</p>\n<h1>Wildcard Pattern</h1>\n<p>The wildcard pattern ignores the value to be matched against. In this\ncase any value is possible. This is the same pattern as <code>let _ = fn()</code>\nwhere the <code>_</code> indicates that you don't wish to further use this value.\nThe interesting part is that this matches all values including <code>nil</code>.</p>\n<p>You can also match <a href=\"lnk::optional\">optionals</a> by appending a <code>?</code> to make it <code>_?</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> p: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>\n\n<span class=\"keyword\">switch</span> p {\n\n<span class=\"comment\">// Any value is possible, but only if the optional has a value</span>\n\n<span class=\"keyword\">case _</span>?: print (\\<span class=\"string\">\"Has</span> <span class=\"type\">String</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"comment\">// Only match the empty optional case</span>\n\n<span class=\"keyword\">case nil</span>: print (\\<span class=\"string\">\"No</span> <span class=\"type\">String</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>As you've seen in the trading example, it also allows you to omit the\ndata you don't need from matching <code>enums</code> or <code>tuples</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> (<span class=\"number\">15</span>, \\<span class=\"string\">\"example</span>\\<span class=\"string\">\"</span>, <span class=\"number\">3.14</span>) {\n\n<span class=\"comment\">// We're only interested in the last value</span>\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> pi): print (\\<span class=\"string\">\"pi</span>: \\(pi)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<h1>Identifier Pattern</h1>\n<p>Matches a concrete value. This is how things work in Objective-C's\n<code>switch</code> implementation:</p>\n<p>Here, we have a special case just for the number 5</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> number = <span class=\"number\">4</span>\n\n<span class=\"keyword\">switch</span> number {\n\n<span class=\"keyword\">case</span> <span class=\"number\">5</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"it</span> <span class=\"keyword\">is</span> a <span class=\"number\">5</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"it</span> <span class=\"keyword\">is</span> something <span class=\"keyword\">else</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>We can also match strings, see our code below to greet people\nin their native language.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> language = \\<span class=\"string\">\"Japanese</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">switch</span> name {\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"Japanese</span>\\<span class=\"string\">\"</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"おはようございます</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"English</span>\\<span class=\"string\">\"</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Hello</span>!\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"German</span>\\<span class=\"string\">\"</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Guten</span> <span class=\"type\">Tag</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<h1>Value-Binding Pattern</h1>\n<p>This is the very same as binding values to variables via <code>let</code> or <code>var</code>.\nOnly in a switch statement. You've already seen this before, so I'll\nprovide a very short example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> (<span class=\"number\">4</span>, <span class=\"number\">5</span>) {\n\n<span class=\"keyword\">case let</span> (x, y): <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(x) \\(y)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>The <code>let (x, y)</code> in the example above will take the values of our <code>(4, 5)</code> <a href=\"lnk::tuple\">tuple</a> and write them into two new variables named <code>x</code> and <code>y</code>.</p>\n<p>We can easily combine this with the other pattern matching operations to develop very powerful patterns. Imagine you have a function that returns an optional tuple <code>(username: String, password: String)?</code>. You'd like to match it and make sure if the password is correct:</p>\n<p>First, our fantastic function (just a prototype):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> usernameAndPassword() \n\n     -&gt; (username: <span class=\"type\">String</span>, password: <span class=\"type\">String</span>)? {... }\n</code></pre></code></pre>\n<p>Now, the <code>switch</code> example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> usernameAndPassword() {\n\n<span class=\"keyword\">case let</span> (<span class=\"keyword\">_</span>, password)? <span class=\"keyword\">where</span> password == \\<span class=\"string\">\"12345</span>\\<span class=\"string\">\"</span>: <span class=\"call\">login</span>()\n\n<span class=\"keyword\">default</span>: <span class=\"call\">logout</span>()\n\n}\n</code></pre></code></pre>\n<p>See how we combined multiple Swift features here, we will go through them step by step:</p>\n<ol>\n<li>We use <code>case let</code> to create new variables</li>\n<li>We use the <code>?</code> operator to <strong>only</strong> match if the optional return value from the\n<code>usernameAndPassword</code> function is not empty.</li>\n<li>We ignore the <code>username</code> part via <code>_</code>, because we're only interested in the <code>password</code></li>\n<li>We use <code>where</code> to make sure our highly secure password is correct</li>\n<li>We use <code>default</code> for all the other cases that fail.</li>\n</ol>\n<h1>Tuple Pattern</h1>\n<p><a href=\"lnk::tuple\">We have a full article on tuples</a>, but here is a quick overview:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> age = <span class=\"number\">23</span>\n\n<span class=\"keyword\">let</span> job: <span class=\"type\">String</span>? = \\<span class=\"string\">\"Operator</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> payload: <span class=\"type\">Any</span> = <span class=\"type\">NSDictionary</span>()\n\n\n\n<span class=\"keyword\">switch</span> (age, job, payload) {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> age, <span class=\"keyword\">_</span>?, <span class=\"keyword\">_ as</span> <span class=\"type\">NSDictionary</span>):\n\n     <span class=\"call\">print</span>(age)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>Here, we're combining three values into a tuple (imagine they're\ncoming from different API calls) and matching them in one go. Note that\nthe pattern achieves three things:</p>\n<ol>\n<li>It extracts the age</li>\n<li>It makes sure there is a job, even though we don't need it</li>\n<li>It makes sure that the payload is of kind <code>NSDictionary</code> even though\nwe don't need the actual value either.</li>\n</ol>\n<h1>Enumeration Case Pattern</h1>\n<p>As you saw in our trading example, pattern matching works <strong>really\ngreat</strong> with Swift's <code>enums</code>. That's because <code>enum cases</code> are like\nsealed, immutable, destructable structs. Much like with <code>tuples</code>, you\ncan unwrap the contents of an individual case right in the match and\nonly extract the information you need.</p>\n<p>Imagine you're writing a game in a functional style and you have a\ncouple of entities that you need to define. You could use <code>structs</code> but\nas your entities will have very little state, you feel that that's a\nbit of an overkill.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Entities {\n\n     <span class=\"keyword\">case</span> soldier(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> tank(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> player(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>Now you need to implement the drawing loop. Here, we only need the X and\nY position:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> <span class=\"call\">entities</span>() {\n\n     <span class=\"keyword\">switch</span> e {\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">soldier</span>(x, y):\n\n       <span class=\"call\">drawImage</span>(\\<span class=\"string\">\"soldier</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>, x, y)\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">tank</span>(x, y):\n\n       <span class=\"call\">drawImage</span>(\\<span class=\"string\">\"tank</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>, x, y)\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">player</span>(x, y):\n\n       <span class=\"call\">drawImage</span>(\\<span class=\"string\">\"player</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>, x, y)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This is the gist of it. The <code>enumeration case pattern</code> is really just\nusing <code>enum</code> cases in the <code>switch</code> statement.</p>\n<h1>Type Casting Pattern</h1>\n<p>As the name already implies, this pattern casts or matches types. It has\ntwo different keywords:</p>\n<ul>\n<li><code>is</code> <strong>type</strong>: Matches the runtime type (or a subclass of it)\nagainst the right hand side. This performs a type cast but\ndisregards the returned type. So your <code>case</code> block won't know about\nthe matched type.</li>\n<li>pattern <code>as</code> <strong>type</strong>: Performs the same match as the <code>is</code> pattern\nbut for a successful match casts the type into the pattern specified\non the left hand side.</li>\n</ul>\n<p>Here is an example of the two.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> a: <span class=\"type\">Any</span> = <span class=\"number\">5</span> \n\n<span class=\"keyword\">switch</span> a {\n\n\n\n<span class=\"comment\">// this fails because a is still Any</span>\n\n<span class=\"comment\">// error: binary operator '+' cannot be applied to operands of type 'Any' and 'Int'</span>\n\n<span class=\"keyword\">case is</span> <span class=\"type\">Int</span>: print (a + <span class=\"number\">1</span>)\n\n\n\n<span class=\"comment\">// This works and returns '6'</span>\n\n<span class=\"keyword\">case let</span> n <span class=\"keyword\">as</span> <span class=\"type\">Int</span>: print (n + <span class=\"number\">1</span>)\n\n\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>Note that there is no <code>pattern</code> before the <code>is</code>. It matches directly\nagainst <code>a</code>.</p>\n<h1>Expression Pattern</h1>\n<p>The expression pattern is very powerful. It matches the <code>switch</code> value\nagainst an expression implementing the <code>~=</code> operator. There're default\nimplementations for this operator, for example for ranges, so that you\ncan do:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> <span class=\"number\">5</span> {\n\n<span class=\"keyword\">case</span> <span class=\"number\">0</span>..<span class=\"number\">10</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"In</span> range <span class=\"number\">0</span>-<span class=\"number\">10</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"In</span> another range\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>However, the much more interesting possibility is overloading the\noperator yourself in order to add matchability to your custom types.\nLet's say that you decided to rewrite the soldier game we wrote earlier\nand you want to use structs after all.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Soldier {\n\n   <span class=\"keyword\">let</span> hp: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Now you'd like to easily match against all entities with a health of\n<strong>0</strong>. We can simply implement the <code>~=</code> operators as follows.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> ~= (pattern: <span class=\"type\">Int</span>, value: <span class=\"type\">Soldier</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">return</span> pattern == value.<span class=\"property\">hp</span>\n\n}\n</code></pre></code></pre>\n<p>Now we can match against an entity. In this example, only soldiers that\nhave a <code>hp</code> of <code>0</code> would be matched (thus, we print <code>dead soldier</code>),\nbecause we're commparing the <code>value.hp</code> to the <code>switch</code> pattern in our\n<code>~=</code> implementation above.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> soldier = <span class=\"type\">Soldier</span>(hp: <span class=\"number\">99</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)\n\n<span class=\"keyword\">switch</span> soldier {\n\n<span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"dead</span> soldier\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>What if you'd like to not just compare the <code>hp</code> but also the <code>x</code> and the <code>y</code>? You\ncan just implement <code>pattern</code> with a <a href=\"lnk::tuple\">tuple</a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> ~= (pattern: (hp: <span class=\"type\">Int</span>, x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>), value: <span class=\"type\">Soldier</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">let</span> (hp, x, y) = pattern\n\n     <span class=\"keyword\">return</span> hp == value.<span class=\"property\">hp</span> &amp;&amp; x == value.<span class=\"property\">x</span> &amp;&amp; y == value.<span class=\"property\">y</span>\n\n}\n\n\n\n\n\n<span class=\"keyword\">let</span> soldier = <span class=\"type\">Soldier</span>(hp: <span class=\"number\">99</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)\n\n<span class=\"keyword\">switch</span> soldier {\n\n<span class=\"keyword\">case</span> (<span class=\"number\">50</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"health</span> <span class=\"number\">50</span> at pos <span class=\"number\">10</span>/<span class=\"number\">10</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>You can even match structs against structs. However, this only works if your\nstructs are <code>Equatable</code>. Swift can implement this automatically, as long as\nyou tell it to by conforming to the protocol. So lets first extend our <code>Soldier</code>\nstruct to conform to <code>Equatable</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Soldier: <span class=\"type\">Equatable</span> {\n\n     <span class=\"keyword\">let</span> hp: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Now, we can add a new match implementation. Since both soldiers are equatable <code>value types</code>, we can actually just directly compare them. If they both have the same values for their three properties (hp, x, y), then they are considered equal:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> ~= (pattern: <span class=\"type\">Soldier</span>, value: <span class=\"type\">Soldier</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">return</span> pattern == value\n\n}\n\n\n\n<span class=\"keyword\">let</span> soldier = <span class=\"type\">Soldier</span>(hp: <span class=\"number\">50</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)\n\n<span class=\"keyword\">switch</span> soldier {\n\n<span class=\"keyword\">case</span> <span class=\"type\">Soldier</span>(hp: <span class=\"number\">50</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"The</span> same\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>The left side of the <code>~=</code> operator (the <code>pattern</code> argument) can be anything. So\nit can even be a <code>protocol</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Entity {\n\n     <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> {<span class=\"keyword\">get</span>}\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Tank: <span class=\"type\">Entity</span> {\n\n     <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> value: <span class=\"type\">Int</span>) { <span class=\"keyword\">self</span>.<span class=\"property\">value</span> = value }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Peasant: <span class=\"type\">Entity</span> {\n\n     <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> value: <span class=\"type\">Int</span>) { <span class=\"keyword\">self</span>.<span class=\"property\">value</span> = value }\n\n}\n\n\n\n<span class=\"keyword\">func</span> ~=(pattern: <span class=\"type\">Entity</span>, x: <span class=\"type\">Entity</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">return</span> pattern.<span class=\"property\">value</span> == x.<span class=\"property\">value</span>\n\n}\n\n\n\n<span class=\"keyword\">switch</span> <span class=\"type\">Tank</span>(<span class=\"number\">42</span>) {\n\n<span class=\"keyword\">case</span> <span class=\"type\">Peasant</span>(<span class=\"number\">42</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Matched</span>\\<span class=\"string\">\"</span>) <span class=\"comment\">// Does match</span>\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>There's a lot of things you can do with <code>Expression Patterns</code>. For a\nmuch more detailed explanation of Expression Patterns, <a href=\"http://austinzheng.com/2014/12/17/custom-pattern-matching/\">have a look at\nthis terrific blog post by Austin\nZheng</a>.</p>\n<p>This completes list of possible switch patterns. Our next topic is\nflow control in <code>switch</code> statements.</p>\n<h1>Fallthrough, Break and Labels</h1>\n<p>The following is not directly related to pattern matching but only\naffects the <code>switch</code> keyword, so I'll keep it brief. By default, and\nunlike C/C++/Objective-C, <code>switch</code> <code>cases</code> do not fall through into the\nnext case which is why in Swift, you don't need to write <code>break</code> for\nevery case. If you never used <code>Objective-C</code> or <code>C</code> and this confuses you,\nhere's a short example that would print &quot;1, 2, 3&quot;:</p>\n<pre class=\"C\"><code><span class=\"techousource techouc\"><span class=\"techoucomment techoublock techouc\"><span class=\"techoupunctuation techoudefinition techoucomment techouc\">/*</span> This is C Code <span class=\"techoupunctuation techoudefinition techoucomment techouc\">*/</span></span>\n<span class=\"techoukeyword techoucontrol techouc\">switch</span> <span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span><span class=\"techouconstant techounumeric techouc\">2</span><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span> <span class=\"techoumeta techoublock techouc\"><span class=\"techoupunctuation techousection techoublock techoubegin techouc\">{</span>\n<span class=\"techoukeyword techoucontrol techouc\">case</span> <span class=\"techouconstant techounumeric techouc\">1</span><span class=\"techoupunctuation techouseparator techouc\">:</span> <span class=\"techoumeta techoufunction-call techouc\"><span class=\"techousupport techoufunction techouC99 techouc\">printf</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoustring techouquoted techoudouble techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&quot;</span>1<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&quot;</span></span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n<span class=\"techoukeyword techoucontrol techouc\">case</span> <span class=\"techouconstant techounumeric techouc\">2</span><span class=\"techoupunctuation techouseparator techouc\">:</span> <span class=\"techoumeta techoufunction-call techouc\"><span class=\"techousupport techoufunction techouC99 techouc\">printf</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoustring techouquoted techoudouble techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&quot;</span>2<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&quot;</span></span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n<span class=\"techoukeyword techoucontrol techouc\">case</span> <span class=\"techouconstant techounumeric techouc\">3</span><span class=\"techoupunctuation techouseparator techouc\">:</span> <span class=\"techoumeta techoufunction-call techouc\"><span class=\"techousupport techoufunction techouC99 techouc\">printf</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoustring techouquoted techoudouble techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&quot;</span>3<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&quot;</span></span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n<span class=\"techoupunctuation techousection techoublock techouend techouc\">}</span></span>\n</span></code></pre></code></pre>\n<p>You would need to use  <code>case 1: printf(&quot;1&quot;); break;</code> in order to not\nautomatically fall through into the next case.</p>\n<h2>Fallthrough</h2>\n<p>In Swift, it is the other way around. If you actually want to\nfall through into the other case, you can opt into this behaviour with the\n<code>fallthrough</code> keyword.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> <span class=\"number\">5</span> {\n\n<span class=\"keyword\">case</span> <span class=\"number\">5</span>:\n\n  <span class=\"call\">print</span>(\\<span class=\"string\">\"Is</span> <span class=\"number\">5</span>\\<span class=\"string\">\"</span>)\n\n  <span class=\"keyword\">fallthrough</span>\n\n<span class=\"keyword\">default</span>:\n\n  <span class=\"call\">print</span>(\\<span class=\"string\">\"Is</span> a number\\<span class=\"string\">\"</span>)\n\n}\n\n<span class=\"comment\">// Will print: \\\"Is 5\\\" \\\"Is a number\\\"</span>\n</code></pre></code></pre>\n<p>This only works, if your <code>switch</code> cases do not establish <code>let</code>\nvariables, because then Swift would not know what to do.</p>\n<h2>Break</h2>\n<p>You can use <code>break</code> to break out of a switch statement\nearly. Why would you do that if there's no default fallthrough? For\nexample if you can only realize within the <code>case</code> that a certain\nrequirement is not met and you can't execute the <code>case</code> any further:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> userType = \\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> userID = <span class=\"number\">10</span>\n\n<span class=\"keyword\">switch</span> (userType, userID)  {\n\n<span class=\"keyword\">case</span> (\\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">_</span>):\n\n   <span class=\"keyword\">guard let</span> userData = <span class=\"call\">getSystemUser</span>(userID) \n\n      <span class=\"keyword\">else</span> { <span class=\"keyword\">break</span> }\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"user</span> info: \\(userData)\\<span class=\"string\">\"</span>)\n\n   <span class=\"call\">insertIntoRemoteDB</span>(userData)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n\n... more code that needs to be executed\n</code></pre></code></pre>\n<p>Here, we don't want to call <code>insertIntoRemoteData</code> when the result from\n<code>getSystemUser</code> is <code>nil</code>. Of course, you could just use an <code>if let</code>\nhere, but if multiple of those cases come together, you quickly end up\nwith a bunch of horrifyingly ugly nested <code>if lets</code>.</p>\n<h2>Labels</h2>\n<p>But what if you execute your switch in a <code>while</code> loop and you want to\nbreak out of the loop, not the <code>switch</code>? For those cases, Swift allows\nyou to define <code>labels</code> to <code>break</code> or <code>continue</code> to:</p>\n<pre class=\"Swift\"><code>gameLoop: <span class=\"keyword\">while true</span> {\n\n   <span class=\"keyword\">switch</span> state() {\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">waiting</span>: <span class=\"keyword\">continue</span> gameLoop\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">done</span>: <span class=\"call\">calculateNextState</span>()\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">gameOver</span>: <span class=\"keyword\">break</span> gameLoop\n\n   }\n\n}\n</code></pre></code></pre>\n<p>See how we explicitly tell Swift in the <code>gameOver</code> case that it should\nnot break out of the <code>switch</code> statement but should break out of the <code>gameLoop</code>\ninstead.</p>\n<p>We've discussed the syntax and implementation details of <code>switch</code> and\npattern matching. Now, let us have a look at some interesting (more or\nless) real world examples.</p>\n<h1>Real World Examples</h1>\n<p>Swift's pattern matching is very helpful in order to write cleaner code.\nSometimes it can be a bit tricky to rethink common programming patterns in a way\nthat makes them applicable to pattern matching. This guide will help you along\nby introducing various real world examples that clearly benefit from\npattern matching.</p>\n<h1>Optionals</h1>\n<p><a href=\"lnk::optional\">There're many ways to unwrap\noptionals,</a>\nand pattern matching is one of them. You've probably used that quite\nfrequently by now, nevertheless, here's a short example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> result: <span class=\"type\">String</span>? = <span class=\"call\">secretMethod</span>()\n\n<span class=\"keyword\">switch</span> result {\n\n<span class=\"keyword\">case nil</span>:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"is</span> nothing\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case let</span> a?:\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(a) <span class=\"keyword\">is</span> a value\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>As you can see, <code>result</code> could be a string, but it could also be <code>nil</code>.\nIt's an <code>Optional</code>. By switching on result, we can figure out whether\nit is <code>.none</code> or whether it is an actual value. Even more, if it is a\nvalue, we can also bind this value to variable right away. In this case\n<code>a</code>. What's beautiful here, is the clearly visible distinction between\nthe two states, that the variable <code>result</code> can be in.</p>\n<h1>Type Matches</h1>\n<p>Given Swift's strong type system, there's usually no need for runtime\ntype checks like it more often happens in Objective-C. However, when you\ninteract with legacy Objective-C code <a href=\"https://netguru.co/blog/objective-c-generics\">(which hasn't been updated to\nreflect simple generics\nyet)</a>, then you often end\nup with code that needs to check for types. Imagine getting an array of\nNSStrings and NSNumbers:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> u = <span class=\"type\">NSArray</span>(array: [<span class=\"type\">NSString</span>(string: \\<span class=\"string\">\"String1</span>\\<span class=\"string\">\"</span>), <span class=\"type\">NSNumber</span>(int: <span class=\"number\">20</span>), <span class=\"type\">NSNumber</span>(int: <span class=\"number\">40</span>)])\n</code></pre></code></pre>\n<p>When you go through this NSArray, you never know what kind of type you\nget. However, <code>switch</code> statements allow you to easily test for types\nhere:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> array {\n\n     <span class=\"keyword\">switch</span> item {\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">NSString</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"string</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">NSNumber</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"number</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">default</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"Unknown</span> type \\(item)\\<span class=\"string\">\"</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<h1>Applying ranges for grading</h1>\n<p>So you're writing the grading iOS app for your local Highschool. The\nteachers want to enter a number value from 0 to 100 and receive the\ngrade character for it (A - F). Pattern Matching to the rescue:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> aGrade = <span class=\"number\">84</span>\n\n\n\n<span class=\"keyword\">switch</span> aGrade {\n\n<span class=\"keyword\">case</span> <span class=\"number\">90</span>...<span class=\"number\">100</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"A</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">80</span>...<span class=\"number\">90</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"B</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">70</span>...<span class=\"number\">80</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"C</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">60</span>...<span class=\"number\">70</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"D</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">0</span>...<span class=\"number\">60</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"F</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Incorrect</span> <span class=\"type\">Grade</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>You can also always have ranges as parts of nested types, such as tuples or even\n<code>struct</code> types, when you implement the <a href=\"lnk::match-operator\"><code>~=</code></a> operator.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> student = (name: \\<span class=\"string\">\"John</span> <span class=\"type\">Donar</span>\\<span class=\"string\">\"</span>, grades: (english: <span class=\"number\">77</span>, chemistry: <span class=\"number\">21</span>, math: <span class=\"number\">60</span>, sociology: <span class=\"number\">42</span>))\n\n<span class=\"keyword\">switch</span> student {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> name, (<span class=\"number\">90</span>...<span class=\"number\">100</span>, <span class=\"number\">0</span>...<span class=\"number\">50</span>, <span class=\"number\">0</span>...<span class=\"number\">50</span>, <span class=\"keyword\">_</span>)): <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(name) <span class=\"keyword\">is</span> good at arts\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> name, (<span class=\"number\">0</span>...<span class=\"number\">50</span>, <span class=\"number\">90</span>...<span class=\"number\">100</span>, <span class=\"number\">90</span>...<span class=\"number\">100</span>, <span class=\"keyword\">_</span>)): <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(name) <span class=\"keyword\">is</span> good at sciences\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<h1>Word Frequencies</h1>\n<p>We have a sequence of pairs, each representing a word and its frequency\nin some text. Our goal is to filter out those pairs whose frequency is\nbelow or above a certain threshold, and then only return the remaining\nwords, without their respective frequencies.</p>\n<p>Here're our words:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> wordFreqs = [(\\<span class=\"string\">\"k</span>\\<span class=\"string\">\"</span>, <span class=\"number\">5</span>), (\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>, <span class=\"number\">7</span>), (\\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>, <span class=\"number\">3</span>)]\n</code></pre></code></pre>\n<p>A simple solution would be to model this with <a href=\"lnk::map-filter-reduce\"><code>map</code> and <code>filter</code></a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> res = wordFreqs.<span class=\"call\">filter</span>({ (e) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">if</span> e.<span class=\"number\">1</span> &gt; <span class=\"number\">3</span> {\n\n         <span class=\"keyword\">return true</span>\n\n     } <span class=\"keyword\">else</span> {\n\n         <span class=\"keyword\">return false</span>\n\n     }\n\n}).<span class=\"call\">map</span> { $0.<span class=\"number\">0</span> }\n\n<span class=\"call\">print</span>(res)\n</code></pre></code></pre>\n<p>However, with <code>compactMap</code> a map that only returns the non-nil elements, we\ncan improve a lot upon this solution. First and foremost, we can get rid\nof the <code>e.1</code> and instead have proper destructuring by utilizing (you\nguessed it) tuples. And then, we only need one call <code>compactMap</code> instead of\n<code>filter</code> and then <code>map</code> which adds unnecessary performance overhead.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> res = wordFreqs.<span class=\"call\">compactMap</span> { (e) -&gt; <span class=\"type\">String</span>? <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">switch</span> e {\n\n     <span class=\"keyword\">case let</span> (s, t) <span class=\"keyword\">where</span> t &gt; <span class=\"number\">3</span>: <span class=\"keyword\">return</span> s\n\n     <span class=\"keyword\">default</span>: <span class=\"keyword\">return nil</span>\n\n     }\n\n}\n\n<span class=\"call\">print</span>(res)\n</code></pre></code></pre>\n<h1>Directory Traversion</h1>\n<p>Imagine you want to traverse a file hierachy and find:</p>\n<ul>\n<li>all &quot;psd&quot; files from customer1 and customer2</li>\n<li>all &quot;blend&quot; files from customer2</li>\n<li>all &quot;jpeg&quot; files from all customers.</li>\n</ul>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> enumerator = <span class=\"type\">FileManager</span>.<span class=\"property\">default</span>.<span class=\"call\">enumeratorAtPath</span>(\\<span class=\"string\">\"</span>/customers/<span class=\"number\">2014</span>/\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n<span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> enumerator {\n\n     <span class=\"keyword\">switch</span> (url.<span class=\"property\">pathComponents</span>, url.<span class=\"property\">pathExtension</span>) {\n\n\n\n     <span class=\"comment\">// psd files from customer1, customer2</span>\n\n     <span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> f, \\<span class=\"string\">\"psd</span>\\<span class=\"string\">\"</span>) \n\n             <span class=\"keyword\">where</span> f.<span class=\"call\">contains</span>(\\<span class=\"string\">\"customer1</span>\\<span class=\"string\">\"</span>) || f.<span class=\"call\">contains</span>(\\<span class=\"string\">\"customer2</span>\\<span class=\"string\">\"</span>): <span class=\"call\">print</span>(url)\n\n\n\n     <span class=\"comment\">// blend files from customer2</span>\n\n     <span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> f, \\<span class=\"string\">\"blend</span>\\<span class=\"string\">\"</span>) \n\n             <span class=\"keyword\">where</span> f.<span class=\"call\">contains</span>(\\<span class=\"string\">\"customer2</span>\\<span class=\"string\">\"</span>): <span class=\"call\">print</span>(url)\n\n\n\n     <span class=\"comment\">// all jpg files</span>\n\n     <span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, \\<span class=\"string\">\"jpg</span>\\<span class=\"string\">\"</span>): <span class=\"call\">print</span>(url)\n\n\n\n     <span class=\"keyword\">default</span>: ()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Note that <code>contains</code> stops at the first match and doesn't traverse the\ncomplete path. Again, pattern matching lead to very succinct and\nreadable code.</p>\n<h1>Fibonacci</h1>\n<p>Also, see how beautiful an implementation of the fibonacci algorithm\nlooks with pattern matching.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> fibonacci(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"call\">switch</span>(i) {\n\n     <span class=\"keyword\">case let</span> n <span class=\"keyword\">where</span> n &lt;= <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>\n\n     <span class=\"keyword\">case</span> <span class=\"number\">0</span>, <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>\n\n     <span class=\"keyword\">case let</span> n: <span class=\"keyword\">return</span> <span class=\"call\">fibonacci</span>(n - <span class=\"number\">1</span>) + <span class=\"call\">fibonacci</span>(n - <span class=\"number\">2</span>)\n\n     }\n\n}\n\n\n\n<span class=\"call\">print</span>(<span class=\"call\">fibonacci</span>(<span class=\"number\">8</span>))\n</code></pre></code></pre>\n<p>Since we're doing recursion here, this will fail to work with sufficiently large numbers\n(you'll see the dreaded <code>stack overflow</code> error)</p>\n<h1>Legacy API and Value Extractions</h1>\n<p>Oftentimes, when you get data from an external source, like a library,\nor an API, it is not only good practice but usually even required that\nyou check the data for consistency before interpreting it. You need to\nmake sure that all keys exists or that the data is of the correct type,\nor the arrays have the required length. Not doing so can lead from buggy\nbehaviour (missing key) to crash of the app (indexing non-existent array\nitems). The classic way to do this is by nesting <code>if</code> statements.</p>\n<p>Let's imagine an API that returns a user. However, there're two types\nof users: System users - like the administrator, or the postmaster - and\nlocal users - like &quot;John B&quot;, &quot;Bill Gates&quot;, etc. Due to the way the\nsystem was designed and grew, there're a couple of nuisances that API\nconsumers have to deal with:</p>\n<ul>\n<li><code>system</code> and <code>local</code> users come via the same API call.</li>\n<li>the <code>department</code> key may not exist, since early versions of the db\ndid not have that field and early employees never had to fill it\nout.</li>\n<li>the <code>name</code> array contains either 4 items (username, middlename,\nlastname, firstname) or 2 items (full name, username) depending on\nwhen the user was created.</li>\n<li>the <code>age</code> is an Integer with the age of the user</li>\n</ul>\n<p>Our system needs to create user accounts for all system users from this\nAPI with only the following information: username, department. We only\nneed users born before 1980. If no department is given, &quot;Corp&quot; is\nassumed.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> legacyAPI(id: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">String</span>: <span class=\"type\">Any</span>] {\n\n     <span class=\"keyword\">return</span> [\\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"department</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Dark</span> <span class=\"type\">Arts</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">57</span>, \n\n            \\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: [\\<span class=\"string\">\"voldemort</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Tom</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Marvolo</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Riddle</span>\\<span class=\"string\">\"</span>]] \n\n}\n</code></pre></code></pre>\n<p>Given these constraints, let's develop a pattern match for it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> item = <span class=\"call\">legacyAPI</span>(<span class=\"number\">4</span>)\n\n<span class=\"keyword\">switch</span> (item[\\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>], item[\\<span class=\"string\">\"department</span>\\<span class=\"string\">\"</span>], item[\\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>], item[\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>]) {\n\n<span class=\"keyword\">case let</span> (sys <span class=\"keyword\">as</span> <span class=\"type\">String</span>, dep <span class=\"keyword\">as</span> <span class=\"type\">String</span>, age <span class=\"keyword\">as</span> <span class=\"type\">Int</span>, name <span class=\"keyword\">as</span> [<span class=\"type\">String</span>]) <span class=\"keyword\">where</span> \n\n   age &lt; <span class=\"number\">1980</span> &amp;&amp;\n\n   sys == \\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>:\n\n   <span class=\"call\">createSystemUser</span>(name.<span class=\"property\">count</span> == <span class=\"number\">2</span> ? name.<span class=\"property\">last</span>! : name.<span class=\"property\">first</span>!, dep: dep ?? \\<span class=\"string\">\"Corp</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>:()\n\n}\n\n\n\n<span class=\"comment\">// returns (\\\"voldemort\\\", \\\"Dark Arts\\\")</span>\n</code></pre></code></pre>\n<p>Note that this code makes one dangerous assumption, which is that if the\nname array does not have 2 items, it <strong>must</strong> have 4 items. If that case\ndoesn't hold, and we get a zero item name array, this would crash.</p>\n<p>Other than that, it is a nice example of how pattern matching even with\njust one case can help you write cleaner code and simplify value\nextractions.</p>\n<p>Also, see how we're writing <code>let</code> at the beginning right after the\ncase, and don't have to repeat it for each assignment within the case.</p>\n<h1>Patterns with other Keywords</h1>\n<p>The Swift documentation points out, that not all patterns can be used\nwith the <code>if</code>, <code>for</code> or the <code>guard</code> statement. However, the docs seem to\nbe outdated. All 7 patterns work for all three keywords.</p>\n<p>As a shorter example, see the <strong>Value Binding</strong>, <strong>Tuple</strong>, and <strong>Type\nCasting</strong> pattern used for all three keywords in one example:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// This is just a collection of keywords that compiles. This code makes no sense</span>\n\n<span class=\"keyword\">func</span> valueTupleType(a: (<span class=\"type\">Int</span>, <span class=\"type\">Any</span>)) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"comment\">// guard case Example</span>\n\n     <span class=\"keyword\">guard case let</span> (x, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>) = a <span class=\"keyword\">else</span> { <span class=\"keyword\">return false</span>}\n\n     <span class=\"call\">print</span>(x)\n\n\n\n     <span class=\"comment\">// for case example</span>\n\n     <span class=\"keyword\">for case let</span> (a, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>) <span class=\"keyword\">in</span> [a] {\n\n         <span class=\"call\">print</span>(a)\n\n     }\n\n\n\n     <span class=\"comment\">// if case example</span>\n\n     <span class=\"keyword\">if case let</span> (x, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>) = a {\n\n        <span class=\"call\">print</span>(\\<span class=\"string\">\"if</span>\\<span class=\"string\">\"</span>, x)\n\n     }\n\n\n\n     <span class=\"comment\">// switch case example</span>\n\n     <span class=\"keyword\">switch</span> a {\n\n     <span class=\"keyword\">case let</span> (a, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>):\n\n         <span class=\"call\">print</span>(a)\n\n         <span class=\"keyword\">return true</span>\n\n     <span class=\"keyword\">default</span>: <span class=\"keyword\">return false</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>With this in mind, we will have a short look at each of those keywords\nin detail.</p>\n<h1>Using <strong>for case</strong></h1>\n<p>Let's write a simple array function which only returns the non-nil elements</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> nonnil&lt;T&gt;(array: [<span class=\"type\">T</span>?]) -&gt; [<span class=\"type\">T</span>] {\n\n    <span class=\"keyword\">var</span> result: [<span class=\"type\">T</span>] = []\n\n    <span class=\"keyword\">for case let</span> x? <span class=\"keyword\">in</span> array {\n\n       result.<span class=\"call\">append</span>(x)\n\n    }\n\n    <span class=\"keyword\">return</span> result\n\n}\n\n\n\n<span class=\"call\">print</span>(<span class=\"call\">nonnil</span>([\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">nil</span>, \\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"c</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">nil</span>]))\n</code></pre></code></pre>\n<p>The <code>case</code> keyword can be used in for loops just like in <code>switch</code> cases.\nHere's another example. Remember the game we talked about earlier?\nWell, after the first refactoring, our entity system now looks like\nthis:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Entity {\n\n     <span class=\"keyword\">enum</span> EntityType {\n\n         <span class=\"keyword\">case</span> soldier\n\n         <span class=\"keyword\">case</span> player\n\n     }\n\n     <span class=\"keyword\">case</span> <span class=\"type\">Entry</span>(type: <span class=\"type\">EntityType</span>, x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, hp: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>Fancy, this allows us to draw all items with even less code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for case let</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(t, x, y, <span class=\"keyword\">_</span>) <span class=\"keyword\">in</span> <span class=\"call\">gameEntities</span>()\n\n<span class=\"keyword\">where</span> x &gt; <span class=\"number\">0</span> &amp;&amp; y &gt; <span class=\"number\">0</span> {\n\n     <span class=\"call\">drawEntity</span>(t, x, y)\n\n}\n</code></pre></code></pre>\n<p>Our one line unwraps all the necessary properties, makes sure we're not\ndrawing beyond 0, and finally calls the render call (<code>drawEntity</code>).</p>\n<p>In order to see if the player won the game, we want to know if there is\nat least one Soldier with health &gt; 0</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> gameOver() -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">for case</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(.<span class=\"dotAccess\">soldier</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> hp) <span class=\"keyword\">in</span> <span class=\"call\">gameEntities</span>() \n\n     <span class=\"keyword\">where</span> hp &gt; <span class=\"number\">0</span> {<span class=\"keyword\">return false</span>}\n\n     <span class=\"keyword\">return true</span>\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">gameOver</span>())\n</code></pre></code></pre>\n<p>What's nice is that the <code>.soldier</code> match is part of the for query. This\nfeels a bit like <code>SQL</code> and less like imperative loop programming. Also,\nthis makes our intent clearer to the compiler, opening up the\npossibilities for dispatch enhancements down the road. Another nice\ntouch is that we don't have to spell out <code>Entity.EntityType.soldier</code>.\nSwift understands our intent even if we only write <code>.soldier</code> as above.</p>\n<h1>Using <strong>guard case</strong></h1>\n<p>Another keyword which supports patterns is the newly introduced <code>guard</code>\nkeyword. You know how it allows you to bind <code>Optionals</code> into the local\nscope much like <code>if let</code> only without nesting things:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> example(a: <span class=\"type\">String</span>?) {\n\n     <span class=\"keyword\">guard let</span> a = a <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     <span class=\"call\">print</span>(a)\n\n}\n\n<span class=\"call\">example</span>(\\<span class=\"string\">\"yes</span>\\<span class=\"string\">\"</span>)\n</code></pre></code></pre>\n<p><code>guard let case</code> allows you to do something similar with the power that\npattern matching introduces. Let's have a look at our soldiers again.\nWe want to calculate the required HP until our player has full health\nagain. Soldiers can't regain HP, so we should always return 0 for a\nsoldier entity.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> <span class=\"type\">MAX_HP</span> = <span class=\"number\">100</span>\n\n\n\n<span class=\"keyword\">func</span> healthHP(entity: <span class=\"type\">Entity</span>) -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">guard case let</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(.<span class=\"dotAccess\">player</span>, <span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, hp) = entity \n\n       <span class=\"keyword\">where</span> hp &lt; <span class=\"type\">MAX_HP</span> \n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"number\">0</span> }\n\n     <span class=\"keyword\">return</span> <span class=\"type\">MAX_HP</span> - hp\n\n}\n\n\n\n<span class=\"call\">print</span>(\\<span class=\"string\">\"Soldier</span>\\<span class=\"string\">\"</span>, <span class=\"call\">healthHP</span>(<span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: .<span class=\"dotAccess\">soldier</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>, hp: <span class=\"number\">79</span>)))\n\n<span class=\"call\">print</span>(\\<span class=\"string\">\"Player</span>\\<span class=\"string\">\"</span>, <span class=\"call\">healthHP</span>(<span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: .<span class=\"dotAccess\">player</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>, hp: <span class=\"number\">57</span>)))\n\n\n\n<span class=\"comment\">// Prints:</span>\n\n\\<span class=\"string\">\"Soldier</span> <span class=\"number\">0</span>\\<span class=\"string\">\"</span>\n\n\\<span class=\"string\">\"Player</span> <span class=\"number\">43</span>\\<span class=\"string\">\"</span>\n\n\n</code></pre></code></pre>\n<p>This is a beautiful example of the culmination of the various mechanisms\nwe've discussed so far.</p>\n<ul>\n<li>It is very clear, there is no nesting involved</li>\n<li>Logic and initialization of state are handled at the top of the\n<code>func</code> which improves readability</li>\n<li>Very terse.</li>\n</ul>\n<p>This can also be very successfully combined with <code>switch</code> and <code>for</code> to\nwrap complex logical constructs into an easy to read format. Of course,\nthat won't make the logic any easier to understand, but at least it\nwill be provided in a much saner package. Especially if you use <code>enums</code>.</p>\n<h1>Using <strong>if case</strong></h1>\n<p><code>if case</code> can be used as the opposite of <code>guard case</code>. It is a great way\nto unwrap and match data within a branch. In line with our previous\n<code>guard</code> example. Obviously, we need an move function. Something that\nallows us to say that an entity moved in a direction. Since our entities\nare <code>enums</code>, we need to return an updated entity.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> move(entity: <span class=\"type\">Entity</span>, xd: <span class=\"type\">Int</span>, yd: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Entity</span> {\n\n     <span class=\"keyword\">if case</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(<span class=\"keyword\">let</span> t, <span class=\"keyword\">let</span> x, <span class=\"keyword\">let</span> y, <span class=\"keyword\">let</span> hp) = entity\n\n     <span class=\"keyword\">where</span> (x + xd) &lt; <span class=\"number\">1000</span> &amp;&amp;\n\n         (y + yd) &lt; <span class=\"number\">1000</span> {\n\n     <span class=\"keyword\">return</span> <span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: t, x: (x + xd), y: (y + yd), hp: hp)\n\n     }\n\n     <span class=\"keyword\">return</span> entity\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">move</span>(<span class=\"type\">Entity</span>.<span class=\"type\">Entry</span>(type: .<span class=\"dotAccess\">soldier</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>, hp: <span class=\"number\">79</span>), xd: <span class=\"number\">30</span>, yd: <span class=\"number\">500</span>))\n\n<span class=\"comment\">// prints: Entry(main.Entity.EntityType.soldier, 40, 510, 79)</span>\n</code></pre></code></pre>\n<h1>Finishing Words</h1>\n<p>Pattern Matching is a really powerful feature of Swift. It is one of the defining features that makes Swift Code so much nicer to read than what you'd write in Objective-C. It is also deeply integrated into the language as it can be used with <code>let</code>, <code>guard</code>, <code>for</code>, <code>if</code>, and <code>switch</code>. It also allows adding <code>where</code> clauses, using <code>is</code> or <code>as</code> for type casts, lets you extend it via <code>~=</code> and much more.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2016-03-29-three-tips-for-clean-swift-code.md":["2fb830c6637cffee",{"identifier":"7ff7cfb2","filename":"2016-03-29-three-tips-for-clean-swift-code.md","info":{"title":"Three tips for concise Swift using the Guard statement","tags":["enum","guard","if let"],"keywords":["swift","mac","cocoa","guard","let","enum","pattern","matching","patterns"],"category":["Swift Tricks","All"],"created":"2016-03-29 10:30:30","description":"Three quick examples for how you can use guard to write shorter and simpler code","description_html":"<p>Three quick examples for how you can use guard to write shorter and simpler code</p>\n","published":true,"slug":"2016-03-29-three-tips-for-clean-swift-code.html","meta":{"feature_image":"https://appventure.me/img-content/2016-03-29-three-tips-for-clean-swift-code-feature-image.jpg","swift_version":"5.0"},"created_timestamp":1459247430,"date":"2016-03-29T10:30:30","date_info":{"year":2016,"month":3,"day":29,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2016-03-29-three-tips-for-clean-swift-code.html","content":"<p>This will be a shorter post compared to some of my previous ones, but I\nwanted to share three useful <code>guard</code> tips for structuring your functions\nin such a way that you end up with code that is more concise and also\neasier to understand. This is <strong>not</strong> a post about general coding\nstyles or coding guidelines, but more about how <code>guard</code> can help you\nsimplify your code.</p>\n<h1>Binding and Condition Combination</h1>\n<h2>Nesting</h2>\n<p>The first example concerns the use of pattern matching in order to\nlet bind variables into the current scope. One thing I really like\nabout this syntax (compared to, say <code>if let</code>) is that it keeps a golden\ncode path, <strong>guarding</strong> you from the all-too common <strong>skyscraper of\ndeath</strong>. Compare:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Lots of nonsensical code to show how nested code structures look confusing</span>\n\n<span class=\"keyword\">if let</span> a = <span class=\"call\">a</span>() {\n\n   <span class=\"keyword\">let</span> x = <span class=\"call\">b</span>(a)\n\n   x.<span class=\"call\">fn</span>()\n\n   <span class=\"keyword\">if let</span> u = x.<span class=\"call\">nxt</span>() {\n\n     <span class=\"keyword\">let</span> ux = u.<span class=\"call\">brm</span>()\n\n     <span class=\"keyword\">if let</span> uxt = ux.<span class=\"call\">nxt</span>() {\n\n        <span class=\"call\">perform</span>(uxt)\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>with:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> a = <span class=\"call\">a</span>() <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n<span class=\"keyword\">let</span> x = <span class=\"call\">b</span>(a)\n\nx.<span class=\"call\">fn</span>()\n\n<span class=\"keyword\">guard let</span> u = x.<span class=\"call\">nxt</span>() <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n<span class=\"keyword\">let</span> ux = u.<span class=\"call\">brm</span>()\n\n<span class=\"keyword\">guard let</span> uxt = ux.<span class=\"call\">nxt</span>() <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n<span class=\"call\">perform</span>(uxt)\n</code></pre></code></pre>\n<p>Now these are awful examples of how not to structure an internal API,\nbut they exist more to drive a point home. <code>Guard</code> is great because it\nbinds the result into the current scope instead of the nested scope. In\nlarger functions, this makes all the difference between having huge,\ndifficult-to-grasp deeply-nested functions and clean versions which look\nalmost like lists of commands.</p>\n<h2>Pattern Binding</h2>\n<p>The above works even better, if your input is an <code>enum</code>. Consider how\nwe're handling the following usecase:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> NotificationListener {\n\n   <span class=\"keyword\">func</span> handleNotification(notification: <span class=\"type\">Notification</span>)\n\n}\n\n<span class=\"keyword\">enum</span> Notification {\n\n   <span class=\"keyword\">case</span> userLoggedIn(user: <span class=\"type\">String</span>, date: <span class=\"type\">NSDate</span>, domain: <span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> fileUploaded(file: <span class=\"type\">String</span>, location: <span class=\"type\">String</span>, size: <span class=\"type\">Int</span>, user: <span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"keyword\">struct</span> FileUploadHandler: <span class=\"type\">NotificationListener</span> {\n\n   <span class=\"comment\">/// Implement the notification handling to move uploaded files to temporary folder</span>\n\n   <span class=\"keyword\">func</span> handleNotification(notification: <span class=\"type\">Notification</span>) {\n\n     <span class=\"keyword\">guard case</span> .<span class=\"dotAccess\">fileUploaded</span>(<span class=\"keyword\">let</span> file, <span class=\"keyword\">let</span> location, <span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> user) = notification\n\n     <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n     <span class=\"keyword\">if</span> user == <span class=\"keyword\">self</span>.<span class=\"property\">currentUser</span> {\n\n        <span class=\"keyword\">self</span>.<span class=\"call\">moveFile</span>(file, atLocation: location)\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>The binding in the <code>guard case</code> line achieves two things for us:</p>\n<ol>\n<li>It makes sure <code>handleNotifications</code> only works for <code>fileUploaded</code>\nnotifications, and not for <code>userLoggedIn</code> notifications.</li>\n<li>It binds all the <code>associated values</code> of the enum into the current\nscope, making it easy for us to use the data.</li>\n</ol>\n<h2>Where Clauses</h2>\n<p>However, with the power of <code>guard</code>, we can even simplify the example. Lo\nand behold:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">struct</span> FileUploadHandler: <span class=\"type\">NotificationListener</span> {\n\n   <span class=\"comment\">/// Implement the notification handling to move uploaded files to temporary folder</span>\n\n   <span class=\"keyword\">func</span> handleNotification(notification: <span class=\"type\">Notification</span>) {\n\n     <span class=\"keyword\">guard case</span> .<span class=\"dotAccess\">fileUploaded</span>(<span class=\"keyword\">let</span> file, <span class=\"keyword\">let</span> location, <span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> user) = notification, \n\n           user == <span class=\"keyword\">self</span>.<span class=\"property\">currentUser</span>\n\n           <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     <span class=\"call\">moveFile</span>(file, atLocation: location)\n\n   }\n\n}\n\n\n</code></pre></code></pre>\n<p>Now, the code is even shorter as the <code>where</code> clause of the <code>guard</code>\nexpression does the correct matching for us.</p>\n<p>You can have multiple <code>where</code> clauses in your <code>guard</code> statement:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> Foundation\n\n\n\n<span class=\"keyword\">func</span> confirmPath(pathObject: <span class=\"type\">AnyObject</span>) -&gt; <span class=\"type\">Bool</span> {\n\n   <span class=\"keyword\">guard let</span> url = pathObject <span class=\"keyword\">as</span>? <span class=\"type\">URL</span>,\n\n       <span class=\"keyword\">let</span> components = url.<span class=\"property\">pathComponents</span>, \n\n       components.<span class=\"property\">count</span> &gt; <span class=\"number\">0</span>,\n\n       <span class=\"keyword\">let</span> first = components.<span class=\"call\">dropFirst</span>().<span class=\"property\">first</span>, \n\n       first == \\<span class=\"string\">\"Applications</span>\\<span class=\"string\">\"</span>,\n\n       <span class=\"keyword\">let</span> last = components.<span class=\"property\">last</span>, \n\n       last == \\<span class=\"string\">\"MyApp</span>.<span class=\"property\">app</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">else</span> { <span class=\"keyword\">return false</span> }\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"valid</span> folder\\<span class=\"string\">\"</span>, last)\n\n   <span class=\"keyword\">return true</span>\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">confirmPath</span>(pathObject: <span class=\"type\">URL</span>(fileURLWithPath: \\<span class=\"string\">\"</span>/<span class=\"type\">Applications</span>/<span class=\"type\">MyApp</span>.<span class=\"property\">app</span>\\<span class=\"string\">\"</span>)))\n</code></pre></code></pre>\n<p>As you can see here, we're combining multiple <code>let</code> bindings with\nrelated <code>where</code> clauses which makes it easy to handle all the\npreconditions in one bigger guard statement instead of having to break\nit up into multiple singular statements.</p>\n<h2>Nested Enums</h2>\n<p>The above even works for nested enums. This may sound like a far-fetched\nexample, but I do actually have a project where I'm using a nested\nenum. In this example, we have a list of different items in the sidebar\nof an Instagram client. Those can be headlines, seperators, or folders:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> SidebarEntry {\n\n   <span class=\"keyword\">case</span> headline(<span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> item(<span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> seperator\n\n}\n</code></pre></code></pre>\n<p>A sidebar could be defined by an array like this:</p>\n<pre class=\"Swift\"><code>[.<span class=\"call\">headline</span>(\\<span class=\"string\">\"Global</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"call\">item</span>(\\<span class=\"string\">\"Dashboard</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"call\">item</span>(\\<span class=\"string\">\"Popular</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"dotAccess\">seperator</span>,\n\n  .<span class=\"call\">headline</span>(\\<span class=\"string\">\"Me</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"call\">item</span>(\\<span class=\"string\">\"Pictures</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"dotAccess\">seperator</span>,\n\n  .<span class=\"call\">headline</span>(\\<span class=\"string\">\"Folders</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"call\">item</span>(\\<span class=\"string\">\"Best</span> <span class=\"type\">Pics</span> <span class=\"number\">2013</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"call\">item</span>(\\<span class=\"string\">\"Wedding</span>\\<span class=\"string\">\"</span>)\n\n]\n</code></pre></code></pre>\n<p>Here, each <code>Item</code> would have to have a different action: I.e. clicking\n&quot;Dashboard&quot; should do something different compared to clicking\n&quot;Pictures&quot;, or the &quot;Wedding&quot; folder. The solution I chose was to\nhave another, nested, enum within the <code>Item</code> enum:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Action {\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">popular</span>\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">dashboard</span>\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">pictures</span>\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">folder</span>(name: <span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"keyword\">enum</span> SidebarEntry {\n\n   <span class=\"keyword\">case</span> headline(<span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> item(name: <span class=\"type\">String</span>, action: <span class=\"type\">Action</span>)\n\n   <span class=\"keyword\">case</span> seperator\n\n}\n\n\n\n[.<span class=\"call\">headline</span>(\\<span class=\"string\">\"Global</span>\\<span class=\"string\">\"</span>),\n\n  .<span class=\"call\">item</span>(name: \\<span class=\"string\">\"Dashboard</span>\\<span class=\"string\">\"</span>, action: .<span class=\"dotAccess\">Dashboard</span>),\n\n  .<span class=\"call\">item</span>(name: \\<span class=\"string\">\"Popular</span>\\<span class=\"string\">\"</span>, action: .<span class=\"dotAccess\">Popular</span>),\n\n  .<span class=\"call\">item</span>(name: \\<span class=\"string\">\"Wedding</span>\\<span class=\"string\">\"</span>, action: .<span class=\"call\">Folder</span>(\\<span class=\"string\">\"fo</span>-wedding\\<span class=\"string\">\"</span>)]\n</code></pre></code></pre>\n<p>Now, if we want publish a folder (to the cloud) we'd like to really\nmake sure that we were called with a folder and not a headline or a\nPopular item:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> publishFolder(entry: <span class=\"type\">SidebarEntry</span>)  {\n\n   <span class=\"keyword\">guard case</span> .<span class=\"dotAccess\">Item</span>(<span class=\"keyword\">_</span>, .<span class=\"dotAccess\">folder</span>(<span class=\"keyword\">let</span> name)) = entry \n\n     <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n   <span class=\"type\">Folders</span>.<span class=\"call\">sharedFolders</span>().<span class=\"call\">byName</span>(name).<span class=\"call\">publish</span>()\n\n}\n</code></pre></code></pre>\n<p>This is a great way to model complex hierarchies but still be able to\nmatch even intricate, nested types.</p>\n<h1>One-Line Guard Return</h1>\n<p>This is a short one. When you end up in the <code>else</code> case, you may want to\nperform an action before you return:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> a = <span class=\"call\">b</span>() <span class=\"keyword\">else</span> {\n\n    <span class=\"call\">print</span>(\\<span class=\"string\">\"wrong</span> action\\<span class=\"string\">\"</span>)\n\n    <span class=\"keyword\">return</span>\n\n}\n\n<span class=\"comment\">// or</span>\n\n<span class=\"keyword\">guard let</span> a = <span class=\"call\">b</span>() <span class=\"keyword\">else</span> {\n\n    <span class=\"keyword\">self</span>.<span class=\"call\">completion</span>(items: <span class=\"keyword\">nil</span>, error: \\<span class=\"string\">\"Could</span> not\\<span class=\"string\">\"</span>)\n\n    <span class=\"keyword\">return</span>\n\n}\n</code></pre></code></pre>\n<p>As long as your command returns <code>void</code>, you can actually combine these\ninto one:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> a = <span class=\"call\">b</span>() <span class=\"keyword\">else</span> {<span class=\"keyword\">return</span> <span class=\"call\">print</span>(\\<span class=\"string\">\"wrong</span> action\\<span class=\"string\">\"</span>)}\n\n<span class=\"comment\">// or</span>\n\n<span class=\"keyword\">guard let</span> a = <span class=\"call\">b</span>() <span class=\"keyword\">else</span> {\n\n    <span class=\"keyword\">return self</span>.<span class=\"call\">completion</span>(items: <span class=\"keyword\">nil</span>, error: \\<span class=\"string\">\"Could</span> not\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>I find this much easier on the eyes and better to read. However, it may\nreduce readability in a complex project when another developer runs into\nthis and wonders what kind of type is being returned here.</p>\n<p>Alternatively, you can also use the semicolon in these cases<sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> a = <span class=\"call\">b</span>() <span class=\"keyword\">else</span> {\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"argh</span>\\<span class=\"string\">\"</span>); <span class=\"keyword\">return</span>\n\n}\n</code></pre></code></pre>\n<h1><code>try?</code> in guards</h1>\n<p>Finally, in cases where you'd need to perform a throwable function, and\nyou don't care about the error result, you can still happily use\n<code>guard</code> just by utilizing the <code>try?</code> syntax, which converts the result\nof your throwing call into an optional, depending on whether it worked\nor not:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> item = item,\n\n    result = <span class=\"keyword\">try</span>? item.<span class=\"call\">perform</span>()\n\n<span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"call\">print</span>(\\<span class=\"string\">\"Could</span> not perform\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<p>The neat thing about this is that it allows us to combine various Swift\nmechanics into one safe call to make sure that our code can safely\nproceed.</p>\n<h1>Wrapping Up</h1>\n<p>Everything combined into one long example. This also shows how you can\ncombine <code>case</code> and <code>let</code> in one <code>guard</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> messageids = overview.<span class=\"property\">headers</span>[\\<span class=\"string\">\"message</span>-id\\<span class=\"string\">\"</span>],\n\n     <span class=\"keyword\">let</span> messageid = messageids.<span class=\"property\">first</span>,\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">MessageId</span>(<span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> msgid) = messageid\n\n     <span class=\"keyword\">where</span> msgid == <span class=\"keyword\">self</span>.<span class=\"property\">originalMessageID</span>\n\n     <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"call\">print</span>(\\<span class=\"string\">\"Unknown</span> <span class=\"type\">Message</span>-<span class=\"type\">ID</span>:\\<span class=\"string\">\"</span>, overview) }\n</code></pre></code></pre>\n<p>That's it. For more detailed information, I recommend reading my much\nlarger articles on <a href=\"lnk::switch\">pattern matching</a> and <a href=\"lnk::enum\">enum</a>.</p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>After leaving Objective-C behind, you'll probably have to search\nyour keyboard to find the key for it again ;)</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"Three quick examples for how you can use guard to write shorter and simpler code\"\ntitle = \"Three tips for concise Swift using the Guard statement\"\ncreated = \"2016-03-29\"\npublished = true\nkeywords = [\"swift\", \"mac\", \"cocoa\", \"guard\", \"let\", \"enum\", \"pattern\", \"matching\", \"patterns\"]\nslug = \"2016-03-29-three-tips-for-clean-swift-code.html\"\ntags = [\"enum\", \"guard\", \"if let\"]\ncategory = [\"Swift Tricks\", \"All\"]\n\n[meta]\nswift_version = \"5.0\"\nfeature_image = \"https://appventure.me/img-content/2016-03-29-three-tips-for-clean-swift-code-feature-image.jpg\"\n---\n\nThis will be a shorter post compared to some of my previous ones, but I\nwanted to share three useful `guard` tips for structuring your functions\nin such a way that you end up with code that is more concise and also\neasier to understand. This is **not** a post about general coding\nstyles or coding guidelines, but more about how `guard` can help you\nsimplify your code.\n\n# Binding and Condition Combination\n\n## Nesting\n\nThe first example concerns the use of pattern matching in order to\nlet bind variables into the current scope. One thing I really like\nabout this syntax (compared to, say `if let`) is that it keeps a golden\ncode path, **guarding** you from the all-too common **skyscraper of\ndeath**. Compare:\n\n``` Swift\n// Lots of nonsensical code to show how nested code structures look confusing\nif let a = a() {\n  let x = b(a)\n  x.fn()\n  if let u = x.nxt() {\n    let ux = u.brm()\n    if let uxt = ux.nxt() {\n       perform(uxt)\n    }\n  }\n}\n```\n\nwith:\n\n``` Swift\nguard let a = a() else { return }\nlet x = b(a)\nx.fn()\nguard let u = x.nxt() else { return }\nlet ux = u.brm()\nguard let uxt = ux.nxt() else { return }\n\nperform(uxt)\n```\n\nNow these are awful examples of how not to structure an internal API,\nbut they exist more to drive a point home. `Guard` is great because it\nbinds the result into the current scope instead of the nested scope. In\nlarger functions, this makes all the difference between having huge,\ndifficult-to-grasp deeply-nested functions and clean versions which look\nalmost like lists of commands.\n\n## Pattern Binding\n\nThe above works even better, if your input is an `enum`. Consider how\nwe\\'re handling the following usecase:\n\n``` Swift\nprotocol NotificationListener {\n  func handleNotification(notification: Notification)\n}\nenum Notification {\n  case userLoggedIn(user: String, date: NSDate, domain: String)\n  case fileUploaded(file: String, location: String, size: Int, user: String)\n}\n\nstruct FileUploadHandler: NotificationListener {\n  /// Implement the notification handling to move uploaded files to temporary folder\n  func handleNotification(notification: Notification) {\n    guard case .fileUploaded(let file, let location, _, let user) = notification\n    else { return }\n\n    if user == self.currentUser {\n       self.moveFile(file, atLocation: location)\n    }\n  }\n}\n```\n\nThe binding in the `guard case` line achieves two things for us:\n\n1.  It makes sure `handleNotifications` only works for `fileUploaded`\n    notifications, and not for `userLoggedIn` notifications.\n2.  It binds all the `associated values` of the enum into the current\n    scope, making it easy for us to use the data.\n\n## Where Clauses\n\nHowever, with the power of `guard`, we can even simplify the example. Lo\nand behold:\n\n``` Swift\n\nstruct FileUploadHandler: NotificationListener {\n  /// Implement the notification handling to move uploaded files to temporary folder\n  func handleNotification(notification: Notification) {\n    guard case .fileUploaded(let file, let location, _, let user) = notification, \n          user == self.currentUser\n          else { return }\n    moveFile(file, atLocation: location)\n  }\n}\n\n```\n\nNow, the code is even shorter as the `where` clause of the `guard`\nexpression does the correct matching for us.\n\nYou can have multiple `where` clauses in your `guard` statement:\n\n``` Swift\nimport Foundation\n\nfunc confirmPath(pathObject: AnyObject) -> Bool {\n  guard let url = pathObject as? URL,\n      let components = url.pathComponents, \n      components.count > 0,\n      let first = components.dropFirst().first, \n      first == \"Applications\",\n      let last = components.last, \n      last == \"MyApp.app\"\n  else { return false }\n  print(\"valid folder\", last)\n  return true\n}\nprint(confirmPath(pathObject: URL(fileURLWithPath: \"/Applications/MyApp.app\")))\n```\n\nAs you can see here, we\\'re combining multiple `let` bindings with\nrelated `where` clauses which makes it easy to handle all the\npreconditions in one bigger guard statement instead of having to break\nit up into multiple singular statements.\n\n## Nested Enums\n\nThe above even works for nested enums. This may sound like a far-fetched\nexample, but I do actually have a project where I\\'m using a nested\nenum. In this example, we have a list of different items in the sidebar\nof an Instagram client. Those can be headlines, seperators, or folders:\n\n``` Swift\nenum SidebarEntry {\n  case headline(String)\n  case item(String)\n  case seperator\n}\n```\n\nA sidebar could be defined by an array like this:\n\n``` Swift\n[.headline(\"Global\"),\n .item(\"Dashboard\"),\n .item(\"Popular\"),\n .seperator,\n .headline(\"Me\"),\n .item(\"Pictures\"),\n .seperator,\n .headline(\"Folders\"),\n .item(\"Best Pics 2013\"),\n .item(\"Wedding\")\n]\n```\n\nHere, each `Item` would have to have a different action: I.e. clicking\n\\\"Dashboard\\\" should do something different compared to clicking\n\\\"Pictures\\\", or the \\\"Wedding\\\" folder. The solution I chose was to\nhave another, nested, enum within the `Item` enum:\n\n``` Swift\nenum Action {\n  case .popular\n  case .dashboard\n  case .pictures\n  case .folder(name: String)\n}\n\nenum SidebarEntry {\n  case headline(String)\n  case item(name: String, action: Action)\n  case seperator\n}\n\n[.headline(\"Global\"),\n .item(name: \"Dashboard\", action: .Dashboard),\n .item(name: \"Popular\", action: .Popular),\n .item(name: \"Wedding\", action: .Folder(\"fo-wedding\")]\n```\n\nNow, if we want publish a folder (to the cloud) we\\'d like to really\nmake sure that we were called with a folder and not a headline or a\nPopular item:\n\n``` Swift\nfunc publishFolder(entry: SidebarEntry)  {\n  guard case .Item(_, .folder(let name)) = entry \n    else { return }\n  Folders.sharedFolders().byName(name).publish()\n}\n```\n\nThis is a great way to model complex hierarchies but still be able to\nmatch even intricate, nested types.\n\n# One-Line Guard Return\n\nThis is a short one. When you end up in the `else` case, you may want to\nperform an action before you return:\n\n``` Swift\nguard let a = b() else {\n   print(\"wrong action\")\n   return\n}\n// or\nguard let a = b() else {\n   self.completion(items: nil, error: \"Could not\")\n   return\n}\n```\n\nAs long as your command returns `void`, you can actually combine these\ninto one:\n\n``` Swift\nguard let a = b() else {return print(\"wrong action\")}\n// or\nguard let a = b() else {\n   return self.completion(items: nil, error: \"Could not\")\n}\n```\n\nI find this much easier on the eyes and better to read. However, it may\nreduce readability in a complex project when another developer runs into\nthis and wonders what kind of type is being returned here.\n\nAlternatively, you can also use the semicolon in these cases[^1]:\n\n``` Swift\nguard let a = b() else {\n  print(\"argh\"); return\n}\n```\n\n# `try?` in guards\n\nFinally, in cases where you\\'d need to perform a throwable function, and\nyou don\\'t care about the error result, you can still happily use\n`guard` just by utilizing the `try?` syntax, which converts the result\nof your throwing call into an optional, depending on whether it worked\nor not:\n\n``` Swift\nguard let item = item,\n   result = try? item.perform()\nelse { return print(\"Could not perform\") }\n```\n\nThe neat thing about this is that it allows us to combine various Swift\nmechanics into one safe call to make sure that our code can safely\nproceed.\n\n# Wrapping Up\n\nEverything combined into one long example. This also shows how you can\ncombine `case` and `let` in one `guard`.\n\n``` Swift\nguard let messageids = overview.headers[\"message-id\"],\n    let messageid = messageids.first,\n    case .MessageId(_, let msgid) = messageid\n    where msgid == self.originalMessageID\n    else { return print(\"Unknown Message-ID:\", overview) }\n```\n\nThat\\'s it. For more detailed information, I recommend reading my much\nlarger articles on [pattern matching](lnk::switch) and [enum](lnk::enum).\n\n\n[^1]: After leaving Objective-C behind, you\\'ll probably have to search\n    your keyboard to find the key for it again ;)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2018-05-03-expanding-swifts-reach.md":["3d16b19c8eb65115",{"identifier":"b944523d","filename":"2018-05-03-expanding-swifts-reach.md","info":{"title":"Expanding Swift's Reach","tags":[],"keywords":["swift","linux","server","opensource"],"category":["Blog","All"],"created":"2018-05-03 10:30:30","description":"How can we as a community help expanding the reach of Swift","description_html":"<p>How can we as a community help expanding the reach of Swift</p>\n","published":true,"slug":"2018-05-03-expanding-swifts-reach.html","meta":{"thumbnail":"/img-content/swifts_reach.png"},"created_timestamp":1525343430,"date":"2018-05-03T10:30:30","date_info":{"year":2018,"month":5,"day":3,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2018-05-03-expanding-swifts-reach.html","content":"<p>I guess we can all agree that Swift is a beautiful programming language\nthat manages to hit the sweet spot in terms of simplicity and\ncomplexity. It could theoretically become one of the major languages of\nthe future. Currently though, Swift's usage is more or less constrained\nto the Apple development domain (plus a few extensions such as\nserver-side Swift or the <a href=\"https://www.tensorflow.org/community/swift\">recently announced Swift for\nTensorflow</a>).</p>\n<blockquote>\n<p>My goal for Swift has always been and still is total world domination.\nIt's a modest goal</p>\n<ul>\n<li>Chris Lattner</li>\n</ul>\n</blockquote>\n<p><a href=\"https://swift.org/blog/swift-4-1-released/\">With Swift 4.1's new generic\nfeatures</a> and the upcoming\n<a href=\"https://swift.org/abi-stability/\">ABI stability in Swift 5</a>, it feels\nlike Swift slowly reaches a point that would allow it to move beyond the\nApple domain. In this post I'd like to discuss what I see as one of the\nissues holding it back from a broader adoption. Specifically, the one\nissue that can be solved by us as a community while most of the other\nissues are already being worked on.</p>\n<p>I'd also like have a brief look at Swift's <strong>competition</strong> in this\nspace. I.e. other languages that also aspire to become a general purpose\nlanguage for all the domains that C++ currently encompasses - and maybe\nmore <sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>. By observing their take on the issue we can see where Swift\nstands in comparison, and what we can do.</p>\n<h1>System Packages</h1>\n<p>Swift has a very healthy open source community with a good amount of\nfantastic, well-written, and useful packages. However, the nature of\nSwift's current primary domain constrained these packages almost\nexclusively to iOS (and much less, macOS) UI libraries. There're a\ndozen UI Animation libraries, UI layout libraries, UI element\nframeworks, UI helpers and, of course, JSON parsers. Most of those\npackages don't even run on Linux as there is no UIKit / AppKit. Of\ncourse, there are also several web frameworks like\n<a href=\"https://vapor.codes/\">Vapor</a> or <a href=\"http://kitura.io/\">Kitura</a>, and\nthey're doing a fantastic job of extending Swift's into the web\ndevelopment realm.</p>\n<p>However, contrary to popular opinion, companies do a lot more on Linux\nthan just running webservers. As we will see in a brief moment, other\nlanguages offer a lot of system management, administration, or general\ndevelopment tools and libraries that make no sense for iOS or macOS app\ndevelopment but are tremendously important for systems- or\nweb-development. I.e. databases and their administration, system file\nmanagement, process management and administration, log and analytics\ncollection, container administration, deployment tooling, or even\nblockchain tooling - just to name a few.</p>\n<p>In line with Swift's 4.1 release, <a href=\"https://news.ycombinator.com/item?id=16710895\">there was a thread on Hacker News\ndiscussing the language</a>.\nI've read the entire thread multiple times due to the fact that the\nanswers were really interesting. What stood out to me was <a href=\"https://news.ycombinator.com/item?id=16710895\">the following\ncomment</a>:</p>\n<blockquote>\n<p>The set of libraries and supported OSes is a tiny dot comparable with\nthe Go and Rust. ... If we start listing the kind of libraries used in\ndistributed applications, database backends, Swift has hardly none of\nthem.</p>\n</blockquote>\n<p>So lets have a look at the others.</p>\n<h1>Competitors</h1>\n<p>The field of programming language development has seen a lot of new\ncompetitors over the last couple of years. Naturally, we (that is, you\ndear reader, and me) will probably not agree on which of these languages\nwe do or don't consider as true competition for Swift. That is,\nhere're - in no particular order - my personal picks based on gut\nfeelings.</p>\n<p>Also, the opinions below are loosely held. So if you're a fan of any of\nthe languages I'm about to mention and my description feels wrong to\nyou and you're burning with a desire for venegance and about to grab\nyour pitchfork and head to Twitter.. please don't, I'm just a normal\nguy with a loosely held opinion who most certainly is wrong about a lot\nof things. Instead, use this energy to pursue the question of how it\ncame to be that I'm misinformed on this particular topic and try to\nhelp to improve on that front.</p>\n<h2>Go</h2>\n<p>Go has been available much longer than Swift, enjoys strong usage in the\nrealm of system tools, is hardly used for GUI applications, doesn't\nprovide more modern language features such as tagged unions, generics,\nor functional programming constructs. It is easy to learn, fast, uses a\nGarbage Collector and the resulting binaries are lightweight in terms of\nmemory. The garbage collector make it somewhat tricky to use Go for\nembedded development or even Webassembly.</p>\n<p>The good performance, simplicity of the language and low memory\nfootprint lead to the development of a lot of system tools &amp; libraries,\nsuch as: Grafana, Kubernetes, CoreOS-etcd, Go-Ethereum, CockroachDB,\nHub, Terraform and many, many others. Have a look at this <a href=\"https://github.com/avelino/awesome-go\">list just to\nobserve how many libraries there are for any use case possibly\nimaginable</a>.</p>\n<p>In short, if you want to develop anything system-based, almost all\npackages you might need as dependencies are readily available.</p>\n<h2>Kotlin</h2>\n<p>Kotlin, basically the Swift for Android is a language that feels and\nlooks a lot like Swift but is - under the hood - quite different. The\nJVM foundation of Kotlin forces it to utilize a much stronger usage of\nreference types vs. value types. Like Go, the Garbage Collector makes\nembedded &amp; systems development a challenge, however <a href=\"https://kotlinlang.org/docs/reference/native-overview.html\">there is\nKotlin-Native which will make this more feasible in the\nfuture.</a> It\nbuilds with LLVM, supports embedded platforms, Webassembly, and much\nmore. Kotlin can also be compiled to Javascript, and Kotlin-Native even\nallows buliding Frameworks for iOS apps.</p>\n<p>Kotlin could also become a big language in the future but is currently\nheld back by the same mechanics that are also holding back Swift: Almost\nall available open source libraries are primarily for Android\ndevelopment (i.e. UI, etc). While Kotlin native solves the issues that a\npure JVM language would have, I have no idea how performant and\nlightweight Kotlin native could actually become (i.e. Compared to C++ or\nSwift, especially for things like embedded development, complex systems\ndevelopment, or Webassembly).</p>\n<h2>Rust</h2>\n<p>Rust is an interesting language. Actually so interesting that I spend\nthe last couple of months slowly learning it. In many ways it is very\nsimilar to Swift - but harder (but this is a topic for a future blog\npost). it feels like the two languages started out diametrically opposed\nfrom each other: Swift started out as an (mostly) easy to learn language\nwith a easy-to-grasp feature set which is slowly adding more complex\nfeatures. Rust started out as a complex language which is slowly adding\nsimpler abstractions or better error messages to make it more\napproachable for beginners. Given that both languages have a very\nsimilar syntax it wouldn't surprise me when, at some point in the\nfuture, both languages converge to a point of high similarity in terms\nof features and simplicity / complexity. However, currently, Rust offers\na couple of very attractive features hidden behind a more complex\nlearning experience:</p>\n<p>A much better cross-platform story, a hard but rewarding memory\nmanagement story (i.e. lifetimes / ownership) <a href=\"https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md\">that is thankfully also\npartially coming to Swift in the\nfuture</a>,\nsupport for\n<a href=\"https://rust-lang-nursery.github.io/rust-wasm/\">Webassembly</a> (i.e. you\ncan write frontend apps in Rust), and the beginnings of a really good\nfoundation of packages to allow users to quickly get started on new\nprojects. While it does not offer the same amount of high-profile\nprojects like Go, there're already a couple of promising projects\n(CoreUtils, RedoxOS, TikV, Vagga, Servo, Parity), but more importantly,\nthere are many libraries for interaction with third party dependencies.\n<a href=\"https://github.com/rust-unofficial/awesome-rust\">Have a look at this\nlist.</a></p>\n<h2>Others</h2>\n<p>There're also D, Nim, Chrystal, Elixir, TypeScript, and obviously C++\nitself but this post is already long enough as it is.</p>\n<h1>What can we see</h1>\n<p>Swift currently falls short in the area of system packages. This is also\na chicken-egg problem:</p>\n<blockquote>\n<p>As long as there are not enough system packages, an interested\ndeveloper will try out Swift, but will not find a package for his\nfavorite database. Not interested in porting a database package just\nfor the sake of writing a simple example app, he will back off and\nnever start to enjoy the language enough to start submitting his own\nsystem packages.</p>\n</blockquote>\n<p>To me it feels like we need to improve our system package / library\ngame. It would certainly be nice if we had something like Kubernetes\nwritten in Swift, but in order for such a project to emerge, we need a\ngood set of base libraries that are useful for general systems\ndevelopment. Libraries for tasks or third party services in the\nfollowing domains (also, some of those domains may have packages\nalready, but that doesn't mean we need more):</p>\n<ul>\n<li>Authentication</li>\n<li>Caching</li>\n<li>Concurrency</li>\n<li>Cloud Providers</li>\n<li>Command Line Argument Parsing</li>\n<li>Command Line UI</li>\n<li>Command Line Editors</li>\n<li>Compression</li>\n<li>Computations (i.e. BLAS)</li>\n<li>Cryptography</li>\n<li>Databases</li>\n<li>Data Processing</li>\n<li>Data Structures</li>\n<li>Data Visualization</li>\n<li>Date and Time</li>\n<li>Distributed Systems</li>\n<li>Email</li>\n<li>Encoding &amp; Decoding</li>\n<li>Filesystems</li>\n<li>Image Processing</li>\n<li>Machine Learning</li>\n<li>Parsing</li>\n<li>Text Processing</li>\n<li>Virtualization</li>\n</ul>\n<p>In order to become a valid general purpose language on Non-Apple\noperating systems, I think, Swift needs to offer a healthy ecosystem of\nuseful system packages on all platforms.</p>\n<h1>So, what can you do</h1>\n<h2>Write libraries</h2>\n<p>Before you decide to write the 150th JSON parser, Animation library,\ncustom switch button, or collection view / table view abstraction,\nconsider writing a fully working cross platform system library. If you\ncan't come up with an idea head over to Rust or Go and see what they\nhave to offer.</p>\n<h2>Rewrite Existing C libraries</h2>\n<p>For certain use cases, Swift does offer libraries but only via a small\nshism to an underlying C implementation. While that does get the job\ndone, it introduces a very unsafe language into the mix, something we\nshould only need to do in use cases where performance is absolutely\ncritical. So, if you can't think of anything you'd want to write,\nmaybe write a pure-swift implementation of something you already use.\nThat's also a great opportunity for learning more C and in turn loving\nSwift even more ;-)</p>\n<h2>Care about Linux</h2>\n<p>I recently wrote a small application in Vapor and for that I needed a\ncouple of additional dependencies (i.e. for time calculations) and\nalmost all existing libraries were iOS / macOS only. If you already work\non something that could be cross platform (due to no UIKit / AppKit\ndependencies) try to go the extra step of testing it on Swift Linux.</p>\n<p>This might also be easier than it sounds. <a href=\"https://hub.docker.com/r/ibmcom/swift-ubuntu/tags/\">There's a readily-available\ndocker image for Swift\n4.1</a>, so you can\njust run that in order to test your code.<sup class=\"footnote-reference\"><a href=\"#2\">2</a></sup>. Alternatively, you can\nrun <a href=\"https://www.virtualbox.org/\">Virtualbox</a> if you'd rather have a\nfull running VM.</p>\n<h2>Support Swift Package Manager</h2>\n<p>If you have a library already, try to always support the Swift Package\nManager in addition to CocoaPods and Carthage.</p>\n<h2>Work on Foundation</h2>\n<p>Another thing that is still difficult is that Swift for Linux's\n<a href=\"https://github.com/apple/swift-corelibs-foundation\">Foundation library</a>\nis a re-implementation of iOS/macOS foundation and therefore still has\nunimplemented features and (especially tricky) bugs. This means that\ncode you write on your Mac in Xcode might run great, but it will crash\non Linux because of a Linux-Only foundation bug. Making Foundation for\nLinux better is another great task to work on in order to improve\nSwift's reach.</p>\n<p>The easiest starter for this is to head over to the <a href=\"https://bugs.swift.org/secure/Dashboard.jspa\">Swift\nJira</a> and search for\nFoundation bugs.</p>\n<h2>Help out Foundation</h2>\n<p>If you don't have the time or are not interested in working on Swift\nFoundation, you can still help out by using it / testing it on Linux and\nsubmitting bug reports. The more people use it, the more stable it will\nbecome.</p>\n<h2>Help the Linux editing experience</h2>\n<p>Linux users won't have Xcode, so they'll be using Atom or Emacs or Vim\nor VSCode. There're already multiple projects that offer Swift support\nfor these editors, but it feels like we can also improve on this front.\nIf you have some cycles to spare, play around with these projects and\nyour favorite non-Xcode editor, see if things work as expected,\notherwise create issues or (even better!) try to actively fix them ;)</p>\n<h2>Try Swift in San Jose</h2>\n<p>If you happen to be in San Jose during this years WWDC, there's a great\nopportunity for you to learn something, meet interesting people, and\nhelp out Swift: <a href=\"https://www.tryswift.co/events/2018/sanjose/\">The Try Swift San\nJose</a>.</p>\n<blockquote>\n<p>...your chance to contribute to Swift. Join a panel of Swift Open\nSource contributors for a discussion about the latest news on the\nSwift open source project, then contribute to Swift Evolution yourself\nwith the help of community mentors!</p>\n</blockquote>\n<p><a href=\"https://www.tryswift.co/events/2018/sanjose/\">Check it out</a>.</p>\n<h1>I should be doing this</h1>\n<p>I haven't had much time to do any open source work in the past 1.5\nyears because I was busy working on <a href=\"https://photodesk-app.com\">my own (closed source)\nproject</a>, but I really want to work on open\nsource Swift code again. I really like Swift, it is a great language,\nand helping it to (hopefully) succeed feels like the best pasttime to\nhave. If you feel the same, feel free to share this article.</p>\n<p><a href=\"https://twitter.com/terhechte\">Also, for any discussion on this article, head to\nTwitter.</a></p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>I.e. WebAssembly</p>\n</div>\n<div class=\"footnote-definition\" id=\"2\"><sup class=\"footnote-definition-label\">2</sup>\n<p>I'm trying to write another blog post that explains this in much\nmore detail</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"How can we as a community help expanding the reach of Swift\"\ntitle = \"Expanding Swift's Reach\"\ncreated = \"2018-05-03\"\npublished = true\nkeywords = [\"swift\", \"linux\", \"server\", \"opensource\"]\nslug = \"2018-05-03-expanding-swifts-reach.html\"\ntags = []\ncategory = [\"Blog\", \"All\"]\n[meta]\nthumbnail = \"/img-content/swifts_reach.png\"\n---\n\nI guess we can all agree that Swift is a beautiful programming language\nthat manages to hit the sweet spot in terms of simplicity and\ncomplexity. It could theoretically become one of the major languages of\nthe future. Currently though, Swift\\'s usage is more or less constrained\nto the Apple development domain (plus a few extensions such as\nserver-side Swift or the [recently announced Swift for\nTensorflow](https://www.tensorflow.org/community/swift)).\n\n> My goal for Swift has always been and still is total world domination.\n> It's a modest goal\n>\n> -   Chris Lattner\n\n[With Swift 4.1\\'s new generic\nfeatures](https://swift.org/blog/swift-4-1-released/) and the upcoming\n[ABI stability in Swift 5](https://swift.org/abi-stability/), it feels\nlike Swift slowly reaches a point that would allow it to move beyond the\nApple domain. In this post I\\'d like to discuss what I see as one of the\nissues holding it back from a broader adoption. Specifically, the one\nissue that can be solved by us as a community while most of the other\nissues are already being worked on.\n\nI\\'d also like have a brief look at Swift\\'s **competition** in this\nspace. I.e. other languages that also aspire to become a general purpose\nlanguage for all the domains that C++ currently encompasses - and maybe\nmore [^1]. By observing their take on the issue we can see where Swift\nstands in comparison, and what we can do.\n\n# System Packages\n\nSwift has a very healthy open source community with a good amount of\nfantastic, well-written, and useful packages. However, the nature of\nSwift\\'s current primary domain constrained these packages almost\nexclusively to iOS (and much less, macOS) UI libraries. There\\'re a\ndozen UI Animation libraries, UI layout libraries, UI element\nframeworks, UI helpers and, of course, JSON parsers. Most of those\npackages don\\'t even run on Linux as there is no UIKit / AppKit. Of\ncourse, there are also several web frameworks like\n[Vapor](https://vapor.codes/) or [Kitura](http://kitura.io/), and\nthey\\'re doing a fantastic job of extending Swift\\'s into the web\ndevelopment realm.\n\nHowever, contrary to popular opinion, companies do a lot more on Linux\nthan just running webservers. As we will see in a brief moment, other\nlanguages offer a lot of system management, administration, or general\ndevelopment tools and libraries that make no sense for iOS or macOS app\ndevelopment but are tremendously important for systems- or\nweb-development. I.e. databases and their administration, system file\nmanagement, process management and administration, log and analytics\ncollection, container administration, deployment tooling, or even\nblockchain tooling - just to name a few.\n\nIn line with Swift\\'s 4.1 release, [there was a thread on Hacker News\ndiscussing the language](https://news.ycombinator.com/item?id=16710895).\nI\\'ve read the entire thread multiple times due to the fact that the\nanswers were really interesting. What stood out to me was [the following\ncomment](https://news.ycombinator.com/item?id=16710895):\n\n> The set of libraries and supported OSes is a tiny dot comparable with\n> the Go and Rust. ... If we start listing the kind of libraries used in\n> distributed applications, database backends, Swift has hardly none of\n> them.\n\nSo lets have a look at the others.\n\n# Competitors\n\nThe field of programming language development has seen a lot of new\ncompetitors over the last couple of years. Naturally, we (that is, you\ndear reader, and me) will probably not agree on which of these languages\nwe do or don\\'t consider as true competition for Swift. That is,\nhere\\'re - in no particular order - my personal picks based on gut\nfeelings.\n\nAlso, the opinions below are loosely held. So if you\\'re a fan of any of\nthe languages I\\'m about to mention and my description feels wrong to\nyou and you\\'re burning with a desire for venegance and about to grab\nyour pitchfork and head to Twitter.. please don\\'t, I\\'m just a normal\nguy with a loosely held opinion who most certainly is wrong about a lot\nof things. Instead, use this energy to pursue the question of how it\ncame to be that I\\'m misinformed on this particular topic and try to\nhelp to improve on that front.\n\nGo\n--\n\nGo has been available much longer than Swift, enjoys strong usage in the\nrealm of system tools, is hardly used for GUI applications, doesn\\'t\nprovide more modern language features such as tagged unions, generics,\nor functional programming constructs. It is easy to learn, fast, uses a\nGarbage Collector and the resulting binaries are lightweight in terms of\nmemory. The garbage collector make it somewhat tricky to use Go for\nembedded development or even Webassembly.\n\nThe good performance, simplicity of the language and low memory\nfootprint lead to the development of a lot of system tools & libraries,\nsuch as: Grafana, Kubernetes, CoreOS-etcd, Go-Ethereum, CockroachDB,\nHub, Terraform and many, many others. Have a look at this [list just to\nobserve how many libraries there are for any use case possibly\nimaginable](https://github.com/avelino/awesome-go).\n\nIn short, if you want to develop anything system-based, almost all\npackages you might need as dependencies are readily available.\n\n## Kotlin\n\nKotlin, basically the Swift for Android is a language that feels and\nlooks a lot like Swift but is - under the hood - quite different. The\nJVM foundation of Kotlin forces it to utilize a much stronger usage of\nreference types vs. value types. Like Go, the Garbage Collector makes\nembedded & systems development a challenge, however [there is\nKotlin-Native which will make this more feasible in the\nfuture.](https://kotlinlang.org/docs/reference/native-overview.html) It\nbuilds with LLVM, supports embedded platforms, Webassembly, and much\nmore. Kotlin can also be compiled to Javascript, and Kotlin-Native even\nallows buliding Frameworks for iOS apps.\n\nKotlin could also become a big language in the future but is currently\nheld back by the same mechanics that are also holding back Swift: Almost\nall available open source libraries are primarily for Android\ndevelopment (i.e. UI, etc). While Kotlin native solves the issues that a\npure JVM language would have, I have no idea how performant and\nlightweight Kotlin native could actually become (i.e. Compared to C++ or\nSwift, especially for things like embedded development, complex systems\ndevelopment, or Webassembly).\n\n## Rust\n\nRust is an interesting language. Actually so interesting that I spend\nthe last couple of months slowly learning it. In many ways it is very\nsimilar to Swift - but harder (but this is a topic for a future blog\npost). it feels like the two languages started out diametrically opposed\nfrom each other: Swift started out as an (mostly) easy to learn language\nwith a easy-to-grasp feature set which is slowly adding more complex\nfeatures. Rust started out as a complex language which is slowly adding\nsimpler abstractions or better error messages to make it more\napproachable for beginners. Given that both languages have a very\nsimilar syntax it wouldn\\'t surprise me when, at some point in the\nfuture, both languages converge to a point of high similarity in terms\nof features and simplicity / complexity. However, currently, Rust offers\na couple of very attractive features hidden behind a more complex\nlearning experience:\n\nA much better cross-platform story, a hard but rewarding memory\nmanagement story (i.e. lifetimes / ownership) [that is thankfully also\npartially coming to Swift in the\nfuture](https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md),\nsupport for\n[Webassembly](https://rust-lang-nursery.github.io/rust-wasm/) (i.e. you\ncan write frontend apps in Rust), and the beginnings of a really good\nfoundation of packages to allow users to quickly get started on new\nprojects. While it does not offer the same amount of high-profile\nprojects like Go, there\\'re already a couple of promising projects\n(CoreUtils, RedoxOS, TikV, Vagga, Servo, Parity), but more importantly,\nthere are many libraries for interaction with third party dependencies.\n[Have a look at this\nlist.](https://github.com/rust-unofficial/awesome-rust)\n\n## Others\n\nThere\\'re also D, Nim, Chrystal, Elixir, TypeScript, and obviously C++\nitself but this post is already long enough as it is.\n\n# What can we see\n\nSwift currently falls short in the area of system packages. This is also\na chicken-egg problem:\n\n> As long as there are not enough system packages, an interested\n> developer will try out Swift, but will not find a package for his\n> favorite database. Not interested in porting a database package just\n> for the sake of writing a simple example app, he will back off and\n> never start to enjoy the language enough to start submitting his own\n> system packages.\n\nTo me it feels like we need to improve our system package / library\ngame. It would certainly be nice if we had something like Kubernetes\nwritten in Swift, but in order for such a project to emerge, we need a\ngood set of base libraries that are useful for general systems\ndevelopment. Libraries for tasks or third party services in the\nfollowing domains (also, some of those domains may have packages\nalready, but that doesn\\'t mean we need more):\n\n-   Authentication\n-   Caching\n-   Concurrency\n-   Cloud Providers\n-   Command Line Argument Parsing\n-   Command Line UI\n-   Command Line Editors\n-   Compression\n-   Computations (i.e. BLAS)\n-   Cryptography\n-   Databases\n-   Data Processing\n-   Data Structures\n-   Data Visualization\n-   Date and Time\n-   Distributed Systems\n-   Email\n-   Encoding & Decoding\n-   Filesystems\n-   Image Processing\n-   Machine Learning\n-   Parsing\n-   Text Processing\n-   Virtualization\n\nIn order to become a valid general purpose language on Non-Apple\noperating systems, I think, Swift needs to offer a healthy ecosystem of\nuseful system packages on all platforms.\n\n# So, what can you do\n\n## Write libraries\n\nBefore you decide to write the 150th JSON parser, Animation library,\ncustom switch button, or collection view / table view abstraction,\nconsider writing a fully working cross platform system library. If you\ncan\\'t come up with an idea head over to Rust or Go and see what they\nhave to offer.\n\n## Rewrite Existing C libraries\n\nFor certain use cases, Swift does offer libraries but only via a small\nshism to an underlying C implementation. While that does get the job\ndone, it introduces a very unsafe language into the mix, something we\nshould only need to do in use cases where performance is absolutely\ncritical. So, if you can\\'t think of anything you\\'d want to write,\nmaybe write a pure-swift implementation of something you already use.\nThat\\'s also a great opportunity for learning more C and in turn loving\nSwift even more ;-)\n\n## Care about Linux\n\nI recently wrote a small application in Vapor and for that I needed a\ncouple of additional dependencies (i.e. for time calculations) and\nalmost all existing libraries were iOS / macOS only. If you already work\non something that could be cross platform (due to no UIKit / AppKit\ndependencies) try to go the extra step of testing it on Swift Linux.\n\nThis might also be easier than it sounds. [There\\'s a readily-available\ndocker image for Swift\n4.1](https://hub.docker.com/r/ibmcom/swift-ubuntu/tags/), so you can\njust run that in order to test your code.[^2]. Alternatively, you can\nrun [Virtualbox](https://www.virtualbox.org/) if you\\'d rather have a\nfull running VM.\n\n## Support Swift Package Manager\n\nIf you have a library already, try to always support the Swift Package\nManager in addition to CocoaPods and Carthage.\n\n## Work on Foundation\n\nAnother thing that is still difficult is that Swift for Linux\\'s\n[Foundation library](https://github.com/apple/swift-corelibs-foundation)\nis a re-implementation of iOS/macOS foundation and therefore still has\nunimplemented features and (especially tricky) bugs. This means that\ncode you write on your Mac in Xcode might run great, but it will crash\non Linux because of a Linux-Only foundation bug. Making Foundation for\nLinux better is another great task to work on in order to improve\nSwift\\'s reach.\n\nThe easiest starter for this is to head over to the [Swift\nJira](https://bugs.swift.org/secure/Dashboard.jspa) and search for\nFoundation bugs.\n\n## Help out Foundation\n\nIf you don\\'t have the time or are not interested in working on Swift\nFoundation, you can still help out by using it / testing it on Linux and\nsubmitting bug reports. The more people use it, the more stable it will\nbecome.\n\n## Help the Linux editing experience\n\nLinux users won\\'t have Xcode, so they\\'ll be using Atom or Emacs or Vim\nor VSCode. There\\'re already multiple projects that offer Swift support\nfor these editors, but it feels like we can also improve on this front.\nIf you have some cycles to spare, play around with these projects and\nyour favorite non-Xcode editor, see if things work as expected,\notherwise create issues or (even better!) try to actively fix them ;)\n\n## Try Swift in San Jose\n\nIf you happen to be in San Jose during this years WWDC, there\\'s a great\nopportunity for you to learn something, meet interesting people, and\nhelp out Swift: [The Try Swift San\nJose](https://www.tryswift.co/events/2018/sanjose/).\n\n> ...your chance to contribute to Swift. Join a panel of Swift Open\n> Source contributors for a discussion about the latest news on the\n> Swift open source project, then contribute to Swift Evolution yourself\n> with the help of community mentors!\n\n[Check it out](https://www.tryswift.co/events/2018/sanjose/).\n\n# I should be doing this\n\nI haven\\'t had much time to do any open source work in the past 1.5\nyears because I was busy working on [my own (closed source)\nproject](https://photodesk-app.com), but I really want to work on open\nsource Swift code again. I really like Swift, it is a great language,\nand helping it to (hopefully) succeed feels like the best pasttime to\nhave. If you feel the same, feel free to share this article.\n\n[Also, for any discussion on this article, head to\nTwitter.](https://twitter.com/terhechte)\n\n[^1]: I.e. WebAssembly\n\n[^2]: I\\'m trying to write another blog post that explains this in much\n    more detail\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/dark_mode_icons.md":["8729683a8536511a",{"identifier":"778b7629","filename":"dark_mode_icons.md","info":{"title":"How do I support macOS icons?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-support-macos-icons.html","content":"<p>Fortunately, each icon in the assets catalog (you're using assets catalogs, are you?) supports different varieties, including macOS. If you enable the &quot;Mac&quot; setting for any icon, additional slots will appear where you can add macOS specific icons to your asset. Catalyst will then automatically choose the right icons. This is what that looks like:</p>\n<p><img src=\"/img-content/catalyst/mac_icon_assets.png\" alt=\"\" /></p>\n<h2>General Icons</h2>\n<p>You could just use your general iOS icons on the Mac, but keep the following things in mind:</p>\n<ul>\n<li>iOS icons are scaled down 77% on macOS / Catalyst. This can add artifacts</li>\n<li>Many Macs still have non-retina displays (i.e. the Macbook Air 13&quot; is still non-retina and still being sold)</li>\n<li>If you don't have @1x variants of your icons, Catalyst will scale down the @2x variants, creating additional artifacts</li>\n<li>Icons might not look as good anymore in a scaled down manner. You might want to include separate macOS icons for some use cases</li>\n</ul>\n<h2>The App Icon</h2>\n<p>For a proper macOS app icon, the following sizes are needed:</p>\n<ul>\n<li>16pt, 16pt @ 2x</li>\n<li>32pt, 32pt @ 2x</li>\n<li>128pt, 128pt @ 2x</li>\n<li>256pt, 256pt @ 2x</li>\n<li>512pt, 512pt @ 2x</li>\n</ul>\n<p>That's 10 icons. However, if you don't care about the ability to add additional detail for retina variants, then you just need the following sizes - as some of those sizes overlap: 16, 32, 64, 128, 256, 512, 1024</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I support macOS icons?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nFortunately, each icon in the assets catalog (you're using assets catalogs, are you?) supports different varieties, including macOS. If you enable the \"Mac\" setting for any icon, additional slots will appear where you can add macOS specific icons to your asset. Catalyst will then automatically choose the right icons. This is what that looks like:\n\n![](/img-content/catalyst/mac_icon_assets.png)\n\n## General Icons\n\nYou could just use your general iOS icons on the Mac, but keep the following things in mind:\n- iOS icons are scaled down 77% on macOS / Catalyst. This can add artifacts\n- Many Macs still have non-retina displays (i.e. the Macbook Air 13\" is still non-retina and still being sold)\n- If you don't have @1x variants of your icons, Catalyst will scale down the @2x variants, creating additional artifacts\n- Icons might not look as good anymore in a scaled down manner. You might want to include separate macOS icons for some use cases\n\n\n## The App Icon\n\nFor a proper macOS app icon, the following sizes are needed:\n- 16pt, 16pt @ 2x\n- 32pt, 32pt @ 2x\n- 128pt, 128pt @ 2x\n- 256pt, 256pt @ 2x\n- 512pt, 512pt @ 2x\n\nThat's 10 icons. However, if you don't care about the ability to add additional detail for retina variants, then you just need the following sizes - as some of those sizes overlap: 16, 32, 64, 128, 256, 512, 1024\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/example/performance.md":["1ae4eb8b602d6bcf",{"identifier":"6f3dfaf0","filename":"performance.md","info":{"title":"Performance","tags":["reflection","performance"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-performance.html","content":"<h1>Performance</h1>\n<p>So we just wrote some code that converts <code>struct</code> types via <code>reflection</code> at runtime to <code>Core Data</code> types.\nHow fast is this? Can this be used well in production? I did some testing:</p>\n<style type=\"text/css\">\n  .linechart {\n      border: 3px solid white;\n      border-radius: 32px;\n      font-family: Sans-Serif;\n      color: white;\n      font-weight: normal;\n      padding: 4px;\n      margin-bottom: 20px;\n  }\n  .redxx {\n      background-color: red;\n  }\n  .greenxx {\n      background-color: green;\n  }\n  .linechart > span {\n      padding: 4px;\n  }\n  h3.ggx {\n      font-family: Sans-Serif;\nfont-weight: normal;\n  }\n  .orangexx {\n      background-color: orange;\n  }\n</style>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px;\">\n<h3 class='ggx'>Create 2000 NSManagedObjects</h3>\n<div class=\"linechart greenxx\" style=\"width: 30%\">\n    <span>Native: 0.062 seconds</span>\n</div>\n<div class=\"linechart redxx\">\n    <span>Reflection: 0.207 seconds</span>\n</div>\n</div>\n<p>Native, here, means creating an <code>NSManagedObject</code> and setting the\nproperty values via <code>setValueForKey</code>. If you create a <code>NSManagedObject</code>\nsubclass within Core Data and set the values directly on the properties\n(without the dynamic <code>setValueForKey</code> overhead) this is probably even\nfaster.</p>\n<p>So, as you can see, using reflection slows the whole process of creating\n<code>NSManagedObjects</code> down by about <strong>3.5x</strong>. This is fine when you're\nusing this for a limited amount of items, or when you don't have to\ncare about speed. However, when you need to reflect over a huge amount\nof <code>structs</code>, this will probably kill your app's performance.</p>\n","raw_content":"[frontMatter]\ntitle = \"Performance\"\ntags = [\"reflection\", \"performance\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Performance\n\nSo we just wrote some code that converts `struct` types via `reflection` at runtime to `Core Data` types.\nHow fast is this? Can this be used well in production? I did some testing:\n\n<style type=\"text/css\">\n  .linechart {\n      border: 3px solid white;\n      border-radius: 32px;\n      font-family: Sans-Serif;\n      color: white;\n      font-weight: normal;\n      padding: 4px;\n      margin-bottom: 20px;\n  }\n  .redxx {\n      background-color: red;\n  }\n  .greenxx {\n      background-color: green;\n  }\n  .linechart > span {\n      padding: 4px;\n  }\n  h3.ggx {\n      font-family: Sans-Serif;\nfont-weight: normal;\n  }\n  .orangexx {\n      background-color: orange;\n  }\n</style>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px;\">\n\n<h3 class='ggx'>Create 2000 NSManagedObjects</h3>\n\n<div class=\"linechart greenxx\" style=\"width: 30%\">\n    <span>Native: 0.062 seconds</span>\n</div>\n<div class=\"linechart redxx\">\n    <span>Reflection: 0.207 seconds</span>\n</div>\n</div>\n\nNative, here, means creating an `NSManagedObject` and setting the\nproperty values via `setValueForKey`. If you create a `NSManagedObject`\nsubclass within Core Data and set the values directly on the properties\n(without the dynamic `setValueForKey` overhead) this is probably even\nfaster.\n\nSo, as you can see, using reflection slows the whole process of creating\n`NSManagedObjects` down by about **3.5x**. This is fine when you\\'re\nusing this for a limited amount of items, or when you don\\'t have to\ncare about speed. However, when you need to reflect over a huge amount\nof `structs`, this will probably kill your app\\'s performance.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/piracy.md":["59d6c99ecd384a3a",{"identifier":"7268a8c9","filename":"piracy.md","info":{"title":"How do I prevent piracy?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-prevent-piracy.html","content":"<h1>This more or less only affects paid apps</h1>\n<p>On iOS, Apple automatically deploys code that does receipt validation and makes sure that your app can't just be pirated by copying it from device to device (albeit this still being a possibilty on rooted iOS devices).</p>\n<p>On macOS, users can just copy the <code>MyApp.app</code> folder to a different Mac and run it. By default, macOS does not perform any receipt validation whatsoever. <a href=\"https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html\">Apple has some guides on how to implement the necessary code to perform receipt validation yourself.</a>.</p>\n<h1>Please Don't do that!</h1>\n<p>This is rather difficult to do properly, and even then you have to do it in a way that can't be easily circumvented by hackers. This is certainly doable but requires an astonishing amount of work. There's a much better solution.</p>\n<h1>Receigen</h1>\n<p><a href=\"http://receigen.etiemble.com\">Receigen</a> is a fantastic macOS app that will automatically generate the required receipt validation code for you. I strongly suggest using <em>Receigen</em> or an alternative solution.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I prevent piracy?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n# This more or less only affects paid apps\n\nOn iOS, Apple automatically deploys code that does receipt validation and makes sure that your app can't just be pirated by copying it from device to device (albeit this still being a possibilty on rooted iOS devices).\n\nOn macOS, users can just copy the `MyApp.app` folder to a different Mac and run it. By default, macOS does not perform any receipt validation whatsoever. [Apple has some guides on how to implement the necessary code to perform receipt validation yourself.](https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html).\n\n# Please Don't do that!\n\nThis is rather difficult to do properly, and even then you have to do it in a way that can't be easily circumvented by hackers. This is certainly doable but requires an astonishing amount of work. There's a much better solution.\n\n# Receigen\n\n[Receigen](http://receigen.etiemble.com) is a fantastic macOS app that will automatically generate the required receipt validation code for you. I strongly suggest using *Receigen* or an alternative solution.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/intro.md":["27ba54064df4f190",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"How Do I ...","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i.html","content":"<p>This is a list of <em>not-so-obvious</em> things which you might run into while working on your Catalyst app. Will be extended constantly.</p>\n","raw_content":"[frontMatter]\ntitle = \"How Do I ...\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nThis is a list of *not-so-obvious* things which you might run into while working on your Catalyst app. Will be extended constantly.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2016-07-15-swift3-nsdata-data.md":["f9c44df2e3815cd4",{"identifier":"84fd12aa","filename":"2016-07-15-swift3-nsdata-data.md","info":{"title":"Data in Swift 3 parsing a Doom WAD File","tags":["Data"],"keywords":["swift","doom","wad","lumps","data","nsdata","swift3","binary","bytes"],"category":["Hands On","All"],"created":"2016-07-15 10:30:30","description":"Swift 3 replaces NSData with the Data value type. Implement a Doom Wad file parser with the new Data type to understand the differences.","description_html":"<p>Swift 3 replaces NSData with the Data value type. Implement a Doom Wad file parser with the new Data type to understand the differences.</p>\n","published":true,"slug":"2016-07-15-swift3-nsdata-data.html","meta":{"swift_version":"3.0","thumbnail":"/img-content/thumb-doom.png","toc":"true","feature_image":"https://appventure.me/img-content/doom@2x.png"},"created_timestamp":1468578630,"date":"2016-07-15T10:30:30","date_info":{"year":2016,"month":7,"day":15,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2016-07-15-swift3-nsdata-data.html","content":"<h1>From NSData to Data in Swift 3</h1>\n<p>Swift 3 encompasses many different small and big changes to the\nlanguage. One of them is the introduction of value type wrappers for\ncommon Foundation reference types such as NSData (<code>Data</code>) or NSDate\n(<code>Date</code>). These new types differ not only in their memory behaviour and\nname, their methods also differ from their reference-based\ncounterparts<sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>. From small changes to new method names up to big\nchanges like completely removed functionalities, these new value types\nrequire some getting used to. This post will try to highlight some of\nthe bigger changes happened to <code>Data</code> the value-based wrapper for\n<code>NSData</code>.</p>\n<p>Even better, after going through the basics, we will write a small\nexample application that will read and parse a Doom <sup class=\"footnote-reference\"><a href=\"#2\">2</a></sup> WAD file.</p>\n<div align=\"center\">\n<img src=\"/img-content/doom.png\" srcset=\"/img-content/doom@2x.png 2x\" /><br/>\n</div>\n<br/>\n<br/>\n<h1>Basic Differences</h1>\n<p>One of the most common usage scenarios for <code>NSData</code> is the loading and\nwriting of data via these calls:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> writeToURL(<span class=\"keyword\">_</span> url: <span class=\"type\">NSURL</span>, atomically atomically: <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Bool</span>\n\n<span class=\"keyword\">func</span> writeToURL(<span class=\"keyword\">_</span> url: <span class=\"type\">NSURL</span>, options writeOptionsMask: <span class=\"type\">NSDataWritingOptions</span>) <span class=\"keyword\">throws</span>\n\n<span class=\"comment\">// ... (implementations for file: String instead of NSURL)</span>\n\n<span class=\"keyword\">init</span>?(contentsOfURL url: <span class=\"type\">NSURL</span>)\n\n<span class=\"keyword\">init</span>(contentsOfURL url: <span class=\"type\">NSURL</span>, options readOptionsMask: <span class=\"type\">NSDataReadingOptions</span>) <span class=\"keyword\">throws</span>\n\n<span class=\"comment\">// ... (implementations for file: String instead of NSURL)</span>\n</code></pre></code></pre>\n<p>For those basic usages, very little changed. The new <code>Data</code> type offers\nthese methods:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>(contentsOf: <span class=\"type\">URL</span>, options: <span class=\"type\">ReadingOptions</span>)\n\n<span class=\"keyword\">func</span> write(to: <span class=\"type\">URL</span>, options: <span class=\"type\">WritingOptions</span>)\n</code></pre></code></pre>\n<p>Note that <code>Data</code> simplifies the various ways of reading and writing data\nfrom the file system into two calls while <code>NSData</code> offers multiple\ndifferent methods.</p>\n<p>Another difference can be observed when comparing the methods on\n<code>NSData</code> with those on <code>Data</code>. While <code>NSData</code> offers 30 methods &amp;\nproperties, <code>Data</code> offers 130. This huge difference is easily explained\nvia Swift's formidable Protocol Extensions. <code>Data</code> obtains many of\nthose methods from the following protocols:</p>\n<ul>\n<li>CustomStringConvertible</li>\n<li>Equatable</li>\n<li>Hashable</li>\n<li>MutableCollection</li>\n<li>RandomAccessCollection</li>\n<li>RangeReplaceableCollection</li>\n<li>ReferenceConvertible</li>\n</ul>\n<p>This adds functionality to <code>Data</code> which did not exist in <code>NSData</code>.\nHere's a small sample:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> distance(from: <span class=\"type\">Int</span>, to: <span class=\"type\">Int</span>)\n\n<span class=\"keyword\">func</span> dropFirst(<span class=\"type\">Int</span>)\n\n<span class=\"keyword\">func</span> dropLast(<span class=\"type\">Int</span>)\n\n<span class=\"keyword\">func</span> filter((<span class=\"type\">UInt8</span>) -&gt; <span class=\"type\">Bool</span>)\n\n<span class=\"keyword\">func</span> flatMap&lt;ElementOfResult&gt;((<span class=\"type\">UInt8</span>) -&gt; <span class=\"type\">ElementOfResult</span>?)\n\n<span class=\"keyword\">func</span> forEach((<span class=\"type\">UInt8</span>) -&gt; <span class=\"type\">Void</span>)\n\n<span class=\"keyword\">func</span> index(<span class=\"type\">Int</span>, offsetBy: <span class=\"type\">Int</span>, limitedBy: <span class=\"type\">Int</span>)\n\n<span class=\"keyword\">func</span> map&lt;T&gt;((<span class=\"type\">UInt8</span>) -&gt; <span class=\"type\">T</span>)\n\n<span class=\"keyword\">func</span> max()\n\n<span class=\"keyword\">func</span> min()\n\n<span class=\"keyword\">func</span> partition()\n\n<span class=\"keyword\">func</span> prefix(<span class=\"type\">Int</span>)\n\n<span class=\"keyword\">func</span> reversed()\n\n<span class=\"keyword\">func</span> sort()\n\n<span class=\"keyword\">func</span> sorted()\n\n<span class=\"keyword\">func</span> split(separator: <span class=\"type\">UInt8</span>, maxSplits: <span class=\"type\">Int</span>, omittingEmptySubsequences: <span class=\"type\">Bool</span>)\n\n<span class=\"keyword\">func</span> reduce&lt;Result&gt;(<span class=\"type\">Result</span>, (partialResult: <span class=\"type\">Result</span>, <span class=\"type\">UInt8</span>) -&gt; <span class=\"type\">Result</span>)\n</code></pre></code></pre>\n<p>As you can see, many functional approaches, such as mapping or filtering\ncan now be done on the byte contents of <code>Data</code> types. This, to me, is a\nhuge improvement over <code>NSData</code>. An example of the benefits this brings\nis how easily you can now subscript and compare data:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> data = <span class=\"type\">Data</span>(bytes: [0x00, 0x01, 0x02, 0x03])  \n\n<span class=\"call\">print</span>(data[<span class=\"number\">2</span>]) <span class=\"comment\">// 2</span>\n\ndata[<span class=\"number\">2</span>] = 0x09\n\nprint (data == <span class=\"type\">Data</span>(bytes: [0x00, 0x01, 0x09, 0x03])) <span class=\"comment\">// true</span>  \n</code></pre></code></pre>\n<p><code>Data</code> also offers several new initializers which specifically handle\nother common Swift data types:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>(bytes: <span class=\"type\">Array</span>&lt;<span class=\"type\">UInt8</span>&gt;)\n\n<span class=\"keyword\">init</span>&lt;SourceType&gt;(buffer: <span class=\"type\">UnsafeMutableBufferPointer</span>&lt;<span class=\"type\">SourceType</span>&gt;)\n\n<span class=\"keyword\">init</span>(repeating: <span class=\"type\">UInt8</span>, count: <span class=\"type\">Int</span>)\n</code></pre></code></pre>\n<h1>GetBytes</h1>\n<p>Another difference which you will run into if you're using <code>Data</code> to\ninteract with lower level code such as <code>C</code> libraries is the distinct\nlack of the <code>NSData</code> <code>getBytes</code> method:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// NSData</span>\n\n<span class=\"keyword\">func</span> getBytes(<span class=\"keyword\">_</span> buffer: <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">Void</span>&gt;, length length: <span class=\"type\">Int</span>)\n</code></pre></code></pre>\n<p>There're many different usage scenarious for <code>getBytes</code>. One of the\nmost common is when you need to parse a file and read the bytes into\ndata types / variables. A common example: Say you want to read a binary\nfile which encodes a list of items. The file is encoded as follows:</p>\n<p>Datatype   Size   Function</p>\n<hr />\n<p>Char       4      Header (ABCD)\nUInt32     4      Start of Data\nUInt32     4      Amount of items</p>\n<p>The file contains a 4 byte string &quot;ABCD&quot; tagging it as the correct\nfile type. The next 4 bytes define the start of the actual data (i.e.\nwhere the header ends and the items begin), the final 4 bytes in the\nheader define the amount of items stored in this file.</p>\n<p>Parsing this data with <code>NSData</code> is pretty straight forward:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> data = ...\n\n<span class=\"keyword\">var</span> length: <span class=\"type\">UInt32</span> = <span class=\"number\">0</span>\n\n<span class=\"keyword\">var</span> start: <span class=\"type\">UInt32</span> = <span class=\"number\">0</span>\n\ndata.<span class=\"call\">getBytes</span>(&amp;start, range: <span class=\"type\">NSRange</span>(location: <span class=\"number\">4</span>, length: <span class=\"number\">4</span>))\n\ndata.<span class=\"call\">getBytes</span>(&amp;length, range: <span class=\"type\">NSRange</span>(location: <span class=\"number\">8</span>, length: <span class=\"number\">4</span>))\n</code></pre></code></pre>\n<p>This will return the correct result<sup class=\"footnote-reference\"><a href=\"#3\">3</a></sup>. If your data does not contain C\nstrings, there's an even easier way of doing this, you can simply\ndefine a <code>struct</code> with the correct fields and read the bytes directly\ninto the struct:</p>\n<p>Datatype   Size   Function</p>\n<hr />\n<p>UInt32     4      Start of Data\nUInt32     4      Amount of items</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> data = ...\n\n<span class=\"keyword\">struct</span> Header { \n\n   <span class=\"keyword\">let</span> start: <span class=\"type\">UInt32</span>\n\n   <span class=\"keyword\">let</span> length: <span class=\"type\">UInt32</span>\n\n}\n\n<span class=\"keyword\">var</span> header = <span class=\"type\">Header</span>(start: <span class=\"number\">0</span>, length: <span class=\"number\">0</span>)\n\ndata.<span class=\"call\">getBytes</span>(&amp;header, range: <span class=\"type\">NSRange</span>(location: <span class=\"number\">0</span>, length: <span class=\"number\">8</span>))\n</code></pre></code></pre>\n<h1>Data alternatives to <code>getBytes</code></h1>\n<p>However, if you're using <code>Data</code> this functionality is not available\nanymore. Instead, <code>Data</code> offers a new method:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Access the bytes in the data.</span>\n\n<span class=\"keyword\">func</span> withUnsafeBytes&lt;ResultType, ContentType&gt;((<span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">ContentType</span>&gt;) -&gt; <span class=\"type\">ResultType</span>)\n</code></pre></code></pre>\n<p>This method allows direct access of the our data's bytes from within a\nclosure. Let's see a simple example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> data = <span class=\"type\">Data</span>(bytes: [0x01, 0x02, 0x03])\n\ndata.<span class=\"call\">withUnsafeBytes</span> { (pointer: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">UInt8</span>&gt;) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span>\n\n     <span class=\"call\">print</span>(pointer)\n\n     <span class=\"call\">print</span>(pointer.<span class=\"property\">pointee</span>)\n\n}\n\n<span class=\"comment\">// Prints:</span> \n\n<span class=\"comment\">// : 0x00007f8dcb77cc50</span>\n\n<span class=\"comment\">// : 1</span>\n</code></pre></code></pre>\n<p>Ok, now that we have an unsafe UInt8 pointer into our data, how does\nthis help us? First of fall, we obviously need a different data type,\nand we're sure (we have to be!) that the data is indeed of this\nparticular data type. We know that this data contains a Int32 type, so\nhow do we decode it correctly?</p>\n<p>As we already have a unsafe pointer (of type UInt8) it is easy to move\nthis into an unsafe pointer of our target type. <code>UnsafePointer</code> has a\n<code>pointee</code> property which returns the type that the pointer is pointing\nto as the correct type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> data = <span class=\"type\">Data</span>(bytes: [0x00, 0x01, 0x00, 0x00])\n\n<span class=\"keyword\">let</span> result = data.<span class=\"call\">withUnsafeBytes</span> { (pointer: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">Int32</span>&gt;) -&gt; <span class=\"type\">Int32</span> <span class=\"keyword\">in</span>\n\n       <span class=\"keyword\">return</span> pointer.<span class=\"property\">pointee</span>\n\n}\n\n<span class=\"call\">print</span>(result)\n\n<span class=\"comment\">//: 256</span>\n</code></pre></code></pre>\n<p>As you can see, we created a byte <code>Data</code> instance, and returned the data\nas <code>Int32</code> by defining an <code>UnsafePointer&lt;Int32&gt;</code> in the closure. You can\nshorten this code if the compiler is able to infer the result type from\nthe context:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> result: <span class=\"type\">Int32</span> = data.<span class=\"call\">withUnsafeBytes</span> { $0.<span class=\"property\">pointee</span> }\n</code></pre></code></pre>\n<h1>Lifetime of the data</h1>\n<p>One important consideration of using <code>withUnsafeBytes</code> (apart from the\nfact that the whole operation is unsafe) is that the lifetime of the\npointer you're accessing is limited to the lifetime of your closure. As\nthe documentation notes:</p>\n<blockquote>\n<p>Warning The byte pointer argument should not be stored and used\noutside of the lifetime of the call to the closure.</p>\n</blockquote>\n<h1>Generic Solution</h1>\n<p>Now that we have a way of accessing raw bytes and casting them to the\ncorrect type, we ought to create a generic solution that allows us to\nperform this operation easily without the syntactical overhead. Also, we\nstill did not account for the fact that we need to perform the operation\non a subsequence of our data and not the whole <code>Data</code> instance. A\ngeneric solution would look like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Data</span> {\n\n     <span class=\"keyword\">func</span> scanValue&lt;T&gt;(start: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">return self</span>.<span class=\"call\">subdata</span>(in: start..&lt;start+length).<span class=\"call\">withUnsafeBytes</span> { $0.<span class=\"property\">pointee</span> }\n\n     }\n\n}\n\n<span class=\"keyword\">let</span> data = <span class=\"type\">Data</span>(bytes: [0x01, 0x02, 0x01, 0x02])\n\n<span class=\"keyword\">let</span> a: <span class=\"type\">Int16</span> = data.<span class=\"call\">scanValue</span>(start: <span class=\"number\">0</span>, length: <span class=\"number\">1</span>)\n\n<span class=\"call\">print</span>(a)\n\n<span class=\"comment\">// : 1</span>\n</code></pre></code></pre>\n<p>Compared to our earlier code, this has a couple of notable differences:</p>\n<ul>\n<li>We're using <code>subdata</code> to only scan the bytes of a specific slice of\nour Data.</li>\n<li>We're using generics to support different possible data types for\nextraction</li>\n</ul>\n<h1>To Data</h1>\n<p>The opposite case, taking an existing variable and getting a <code>Data</code>\nbuffer to the content, is not relevant for the Doom example below, but\neasy enough to implement:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> variable = <span class=\"number\">256</span>\n\n<span class=\"keyword\">let</span> data = <span class=\"type\">Data</span>(buffer: <span class=\"type\">UnsafeBufferPointer</span>(start: &amp;variable, count: <span class=\"number\">1</span>))\n\n<span class=\"call\">print</span>(data) <span class=\"comment\">// : &lt;00010000 00000000&gt;</span>\n</code></pre></code></pre>\n<h1>Parsing the Doom WAD file</h1>\n<p>I've played a lot of Doom in my youth. I loved the game. I also created\na lot of Doom levels and modified the WAD file to incorporate new\nsprites, textures, and more. So when I thought about a nice (and simple)\nexample of how to parse a binary file, I remembered the layout of the\nWAD file which is pretty straightforward and easy to implement. So I\nwrote a simple app that reads a WAD file and lists the names of all the\nfloor textures stored in the WAD<sup class=\"footnote-reference\"><a href=\"#4\">4</a></sup>.</p>\n<p>The source code for this application <a href=\"https://github.com/terhechte/SwiftWadReader\">is available on\nGithub</a>.</p>\n<p>The Doom WAD file layout is described in these two documents:</p>\n<ul>\n<li><a href=\"http://doom.wikia.com/wiki/WAD\">http://doom.wikia.com/wiki/WAD</a></li>\n<li><a href=\"http://doomlegacy.sourceforge.net/hosted/doomspec1666.txt\">http://doomlegacy.sourceforge.net/hosted/doomspec1666.txt</a></li>\n</ul>\n<p>However, for our simple example, we only need to understand a subset of\nthe format. First, each WAD file begins with a header:</p>\n<p>Datatype   Size   Function</p>\n<hr />\n<p>Char       4      IWAD or PWAD string\nInt32      4      The number of lumps in the WAD\nInt32      4      Pointer to the location of the directory</p>\n<p>The first 4 bytes are spend to identify the file format. <code>IWAD</code> are\nofficial Doom WAD files, <code>PWAD</code> are patches containing additional\ninformation patched at runtime into the main WAD file. Our application\nwill only read <code>IWAD</code> files. The next 4 bytes define the number of\n<em>lumps</em> in the WAD. Lumps are the individual items that the Doom engine\noperates with: Textures, Sprite-Frames, Text blocks, Models, etc. Each\ntexture is a distinct lump. The final 4 bytes define the location of the\n<em>directory</em>. We'll explain the directory below, once we start parsing\nit. First, lets parse the header.</p>\n<h2>Parsing the Header</h2>\n<p>Reading a WAD file is straight forward:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span> <span class=\"type\">Data</span>(contentsOf: wadFileURL, options: .<span class=\"dotAccess\">alwaysMapped</span>)\n</code></pre></code></pre>\n<p>Once we have the data, we need to parse the header. We're making heavy\nuse of the <code>scanValue</code> <code>Data</code> extension we defined earlier.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public func</span> validateWadFile() <span class=\"keyword\">throws</span> {\n\n     <span class=\"comment\">// Several Wad File definitions</span>\n\n     <span class=\"keyword\">let</span> wadMaxSize = <span class=\"number\">12</span>, wadLumpsStart = <span class=\"number\">4</span>, wadDirectoryStart = <span class=\"number\">8</span>, wadDefSize = <span class=\"number\">4</span>\n\n     <span class=\"comment\">// A WAD file always starts with a 12-byte header.</span>\n\n     <span class=\"keyword\">guard</span> data.<span class=\"property\">count</span> &gt;= wadMaxSize <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">WadReaderError</span>.<span class=\"call\">invalidWadFile</span>(reason: \\<span class=\"string\">\"File</span> <span class=\"keyword\">is</span> too small\\<span class=\"string\">\"</span>) }\n\n\n\n     <span class=\"comment\">// It contains three values:</span>\n\n\n\n     <span class=\"comment\">// The ASCII characters \\\"IWAD\\\" or \\\"PWAD\\\". Defines whether the WAD is an IWAD or a PWAD.</span>\n\n     <span class=\"keyword\">let</span> validStart = \\<span class=\"string\">\"IWAD</span>\\<span class=\"string\">\"</span>.<span class=\"call\">data</span>(using: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.<span class=\"property\">ascii</span>)!\n\n     <span class=\"keyword\">guard</span> data.<span class=\"call\">subdata</span>(in: <span class=\"number\">0</span>..&lt;wadDefSize) == validStart <span class=\"keyword\">else</span>\n\n     { <span class=\"keyword\">throw</span> <span class=\"type\">WadReaderError</span>.<span class=\"call\">invalidWadFile</span>(reason: \\<span class=\"string\">\"Not</span> an <span class=\"type\">IWAD</span>\\<span class=\"string\">\"</span>) }\n\n\n\n     <span class=\"comment\">// An integer specifying the number of lumps in the WAD.</span>\n\n     <span class=\"keyword\">let</span> lumpsInteger: <span class=\"type\">Int32</span> = data.<span class=\"call\">scanValue</span>(start: wadLumpsStart, length: wadDefSize)\n\n\n\n     <span class=\"comment\">// An integer holding a pointer to the location of the directory.</span>\n\n     <span class=\"keyword\">let</span> directoryInteger: <span class=\"type\">Int32</span> = data.<span class=\"call\">scanValue</span>(start: wadDirectoryStart, length: wadDefSize)\n\n\n\n     <span class=\"keyword\">guard</span> lumpsInteger &gt; <span class=\"number\">0</span> &amp;&amp; directoryInteger &gt; <span class=\"type\">Int32</span>(wadMaxSize)\n\n         <span class=\"keyword\">else</span> {\n\n             <span class=\"keyword\">throw</span> <span class=\"type\">WadReaderError</span>.<span class=\"call\">invalidWadFile</span>(reason: \\<span class=\"string\">\"Empty</span> <span class=\"type\">Wad File</span>\\<span class=\"string\">\"</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>You can find additional types (such as the <code>WadReaderError</code> <code>enum</code>) in\n<a href=\"https://github.com/terhechte/SwiftWadReader\">the source on GitHub</a>. The\nnext step is to parse the directory, so that we get the addresses and\nsizes of the individual lumps.</p>\n<h2>Parsing the Directory</h2>\n<p>The directory associates names of lumps with the data that belong to\nthem. It consists of a number of entries, each with a length of 16\nbytes. The length of the directory is determined by the number given in\nthe WAD header.</p>\n<p>Each of the 16 bytes entries follows the same format:</p>\n<p>Datatype   Size   Function</p>\n<hr />\n<p>Int32      4      The start of the lumps data in the file\nInt32      4      The size of the lump in bytes\nChar       8      An ASCII string defining the lump's name</p>\n<p>The name char is a bit more complicated. The documentation says:</p>\n<blockquote>\n<p>An ASCII string defining the lump's name. Only the characters A-Z\n(uppercase), 0-9, and [ ] - _ should be used in lump names (an\nexception has to be made for some of the Arch-Vile sprites, which use\n&quot;\\&quot;). When a string is less than 8 bytes long, it should be\nnull-padded to the tight byte.</p>\n</blockquote>\n<p>Note the last sentence. In C, a String is terminated with the null\ncharacter (<code>\\0</code>). This signifies to the system that the memory for the\nstring ends here. Doom saves space by having an optional null character.\nWhen the string is less than 8 bytes long, it will contain a null\ncharacter, when it is of the max length (8 bytes) the 8th byte will be\nthe final character, not the null character.</p>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">      0   1   2   3      4      5      6      7      \n</span></code></pre></code></pre>\n<hr />\n<p>Short   I   M   P   <code>\\0</code>   <code>\\0</code>   <code>\\0</code>   <code>\\0</code>   <code>\\0</code>   #\nLong    F   L   O   O      R      4      _     5      #</p>\n<p>See above for an example. The Short name has a null character after the\nlast letter in position 3, the long name does not have a null character,\ninstead the last letter is the <strong>5</strong> from the name <strong>FLOOR4~5~</strong>. The\n<code>#</code> signifies the beginning of the next item / piece of memory.</p>\n<p>Before we venture into supporting this, lets first take care of the\neasier part, reading the start and size.</p>\n<p>Before we start, we should define a data structure that can store the\ninformation from the directory:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public struct</span> Lump {\n\n     <span class=\"keyword\">public let</span> filepos: <span class=\"type\">Int32</span>\n\n     <span class=\"keyword\">public let</span> size: <span class=\"type\">Int32</span>\n\n     <span class=\"keyword\">public let</span> name: <span class=\"type\">String</span>\n\n}\n</code></pre></code></pre>\n<p>Afterwards, we take the slice of data that constitutes our directory\nfrom the complete data instance.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Define the default size of a directory entry</span>\n\n<span class=\"keyword\">let</span> wadDirectoryEntrySize = <span class=\"number\">16</span>\n\n<span class=\"comment\">// Extract the directory slice from the main Data</span>\n\n<span class=\"keyword\">let</span> directory = data.<span class=\"call\">subdata</span>(in: <span class=\"type\">Int</span>(directoryLocation)..&lt;(<span class=\"type\">Int</span>(directoryLocation) + <span class=\"type\">Int</span>(numberOfLumps) * wadDirectoryEntrySize))\n</code></pre></code></pre>\n<p>Next, we can iterate over the <code>Data</code> in 16byte steps. This works great\nwith Swift's <code>stride</code> function:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for</span> currentIndex <span class=\"keyword\">in</span> <span class=\"call\">stride</span>(from: <span class=\"number\">0</span>, to: directory.<span class=\"property\">count</span>, by: wadDirectoryEntrySize) {\n\n     <span class=\"keyword\">let</span> currentDirectoryEntry = directory.<span class=\"call\">subdata</span>(in: currentIndex..&lt;currentIndex+wadDirectoryEntrySize)\n\n\n\n     <span class=\"comment\">// An integer holding a pointer to the start of the lump's data in the file.</span>\n\n     <span class=\"keyword\">let</span> lumpStart: <span class=\"type\">Int32</span> = currentDirectoryEntry.<span class=\"call\">scanValue</span>(start: <span class=\"number\">0</span>, length: <span class=\"number\">4</span>)\n\n\n\n     <span class=\"comment\">// An integer representing the size of the lump in bytes.</span>\n\n     <span class=\"keyword\">let</span> lumpSize: <span class=\"type\">Int32</span> = currentDirectoryEntry.<span class=\"call\">scanValue</span>(start: <span class=\"number\">4</span>, length: <span class=\"number\">4</span>)\n\n     ...\n\n}\n</code></pre></code></pre>\n<p>This was the easier part the next part is a bit more difficult.</p>\n<h2>Parsing C Strings</h2>\n<p>Remember, for each lump's name, we need to stop reading bytes into our\nSwift string once we reach a null terminator <strong>or</strong> once we reach 8\nbytes. The very first thing to do is create a data slice with the\nrelevant data:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> nameData = currentDirectoryEntry.<span class=\"call\">subdata</span>(in: <span class=\"number\">8</span>..&lt;<span class=\"number\">16</span>)\n</code></pre></code></pre>\n<p>Swift offers great support for C String interoperability. This means\nthat to create a string we just need to hand the data to a <code>String</code>\ninitializer:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> lumpName = <span class=\"type\">String</span>(data: nameData, encoding: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.<span class=\"property\">ascii</span>)\n</code></pre></code></pre>\n<p>This works, though the result is not correct. This method ignores the\nnull terminator, so that all names, even the short ones, are converted\nto 8byte strings. As an example, the lump for the <strong>IMP</strong> character name\nbecomes <strong>IMP00000</strong>. This happens because Doom fills the remaining 5\nbytes with null characters and <code>String(data:encoding:)</code> does not\ninterpret them but creates a string of the full 8 bytes of the\n<code>nameData</code>.</p>\n<p>If we want to support null characters, Swift offers something else, a\n<code>cString</code> initializer which is defined for reading valid cStrings with\nnull terminators:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Produces a string containing the bytes in a given C array,</span> \n\n<span class=\"comment\">// interpreted according to a given encoding.</span>\n\n<span class=\"keyword\">init</span>?(cString: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">CChar</span>&gt;, encoding enc: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>)\n</code></pre></code></pre>\n<p>Note that it doesn't require a <code>data</code> instance as its parameter but an\nunsafePointer to <code>CChars</code> instead. We already know how to do that, so\nlets write the code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> lumpName2 = nameData.<span class=\"call\">withUnsafeBytes</span>({ (pointer: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">UInt8</span>&gt;) -&gt; <span class=\"type\">String</span>? <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">return</span> <span class=\"type\">String</span>(cString: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">CChar</span>&gt;(pointer), encoding: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.<span class=\"property\">ascii</span>)\n\n})\n</code></pre></code></pre>\n<p>This, again, doesn't work. In all cases where Doom's names are less\nthan 8 characters, this code works flawlessly, but once we reach a 8\nbyte name without a null terminator, it will continue reading (into the\nnext 16byte segment) until it finds the next valid null terminator. This\nresults in long strings with random memory at the end.</p>\n<p>Since this logic is custom to Doom, we also need to implement custom\ncode. As <code>Data</code> supports Swift's collection &amp; sequence operations, we\ncan just solve this in terms of reduce:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> lumpName3Bytes = <span class=\"keyword\">try</span> nameData.<span class=\"call\">reduce</span>([<span class=\"type\">UInt8</span>](), { (a: [<span class=\"type\">UInt8</span>], b: <span class=\"type\">UInt8</span>) <span class=\"keyword\">throws</span> -&gt; [<span class=\"type\">UInt8</span>] <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">guard</span> b &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> a }\n\n     <span class=\"keyword\">guard</span> a.<span class=\"property\">count</span> &lt;= <span class=\"number\">8</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> a }\n\n     <span class=\"keyword\">return</span> a + [b]\n\n})\n\n<span class=\"keyword\">guard let</span> lumpName3 = <span class=\"type\">String</span>(bytes: lumpName3Bytes, encoding: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.<span class=\"property\">ascii</span>)\n\n     <span class=\"keyword\">else</span> {\n\n         <span class=\"keyword\">throw</span> <span class=\"type\">WadReaderError</span>.<span class=\"call\">invalidLup</span>(reason: \\<span class=\"string\">\"Could</span> not decode lump name <span class=\"keyword\">for</span> bytes \\(lumpName3Bytes)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>This code just reduces over the <code>UInt8</code> bytes of our data and checks\nwhether we have an early null terminator. This code works, <a href=\"https://appventure.me/2015/11/30/reduce-all-the-things/\">though it is\nnot necessarily fast as the data has to be moved through several\nabstractions.</a></p>\n<p>It would be better if we could solve this similarly to how the Doom\nengine does it. Doom just moves the pointer of the <code>char*</code> and checks\nfor each char whether it is a null terminator in order to break early.\nAs Doom is written in low level C code, it can just iterate over the raw\npointer addresses.</p>\n<p>How would we implement this logic in Swift? We can actually do something\nquite similar in Swift by, again, utilizing <code>withUnsafeBytes</code>. Lets see:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">let</span> finalLumpName = nameData.<span class=\"call\">withUnsafeBytes</span>({ (pointer: <span class=\"type\">UnsafePointer</span>&lt;<span class=\"type\">CChar</span>&gt;) -&gt; <span class=\"type\">String</span>? <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">var</span> localPointer = pointer\n\n     <span class=\"keyword\">for _ in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">8</span> {\n\n         <span class=\"keyword\">guard</span> localPointer.<span class=\"property\">pointee</span> != <span class=\"type\">CChar</span>(<span class=\"number\">0</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">break</span> }\n\n         localPointer = localPointer.<span class=\"call\">successor</span>()\n\n     }\n\n     <span class=\"keyword\">let</span> position = pointer.<span class=\"call\">distance</span>(to: localPointer)\n\n     <span class=\"keyword\">return</span> <span class=\"type\">String</span>(data: nameData.<span class=\"call\">subdata</span>(in: <span class=\"number\">0</span>..&lt;position),\n\n                   encoding: <span class=\"type\">String</span>.<span class=\"type\">Encoding</span>.<span class=\"property\">ascii</span>)\n\n})\n\n<span class=\"keyword\">guard let</span> lumpName4 = finalLumpName <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">throw</span> <span class=\"type\">WadReaderError</span>.<span class=\"call\">invalidLup</span>(reason: \\<span class=\"string\">\"Could</span> not decode lump name <span class=\"keyword\">for</span> bytes \\(lumpName3Bytes)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>Similar to our earlier uses of <code>withUnsafeBytes</code> we're receiving a\npointer to the raw memory. <code>pointer</code> is a <code>let</code> constant, but we need to\nmodify the variable, which is why we create a local mutable version in\nthe first line <sup class=\"footnote-reference\"><a href=\"#5\">5</a></sup>.</p>\n<p>Afterwards, we're performing the main work. We loop from 0 to 8 and for\neach loop iteration we test whether the char that the pointer is\npointing to (the <code>pointee</code>) is equal to the null terminator\n(<code>CChar(0)</code>). If it is equal to the null terminator, this means that we\nfound the null terminator early, and we break. If it is not equal to the\nnull terminator, we overwrite <code>localPointer</code> with its successor, i.e.\nthe next position in memory after the current pointer. That way, we're\niterating byte by byte over the contents of our memory.</p>\n<p>Once we're done, we calculate the distance between our original\n<code>pointer</code> and our <code>localPointer</code>. If we just advanced three times before\nfinding a null terminator, the distance between the two pointers would\nbe 3. This distance, finally, allows us to create a new String instance\nwith the subdata of actual C String.</p>\n<p>This allows us to create a new <code>Lump</code> struct with the required data:</p>\n<pre class=\"Swift\"><code>lumps.<span class=\"call\">append</span>(<span class=\"type\">Lump</span>(filepos: lumpStart, size: lumpSize, name: lumpName4))                \n</code></pre></code></pre>\n<p>When you look into the source, you will see ominous references to\n<code>F_START</code> and <code>F_END</code>. Doom marks the beginning and end of special <em>lump\nregions</em> with empty lumps with magic names. <code>F_START / F_END</code> enclose\nall the floor texture lumps. We will ignore this additional step in this\ntutorial.</p>\n<p>A screenshot from the final application:</p>\n<div align=\"center\">\n<img src=\"/img-content/doom-shot.png\" srcset=\"/img-content/doom-shot@2x.png 2x\" style=\"box-shadow: 6px 6px 32px rgba(0, 0, 0, 0.5); border-radius: 4px;\" /><br/>\n<br/>\n<br/>\n</div>\n<p>Not really impressive, I know. One of the next installments on this blog\nmight concentrate on how to display those textures.</p>\n<h1>Bridging to NSData</h1>\n<p>I find the new <code>Data</code> easier to work with than <code>NSData</code>. Nevertheless,\nif you need <code>NSData</code> or if you need to use the <code>getBytes</code> method,\nthere's an easy way to convert <code>Data</code> to <code>NSData</code>. The Swift\ndocumentation writes:</p>\n<blockquote>\n<p>This type provides &quot;copy-on-write&quot; behavior, and is also bridged to\nthe Objective-C NSData class. You can wrap an instance of a custom\nsubclass of NSData in struct Data by converting it using myData as\nData.</p>\n</blockquote>\n<pre class=\"Swift\"><code><span class=\"comment\">// Create a new Data Struct</span>\n\n<span class=\"keyword\">let</span> aDataStruct = <span class=\"type\">Data</span>()\n\n<span class=\"comment\">// Get the underlying reference type NSData</span>\n\n<span class=\"keyword\">let</span> aDataReference = aDataStruct <span class=\"keyword\">as</span> <span class=\"type\">NSData</span>\n</code></pre></code></pre>\n<p>Whenever you feel that what you're trying to do seems to be really hard\nwith the <code>Data</code> type, it is easy to go back to <code>NSData</code> to use the well\nknown tried and trusted methods. However, in general you should strive\nto use the new <code>Data</code> type whenever possible (except if you need\nreference semantics):</p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>Some, such as <code>Date</code> aren't even wrappers but completely new\nimplementations</p>\n</div>\n<div class=\"footnote-definition\" id=\"2\"><sup class=\"footnote-definition-label\">2</sup>\n<p>Doom1, Doom2, Hexen, Heretic, or Ultimate Doom. Though I've only\ntested it with Doom1 Shareware</p>\n</div>\n<div class=\"footnote-definition\" id=\"3\"><sup class=\"footnote-definition-label\">3</sup>\n<p>Note we did not make sure that this is indeed an ABCD file by\ntesting for the first 4 bytes, but that would be easy to add</p>\n</div>\n<div class=\"footnote-definition\" id=\"4\"><sup class=\"footnote-definition-label\">4</sup>\n<p>I kinda wanted to also display the textures but lacked the time to\nimplement that.</p>\n</div>\n<div class=\"footnote-definition\" id=\"5\"><sup class=\"footnote-definition-label\">5</sup>\n<p>Swift 3 dropped support for the useful <code>var</code> annotation in closure\nor function bodies</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"Swift 3 replaces NSData with the Data value type. Implement a Doom Wad file parser with the new Data type to understand the differences.\"\ntitle = \"Data in Swift 3 parsing a Doom WAD File\"\ncreated = \"2016-07-15\"\npublished = true\nkeywords = [\"swift\", \"doom\", \"wad\", \"lumps\", \"data\", \"nsdata\", \"swift3\", \"binary\", \"bytes\"]\nslug = \"2016-07-15-swift3-nsdata-data.html\"\ntags = [\"Data\"]\ncategory = [\"Hands On\", \"All\"]\n\n[meta]\nswift_version = \"3.0\"\nthumbnail = \"/img-content/thumb-doom.png\"\ntoc = \"true\"\nfeature_image = \"https://appventure.me/img-content/doom@2x.png\"\n---\n\n# From NSData to Data in Swift 3\n\nSwift 3 encompasses many different small and big changes to the\nlanguage. One of them is the introduction of value type wrappers for\ncommon Foundation reference types such as NSData (`Data`) or NSDate\n(`Date`). These new types differ not only in their memory behaviour and\nname, their methods also differ from their reference-based\ncounterparts[^1]. From small changes to new method names up to big\nchanges like completely removed functionalities, these new value types\nrequire some getting used to. This post will try to highlight some of\nthe bigger changes happened to `Data` the value-based wrapper for\n`NSData`.\n\nEven better, after going through the basics, we will write a small\nexample application that will read and parse a Doom [^2] WAD file.\n\n<div align=\"center\">\n<img src=\"/img-content/doom.png\" srcset=\"/img-content/doom@2x.png 2x\" /><br/>\n</div>\n<br/>\n<br/>\n\n# Basic Differences\n\nOne of the most common usage scenarios for `NSData` is the loading and\nwriting of data via these calls:\n\n``` Swift\nfunc writeToURL(_ url: NSURL, atomically atomically: Bool) -> Bool\nfunc writeToURL(_ url: NSURL, options writeOptionsMask: NSDataWritingOptions) throws\n// ... (implementations for file: String instead of NSURL)\ninit?(contentsOfURL url: NSURL)\ninit(contentsOfURL url: NSURL, options readOptionsMask: NSDataReadingOptions) throws\n// ... (implementations for file: String instead of NSURL)\n```\n\nFor those basic usages, very little changed. The new `Data` type offers\nthese methods:\n\n``` Swift\ninit(contentsOf: URL, options: ReadingOptions)\nfunc write(to: URL, options: WritingOptions)\n```\n\nNote that `Data` simplifies the various ways of reading and writing data\nfrom the file system into two calls while `NSData` offers multiple\ndifferent methods.\n\nAnother difference can be observed when comparing the methods on\n`NSData` with those on `Data`. While `NSData` offers 30 methods &\nproperties, `Data` offers 130. This huge difference is easily explained\nvia Swift\\'s formidable Protocol Extensions. `Data` obtains many of\nthose methods from the following protocols:\n\n-   CustomStringConvertible\n-   Equatable\n-   Hashable\n-   MutableCollection\n-   RandomAccessCollection\n-   RangeReplaceableCollection\n-   ReferenceConvertible\n\nThis adds functionality to `Data` which did not exist in `NSData`.\nHere\\'s a small sample:\n\n``` Swift\nfunc distance(from: Int, to: Int)\nfunc dropFirst(Int)\nfunc dropLast(Int)\nfunc filter((UInt8) -> Bool)\nfunc flatMap<ElementOfResult>((UInt8) -> ElementOfResult?)\nfunc forEach((UInt8) -> Void)\nfunc index(Int, offsetBy: Int, limitedBy: Int)\nfunc map<T>((UInt8) -> T)\nfunc max()\nfunc min()\nfunc partition()\nfunc prefix(Int)\nfunc reversed()\nfunc sort()\nfunc sorted()\nfunc split(separator: UInt8, maxSplits: Int, omittingEmptySubsequences: Bool)\nfunc reduce<Result>(Result, (partialResult: Result, UInt8) -> Result)\n```\n\nAs you can see, many functional approaches, such as mapping or filtering\ncan now be done on the byte contents of `Data` types. This, to me, is a\nhuge improvement over `NSData`. An example of the benefits this brings\nis how easily you can now subscript and compare data:\n\n``` Swift\nvar data = Data(bytes: [0x00, 0x01, 0x02, 0x03])  \nprint(data[2]) // 2\ndata[2] = 0x09\nprint (data == Data(bytes: [0x00, 0x01, 0x09, 0x03])) // true  \n```\n\n`Data` also offers several new initializers which specifically handle\nother common Swift data types:\n\n``` Swift\ninit(bytes: Array<UInt8>)\ninit<SourceType>(buffer: UnsafeMutableBufferPointer<SourceType>)\ninit(repeating: UInt8, count: Int)\n```\n\n# GetBytes\n\nAnother difference which you will run into if you\\'re using `Data` to\ninteract with lower level code such as `C` libraries is the distinct\nlack of the `NSData` `getBytes` method:\n\n``` Swift\n// NSData\nfunc getBytes(_ buffer: UnsafeMutablePointer<Void>, length length: Int)\n```\n\nThere\\'re many different usage scenarious for `getBytes`. One of the\nmost common is when you need to parse a file and read the bytes into\ndata types / variables. A common example: Say you want to read a binary\nfile which encodes a list of items. The file is encoded as follows:\n\n  Datatype   Size   Function\n  ---------- ------ -----------------\n  Char       4      Header (ABCD)\n  UInt32     4      Start of Data\n  UInt32     4      Amount of items\n\nThe file contains a 4 byte string \\\"ABCD\\\" tagging it as the correct\nfile type. The next 4 bytes define the start of the actual data (i.e.\nwhere the header ends and the items begin), the final 4 bytes in the\nheader define the amount of items stored in this file.\n\nParsing this data with `NSData` is pretty straight forward:\n\n``` Swift\nlet data = ...\nvar length: UInt32 = 0\nvar start: UInt32 = 0\ndata.getBytes(&start, range: NSRange(location: 4, length: 4))\ndata.getBytes(&length, range: NSRange(location: 8, length: 4))\n```\n\nThis will return the correct result[^3]. If your data does not contain C\nstrings, there\\'s an even easier way of doing this, you can simply\ndefine a `struct` with the correct fields and read the bytes directly\ninto the struct:\n\n  Datatype   Size   Function\n  ---------- ------ -----------------\n  UInt32     4      Start of Data\n  UInt32     4      Amount of items\n\n``` Swift\nlet data = ...\nstruct Header { \n  let start: UInt32\n  let length: UInt32\n}\nvar header = Header(start: 0, length: 0)\ndata.getBytes(&header, range: NSRange(location: 0, length: 8))\n```\n\n# Data alternatives to `getBytes`\n\nHowever, if you\\'re using `Data` this functionality is not available\nanymore. Instead, `Data` offers a new method:\n\n``` Swift\n// Access the bytes in the data.\nfunc withUnsafeBytes<ResultType, ContentType>((UnsafePointer<ContentType>) -> ResultType)\n```\n\nThis method allows direct access of the our data\\'s bytes from within a\nclosure. Let\\'s see a simple example:\n\n``` Swift\nlet data = Data(bytes: [0x01, 0x02, 0x03])\ndata.withUnsafeBytes { (pointer: UnsafePointer<UInt8>) -> Void in\n    print(pointer)\n    print(pointer.pointee)\n}\n// Prints: \n// : 0x00007f8dcb77cc50\n// : 1\n```\n\nOk, now that we have an unsafe UInt8 pointer into our data, how does\nthis help us? First of fall, we obviously need a different data type,\nand we\\'re sure (we have to be!) that the data is indeed of this\nparticular data type. We know that this data contains a Int32 type, so\nhow do we decode it correctly?\n\nAs we already have a unsafe pointer (of type UInt8) it is easy to move\nthis into an unsafe pointer of our target type. `UnsafePointer` has a\n`pointee` property which returns the type that the pointer is pointing\nto as the correct type:\n\n``` Swift\nlet data = Data(bytes: [0x00, 0x01, 0x00, 0x00])\nlet result = data.withUnsafeBytes { (pointer: UnsafePointer<Int32>) -> Int32 in\n      return pointer.pointee\n}\nprint(result)\n//: 256\n```\n\nAs you can see, we created a byte `Data` instance, and returned the data\nas `Int32` by defining an `UnsafePointer<Int32>` in the closure. You can\nshorten this code if the compiler is able to infer the result type from\nthe context:\n\n``` Swift\nlet result: Int32 = data.withUnsafeBytes { $0.pointee }\n```\n\n# Lifetime of the data\n\nOne important consideration of using `withUnsafeBytes` (apart from the\nfact that the whole operation is unsafe) is that the lifetime of the\npointer you\\'re accessing is limited to the lifetime of your closure. As\nthe documentation notes:\n\n> Warning The byte pointer argument should not be stored and used\n> outside of the lifetime of the call to the closure.\n\n# Generic Solution\n\nNow that we have a way of accessing raw bytes and casting them to the\ncorrect type, we ought to create a generic solution that allows us to\nperform this operation easily without the syntactical overhead. Also, we\nstill did not account for the fact that we need to perform the operation\non a subsequence of our data and not the whole `Data` instance. A\ngeneric solution would look like this:\n\n``` Swift\nextension Data {\n    func scanValue<T>(start: Int, length: Int) -> T {\n        return self.subdata(in: start..<start+length).withUnsafeBytes { $0.pointee }\n    }\n}\nlet data = Data(bytes: [0x01, 0x02, 0x01, 0x02])\nlet a: Int16 = data.scanValue(start: 0, length: 1)\nprint(a)\n// : 1\n```\n\nCompared to our earlier code, this has a couple of notable differences:\n\n-   We\\'re using `subdata` to only scan the bytes of a specific slice of\n    our Data.\n-   We\\'re using generics to support different possible data types for\n    extraction\n\n# To Data\n\nThe opposite case, taking an existing variable and getting a `Data`\nbuffer to the content, is not relevant for the Doom example below, but\neasy enough to implement:\n\n``` Swift\nvar variable = 256\nlet data = Data(buffer: UnsafeBufferPointer(start: &variable, count: 1))\nprint(data) // : <00010000 00000000>\n```\n\n# Parsing the Doom WAD file\n\nI\\'ve played a lot of Doom in my youth. I loved the game. I also created\na lot of Doom levels and modified the WAD file to incorporate new\nsprites, textures, and more. So when I thought about a nice (and simple)\nexample of how to parse a binary file, I remembered the layout of the\nWAD file which is pretty straightforward and easy to implement. So I\nwrote a simple app that reads a WAD file and lists the names of all the\nfloor textures stored in the WAD[^4].\n\nThe source code for this application [is available on\nGithub](https://github.com/terhechte/SwiftWadReader).\n\nThe Doom WAD file layout is described in these two documents:\n\n-   <http://doom.wikia.com/wiki/WAD>\n-   <http://doomlegacy.sourceforge.net/hosted/doomspec1666.txt>\n\nHowever, for our simple example, we only need to understand a subset of\nthe format. First, each WAD file begins with a header:\n\n  Datatype   Size   Function\n  ---------- ------ ------------------------------------------\n  Char       4      IWAD or PWAD string\n  Int32      4      The number of lumps in the WAD\n  Int32      4      Pointer to the location of the directory\n\nThe first 4 bytes are spend to identify the file format. `IWAD` are\nofficial Doom WAD files, `PWAD` are patches containing additional\ninformation patched at runtime into the main WAD file. Our application\nwill only read `IWAD` files. The next 4 bytes define the number of\n*lumps* in the WAD. Lumps are the individual items that the Doom engine\noperates with: Textures, Sprite-Frames, Text blocks, Models, etc. Each\ntexture is a distinct lump. The final 4 bytes define the location of the\n*directory*. We\\'ll explain the directory below, once we start parsing\nit. First, lets parse the header.\n\n## Parsing the Header\n\nReading a WAD file is straight forward:\n\n``` Swift\nlet data = try Data(contentsOf: wadFileURL, options: .alwaysMapped)\n```\n\nOnce we have the data, we need to parse the header. We\\'re making heavy\nuse of the `scanValue` `Data` extension we defined earlier.\n\n``` Swift\npublic func validateWadFile() throws {\n    // Several Wad File definitions\n    let wadMaxSize = 12, wadLumpsStart = 4, wadDirectoryStart = 8, wadDefSize = 4\n    // A WAD file always starts with a 12-byte header.\n    guard data.count >= wadMaxSize else { throw WadReaderError.invalidWadFile(reason: \"File is too small\") }\n\n    // It contains three values:\n\n    // The ASCII characters \"IWAD\" or \"PWAD\". Defines whether the WAD is an IWAD or a PWAD.\n    let validStart = \"IWAD\".data(using: String.Encoding.ascii)!\n    guard data.subdata(in: 0..<wadDefSize) == validStart else\n    { throw WadReaderError.invalidWadFile(reason: \"Not an IWAD\") }\n\n    // An integer specifying the number of lumps in the WAD.\n    let lumpsInteger: Int32 = data.scanValue(start: wadLumpsStart, length: wadDefSize)\n\n    // An integer holding a pointer to the location of the directory.\n    let directoryInteger: Int32 = data.scanValue(start: wadDirectoryStart, length: wadDefSize)\n\n    guard lumpsInteger > 0 && directoryInteger > Int32(wadMaxSize)\n        else {\n            throw WadReaderError.invalidWadFile(reason: \"Empty Wad File\")\n    }\n}\n```\n\nYou can find additional types (such as the `WadReaderError` `enum`) in\n[the source on GitHub](https://github.com/terhechte/SwiftWadReader). The\nnext step is to parse the directory, so that we get the addresses and\nsizes of the individual lumps.\n\n## Parsing the Directory\n\nThe directory associates names of lumps with the data that belong to\nthem. It consists of a number of entries, each with a length of 16\nbytes. The length of the directory is determined by the number given in\nthe WAD header.\n\nEach of the 16 bytes entries follows the same format:\n\n  Datatype   Size   Function\n  ---------- ------ -------------------------------------------\n  Int32      4      The start of the lumps data in the file\n  Int32      4      The size of the lump in bytes\n  Char       8      An ASCII string defining the lump\\'s name\n\nThe name char is a bit more complicated. The documentation says:\n\n> An ASCII string defining the lump\\'s name. Only the characters A-Z\n> (uppercase), 0-9, and \\[ \\] - \\_ should be used in lump names (an\n> exception has to be made for some of the Arch-Vile sprites, which use\n> \\\"\\\\\\\"). When a string is less than 8 bytes long, it should be\n> null-padded to the tight byte.\n\nNote the last sentence. In C, a String is terminated with the null\ncharacter (`\\0`). This signifies to the system that the memory for the\nstring ends here. Doom saves space by having an optional null character.\nWhen the string is less than 8 bytes long, it will contain a null\ncharacter, when it is of the max length (8 bytes) the 8th byte will be\nthe final character, not the null character.\n\n          0   1   2   3      4      5      6      7      \n  ------- --- --- --- ------ ------ ------ ------ ------ ----\n  Short   I   M   P   `\\0`   `\\0`   `\\0`   `\\0`   `\\0`   \\#\n  Long    F   L   O   O      R      4      \\_     5      \\#\n\nSee above for an example. The Short name has a null character after the\nlast letter in position 3, the long name does not have a null character,\ninstead the last letter is the **5** from the name **FLOOR4~5~**. The\n`#` signifies the beginning of the next item / piece of memory.\n\nBefore we venture into supporting this, lets first take care of the\neasier part, reading the start and size.\n\nBefore we start, we should define a data structure that can store the\ninformation from the directory:\n\n``` Swift\npublic struct Lump {\n    public let filepos: Int32\n    public let size: Int32\n    public let name: String\n}\n```\n\nAfterwards, we take the slice of data that constitutes our directory\nfrom the complete data instance.\n\n``` Swift\n// Define the default size of a directory entry\nlet wadDirectoryEntrySize = 16\n// Extract the directory slice from the main Data\nlet directory = data.subdata(in: Int(directoryLocation)..<(Int(directoryLocation) + Int(numberOfLumps) * wadDirectoryEntrySize))\n```\n\nNext, we can iterate over the `Data` in 16byte steps. This works great\nwith Swift\\'s `stride` function:\n\n``` Swift\nfor currentIndex in stride(from: 0, to: directory.count, by: wadDirectoryEntrySize) {\n    let currentDirectoryEntry = directory.subdata(in: currentIndex..<currentIndex+wadDirectoryEntrySize)\n\n    // An integer holding a pointer to the start of the lump's data in the file.\n    let lumpStart: Int32 = currentDirectoryEntry.scanValue(start: 0, length: 4)\n\n    // An integer representing the size of the lump in bytes.\n    let lumpSize: Int32 = currentDirectoryEntry.scanValue(start: 4, length: 4)\n    ...\n}\n```\n\nThis was the easier part the next part is a bit more difficult.\n\n## Parsing C Strings\n\nRemember, for each lump\\'s name, we need to stop reading bytes into our\nSwift string once we reach a null terminator **or** once we reach 8\nbytes. The very first thing to do is create a data slice with the\nrelevant data:\n\n``` Swift\nlet nameData = currentDirectoryEntry.subdata(in: 8..<16)\n```\n\nSwift offers great support for C String interoperability. This means\nthat to create a string we just need to hand the data to a `String`\ninitializer:\n\n``` Swift\nlet lumpName = String(data: nameData, encoding: String.Encoding.ascii)\n```\n\nThis works, though the result is not correct. This method ignores the\nnull terminator, so that all names, even the short ones, are converted\nto 8byte strings. As an example, the lump for the **IMP** character name\nbecomes **IMP00000**. This happens because Doom fills the remaining 5\nbytes with null characters and `String(data:encoding:)` does not\ninterpret them but creates a string of the full 8 bytes of the\n`nameData`.\n\nIf we want to support null characters, Swift offers something else, a\n`cString` initializer which is defined for reading valid cStrings with\nnull terminators:\n\n``` Swift\n// Produces a string containing the bytes in a given C array, \n// interpreted according to a given encoding.\ninit?(cString: UnsafePointer<CChar>, encoding enc: String.Encoding)\n```\n\nNote that it doesn\\'t require a `data` instance as its parameter but an\nunsafePointer to `CChars` instead. We already know how to do that, so\nlets write the code:\n\n``` Swift\nlet lumpName2 = nameData.withUnsafeBytes({ (pointer: UnsafePointer<UInt8>) -> String? in\n    return String(cString: UnsafePointer<CChar>(pointer), encoding: String.Encoding.ascii)\n})\n```\n\nThis, again, doesn\\'t work. In all cases where Doom\\'s names are less\nthan 8 characters, this code works flawlessly, but once we reach a 8\nbyte name without a null terminator, it will continue reading (into the\nnext 16byte segment) until it finds the next valid null terminator. This\nresults in long strings with random memory at the end.\n\nSince this logic is custom to Doom, we also need to implement custom\ncode. As `Data` supports Swift\\'s collection & sequence operations, we\ncan just solve this in terms of reduce:\n\n``` Swift\nlet lumpName3Bytes = try nameData.reduce([UInt8](), { (a: [UInt8], b: UInt8) throws -> [UInt8] in\n    guard b > 0 else { return a }\n    guard a.count <= 8 else { return a }\n    return a + [b]\n})\nguard let lumpName3 = String(bytes: lumpName3Bytes, encoding: String.Encoding.ascii)\n    else {\n        throw WadReaderError.invalidLup(reason: \"Could not decode lump name for bytes \\(lumpName3Bytes)\")\n}\n```\n\nThis code just reduces over the `UInt8` bytes of our data and checks\nwhether we have an early null terminator. This code works, [though it is\nnot necessarily fast as the data has to be moved through several\nabstractions.](https://appventure.me/2015/11/30/reduce-all-the-things/)\n\nIt would be better if we could solve this similarly to how the Doom\nengine does it. Doom just moves the pointer of the `char*` and checks\nfor each char whether it is a null terminator in order to break early.\nAs Doom is written in low level C code, it can just iterate over the raw\npointer addresses.\n\nHow would we implement this logic in Swift? We can actually do something\nquite similar in Swift by, again, utilizing `withUnsafeBytes`. Lets see:\n\n``` Swift\n\nlet finalLumpName = nameData.withUnsafeBytes({ (pointer: UnsafePointer<CChar>) -> String? in\n    var localPointer = pointer\n    for _ in 0..<8 {\n        guard localPointer.pointee != CChar(0) else { break }\n        localPointer = localPointer.successor()\n    }\n    let position = pointer.distance(to: localPointer)\n    return String(data: nameData.subdata(in: 0..<position),\n                  encoding: String.Encoding.ascii)\n})\nguard let lumpName4 = finalLumpName else {\n    throw WadReaderError.invalidLup(reason: \"Could not decode lump name for bytes \\(lumpName3Bytes)\")\n}\n```\n\nSimilar to our earlier uses of `withUnsafeBytes` we\\'re receiving a\npointer to the raw memory. `pointer` is a `let` constant, but we need to\nmodify the variable, which is why we create a local mutable version in\nthe first line [^5].\n\nAfterwards, we\\'re performing the main work. We loop from 0 to 8 and for\neach loop iteration we test whether the char that the pointer is\npointing to (the `pointee`) is equal to the null terminator\n(`CChar(0)`). If it is equal to the null terminator, this means that we\nfound the null terminator early, and we break. If it is not equal to the\nnull terminator, we overwrite `localPointer` with its successor, i.e.\nthe next position in memory after the current pointer. That way, we\\'re\niterating byte by byte over the contents of our memory.\n\nOnce we\\'re done, we calculate the distance between our original\n`pointer` and our `localPointer`. If we just advanced three times before\nfinding a null terminator, the distance between the two pointers would\nbe 3. This distance, finally, allows us to create a new String instance\nwith the subdata of actual C String.\n\nThis allows us to create a new `Lump` struct with the required data:\n\n``` Swift\nlumps.append(Lump(filepos: lumpStart, size: lumpSize, name: lumpName4))                \n```\n\nWhen you look into the source, you will see ominous references to\n`F_START` and `F_END`. Doom marks the beginning and end of special *lump\nregions* with empty lumps with magic names. `F_START / F_END` enclose\nall the floor texture lumps. We will ignore this additional step in this\ntutorial.\n\nA screenshot from the final application:\n\n<div align=\"center\">\n<img src=\"/img-content/doom-shot.png\" srcset=\"/img-content/doom-shot@2x.png 2x\" style=\"box-shadow: 6px 6px 32px rgba(0, 0, 0, 0.5); border-radius: 4px;\" /><br/>\n<br/>\n<br/>\n</div>\n\nNot really impressive, I know. One of the next installments on this blog\nmight concentrate on how to display those textures.\n\n# Bridging to NSData\n\nI find the new `Data` easier to work with than `NSData`. Nevertheless,\nif you need `NSData` or if you need to use the `getBytes` method,\nthere\\'s an easy way to convert `Data` to `NSData`. The Swift\ndocumentation writes:\n\n> This type provides \"copy-on-write\" behavior, and is also bridged to\n> the Objective-C NSData class. You can wrap an instance of a custom\n> subclass of NSData in struct Data by converting it using myData as\n> Data.\n\n``` Swift\n// Create a new Data Struct\nlet aDataStruct = Data()\n// Get the underlying reference type NSData\nlet aDataReference = aDataStruct as NSData\n```\n\nWhenever you feel that what you\\'re trying to do seems to be really hard\nwith the `Data` type, it is easy to go back to `NSData` to use the well\nknown tried and trusted methods. However, in general you should strive\nto use the new `Data` type whenever possible (except if you need\nreference semantics):\n\n[^1]: Some, such as `Date` aren\\'t even wrappers but completely new\n    implementations\n\n[^2]: Doom1, Doom2, Hexen, Heretic, or Ultimate Doom. Though I\\'ve only\n    tested it with Doom1 Shareware\n\n[^3]: Note we did not make sure that this is indeed an ABCD file by\n    testing for the first 4 bytes, but that would be easy to add\n\n[^4]: I kinda wanted to also display the textures but lacked the time to\n    implement that.\n\n[^5]: Swift 3 dropped support for the useful `var` annotation in closure\n    or function bodies\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/introduction.md":["7bf6b196c6144e14",{"identifier":"f90b081e","filename":"introduction.md","info":{"title":"Introduction","tags":["reflection"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-introduction.html","content":"<h1>Introduction</h1>\n<p>Even though Swift stresses strong types, compile time safety and static\ndispatch, it still offers a Reflection mechanism as part of the standard\nlibrary.</p>\n<p>Reflection means that you can ask Swift at runtime questions about types.\nI.e. you can tell Swift &quot;what are the methods that this class implements&quot;</p>\n<p>This might not sound useful, but in reality is allows to do some really\nclever tricks: For example, you could write a function that takes any\n<code>struct</code>, lists all the properties (<code>var username, var age</code>, etc)\nand writes this information into Core Data.</p>\n<p>Reflection in Swift is <code>read-only</code>, so you can't write any properties.\nHowever, it is still quite powerful. This guide will explain reflection\nand also show how it can be used in a practical way (the aforementioned\nstruct to Core Data example).</p>\n<p>The best understanding of the topic can be achieved by having a look at\nthe API to see what it offers us.</p>\n","raw_content":"[frontMatter]\ntitle = \"Introduction\"\ntags = [\"reflection\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Introduction\n\nEven though Swift stresses strong types, compile time safety and static\ndispatch, it still offers a Reflection mechanism as part of the standard\nlibrary. \n\nReflection means that you can ask Swift at runtime questions about types.\nI.e. you can tell Swift \"what are the methods that this class implements\"\n\nThis might not sound useful, but in reality is allows to do some really\nclever tricks: For example, you could write a function that takes any\n`struct`, lists all the properties (`var username, var age`, etc)\nand writes this information into Core Data. \n\nReflection in Swift is `read-only`, so you can't write any properties.\nHowever, it is still quite powerful. This guide will explain reflection\nand also show how it can be used in a practical way (the aforementioned\nstruct to Core Data example).\n\nThe best understanding of the topic can be achieved by having a look at\nthe API to see what it offers us.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/sidebar.md":["189e1021ec9b1c7c",{"identifier":"0794be87","filename":"sidebar.md","info":{"title":"How do I create a sidebar?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-create-a-sidebar.html","content":"<p>Sidebars are a staple of macOS. Many apps on macOS have sidebars and use them to support a huge variety of usage scenarios. Apple added sidebar support right into Catalyst. By default, any Master-Detail view implemented using the <code>UISplitViewController</code> will inhibit macOS sidebar behaviour. However, if you just do that, the sidebar contents (that is, the Master part of the Master Detail View) will look strangely out of place. The rows still look like normal UIKit Rows:</p>\n<p><img src=\"/img-content/catalyst/sidebars.jpeg\" alt=\"Sidebars\" /></p>\n<p>Thankfully, this can easily be fixed. Apple offers a new property on the <code>UISplitViewController</code>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// The background style of the primary view controller.</span>\n\n<span class=\"keyword\">@available</span>(iOS <span class=\"number\">13.0</span>, *)\n\n<span class=\"keyword\">open var</span> primaryBackgroundStyle: <span class=\"type\">UISplitViewController</span>.<span class=\"type\">BackgroundStyle</span>\n</code></pre></code></pre>\n<p>If you're on Catalyst, you can set this to <code>.sidebar</code> in order to get the macOS native sidebar look and feel from the right side of the screenshot above:</p>\n<pre class=\"Swift\"><code>primaryBackgroundStyle = .<span class=\"dotAccess\">sidebar</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I create a sidebar?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nSidebars are a staple of macOS. Many apps on macOS have sidebars and use them to support a huge variety of usage scenarios. Apple added sidebar support right into Catalyst. By default, any Master-Detail view implemented using the `UISplitViewController` will inhibit macOS sidebar behaviour. However, if you just do that, the sidebar contents (that is, the Master part of the Master Detail View) will look strangely out of place. The rows still look like normal UIKit Rows:\n\n![Sidebars](/img-content/catalyst/sidebars.jpeg)\n\nThankfully, this can easily be fixed. Apple offers a new property on the `UISplitViewController`:\n\n``` swift\n// The background style of the primary view controller.\n@available(iOS 13.0, *)\nopen var primaryBackgroundStyle: UISplitViewController.BackgroundStyle\n```\n\nIf you're on Catalyst, you can set this to `.sidebar` in order to get the macOS native sidebar look and feel from the right side of the screenshot above:\n\n``` swift\nprimaryBackgroundStyle = .sidebar\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/fixed_size_sequences.md":["47dcd8aff2cdfd98",{"identifier":"348ba67c","filename":"fixed_size_sequences.md","info":{"title":"Fixed-Size Sequences","tags":["tuples"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-fixedsize-sequences.html","content":"<h1>Fixed-Size Sequences</h1>\n<p>Another area where tuples can be used is when you intend to constrain a\ntype to a fixed number of items. Imagine an object that calculates\nvarious statistics for each month in a year. You need to store a certain\nInteger value for each month separately. The solution that comes to mind\nfirst would of course be:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> monthValuesArray: [<span class=\"type\">Int</span>]\n</code></pre></code></pre>\n<p>However, in this case we don't know whether the property indeed\ncontains 12 elements. A user of our object could accidentally insert 13\nvalues, or 11. We can't tell the type checker that this is a fixed size\narray of 12 items. With a tuple, this specific constraint can easily\nbe put into place:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> monthValues: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)\n</code></pre></code></pre>\n<p>The alternative would be to have the constraining logic in the object's\nfunctionality (say via a <code>guard</code> statement); however, this would be a\nrun time check. The tuple check happens at compile time; your code\nwon't even compile if you try to give 11 months to your object.</p>\n","raw_content":"[frontMatter]\ntitle = \"Fixed-Size Sequences\"\ntags = [\"tuples\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Fixed-Size Sequences\n\nAnother area where tuples can be used is when you intend to constrain a\ntype to a fixed number of items. Imagine an object that calculates\nvarious statistics for each month in a year. You need to store a certain\nInteger value for each month separately. The solution that comes to mind\nfirst would of course be:\n\n``` Swift\nvar monthValuesArray: [Int]\n```\n\nHowever, in this case we don\\'t know whether the property indeed\ncontains 12 elements. A user of our object could accidentally insert 13\nvalues, or 11. We can\\'t tell the type checker that this is a fixed size\narray of 12 items. With a tuple, this specific constraint can easily\nbe put into place:\n\n``` Swift\nvar monthValues: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int)\n```\n\nThe alternative would be to have the constraining logic in the object\\'s\nfunctionality (say via a `guard` statement); however, this would be a\nrun time check. The tuple check happens at compile time; your code\nwon\\'t even compile if you try to give 11 months to your object.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/limitations.md":["752c643cc47a3eb9",{"identifier":"14a3abd5","filename":"limitations.md","info":{"title":"Limitations","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-limitations.html","content":"<h1>Limitations</h1>\n<h2>Tuples</h2>\n<p>The biggest issue is, Tuple support.\nI love tuples, they make many things easier, but they're currently\nunder-documented and cannot be used in many scenarios. In terms of\nenums, you can't have tuples as the enum value:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Devices: (intro: <span class=\"type\">Int</span>, name: <span class=\"type\">String</span>) {\n\n   <span class=\"keyword\">case</span> iPhone = (intro: <span class=\"number\">2007</span>, name: \\<span class=\"string\">\"iPhone</span>\\<span class=\"string\">\"</span>)\n\n   <span class=\"keyword\">case</span> appleTV = (intro: <span class=\"number\">2006</span>, name: \\<span class=\"string\">\"Apple</span> <span class=\"type\">TV</span>\\<span class=\"string\">\"</span>)\n\n   <span class=\"keyword\">case</span> appleWatch = (intro: <span class=\"number\">2014</span>, name: \\<span class=\"string\">\"Apple</span> <span class=\"type\">Watch</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>This may not look like the best example, but once you start using enums,\nyou'll often end up in situations where you'd like to be able to do\nsomething like the above.</p>\n<h2>Default Associated Values</h2>\n<p>Another thing which you may run into is that associated values are\nalways types but you can't set a default value for those types. Imagine\nsuch an example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Characters {\n\n   <span class=\"keyword\">case</span> mage(health: <span class=\"type\">Int</span> = <span class=\"number\">70</span>, magic: <span class=\"type\">Int</span> = <span class=\"number\">100</span>, strength: <span class=\"type\">Int</span> = <span class=\"number\">30</span>)\n\n   <span class=\"keyword\">case</span> warrior(health: <span class=\"type\">Int</span> = <span class=\"number\">100</span>, magic: <span class=\"type\">Int</span> = <span class=\"number\">0</span>, strength: <span class=\"type\">Int</span> = <span class=\"number\">100</span>)\n\n   <span class=\"keyword\">case</span> neophyte(health: <span class=\"type\">Int</span> = <span class=\"number\">50</span>, magic: <span class=\"type\">Int</span> = <span class=\"number\">20</span>, strength: <span class=\"type\">Int</span> = <span class=\"number\">80</span>)\n\n}\n</code></pre></code></pre>\n<p>You could still create new cases with different values, but the default\nsettings for your character would be mapped.</p>\n","raw_content":"[frontMatter]\ntitle = \"Limitations\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Limitations\n\n## Tuples\n\nThe biggest issue is, Tuple support.\nI love tuples, they make many things easier, but they\\'re currently\nunder-documented and cannot be used in many scenarios. In terms of\nenums, you can\\'t have tuples as the enum value:\n\n``` Swift\nenum Devices: (intro: Int, name: String) {\n  case iPhone = (intro: 2007, name: \"iPhone\")\n  case appleTV = (intro: 2006, name: \"Apple TV\")\n  case appleWatch = (intro: 2014, name: \"Apple Watch\")\n}\n```\n\nThis may not look like the best example, but once you start using enums,\nyou\\'ll often end up in situations where you\\'d like to be able to do\nsomething like the above.\n\n## Default Associated Values\n\nAnother thing which you may run into is that associated values are\nalways types but you can\\'t set a default value for those types. Imagine\nsuch an example:\n\n``` Swift\nenum Characters {\n  case mage(health: Int = 70, magic: Int = 100, strength: Int = 30)\n  case warrior(health: Int = 100, magic: Int = 0, strength: Int = 100)\n  case neophyte(health: Int = 50, magic: Int = 20, strength: Int = 80)\n}\n```\n\nYou could still create new cases with different values, but the default\nsettings for your character would be mapped.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/fibonacci.md":["d44c851219f5cf16",{"identifier":"5188afd4","filename":"fibonacci.md","info":{"title":"Fibonacci","tags":["pattern matching","switch"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-fibonacci.html","content":"<h1>Fibonacci</h1>\n<p>Also, see how beautiful an implementation of the fibonacci algorithm\nlooks with pattern matching.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> fibonacci(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"call\">switch</span>(i) {\n\n     <span class=\"keyword\">case let</span> n <span class=\"keyword\">where</span> n &lt;= <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>\n\n     <span class=\"keyword\">case</span> <span class=\"number\">0</span>, <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>\n\n     <span class=\"keyword\">case let</span> n: <span class=\"keyword\">return</span> <span class=\"call\">fibonacci</span>(n - <span class=\"number\">1</span>) + <span class=\"call\">fibonacci</span>(n - <span class=\"number\">2</span>)\n\n     }\n\n}\n\n\n\n<span class=\"call\">print</span>(<span class=\"call\">fibonacci</span>(<span class=\"number\">8</span>))\n</code></pre></code></pre>\n<p>Since we're doing recursion here, this will fail to work with sufficiently large numbers\n(you'll see the dreaded <code>stack overflow</code> error)</p>\n","raw_content":"[frontMatter]\ntitle = \"Fibonacci\"\ntags = [\"pattern matching\", \"switch\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Fibonacci\n\nAlso, see how beautiful an implementation of the fibonacci algorithm\nlooks with pattern matching.\n\n``` Swift\nfunc fibonacci(i: Int) -> Int {\n    switch(i) {\n    case let n where n <= 0: return 0\n    case 0, 1: return 1\n    case let n: return fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\nprint(fibonacci(8))\n```\n\nSince we're doing recursion here, this will fail to work with sufficiently large numbers\n(you'll see the dreaded `stack overflow` error)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2019-03-17-protocol-composition-untangle-codebase.md":["734c7ebf47fcd0f6",{"identifier":"f37db680","filename":"2019-03-17-protocol-composition-untangle-codebase.md","info":{"title":"Using protocol composition to untangle your codebase","tags":["protocol","composition"],"keywords":["ios","macos","swift","protocol","composition","struct","untagle"],"category":[],"created":"2019-03-17 10:30:30","description":"A simple way to untangle your codebase via protocols. Particularly useful for project configurations.","description_html":"<p>A simple way to untangle your codebase via protocols. Particularly useful for project configurations.</p>\n","published":true,"slug":"2019-03-17-protocol-composition-untangle-codebase.html","meta":{"feature_image":"/img-content/2019-03-17-protocol-composition-untangle-codebase.jpg","thumbnail":"/img-content/protocol_composition.png"},"created_timestamp":1552818630,"date":"2019-03-17T10:30:30","date_info":{"year":2019,"month":3,"day":17,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2019-03-17-protocol-composition-untangle-codebase.html","content":"<p>In this article, I'd like to discuss the benefit of splitting protocols\ninto smaller mini-protocols. In order to exemplify this, we will look\ninto the imaginary implementation of a static site generator in Swift.\nWe will only cover the <code>structure</code> of a site generator, though. The\nwriting of an actual static site generator in Swift has to wait for\nanother time.</p>\n<p>Static site generators take articles (usually written in Markdown) and\nconvert them into HTML. This, by itself, is easy, but there is a lot of\nadditional functionality that needs to be implemented for a static site\ngenerator to be actually useful. Examples are:</p>\n<ul>\n<li>Google sitemap support</li>\n<li>RSS feeds</li>\n<li>Copying assets (images, css, js)</li>\n<li>Calculating tag clouds</li>\n</ul>\n<h2>Configuration</h2>\n<p>The structure of different websites varies to a large degree, it is\nalmost safe to say that no two websites are equal. In order to\naccomodate for that, our static site generator will need to provide a\nconfiguration which allows the consumer to configure it depending on the\nneeds of the particular website. Obviously, we will have all time\nfavorites, such as the <code>title</code>, the <code>address</code> of the server,\n<code>meta tags</code>, or the name of the <code>author</code>. We will store this\nconfiguration in a Swift <code>struct</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Configuration {\n\n   <span class=\"keyword\">let</span> title = \\<span class=\"string\">\"My</span> <span class=\"type\">Website</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> address = \\<span class=\"string\">\"https</span>://terhech.<span class=\"property\">de</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> metaTags = [\\<span class=\"string\">\"swift</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"website</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"furry</span>\\<span class=\"string\">\"</span>]\n\n   <span class=\"keyword\">let</span> author = \\<span class=\"string\">\"Benedikt</span> <span class=\"type\">Terhechte</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>When our app starts up, we create one <code>Configuration</code> and\ndependency-inject it into all of our components so that we can access\nthe configuration properties:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> HTMLRenderer {\n\n   <span class=\"keyword\">private let</span> config: <span class=\"type\">Configuration</span>\n\n     <span class=\"keyword\">init</span>(with configuration: <span class=\"type\">Configuration</span>) {\n\n       config = configuration\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Here is an example of our <code>HTMLRenderer</code> and how it uses the <code>config</code>\nproperty to access the <code>Configuration</code> values via the <code>private</code>,\ndependency-injected, <code>config</code> property:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Somewhere in our `HTMLRenderer` code</span>\n\ntemplate.<span class=\"call\">write</span>(<span class=\"type\">Tag</span>(name: \\<span class=\"string\">\"title</span>\\<span class=\"string\">\"</span>, \n\n                   value: config.<span class=\"property\">title</span>))\n\ntemplate.<span class=\"call\">write</span>(<span class=\"type\">Tag</span>(name: \\<span class=\"string\">\"meta</span>\\<span class=\"string\">\"</span>, \n\n              attributes: [\\<span class=\"string\">\"content</span>\\<span class=\"string\">\"</span>: config.<span class=\"property\">metaTags</span>.<span class=\"call\">join</span>(\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>),\n\n                           \\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"keywords</span>\\<span class=\"string\">\"</span>]))\n</code></pre></code></pre>\n<p>As we continue working on our engine we also add additional\nconfiguration properties. The RSS Feed, the sitemap generator, the\nassets and so on all require additional configuration properties.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Configuration {\n\n   ...\n\n   <span class=\"comment\">// RSS Properties</span>\n\n   <span class=\"keyword\">let</span> rssAddress = \\<span class=\"string\">\"https</span>://terhech.<span class=\"property\">de</span>/feed.<span class=\"property\">rss</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> rssTitle = \\<span class=\"string\">\"My</span> <span class=\"type\">Website Feed</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> maxAmountOfArticlesInRSS = <span class=\"number\">10</span>\n\n\n\n   <span class=\"comment\">// Sitemap configuration</span>\n\n   <span class=\"keyword\">let</span> sitemapFilename = \\<span class=\"string\">\"sitemap</span>.<span class=\"property\">xml</span>\\<span class=\"string\">\"</span>\n\n\n\n   <span class=\"comment\">// Copy Folders Configuration</span>\n\n   <span class=\"keyword\">let</span> foldersToCopy = [\\<span class=\"string\">\"css</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"js</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"img</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"playgrounds</span>\\<span class=\"string\">\"</span>]\n\n}\n</code></pre></code></pre>\n<p>At first, this works great. However, after some time we decide that\nwe'd like to split up our codebase into multiple frameworks. The reason\nis that much of the code that we wrote (such as our <code>RSS</code> generator) can\nalso be used in other projects.</p>\n<p>Now, we have the problem that most of our code is dependent on our\ncentral <code>Configuration</code> structure. For example, if somebody just wanted\nto use our <code>SitemapGenerator.framework</code>, they'd need to initialize a\n<code>Configuration</code> <code>struct</code>, even though they don't need 90% of the actual\nconfiguration.</p>\n<p>In order to solve this, we decide to split the configuration up into\nmany smaller configurations, each for their specific use case:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> HTMLConfiguration {\n\n   <span class=\"keyword\">let</span> title = \\<span class=\"string\">\"My</span> <span class=\"type\">Website</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> address = \\<span class=\"string\">\"https</span>://terhech.<span class=\"property\">de</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> metaTags = [\\<span class=\"string\">\"swift</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"website</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"furry</span>\\<span class=\"string\">\"</span>]\n\n   <span class=\"keyword\">let</span> author = \\<span class=\"string\">\"Benedikt</span> <span class=\"type\">Terhechte</span>\\<span class=\"string\">\"</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> RSSConfiguration {\n\n   <span class=\"keyword\">let</span> rssAddress = \\<span class=\"string\">\"https</span>://terhech.<span class=\"property\">de</span>/feed.<span class=\"property\">rss</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> rssTitle = \\<span class=\"string\">\"My</span> <span class=\"type\">Website Feed</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">let</span> maxAmountOfArticlesInRSS = <span class=\"number\">10</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> SitemapConfiguration {\n\n   <span class=\"keyword\">let</span> sitemapFilename = \\<span class=\"string\">\"sitemap</span>.<span class=\"property\">xml</span>\\<span class=\"string\">\"</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> FoldersConfiguration {\n\n   <span class=\"keyword\">let</span> foldersToCopy = [\\<span class=\"string\">\"css</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"js</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"img</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"playgrounds</span>\\<span class=\"string\">\"</span>]\n\n}\n</code></pre></code></pre>\n<p>Not only does this solve our problem, we also have the added benefit of\nnot needing additional documentation in the source code as the names of\nthe <code>struct</code> types are now self-explanatory.</p>\n<p>While this is clearly better in terms of simplifying the experience of\nusing our many frameworks (such as the <code>SitemapGenerator.framework</code>), it\nworsens the situation for our actual main product, the static site\ngenerator.</p>\n<p>In there, we have many components that use more than just one of our\nframeworks. They suddenly require us to dependency-inject multiple,\ndifferent, configurations in their initializer.</p>\n<p>Consider our HTML-Renderer which internally renders the HTML file but\nalso uses our <code>RSS.framework</code> and <code>SitemapGenerator.framework</code> to render\nthe sitemap and the rss feed. It now requires three different\nconfigurations for startup:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> HTMLRenderer {\n\n   <span class=\"keyword\">init</span>(htmlConfiguration: <span class=\"type\">HTMLConfiguration</span>, \n\n       sitemapConfiguration: <span class=\"type\">SitemapConfiguration</span>, \n\n       rssConfiguration: <span class=\"type\">RSSConfiguration</span>) {\n\n     ..\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Clearly, this is already getting out of hand, and it may become even\nworse once we incoroporate more functionality into our static site\ngenerator.</p>\n<p>So, how do we solve this? As always - with protocols of course.</p>\n<h2>Protocols to the rescue</h2>\n<p>Instead of defining <code>struct</code> types for our configurations, we can\nobviously also define <code>protocol</code> types:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> HTMLConfigurationProtocol {\n\n   <span class=\"keyword\">var</span> title: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"keyword\">var</span> address: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"keyword\">var</span> metaTags: [<span class=\"type\">String</span>] { <span class=\"keyword\">get</span> }\n\n   <span class=\"keyword\">var</span> author: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"keyword\">protocol</span> RSSConfigurationProtocol {\n\n   <span class=\"keyword\">var</span> rssAddress: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"keyword\">var</span> rssTitle: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"keyword\">var</span> maxAmountOfArticlesInRSS: <span class=\"type\">Int</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"keyword\">protocol</span> SitemapConfigurationProtocol {\n\n   <span class=\"keyword\">var</span> sitemapFilename: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"keyword\">protocol</span> FoldersConfigurationProtocol {\n\n   <span class=\"keyword\">var</span> foldersToCopy: [<span class=\"type\">String</span>] { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>So, how does this exactly solve our problem? Our renderer code still\nlooks just as messy, only that now we added one level of indirection:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> HTMLRenderer {\n\n   <span class=\"keyword\">init</span>(htmlConfiguration: <span class=\"type\">HTMLConfigurationProtocol</span>, \n\n       sitemapConfiguration: <span class=\"type\">SitemapConfigurationProtocol</span>, \n\n       rssConfiguration: <span class=\"type\">RSSConfigurationProtocol</span>) {\n\n     ..\n\n   }\n\n}\n</code></pre></code></pre>\n<p>This, however, is not our renderer's final form.</p>\n<h2>Protocol Composition</h2>\n<p>Swift has a particular nifty feature that allows you to define that a\ntype has to conform to a number of protocols by joining them via <code>&amp;</code>. We\ncan use this in our renderer to state that it requires a configuration\ntype that conforms to the <code>HTMLConfigurationProtocol</code>, the\n<code>SitemapConfigurationProtocol</code> and the <code>RSSConfigurationProtocol</code>:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">struct</span> HTMLRenderer {\n\n   <span class=\"keyword\">init</span>(configuration: <span class=\"type\">HTMLConfigurationProtocol</span> &amp; \n\n           <span class=\"type\">SitemapConfigurationProtocol</span> &amp; \n\n           <span class=\"type\">RSSConfigurationProtocol</span>) {\n\n     ..\n\n   }\n\n}\n\n\n</code></pre></code></pre>\n<p>What we're doing here is telling Swift that only a type that conforms\nto <code>HTMLConfigurationProtocol</code>, <code>SitemapConfigurationProtocol</code>, and\n<code>RSSConfigurationProtocol</code> <strong>at the same time</strong> is allowed to be used\nfor the <code>configuration</code> of the <code>HTMLRenderer</code>.</p>\n<p>This solves our problem in a very beautiful way:</p>\n<ul>\n<li>Our specific frameworks just know about their specific Configuration\nprotocols (such as <code>SitemapConfigurationProtocol</code>).</li>\n<li>Our overarching <strong>static site generator</strong> knows about all the\nprotocols of the sub-frameworks it incorporates and can conform to\nthem accordingly</li>\n<li>New projects leveraging one of our frameworks can easily extend\ntheir existing configuration to conform to the relevant protocol and\ndon't need to introduce a wholy new type.</li>\n</ul>\n<p>Most importantly, our <code>Configuration</code> struct in our main\n<code>Static Site Generator</code> is just one type again, it just conforms to\nmultiple protocols.</p>\n","raw_content":"[frontMatter]\ndescription = \"A simple way to untangle your codebase via protocols. Particularly useful for project configurations.\"\ntitle = \"Using protocol composition to untangle your codebase\"\ncreated = \"2019-03-17\"\npublished = true\nkeywords = [\"ios\", \"macos\", \"swift\", \"protocol\", \"composition\", \"struct\", \"untagle\"]\nslug = \"2019-03-17-protocol-composition-untangle-codebase.html\"\ntags = [\"protocol\", \"composition\"]\n[meta]\nfeature_image = \"/img-content/2019-03-17-protocol-composition-untangle-codebase.jpg\"\nthumbnail = \"/img-content/protocol_composition.png\"\n---\n\nIn this article, I\\'d like to discuss the benefit of splitting protocols\ninto smaller mini-protocols. In order to exemplify this, we will look\ninto the imaginary implementation of a static site generator in Swift.\nWe will only cover the `structure` of a site generator, though. The\nwriting of an actual static site generator in Swift has to wait for\nanother time.\n\nStatic site generators take articles (usually written in Markdown) and\nconvert them into HTML. This, by itself, is easy, but there is a lot of\nadditional functionality that needs to be implemented for a static site\ngenerator to be actually useful. Examples are:\n\n-   Google sitemap support\n-   RSS feeds\n-   Copying assets (images, css, js)\n-   Calculating tag clouds\n\n## Configuration\n\nThe structure of different websites varies to a large degree, it is\nalmost safe to say that no two websites are equal. In order to\naccomodate for that, our static site generator will need to provide a\nconfiguration which allows the consumer to configure it depending on the\nneeds of the particular website. Obviously, we will have all time\nfavorites, such as the `title`, the `address` of the server,\n`meta tags`, or the name of the `author`. We will store this\nconfiguration in a Swift `struct`:\n\n``` Swift\nstruct Configuration {\n  let title = \"My Website\"\n  let address = \"https://terhech.de\"\n  let metaTags = [\"swift\", \"website\", \"furry\"]\n  let author = \"Benedikt Terhechte\"\n}\n```\n\nWhen our app starts up, we create one `Configuration` and\ndependency-inject it into all of our components so that we can access\nthe configuration properties:\n\n``` Swift\nstruct HTMLRenderer {\n  private let config: Configuration\n    init(with configuration: Configuration) {\n      config = configuration\n    }\n}\n```\n\nHere is an example of our `HTMLRenderer` and how it uses the `config`\nproperty to access the `Configuration` values via the `private`,\ndependency-injected, `config` property:\n\n``` Swift\n// Somewhere in our `HTMLRenderer` code\ntemplate.write(Tag(name: \"title\", \n                  value: config.title))\ntemplate.write(Tag(name: \"meta\", \n             attributes: [\"content\": config.metaTags.join(\", \"),\n                          \"name\": \"keywords\"]))\n```\n\nAs we continue working on our engine we also add additional\nconfiguration properties. The RSS Feed, the sitemap generator, the\nassets and so on all require additional configuration properties.\n\n``` Swift\nstruct Configuration {\n  ...\n  // RSS Properties\n  let rssAddress = \"https://terhech.de/feed.rss\"\n  let rssTitle = \"My Website Feed\"\n  let maxAmountOfArticlesInRSS = 10\n\n  // Sitemap configuration\n  let sitemapFilename = \"sitemap.xml\"\n\n  // Copy Folders Configuration\n  let foldersToCopy = [\"css\", \"js\", \"img\", \"playgrounds\"]\n}\n```\n\nAt first, this works great. However, after some time we decide that\nwe\\'d like to split up our codebase into multiple frameworks. The reason\nis that much of the code that we wrote (such as our `RSS` generator) can\nalso be used in other projects.\n\nNow, we have the problem that most of our code is dependent on our\ncentral `Configuration` structure. For example, if somebody just wanted\nto use our `SitemapGenerator.framework`, they\\'d need to initialize a\n`Configuration` `struct`, even though they don\\'t need 90% of the actual\nconfiguration.\n\nIn order to solve this, we decide to split the configuration up into\nmany smaller configurations, each for their specific use case:\n\n``` Swift\nstruct HTMLConfiguration {\n  let title = \"My Website\"\n  let address = \"https://terhech.de\"\n  let metaTags = [\"swift\", \"website\", \"furry\"]\n  let author = \"Benedikt Terhechte\"\n}\n\nstruct RSSConfiguration {\n  let rssAddress = \"https://terhech.de/feed.rss\"\n  let rssTitle = \"My Website Feed\"\n  let maxAmountOfArticlesInRSS = 10\n}\n\nstruct SitemapConfiguration {\n  let sitemapFilename = \"sitemap.xml\"\n}\n\nstruct FoldersConfiguration {\n  let foldersToCopy = [\"css\", \"js\", \"img\", \"playgrounds\"]\n}\n```\n\nNot only does this solve our problem, we also have the added benefit of\nnot needing additional documentation in the source code as the names of\nthe `struct` types are now self-explanatory.\n\nWhile this is clearly better in terms of simplifying the experience of\nusing our many frameworks (such as the `SitemapGenerator.framework`), it\nworsens the situation for our actual main product, the static site\ngenerator.\n\nIn there, we have many components that use more than just one of our\nframeworks. They suddenly require us to dependency-inject multiple,\ndifferent, configurations in their initializer.\n\nConsider our HTML-Renderer which internally renders the HTML file but\nalso uses our `RSS.framework` and `SitemapGenerator.framework` to render\nthe sitemap and the rss feed. It now requires three different\nconfigurations for startup:\n\n``` Swift\nstruct HTMLRenderer {\n  init(htmlConfiguration: HTMLConfiguration, \n      sitemapConfiguration: SitemapConfiguration, \n      rssConfiguration: RSSConfiguration) {\n    ..\n  }\n}\n```\n\nClearly, this is already getting out of hand, and it may become even\nworse once we incoroporate more functionality into our static site\ngenerator.\n\nSo, how do we solve this? As always - with protocols of course.\n\n## Protocols to the rescue\n\nInstead of defining `struct` types for our configurations, we can\nobviously also define `protocol` types:\n\n``` Swift\nprotocol HTMLConfigurationProtocol {\n  var title: String { get }\n  var address: String { get }\n  var metaTags: [String] { get }\n  var author: String { get }\n}\n\nprotocol RSSConfigurationProtocol {\n  var rssAddress: String { get }\n  var rssTitle: String { get }\n  var maxAmountOfArticlesInRSS: Int { get }\n}\n\nprotocol SitemapConfigurationProtocol {\n  var sitemapFilename: String { get }\n}\n\nprotocol FoldersConfigurationProtocol {\n  var foldersToCopy: [String] { get }\n}\n```\n\nSo, how does this exactly solve our problem? Our renderer code still\nlooks just as messy, only that now we added one level of indirection:\n\n``` Swift\nstruct HTMLRenderer {\n  init(htmlConfiguration: HTMLConfigurationProtocol, \n      sitemapConfiguration: SitemapConfigurationProtocol, \n      rssConfiguration: RSSConfigurationProtocol) {\n    ..\n  }\n}\n```\n\nThis, however, is not our renderer\\'s final form.\n\n## Protocol Composition\n\nSwift has a particular nifty feature that allows you to define that a\ntype has to conform to a number of protocols by joining them via `&`. We\ncan use this in our renderer to state that it requires a configuration\ntype that conforms to the `HTMLConfigurationProtocol`, the\n`SitemapConfigurationProtocol` and the `RSSConfigurationProtocol`:\n\n``` Swift\n\nstruct HTMLRenderer {\n  init(configuration: HTMLConfigurationProtocol & \n          SitemapConfigurationProtocol & \n          RSSConfigurationProtocol) {\n    ..\n  }\n}\n\n```\n\nWhat we\\'re doing here is telling Swift that only a type that conforms\nto `HTMLConfigurationProtocol`, `SitemapConfigurationProtocol`, and\n`RSSConfigurationProtocol` **at the same time** is allowed to be used\nfor the `configuration` of the `HTMLRenderer`.\n\nThis solves our problem in a very beautiful way:\n\n-   Our specific frameworks just know about their specific Configuration\n    protocols (such as `SitemapConfigurationProtocol`).\n-   Our overarching **static site generator** knows about all the\n    protocols of the sub-frameworks it incorporates and can conform to\n    them accordingly\n-   New projects leveraging one of our frameworks can easily extend\n    their existing configuration to conform to the relevant protocol and\n    don\\'t need to introduce a wholy new type.\n\nMost importantly, our `Configuration` struct in our main\n`Static Site Generator` is just one type again, it just conforms to\nmultiple protocols.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/diving_in/methods_and_properties.md":["b953e02799f3b15d",{"identifier":"28dff355","filename":"methods_and_properties.md","info":{"title":"Methods and Properties","tags":["enum","property","method"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-methods-and-properties.html","content":"<h1>Methods and Properties</h1>\n<p>Swift <code>enum</code> types can have methods and properties attached to them. This works exactly like you'd do it for\n<code>class</code> or <code>struct</code> types. Here is a very simple example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Transportation {\n\n   <span class=\"keyword\">case</span> car(<span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> train(<span class=\"type\">Int</span>)\n\n\n\n   <span class=\"keyword\">func</span> distance() -&gt; <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">car</span>(<span class=\"keyword\">let</span> miles): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(miles) miles by car\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">train</span>(<span class=\"keyword\">let</span> miles): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(miles) miles by train\\<span class=\"string\">\"</span>\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>The main difference to <code>struct</code> or <code>class</code> types is that you can <code>switch</code> on <code>self</code> within the method\nin order to calculate the output.</p>\n<p>Here is another, more involved, example where we use the <code>enum values</code> to determine the numerical attributes of a character in a method.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Wearable {\n\n     <span class=\"keyword\">enum</span> Weight: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">1</span>\n\n     }\n\n     <span class=\"keyword\">enum</span> Armor: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">2</span>\n\n     }\n\n     <span class=\"keyword\">case</span> helmet(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n\n\n     <span class=\"keyword\">func</span> attributes() -&gt; (weight: <span class=\"type\">Int</span>, armor: <span class=\"type\">Int</span>) {\n\n        <span class=\"keyword\">switch self</span> {\n\n        <span class=\"keyword\">case</span> .<span class=\"dotAccess\">helmet</span>(<span class=\"keyword\">let</span> w, <span class=\"keyword\">let</span> a): \n\n           <span class=\"keyword\">return</span> (weight: w.<span class=\"property\">rawValue</span> * <span class=\"number\">2</span>, armor: a.<span class=\"property\">rawValue</span> * <span class=\"number\">4</span>)\n\n        }\n\n     }\n\n}\n\n<span class=\"keyword\">let</span> woodenHelmetProps = <span class=\"type\">Wearable</span>.<span class=\"call\">helmet</span>(weight: .<span class=\"dotAccess\">light</span>, armor: .<span class=\"dotAccess\">light</span>)\n\n     .<span class=\"call\">attributes</span>()\n</code></pre></code></pre>\n<h3>Properties</h3>\n<p>Enums don't allow for adding stored properties. This means the following does not work:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">case</span> iPad\n\n   <span class=\"keyword\">case</span> iPhone\n\n   \n\n   <span class=\"keyword\">let</span> introduced: <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Here, we'd like to store an Apple device together with the year when\nit was introduced. However, this does not compile.</p>\n<p>Even though you can't add actual stored properties to an <code>enum</code>, you\ncan still create computed properties. Their contents, of course, can be\nbased on the <strong>enum value</strong> or <strong>enum associated value</strong>. They're read-only though.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">case</span> iPad,\n\n   <span class=\"keyword\">case</span> iPhone\n\n\n\n   <span class=\"keyword\">var</span> introduced: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">iPhone</span>: <span class=\"keyword\">return</span> <span class=\"number\">2007</span>\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">iPad</span>: <span class=\"keyword\">return</span> <span class=\"number\">2010</span>\n\n      }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>This works great as the year of the introduction of an Apple device never changes.\nYou couldn't use this if you'd like to store mutable / changing information. In those cases\nyou'd always use <code>associated values</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character {\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> warior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>Also, you can always still add properties for easy retrieval of the <code>associated value</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Character</span> {\n\n   <span class=\"keyword\">var</span> level: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">wizard</span>(<span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> level): <span class=\"keyword\">return</span> level\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">warior</span>(<span class=\"keyword\">_</span>, <span class=\"keyword\">let</span> level): <span class=\"keyword\">return</span> level\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<h3>Static Methods</h3>\n<p>You can also have static methods on <code>enums</code>, i.e. in order to create an\n<code>enum</code> from a non-value type.</p>\n<p>Static methods are methods you can call on the name of the type instead of\na specific instance of the type. In this example we add a static method\nto our <code>enum Device</code> which returns the most recently released device:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">static var</span> newestDevice: <span class=\"type\">Device</span> {\n\n     <span class=\"keyword\">return</span> .<span class=\"dotAccess\">appleWatch</span>\n\n   }\n\n\n\n   <span class=\"keyword\">case</span> iPad,\n\n   <span class=\"keyword\">case</span> iPhone\n\n   <span class=\"keyword\">case</span> appleWatch\n\n}\n</code></pre></code></pre>\n<h3>Mutating Methods</h3>\n<p>Methods can be declared <code>mutating</code>. They're then allowed to change the\n<code>case</code> of the underlying <code>self</code> parameter. Imagine a lamp that has three states:\n<code>off</code>, <code>low</code>, <code>bright</code> where <code>low</code> is low light and <code>bright</code> a very strong light.\nWe want a function called <code>next</code> that switches to the next state:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> TriStateSwitch {\n\n     <span class=\"keyword\">case</span> off, low, bright\n\n     <span class=\"keyword\">mutating func</span> next() {\n\n         <span class=\"keyword\">switch self</span> {\n\n         <span class=\"keyword\">case</span> .<span class=\"dotAccess\">off</span>:\n\n             <span class=\"keyword\">self</span> = low\n\n         <span class=\"keyword\">case</span> .<span class=\"dotAccess\">low</span>:\n\n             <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">bright</span>\n\n         <span class=\"keyword\">case</span> high:\n\n             <span class=\"keyword\">self</span> = off\n\n         }\n\n     }\n\n}\n\n<span class=\"keyword\">var</span> ovenLight = <span class=\"type\">TriStateSwitch</span>.<span class=\"property\">low</span>\n\novenLight.<span class=\"call\">next</span>()\n\n<span class=\"comment\">// ovenLight is now equal to .bright</span>\n\novenLight.<span class=\"call\">next</span>()\n\n<span class=\"comment\">// ovenLight is now equal to .off</span>\n</code></pre></code></pre>\n<p>Before we look at advanced <code>enum</code> usage, we'll do a brief recap of what we've\nlearned in this section so far.</p>\n","raw_content":"[frontMatter]\ntitle = \"Methods and Properties\"\ntags = [\"enum\", \"property\", \"method\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Methods and Properties\n\nSwift `enum` types can have methods and properties attached to them. This works exactly like you'd do it for\n`class` or `struct` types. Here is a very simple example:\n\n``` Swift\nenum Transportation {\n  case car(Int)\n  case train(Int)\n\n  func distance() -> String {\n    switch self {\n    case .car(let miles): return \"\\(miles) miles by car\"\n    case .train(let miles): return \"\\(miles) miles by train\"\n    }\n  }\n}\n```\n\nThe main difference to `struct` or `class` types is that you can `switch` on `self` within the method\nin order to calculate the output.\n\nHere is another, more involved, example where we use the `enum values` to determine the numerical attributes of a character in a method.\n\n``` Swift\nenum Wearable {\n    enum Weight: Int {\n        case light = 1\n    }\n    enum Armor: Int {\n        case light = 2\n    }\n    case helmet(weight: Weight, armor: Armor)\n\n    func attributes() -> (weight: Int, armor: Int) {\n       switch self {\n       case .helmet(let w, let a): \n          return (weight: w.rawValue * 2, armor: a.rawValue * 4)\n       }\n    }\n}\nlet woodenHelmetProps = Wearable.helmet(weight: .light, armor: .light)\n    .attributes()\n```\n\n### Properties\n\nEnums don't allow for adding stored properties. This means the following does not work:\n\n``` Swift\nenum Device {\n  case iPad\n  case iPhone\n  \n  let introduced: Int\n}\n```\n\nHere, we'd like to store an Apple device together with the year when\nit was introduced. However, this does not compile.\n\nEven though you can\\'t add actual stored properties to an `enum`, you\ncan still create computed properties. Their contents, of course, can be\nbased on the **enum value** or **enum associated value**. They're read-only though.\n\n``` Swift\nenum Device {\n  case iPad,\n  case iPhone\n\n  var introduced: Int {\n    switch self {\n    case .iPhone: return 2007\n    case .iPad: return 2010\n     }\n  }\n}\n```\n\nThis works great as the year of the introduction of an Apple device never changes.\nYou couldn't use this if you'd like to store mutable / changing information. In those cases\nyou'd always use `associated values`:\n\n``` Swift\nenum Character {\n  case wizard(name: String, level: Int)\n  case warior(name: String, level: Int)\n}\n```\n\nAlso, you can always still add properties for easy retrieval of the `associated value`:\n\n``` Swift\nextension Character {\n  var level: Int {\n    switch self {\n    case .wizard(_, let level): return level\n    case .warior(_, let level): return level\n    }\n  }\n}\n```\n\n### Static Methods\n\nYou can also have static methods on `enums`, i.e. in order to create an\n`enum` from a non-value type. \n\nStatic methods are methods you can call on the name of the type instead of\na specific instance of the type. In this example we add a static method\nto our `enum Device` which returns the most recently released device:\n\n``` Swift\nenum Device {\n  static var newestDevice: Device {\n    return .appleWatch\n  }\n\n  case iPad,\n  case iPhone\n  case appleWatch\n}\n```\n\n### Mutating Methods\n\nMethods can be declared `mutating`. They\\'re then allowed to change the\n`case` of the underlying `self` parameter. Imagine a lamp that has three states:\n`off`, `low`, `bright` where `low` is low light and `bright` a very strong light.\nWe want a function called `next` that switches to the next state:\n\n``` Swift\nenum TriStateSwitch {\n    case off, low, bright\n    mutating func next() {\n        switch self {\n        case .off:\n            self = low\n        case .low:\n            self = .bright\n        case high:\n            self = off\n        }\n    }\n}\nvar ovenLight = TriStateSwitch.low\novenLight.next()\n// ovenLight is now equal to .bright\novenLight.next()\n// ovenLight is now equal to .off\n```\n\nBefore we look at advanced `enum` usage, we'll do a brief recap of what we've \nlearned in this section so far.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/optionals/how_to_handle_optionals.md":["dba1f7e73a44a27c",{"identifier":"3e973440","filename":"how_to_handle_optionals.md","info":{"title":"How to handle optionals","tags":["optionals"],"keywords":[],"category":[],"created":"2019-03-02 16:04:26","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551542666,"date":"2019-03-02T16:04:26","date_info":{"year":2019,"month":3,"day":2,"hour":16,"minute":4,"second":26},"identifier":"","indexed":true},"slug":"//2019-3-2-how-to-handle-optionals.html","content":"<h1>How to handle optionals</h1>\n<p>As we saw in the <a href=\"javascript:prev()\">previous</a> chapter, Optionals are\nreally just <code>enum</code> types. However, as they're deeply ingrained into\nthe language, Swift offers a lot of additional possibilities of\nhandling <code>Optionals</code>.</p>\n<h2>If Let</h2>\n<p>Certainly the most used one is the so-called if let. You're basically telling\nSwift &quot;If this optional value <code>myOptionalValue</code> actually contains a value, please give me the contained value\ninto the variable named <code>myUnwrappedValue</code>&quot;:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> myUnwrappedValue = myOptionalValue {\n\n   <span class=\"call\">print</span>(myUnwrappedValue)\n\n}\n</code></pre></code></pre>\n<p>If <code>myOptionalValue</code> is actually empty, then the <code>print</code> statement\nwould never be executed. As with any typical <code>if</code> statement, this\ncan also have an else expression:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> myUnwrappedValue = myOptionalValue {\n\n   <span class=\"call\">print</span>(myUnwrappedValue)\n\n} <span class=\"keyword\">else</span> {\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"No</span> <span class=\"type\">Value</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>You can also combine multiple <code>if let</code> statements if you need to handle\nmultiple <code>Optional</code> values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> firstValue = firstOptionalValue,\n\n    <span class=\"keyword\">let</span> secondValue = secondOptionalValue,\n\n    <span class=\"keyword\">let</span> thirdValue = <span class=\"call\">thirdOptionalValue</span> {\n\n    <span class=\"call\">print</span>(firstValue, secondValue, thirdValue)\n\n} \n</code></pre></code></pre>\n<p>Finally, you can mix and match the <code>if let</code> pattern with normal if expressions:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> firstValue = firstOptionalValue,\n\n    firstValue &gt; <span class=\"number\">10</span>\n\n    <span class=\"keyword\">let</span> secondValue = secondOptionalValue,\n\n    secondValue == \\<span class=\"string\">\"HTTP</span>\\<span class=\"string\">\"</span>,\n\n    <span class=\"keyword\">let</span> thirdValue = <span class=\"call\">thirdOptionalValue</span> {\n\n    <span class=\"call\">print</span>(firstValue, secondValue, thirdValue)\n\n} \n</code></pre></code></pre>\n<p>In this example, we only print the three values if the firstOptionalValue is not empty and has a value &gt; 10, and if the second optional value is not empty and has the value &quot;HTTP&quot; and if the third optional value is not empty.</p>\n<h2>Guard</h2>\n<p>Another nice feature of Swift are the <code>guard</code> statements. They're basically like inverted <code>if</code> statements. You usually use them at the beginning of a block of code to make sure that all your requirements are held. The main difference compared to <code>if let</code> is that you're required to leave the current scope (i.e. <code>return</code>, <code>continue</code>, or <code>break</code>) if the <code>guard</code> does not succeed. Lets look at this nonsensical function that tries to do addition with two <code>Optional</code> <code>Int</code> values. For that to work, we need to make sure that</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> addOptionals(firstNumber: <span class=\"type\">Int</span>?, secondNumber: <span class=\"type\">Int</span>?) -&gt; <span class=\"type\">Int</span>? {\n\n   <span class=\"keyword\">guard let</span> first = firstNumber, <span class=\"keyword\">let</span> second = secondNumber\n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }\n\n   <span class=\"keyword\">return</span> first + second\n\n}\n</code></pre></code></pre>\n<p>So here, we do the <code>guard let</code> in order to make sure that both <code>firstNumber</code> and <code>secondNumber</code> have a value, otherwise we can't really do the addition. So if one of them (or both) don't have a value, we return early in the <code>else { return nil}</code> block.</p>\n<p>Observe how with <code>if let</code> the code-to-be-executed is within the <code>if</code> braces, while with <code>guard let</code> it is not:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if let</span> a = b {\n\n   <span class=\"call\">print</span>(b)\n\n}\n\n\n\n<span class=\"keyword\">guard let</span> a = b <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n<span class=\"call\">print</span>(b)\n</code></pre></code></pre>\n<p>This makes it easier to follow the structure of code because your main code is not nested but only at the very left side of the function.</p>\n<h2>Switch</h2>\n<p>We already mentioned this in the <a href=\"javascript:previous()\">previous</a> chapter, but you can also use <code>switch</code> to handle <code>Optionals</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> myOptionalValue {\n\n<span class=\"keyword\">case let</span> value?: <span class=\"call\">print</span>(value)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>We have a whole guide on pattern matching with Swift where this is explained\nin much more detail.</p>\n<h2>Forced Unwrap</h2>\n<p>Sometimes, if you're absolutely sure that your <code>Optional</code> has a value, you can\nalso use the <code>forced unwrap</code>. This tells Swift to handle this <code>Optional</code> value as if\nit was a non-optional value.</p>\n<p>This works great, but it means that the optional has to have a value. If\nyou try a forced unwrap on an empty optional (i.e. nil) it will cause a\nruntime error (meaning, crash).</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> oneValue: <span class=\"type\">Int</span>? = <span class=\"number\">5</span>\n\n<span class=\"keyword\">let</span> twoValue: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n\n\n\n<span class=\"call\">print</span>(oneValue!) <span class=\"comment\">// No Crash</span>\n\n<span class=\"call\">print</span>(twoValue!) <span class=\"comment\">// Crash</span>\n</code></pre></code></pre>\n<p>But wait, there's more. The next section in our guides discusses two additional methods of\nhandling optionals that are also really, really useful: Optional Chaining and Map.</p>\n","raw_content":"[frontMatter]\ntitle = \"How to handle optionals\"\ntags = [\"optionals\"]\ncreated = \"2019-03-02 16:04:26\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# How to handle optionals\n\nAs we saw in the [previous](javascript:prev()) chapter, Optionals are \nreally just `enum` types. However, as they're deeply ingrained into\nthe language, Swift offers a lot of additional possibilities of\nhandling `Optionals`.\n\n## If Let\n\nCertainly the most used one is the so-called if let. You're basically telling\nSwift \"If this optional value `myOptionalValue` actually contains a value, please give me the contained value\ninto the variable named `myUnwrappedValue`\":\n\n``` Swift\nif let myUnwrappedValue = myOptionalValue {\n  print(myUnwrappedValue)\n}\n```\n\nIf `myOptionalValue` is actually empty, then the `print` statement\nwould never be executed. As with any typical `if` statement, this\ncan also have an else expression:\n\n``` Swift\nif let myUnwrappedValue = myOptionalValue {\n  print(myUnwrappedValue)\n} else {\n  print(\"No Value\")\n}\n```\n\nYou can also combine multiple `if let` statements if you need to handle\nmultiple `Optional` values:\n\n``` Swift\nif let firstValue = firstOptionalValue,\n   let secondValue = secondOptionalValue,\n   let thirdValue = thirdOptionalValue {\n   print(firstValue, secondValue, thirdValue)\n} \n```\n\nFinally, you can mix and match the `if let` pattern with normal if expressions:\n\n``` Swift\nif let firstValue = firstOptionalValue,\n   firstValue > 10\n   let secondValue = secondOptionalValue,\n   secondValue == \"HTTP\",\n   let thirdValue = thirdOptionalValue {\n   print(firstValue, secondValue, thirdValue)\n} \n```\n\nIn this example, we only print the three values if the firstOptionalValue is not empty and has a value > 10, and if the second optional value is not empty and has the value \"HTTP\" and if the third optional value is not empty.\n\n## Guard\n\nAnother nice feature of Swift are the `guard` statements. They're basically like inverted `if` statements. You usually use them at the beginning of a block of code to make sure that all your requirements are held. The main difference compared to `if let` is that you're required to leave the current scope (i.e. `return`, `continue`, or `break`) if the `guard` does not succeed. Lets look at this nonsensical function that tries to do addition with two `Optional` `Int` values. For that to work, we need to make sure that \n\n``` Swift\nfunc addOptionals(firstNumber: Int?, secondNumber: Int?) -> Int? {\n  guard let first = firstNumber, let second = secondNumber\n        else { return nil }\n  return first + second\n}\n```\n\nSo here, we do the `guard let` in order to make sure that both `firstNumber` and `secondNumber` have a value, otherwise we can't really do the addition. So if one of them (or both) don't have a value, we return early in the `else { return nil}` block. \n\nObserve how with `if let` the code-to-be-executed is within the `if` braces, while with `guard let` it is not:\n\n``` Swift\nif let a = b {\n  print(b)\n}\n\nguard let a = b else { return }\nprint(b)\n```\n\nThis makes it easier to follow the structure of code because your main code is not nested but only at the very left side of the function.\n\n## Switch\n\nWe already mentioned this in the [previous](javascript:previous()) chapter, but you can also use `switch` to handle `Optionals`:\n\n``` Swift\nswitch myOptionalValue {\ncase let value?: print(value)\ndefault: ()\n}\n```\n\nWe have a whole guide on pattern matching with Swift where this is explained\nin much more detail.\n\n## Forced Unwrap\n\nSometimes, if you're absolutely sure that your `Optional` has a value, you can \nalso use the `forced unwrap`. This tells Swift to handle this `Optional` value as if\nit was a non-optional value.\n\nThis works great, but it means that the optional has to have a value. If\nyou try a forced unwrap on an empty optional (i.e. nil) it will cause a\nruntime error (meaning, crash).\n\n``` Swift\nlet oneValue: Int? = 5\nlet twoValue: Int? = nil\n\nprint(oneValue!) // No Crash\nprint(twoValue!) // Crash\n```\n\nBut wait, there's more. The next section in our guides discusses two additional methods of\nhandling optionals that are also really, really useful: Optional Chaining and Map.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/preferences.md":["790ed83d72b0b390",{"identifier":"7d7bafdd","filename":"preferences.md","info":{"title":"How do I implement preferences on macOS?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-implement-preferences-on-macos.html","content":"<p>In order to implement the preferences or your app, <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html\">Apple supports the <em>Settings.bundle</em> technology that has been there since iOS 2.0 (or rather, iPhoneOS 2.0)</a>. The documentation is actually so old, that it is archived and the documentation screenshots look like this:</p>\n<p><img src=\"/img-content/catalyst/settings2.jpg\" alt=\"\" />\n<img src=\"/img-content/catalyst/settings3.jpg\" alt=\"\" /></p>\n<p>On iOS, this means that you just need to add a new bundle target to your project and fill it with a collection of specially crafted <code>Plist</code> files. These settings then appear in the general iOS settings and any changes done there are stored in the <code>NSUserDefaults</code>.</p>\n<p>If your app supports settings bundles, then your Catalyst app will automatically add a Preferences window to your app that looks something like this:</p>\n<p><img src=\"/img-content/catalyst/settings1.png\" alt=\"\" /></p>\n<p>For details on how to achieve this, <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html\">refer to Apples documentation.</a></p>\n<p>Now, if you have more involved logic in your settings, special view controllers, web views, and other things, then this doesn't work well for you. <a href=\"how/logic_preferences.md\">In that case, you can read here how to implement more complex preferences on macOS.</a></p>\n<h1>Preferences with a Toolbar</h1>\n<p>Now, one thing you might wonder is how to get this wonderful Preferences Toolbar, that Apple has in their Podcast app (see the last screenshot). <a href=\"rel::how/preferences_toolbar.md\">As it turns out, this is currently completely undocumented, and we're explaining the details of how to achieve this here.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"How do I implement preferences on macOS?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nIn order to implement the preferences or your app, [Apple supports the *Settings.bundle* technology that has been there since iOS 2.0 (or rather, iPhoneOS 2.0)](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html). The documentation is actually so old, that it is archived and the documentation screenshots look like this:\n\n![](/img-content/catalyst/settings2.jpg)\n![](/img-content/catalyst/settings3.jpg)\n\nOn iOS, this means that you just need to add a new bundle target to your project and fill it with a collection of specially crafted `Plist` files. These settings then appear in the general iOS settings and any changes done there are stored in the `NSUserDefaults`.\n\nIf your app supports settings bundles, then your Catalyst app will automatically add a Preferences window to your app that looks something like this:\n\n![](/img-content/catalyst/settings1.png)\n\nFor details on how to achieve this, [refer to Apples documentation.](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html)\n\nNow, if you have more involved logic in your settings, special view controllers, web views, and other things, then this doesn't work well for you. [In that case, you can read here how to implement more complex preferences on macOS.](how/logic_preferences.md)\n\n# Preferences with a Toolbar\n\nNow, one thing you might wonder is how to get this wonderful Preferences Toolbar, that Apple has in their Podcast app (see the last screenshot). [As it turns out, this is currently completely undocumented, and we're explaining the details of how to achieve this here.](rel::how/preferences_toolbar.md)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/intro.md":["d8852cc69d39e0f6",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Advanced Enum Usage","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-advanced-enum-usage.html","content":"<h1>Advanced Enum Usage</h1>\n<p>The <code>enum</code> type is one of Swift's most distinctive features. We already saw a lot of different use cases. However, There's much more that enums can do.</p>\n<p>They can be used with protocols, just like other Swift types, they can have extensions, they can be generic, and much more. This chapter will introduce these interesting <code>enum</code> features.</p>\n<p>We will start by having a look at conforming enums to protocols.</p>\n","raw_content":"[frontMatter]\ntitle = \"Advanced Enum Usage\"\ntags = []\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Advanced Enum Usage\n\nThe `enum` type is one of Swift's most distinctive features. We already saw a lot of different use cases. However, There's much more that enums can do.\n\nThey can be used with protocols, just like other Swift types, they can have extensions, they can be generic, and much more. This chapter will introduce these interesting `enum` features.\n\nWe will start by having a look at conforming enums to protocols.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/swiftui/complete_book.html":["e3b0c44298fc1c14",{"identifier":"669d","filename":"complete_book.html","info":{"title":"SwiftUI Introduction","tags":[],"keywords":["swift","swiftui"],"category":[],"created":"2019-06-12 10:30:30","description":"SwiftUI is a generational milestone for the Apple development ecosystem. This is a in-development introduction into the topic.","description_html":"<p>SwiftUI is a generational milestone for the Apple development ecosystem. This is a in-development introduction into the topic.</p>\n","published":true,"slug":null,"meta":{"short_title":"🚀 SwiftUI [Beta]","featured":"true","swift_version":"5.1","short_code":"<pre class='Swift'><code><span class='apvsource swift'>var <span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'>body</span> :</span> <span class='apvsource swift'>some <span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'>View</span></span></code></pre>"},"created_timestamp":1560335430,"date":"2019-06-12T10:30:30","date_info":{"year":2019,"month":6,"day":12,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/swiftui/complete_book.html","content":"<h1>Preface</h1>\n<p>When Apple released Swift in 2014 it was a tectonic shift for the Apple development community. One that few people had anticipated. Though while Swift was a much different language than Objective-C, the methods and function you'd call, the frameworks, kept unchanged. In fact, you could ignore the enums and associated types and write Swift that looked and felt much like Objective-C, utilising Foundation and UIKit just as before. This was important for Apple because the scope of UIKit and Foundation is much bigger than that of Swift.</p>\n<p>With SwiftUI, all of this changes. While a Objective-C developer from the 80s would feel right at home with 2017 era Swift code employing target action or delegate mechanisms, a SwiftUI project would look much more alien to him. Apple moved past its development history (shared with NeXT) of the past ~30 years in a generational leap that will hopefully be the base for decades to come. In doing so, Apple also moved the goalpost of mobile application development:</p>\n<ul>\n<li>A shared framework for all Apple platforms (iOS, macOS, watchOS, etc)</li>\n<li>Declarative with live reload and live preview</li>\n<li>Type-Safe UI declarations</li>\n<li>Going beyond Interface Builder</li>\n<li>High level abstraction that will allow future compile time optimizations</li>\n<li>Fully compatible with UIKit / AppKit</li>\n<li>Automatic support for dark mode, dynamic text, and more</li>\n<li>Smart dependency injection via environments</li>\n<li>Combine framework for well thought-out bindings</li>\n<li>much more</li>\n</ul>\n<p>However, don't throw away your old code just yet. While SwiftUI is very exciting (as all Shiny New Things tend to be), it is also a very early beta. Apple already shipped some watchOS apps with SwiftUI (Calculator is an example) but at the same time a calculator on the watch is a different beast than a 200k LOC iPhone app. Some important components will come in a later beta, some components might only come next year, the documentation is still very, very sparse, live preview requires the beta of macOS Catalina.</p>\n<p>In general, it seems that much of the flexibility that UIKit offered has been replaced with a more high level and less customizable interface. You can always resort to UIKit though. This is also a very important point to stress.</p>\n<p>Just as Swift changed a lot after its introduction, I also expected SwiftUI to change in the coming years. This guide introduces SwiftUI in a general manner by developing a small app. It also lists various tips and tricks for things that are difficult or non-intuitive to do in SwiftUI. Lets begin!</p>\n<h1>Declarative.. what? Reactive.. what?</h1>\n<p>When SwiftUI came out some developers were quick to draw parallels to other existing app development technologies such as RxSwift, React, Flutter, Elm, and others. Indeed, some of the key ideas of SwiftUI are similar to what these other technologies offer. However, even if you've never used one of them, don't be afraid. While the general ideas are the same, the implementations vary wildly. You'd also not claim to be a <code>.NET</code> developer just because <code>Windows Forms</code> and UIKit are object oriented UI frameworks. In a similar manner the details matter and that is, really, where we all start as beginners again.</p>\n<p>Below, you will find a quick introduction into declarative and reactive programming. If you think you already know this, <a href=\"javascript:next()\">just move on to the next part where we build a shoe composer in SwiftUI.</a></p>\n<h1>The beauty of a game engine</h1>\n<p>One point that was reiterated during 2019 WWDC as well as numerous conference talks, blog posts and tweets before that is that state is a very fickle thing. Many bugs manifest because we have a variable that is shared between places and one of the places updates it while the other doesn't register this update, and suddenly we have different state in two places and confusing things happen. Imagine a search field that doesn't update the result list when the user replaces the next with a paste command. The problem is not that we forgot to also remember to update the list on paste, the problem is that the state of the search field contents exists in two places: In the search field and in the result list as a predicate. The correct solution would be to have the state only in one place and both the list and the search field connect to this value. As the value changes, both the text field and the list redraw.</p>\n<p>Most 3D game engines work this way. While the fundamentals of a game engine are incredibly complicated, the basics are stunningly simple. A game engine works as follows:</p>\n<ul>\n<li>Have a internal state of what the world looks like (which player is where, which enemies are where)</li>\n<li>Draw the whole world</li>\n<li>while True\n<ul>\n<li>Take user input, calculate enemy movement</li>\n<li>Update the internal state</li>\n<li>Draw the whole world</li>\n</ul>\n</li>\n</ul>\n<p>Can you pin-point what is so fundamentally simple about this? There are no UIViews or UIButtons or UITableViews that need to be updated once the user enters something. Everything is being re-rendered all the time. Each change to the internal state (the user moved) results in a complete re-render of the whole scene. There're no hidden views, forgotten UIViewController children, data sources, UI updates, and so on. The whole scene, really, is just a long list of draw calls based on the current state.</p>\n<h1>Being lazy</h1>\n<p>Doing this with a traditional UI framework like UIKit would be rather cumbersome. Not only would the CPU be busy allocating and deallocating a lot of views all the time, all the user actions would also result in heavy flickering and jittery movements. That's because all of UIKit is build on the model that views are not recreated 60 times a second. However, our UI apps don't actually change like a game scene. Instead, only some elements change. In a game, each movement usually moves all the vertices of the scene around. In our apps, most of the time, just one element changes its state. Thus we can add an optimization to make this game engine approach much more feasible for our us: We only re-render what actually changed. If the user taps a button, this button needs to be re-rendered, everything else can be kept as is. This is one of the magic ingredients of SwiftUI.</p>\n<h1>A game engine that does UI</h1>\n<p>SwiftUI does everything explained above. It forces you to share state with bindings among multiple views. If state changes, the views are compared to see if the new state would change their output. If that's the case they're re-rendered. If not, they're kept as is. With this approach, SwiftUI is like a game engine for UI apps. Instead of thinking how you would add and remove buttons, you just re-render your whole UI based on the current state. SwiftUI makes sure that only the relevant parts are actually updated. This is best explained with a simple example.</p>\n<h1>A simple example</h1>\n<p>Imagine you have an app with a toggle button and a search field. The toggle button controls the visibility of the search field. Here is our UIKit implementation:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> ButtonView: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">var</span> toggleButton = <span class=\"type\">UISwitch</span>()\n\n     <span class=\"keyword\">var</span> searchField = <span class=\"type\">UISearchTextField</span>()\n\n     \n\n     <span class=\"keyword\">override func</span> viewDidAppear(<span class=\"keyword\">_</span> animated: <span class=\"type\">Bool</span>) {\n\n         <span class=\"keyword\">super</span>.<span class=\"call\">viewDidAppear</span>(animated)\n\n         toggleButton.<span class=\"call\">addTarget</span>(<span class=\"keyword\">self</span>, action: <span class=\"keyword\">#selector</span>(<span class=\"call\">didTapButton</span>(sender:)), for: .<span class=\"dotAccess\">allTouchEvents</span>)\n\n         searchField.<span class=\"property\">isHidden</span> = <span class=\"keyword\">true</span>\n\n         view.<span class=\"call\">addSubview</span>(toggleButton)\n\n         view.<span class=\"call\">addSubview</span>(searchField)\n\n     }\n\n     \n\n     <span class=\"keyword\">@objc func</span> didTapButton(sender: <span class=\"type\">UISwitch</span>) {\n\n         searchField.<span class=\"property\">isHidden</span> = !toggleButton.<span class=\"property\">isOn</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This is classic iOS code and while there are many things that can be improved here, it shows a standard pattern. In contrast to the game engine example we had earlier, this view is not re-rendered for every user action. In fact, this view has state in multiple places: <code>searchField.isHidden</code> and <code>toggleButton.isOn</code>. We assign them in <code>didTapButton</code>, but this is not a clear binding that UIKit knows about. If we just change <code>toggleButton.isOn = true</code> somewhere else, the searchfield will not change. Lets look at a (simplified) SwiftUI alternative:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ButtonView : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@State var</span> visible: <span class=\"type\">Bool</span> = <span class=\"keyword\">false</span>\n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span> {\n\n             <span class=\"type\">Toggle</span>(isOn: <span class=\"property\">$visible</span>) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Toggle</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"keyword\">if</span> visible {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Hello</span> <span class=\"type\">World</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>So what is happening here? First of all, we're missing a lot of ceremony around the initialization and creation of UI elements. Where is our toggle initialized, and where is our text initialized? Also, where are we setting the value from the toggle on the <code>hidden</code> property of the text? Also, what's with the weird <code>some View</code>, <code>@State</code>, <code>VStack</code>, and <code>$visible</code>. We will explain one after the other.</p>\n<p>First of all, remember what we said earlier. SwiftUI is like a lazy game engine. Whenever something changes, the UI is rerendered. Since our UI is always rerendered, we don't have to care about state, about the allocation and creation and initialization of buttons. Instead, we just describe to Swift what the UI should look like (akin to the <code>draw</code> calls in a game engine). That's what's happening here. Our <code>var body : some View</code> is a property that returns the complete description of our current UI. The UI is composed out of UI components. In our example this is <code>VStack</code>, <code>Toggle</code>, and <code>Text</code>.</p>\n<ul>\n<li><code>VStack</code>: This is a vertical stack. It aligns its children in a vertical list.</li>\n<li><code>Toggle</code>: Is our toggle button. However, compared to UIKit the toggle button requires a value that stores the current toggle value. <em>It doesn't store it itself</em>. There is no internal toggle state. Instead, the toggle requires you to tell it where to store its state. We do this with the <code>$NameOfVariable</code>. The syntax for this might look a bit alien, but we will ignore this for now for the sake of simplicity.</li>\n<li><code>Text</code>: This will construct a new <code>label</code>. Easy.</li>\n<li><code>if visible</code>: This also looks kinda obvious. If the variable <code>visible</code> is set to <code>true</code> then, please render the text field. But.. how does this update? Initially, <code>visible</code> is set to false, so how does the <code>Text</code> become visible again? Remember, just like a game engine, whenever the state changes, we re-render the UI. So that means that whenever <code>visible</code> changes its value, the <code>if visible</code> is executed again.</li>\n</ul>\n<p>But how does Swift figure out that <code>var visible</code> has changed? We did not set a <code>didSet</code> or <code>set {} get {}</code> for this property, neither did we use <code>@managed</code>, <code>@objc</code> or <code>@dynamic</code>. Instead there is a new thing! <code>@State</code>. This is what tells Swift that <code>visible</code> should be a special variable that we can bind components to. Components such as our <code>Toggle</code> button. <code>@State</code> is used for component / view local state. The way it works is as follows:</p>\n<ol>\n<li><code>@State var visible: Bool</code> will create a new variable with a lot of update and subscription machinery in the background.</li>\n<li><code>Toggle(isOn: $visible)</code> will bind to this <code>visisble</code> value. Whenever <code>visible</code> changes, our toggle will change. Changing our toggle will always also change <code>visible</code>. These two are linked.</li>\n<li>Since we're referring to our <code>visible</code> variable from within our <code>body</code> (via <code>if visible</code>) Swift knows that our <code>body</code> is dependent upon <code>visible</code>. This means that whenever <code>visible</code> changes, Swift will be like &quot;Oh, visible changed, this means the view is probably out of date, I will re-render the view&quot;.</li>\n</ol>\n<p>So, our <code>if visible { Text(...) }</code> will be re-executed whenever our toggle is pressed.</p>\n<h2>Multiple toggles</h2>\n<p>With the above, you might wonder, what happens if we add multiple toggles and or buttons to modify our state? Does it still work? Of course it does! Here's a convoluted example:</p>\n<p><img src=\"/img-content/swiftui_intro_toggles.png\" width=\"40%\" style=\"box-shadow: 2px 2px 24px 0px rgba(0, 0, 0, 0.6);\" /></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ButtonView : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@State var</span> visible: <span class=\"type\">Bool</span> = <span class=\"keyword\">false</span>\n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span> {\n\n             <span class=\"type\">Toggle</span>(isOn: <span class=\"property\">$visible</span>) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Toggle</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"type\">Toggle</span>(isOn: <span class=\"property\">$visible</span>) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Toggle</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"type\">Button</span>(action: {\n\n                 <span class=\"keyword\">self</span>.<span class=\"property\">visible</span>.<span class=\"call\">toggle</span>()\n\n             }) {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Yeah</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n             <span class=\"keyword\">if</span> visible {\n\n                 <span class=\"type\">Text</span>(\\<span class=\"string\">\"Hello</span> <span class=\"type\">World</span>\\<span class=\"string\">\"</span>)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Here, we have not one, not two, but there toggles that all refer to our <code>visible</code>. Tapping any one of them will change our state and will also update all our other toggles. This shows how powerful it is to have a declarative UI system that uses bindings to make sure there is only one source of truth.</p>\n<p>This was a brief overview of how SwiftUI works, and in the next section (coming soon!) we will build a UI to customize sneakers. Here's a preview already:</p>\n<p><img src=\"/img-content/swiftui_intro_preview_sneakers.png\" width=\"30%\" style=\"box-shadow: 2px 2px 24px 0px rgba(0, 0, 0, 0.6);\" /></p>\n<p>In order to better understand how SwiftUI works, we will develop a simple tutorial app. We will continue adding features to this app in the next chapters. For now, the first thing we will build is a simple way for users to customize / design sneakers. In order to allow this, we need a preview of the current sneaker, a way to change the colors of the current sneaker, and a way to store the current sneaker.</p>\n<p>Here is a small GIF of what we are about to create.</p>\n<p><img src=\"/img-content/swiftui_tutorial_anim.gif\" width=\"30%\" /></p>\n<h2>The Model</h2>\n<p>Lets start with the model as it will help us shape the rest of the application. Currently, our model will only store the colors of the current sneaker. However, future chapters will also add the manufacturers name, shoe name, shoe model, etc. So in order to prepare for that we will have a more general <code>ShoeConfiguration</code> type that will contain a more distinct <code>ShoeColors</code> type. We will first have a look at this <code>ShoeColors</code> type.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ShoeColors {\n\n     <span class=\"comment\">/// Outline Color</span>\n\n     <span class=\"keyword\">var</span> outline: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Base Color</span>\n\n     <span class=\"keyword\">var</span> base: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Side Color</span>\n\n     <span class=\"keyword\">var</span> side: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Sole Color</span>\n\n     <span class=\"keyword\">var</span> sole: <span class=\"type\">Color</span>\n\n     <span class=\"comment\">/// Back Cage Color</span>\n\n     <span class=\"keyword\">var</span> cage: <span class=\"type\">Color</span>\n\n}\n</code></pre></code></pre>\n<p>Our configuration has colors for multiple parts of the shoe. The outline, the base color, the side color, and so on. Note that we're not using <code>UIColor</code> or <code>NSColor</code> or <code>CGColor</code>, or even <code>CIColor</code>; no, there's a new color type in SwiftUI. It has a limited set of default color defintions, but it is sufficient for our use case here.</p>\n<p>The next part is to have a configuration for our shoe. The colors will be just one part of the configuration. A first draft would look something like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> ShoeConfiguration {\n\n     \n\n     <span class=\"keyword\">var</span> shoeColors: <span class=\"type\">ShoeColors</span> \n\n     \n\n     <span class=\"keyword\">init</span>() {\n\n         shoeColors = <span class=\"type\">ShoeColors</span>(outline: .<span class=\"dotAccess\">black</span>, base: .<span class=\"dotAccess\">white</span>, side: .<span class=\"dotAccess\">orange</span>, sole: .<span class=\"dotAccess\">purple</span>, cage: .<span class=\"dotAccess\">gray</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>We're creating a simple <code>class</code> that acts as the configuration of one shoe. Currently, we're only hosting <code>shoeColors</code>, so there's not really much going on. What we do do, though, is to configure a default shoe in the initializer.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> SwiftUI\n\n<span class=\"keyword\">import</span> Combine\n\n\n\n<span class=\"keyword\">class</span> ShoeConfiguration: <span class=\"type\">BindableObject</span> {\n\n     \n\n     <span class=\"keyword\">struct</span> ShoeColors {\n\n         <span class=\"keyword\">var</span> outline: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> base: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> side: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> sole: <span class=\"type\">Color</span>\n\n         <span class=\"keyword\">var</span> cage: <span class=\"type\">Color</span>\n\n     }\n\n     \n\n     <span class=\"keyword\">var</span> shoeColors: <span class=\"type\">ShoeColors</span> {\n\n         <span class=\"keyword\">didSet</span> {\n\n             didChange.<span class=\"call\">send</span>(<span class=\"keyword\">self</span>)\n\n         }\n\n     }\n\n     \n\n     <span class=\"keyword\">var</span> didChange = <span class=\"type\">PassthroughSubject</span>&lt;<span class=\"type\">ShoeConfiguration</span>, <span class=\"type\">Never</span>&gt;()\n\n     \n\n     <span class=\"keyword\">init</span>() {\n\n         shoeColors = <span class=\"type\">ShoeColors</span>(outline: .<span class=\"dotAccess\">black</span>, base: .<span class=\"dotAccess\">white</span>, side: .<span class=\"dotAccess\">orange</span>, sole: .<span class=\"dotAccess\">purple</span>, cage: .<span class=\"dotAccess\">gray</span>)\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> ShoeView : <span class=\"type\">View</span> {\n\n     \n\n     <span class=\"keyword\">@Binding var</span> colors: <span class=\"type\">ShoeConfiguration</span>.<span class=\"type\">ShoeColors</span>\n\n     \n\n     <span class=\"keyword\">private func</span> colorParts() -&gt; [(name: <span class=\"type\">String</span>, color: <span class=\"type\">Color</span>)] {\n\n         <span class=\"keyword\">return</span> [\n\n             (\\<span class=\"string\">\"base</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">base</span>),\n\n             (\\<span class=\"string\">\"side</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">side</span>),\n\n             (\\<span class=\"string\">\"sole</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">sole</span>),\n\n             (\\<span class=\"string\">\"cage</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">cage</span>),\n\n             (\\<span class=\"string\">\"outline</span>\\<span class=\"string\">\"</span>, colors.<span class=\"property\">outline</span>)\n\n         ]\n\n     }\n\n     \n\n     <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">ZStack</span> {\n\n             <span class=\"type\">ForEach</span>(<span class=\"call\">colorParts</span>().<span class=\"call\">identified</span>(by: \\.<span class=\"property\">name</span>)) { shoePart <span class=\"keyword\">in</span>\n\n                 <span class=\"type\">Image</span>(shoePart.<span class=\"property\">name</span>).<span class=\"call\">resizable</span>()\n\n                     .<span class=\"call\">renderingMode</span>(.<span class=\"dotAccess\">template</span>)\n\n                     .<span class=\"call\">foregroundColor</span>(shoePart.<span class=\"property\">color</span>)\n\n             }\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">func</span> scaledFrame(from geometry: <span class=\"type\">GeometryProxy</span>, scale: <span class=\"type\">CGFloat</span>) -&gt; <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"keyword\">self</span>.<span class=\"call\">frame</span>(width: geometry.<span class=\"property\">size</span>.<span class=\"property\">width</span> * scale, height: geometry.<span class=\"property\">size</span>.<span class=\"property\">height</span> * scale)\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> ColorPickerEntry : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">var</span> selected: <span class=\"type\">Bool</span>\n\n     <span class=\"keyword\">var</span> shoeColor: <span class=\"type\">Color</span>\n\n     \n\n     <span class=\"keyword\">private let</span> outerScale: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.7</span>\n\n     <span class=\"keyword\">private let</span> innerScale: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.5</span>\n\n     \n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">GeometryReader</span> { geometry <span class=\"keyword\">in</span>\n\n             <span class=\"type\">Group</span> {\n\n                 <span class=\"keyword\">if self</span>.<span class=\"property\">selected</span> {\n\n                     <span class=\"type\">Circle</span>().<span class=\"call\">fill</span>(<span class=\"keyword\">self</span>.<span class=\"property\">shoeColor</span>)\n\n                         .<span class=\"call\">overlay</span>(<span class=\"type\">Circle</span>().<span class=\"call\">stroke</span>(<span class=\"type\">Color</span>.<span class=\"property\">black</span>, lineWidth: <span class=\"number\">2.0</span>))\n\n                         .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">outerScale</span>)\n\n                 } <span class=\"keyword\">else</span> {\n\n                     <span class=\"type\">Circle</span>().<span class=\"call\">stroke</span>(<span class=\"type\">Color</span>.<span class=\"property\">gray</span>)\n\n                         .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">innerScale</span>)\n\n                         .<span class=\"call\">overlay</span>(<span class=\"type\">Circle</span>().<span class=\"call\">fill</span>(<span class=\"keyword\">self</span>.<span class=\"property\">shoeColor</span>)\n\n                             .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">innerScale</span>), alignment: .<span class=\"dotAccess\">center</span>)\n\n                         .<span class=\"call\">overlay</span>(<span class=\"type\">Circle</span>().<span class=\"call\">stroke</span>(<span class=\"type\">Color</span>.<span class=\"property\">gray</span>)\n\n                             .<span class=\"call\">scaledFrame</span>(from: geometry, scale: <span class=\"keyword\">self</span>.<span class=\"property\">outerScale</span>))\n\n                 }\n\n             }.<span class=\"call\">frame</span>(width: geometry.<span class=\"property\">size</span>.<span class=\"property\">width</span>, height: geometry.<span class=\"property\">size</span>.<span class=\"property\">height</span>)\n\n         }\n\n     }\n\n}\n\n\n\n\n\n<span class=\"keyword\">struct</span> ColorPicker : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@Binding var</span> selectedColor: <span class=\"type\">Color</span>\n\n     <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> body : <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span>(alignment: <span class=\"type\">HorizontalAlignment</span>.<span class=\"property\">center</span>, spacing: <span class=\"number\">0</span>) {\n\n             <span class=\"type\">Text</span>(name).<span class=\"call\">font</span>(.<span class=\"dotAccess\">body</span>)\n\n             <span class=\"type\">HStack</span> {\n\n                 <span class=\"type\">ForEach</span>([<span class=\"type\">Color</span>.<span class=\"property\">black</span>, <span class=\"type\">Color</span>.<span class=\"property\">white</span>, <span class=\"type\">Color</span>.<span class=\"property\">orange</span>, <span class=\"type\">Color</span>.<span class=\"property\">purple</span>, <span class=\"type\">Color</span>.<span class=\"property\">gray</span>].<span class=\"call\">identified</span>(by: \\.<span class=\"property\">hashValue</span>)) { color <span class=\"keyword\">in</span>\n\n                     <span class=\"type\">Button</span>(action: {\n\n                         <span class=\"keyword\">self</span>.<span class=\"property\">selectedColor</span> = color\n\n                     }) {\n\n                         <span class=\"type\">ColorPickerEntry</span>(selected: <span class=\"keyword\">self</span>.<span class=\"property\">selectedColor</span>.<span class=\"property\">hashValue</span> == color.<span class=\"property\">hashValue</span>, shoeColor: color)\n\n                             .<span class=\"call\">frame</span>(width: <span class=\"number\">38</span>, height: <span class=\"number\">38</span>)\n\n                     }\n\n                 }\n\n             }\n\n         }\n\n     }\n\n}\n\n\n\n\n\n<span class=\"keyword\">struct</span> ShoeConfigurator : <span class=\"type\">View</span> {\n\n     \n\n     <span class=\"keyword\">@ObjectBinding var</span> shoeConfiguration = <span class=\"type\">ShoeConfiguration</span>()\n\n     \n\n     <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">VStack</span> {\n\n             <span class=\"type\">ShoeView</span>(colors: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>)\n\n                 .<span class=\"call\">frame</span>(width: <span class=\"number\">250</span>, height: <span class=\"number\">114</span>, alignment: .<span class=\"dotAccess\">center</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">base</span>,\n\n                         name: \\<span class=\"string\">\"Base</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">cage</span>,\n\n                         name: \\<span class=\"string\">\"Cage</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">side</span>,\n\n                         name: \\<span class=\"string\">\"Side</span>\\<span class=\"string\">\"</span>)\n\n             <span class=\"type\">ColorPicker</span>(selectedColor: <span class=\"property\">$shoeConfiguration</span>.<span class=\"property\">shoeColors</span>.<span class=\"property\">sole</span>,\n\n                         name: \\<span class=\"string\">\"Sole</span>\\<span class=\"string\">\"</span>)\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> ContentView : <span class=\"type\">View</span> {\n\n     <span class=\"keyword\">@State private var</span> selection = <span class=\"number\">0</span>\n\n     \n\n     <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">ShoeConfigurator</span>()\n\n     }\n\n}\n\n\n\n<span class=\"preprocessing\">#if DEBUG</span>\n\n<span class=\"keyword\">struct</span> ContentView_Previews : <span class=\"type\">PreviewProvider</span> {\n\n     <span class=\"keyword\">static var</span> previews: <span class=\"keyword\">some</span> <span class=\"type\">View</span> {\n\n         <span class=\"type\">ContentView</span>()\n\n     }\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n\n\n</code></pre></code></pre>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2016-04-14-force-optionals-in-guard-or-let-optional-binding.md":["8cdd75f7e7a12338",{"identifier":"21d5fb1f","filename":"2016-04-14-force-optionals-in-guard-or-let-optional-binding.md","info":{"title":"Force optionals in multi-unwrapped 'guard let' or 'if let'","tags":["optional"],"keywords":["swift","guard","let","unwrap","bind","binding","unwrapped","optional","some","none","optionals"],"category":["Swift Tricks","All"],"created":"2016-04-14 10:30:30","description":"Mixing optional and non-optional functions in a guard is impossible and requires breaking up the lines. Here's a neat solution on how to circumvent this.","description_html":"<p>Mixing optional and non-optional functions in a guard is impossible and requires breaking up the lines. Here's a neat solution on how to circumvent this.</p>\n","published":true,"slug":"2016-04-14-force-optionals-in-guard-or-let-optional-binding.html","meta":{"feature_image":"https://appventure.me/img-content/2016-04-14-force-optionals-in-guard-or-let-optional-binding-feature-image.jpg","swift_version":"5.0"},"created_timestamp":1460629830,"date":"2016-04-14T10:30:30","date_info":{"year":2016,"month":4,"day":14,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2016-04-14-force-optionals-in-guard-or-let-optional-binding.html","content":"<p>I really love unwrapping optionals in a multi- <code>guard</code> or <code>let</code>\nstatement with additional <code>where</code> clauses added. <a href=\"https://appventure.me/posts/2016-03-29-three-tips-for-clean-swift-code.html\">See my previous post\non this\nhere</a>.</p>\n<p>However, sometimes I run into a situation where I have one function call\n(or a array subscript) in between my others that does not return an\noptional:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Imagine this function does something complicated</span>\n\n<span class=\"keyword\">func</span> someArray() -&gt; [<span class=\"type\">Int</span>]? {\n\n     <span class=\"keyword\">return</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]\n\n}\n\n\n\n<span class=\"keyword\">func</span> example() {\n\n     <span class=\"keyword\">guard let</span> array = <span class=\"call\">someArray</span>(),\n\n         <span class=\"keyword\">let</span> numberThree = array[<span class=\"number\">2</span>],\n\n         numberThree == <span class=\"number\">3</span>\n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     <span class=\"call\">print</span>(numberThree)\n\n}\n\n\n</code></pre></code></pre>\n<p>This doesn't work. The compiler will explain to you that it expects an\noptional:</p>\n<blockquote>\n<p>&quot;Initializer for conditional binding must have Optional type, not\n'Int'&quot;</p>\n</blockquote>\n<p>So, what you oftentimes end up with, instead, is something like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> example() {\n\n     <span class=\"keyword\">guard let</span> array = <span class=\"call\">someArray</span>() <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     <span class=\"keyword\">let</span> numberThree = array[<span class=\"number\">2</span>]\n\n     <span class=\"keyword\">guard</span> numberThree == <span class=\"number\">3</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     <span class=\"call\">print</span>(numberThree)\n\n}\n</code></pre></code></pre>\n<p>Not only is this awful to look at, you also have to write the failure\nblock twice. That's ok for a simple example as this one <code>{ return }</code>,\nbut when you have to perform a bit more work in there you'll have to\nrepeat code blocks; and that's bad <sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>.</p>\n<p>So what's the solution here? Well, since the <code>guard</code> or <code>let</code> requires\nan optional, we can just as well create one and unpack it again:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> example() {\n\n     <span class=\"keyword\">guard let</span> array = <span class=\"call\">someArray</span>(),\n\n         numberThree = <span class=\"type\">Optional</span>.<span class=\"call\">some</span>(array[<span class=\"number\">2</span>])\n\n         <span class=\"keyword\">where</span> numberThree == <span class=\"number\">3</span>\n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     <span class=\"call\">print</span>(numberThree)\n\n}\n</code></pre></code></pre>\n<p>As you may remember, Swift's optionals are internally more or less\n<code>enums</code> with a <code>.some</code> and a <code>.none</code> case. So what we're doing here is\ncreating a new <code>.some</code> case only to unwrap it again in the very same\nline: The <code>array[2]</code> expression will be wrapped with <code>Optional.some</code> and\nthen unwrapped again into <code>numberThree</code>.</p>\n<p>There is a wee bit of overhead here, but on the other hand it does allow\nus to keep the <code>guard</code> or <code>let</code> unwrappings much cleaner.</p>\n<p>This obviously doesn't just work with array subscripts like <code>array[3]</code>\nbut also with any non-optional function, i.e.:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">guard let</span> aString = <span class=\"call\">optionalString</span>(),\n\n     <span class=\"keyword\">let</span> elements = <span class=\"type\">Optional</span>.<span class=\"type\">Some</span>(aString.<span class=\"property\">characters</span>.<span class=\"call\">split</span>(\\<span class=\"string\">\"</span>/\\<span class=\"string\">\"</span>)),\n\n     <span class=\"keyword\">let</span> last = elements.<span class=\"property\">last</span>,\n\n     <span class=\"keyword\">let</span> count = <span class=\"type\">Optional</span>.<span class=\"type\">Some</span>(last.<span class=\"property\">characters</span>.<span class=\"property\">count</span>),\n\n     count == <span class=\"number\">5</span> <span class=\"keyword\">else</span> { <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Wrong</span> <span class=\"type\">Path</span>\\<span class=\"string\">\"</span>) }\n\n<span class=\"call\">print</span>(\\<span class=\"string\">\"We</span> have \\(count) items <span class=\"keyword\">in</span> \\(last)\\<span class=\"string\">\"</span>)\n</code></pre></code></pre>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>Or you start refactoring this into seperate closures or functions,\nbut that's an awful lot of work for just one guard statement</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"Mixing optional and non-optional functions in a guard is impossible and requires breaking up the lines. Here's a neat solution on how to circumvent this.\"\ntitle = \"Force optionals in multi-unwrapped 'guard let' or 'if let'\"\ncreated = \"2016-04-14\"\npublished = true\nkeywords = [\"swift\", \"guard\", \"let\", \"unwrap\", \"bind\", \"binding\", \"unwrapped\", \"optional\", \"some\", \"none\", \"optionals\"]\nslug = \"2016-04-14-force-optionals-in-guard-or-let-optional-binding.html\"\ntags = [\"optional\"]\ncategory = [\"Swift Tricks\", \"All\"]\n\n[meta]\nswift_version = \"5.0\"\nfeature_image = \"https://appventure.me/img-content/2016-04-14-force-optionals-in-guard-or-let-optional-binding-feature-image.jpg\"\n---\n\nI really love unwrapping optionals in a multi- `guard` or `let`\nstatement with additional `where` clauses added. [See my previous post\non this\nhere](https://appventure.me/posts/2016-03-29-three-tips-for-clean-swift-code.html).\n\nHowever, sometimes I run into a situation where I have one function call\n(or a array subscript) in between my others that does not return an\noptional:\n\n``` Swift\n// Imagine this function does something complicated\nfunc someArray() -> [Int]? {\n    return [1, 2, 3, 4, 5, 6]\n}\n\nfunc example() {\n    guard let array = someArray(),\n        let numberThree = array[2],\n        numberThree == 3\n        else { return }\n    print(numberThree)\n}\n\n```\n\nThis doesn\\'t work. The compiler will explain to you that it expects an\noptional:\n\n> \\\"Initializer for conditional binding must have Optional type, not\n> \\'Int\\'\\\"\n\nSo, what you oftentimes end up with, instead, is something like this:\n\n``` Swift\nfunc example() {\n    guard let array = someArray() else { return }\n    let numberThree = array[2]\n    guard numberThree == 3 else { return }\n    print(numberThree)\n}\n```\n\nNot only is this awful to look at, you also have to write the failure\nblock twice. That\\'s ok for a simple example as this one `{ return }`,\nbut when you have to perform a bit more work in there you\\'ll have to\nrepeat code blocks; and that\\'s bad [^1].\n\nSo what\\'s the solution here? Well, since the `guard` or `let` requires\nan optional, we can just as well create one and unpack it again:\n\n``` Swift\nfunc example() {\n    guard let array = someArray(),\n        numberThree = Optional.some(array[2])\n        where numberThree == 3\n        else { return }\n    print(numberThree)\n}\n```\n\nAs you may remember, Swift\\'s optionals are internally more or less\n`enums` with a `.some` and a `.none` case. So what we\\'re doing here is\ncreating a new `.some` case only to unwrap it again in the very same\nline: The `array[2]` expression will be wrapped with `Optional.some` and\nthen unwrapped again into `numberThree`.\n\nThere is a wee bit of overhead here, but on the other hand it does allow\nus to keep the `guard` or `let` unwrappings much cleaner.\n\nThis obviously doesn\\'t just work with array subscripts like `array[3]`\nbut also with any non-optional function, i.e.:\n\n``` Swift\nguard let aString = optionalString(),\n    let elements = Optional.Some(aString.characters.split(\"/\")),\n    let last = elements.last,\n    let count = Optional.Some(last.characters.count),\n    count == 5 else { fatalError(\"Wrong Path\") }\nprint(\"We have \\(count) items in \\(last)\")\n```\n\n[^1]: Or you start refactoring this into seperate closures or functions,\n    but that\\'s an awful lot of work for just one guard statement\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/mirrors/what_is_in_a_mirror.md":["ee4974ff3739aa9b",{"identifier":"33877742","filename":"what_is_in_a_mirror.md","info":{"title":"What is in a Mirror","tags":["reflection","mirror"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-what-is-in-a-mirror.html","content":"<h1>What is in a Mirror</h1>\n<p>The <code>Mirror struct</code> contains several <code>types</code> to help you identify the\ninformation you'd like to query.</p>\n<p>The first one is the <code>DisplayStyle</code> <code>enum</code> which tells you the type of\nthe subject:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public enum</span> DisplayStyle {\n\n     <span class=\"keyword\">case</span> `<span class=\"keyword\">struct</span>`\n\n     <span class=\"keyword\">case</span> `<span class=\"keyword\">class</span>`\n\n     <span class=\"keyword\">case</span> `<span class=\"keyword\">enum</span>`\n\n     <span class=\"keyword\">case</span> tuple\n\n     <span class=\"keyword\">case</span> optional\n\n     <span class=\"keyword\">case</span> collection\n\n     <span class=\"keyword\">case</span> dictionary\n\n     <span class=\"keyword\">case set</span>\n\n}\n</code></pre></code></pre>\n<p>Those are the supported types of the reflection API. As we saw earlier,\nreflection only requires an <code>Any</code> type, and there're many things in the\nSwift standard library that are of type <code>Any</code> but aren't listed in the\n<code>DisplayStyle</code> enum above. What happens when you try to reflect over one\nof those, say a closure?</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> closure = { (a: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in return</span> a * <span class=\"number\">2</span> }\n\n<span class=\"keyword\">let</span> aMirror = <span class=\"type\">Mirror</span>(reflecting: closure)\n</code></pre></code></pre>\n<p>In this case, you'd get a mirror, but the <code>DisplayStyle</code> would be nil\n<sup class=\"footnote-reference\"><a href=\"#2\">1</a></sup></p>\n<p>There's also a <code>typealias</code> for the child elements of a <code>Mirror</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public typealias</span> Child = (label: <span class=\"type\">String</span>?, value: <span class=\"type\">Any</span>)\n</code></pre></code></pre>\n<p>So each child consists out of an optional <strong>label</strong> and a <strong>value</strong> of\ntype <code>Any</code>. Why would the label be an <code>Optional</code>? If you think about it,\nit makes sense, not all of the structures that are supported by\nreflection have children with names. A <code>struct</code> has the property's name\nas the label, but a Collection only has indexes, not names. Tuples are a\nlittle bit special. In Swift values in tuple could have optional labels.\nDoesn't matter if value in tupple is labeled or not, in reflection\ntuple will have labels &quot;.0&quot;, &quot;.1&quot; and so on.</p>\n<p>Next up is the <code>AncestorRepresentation</code> <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public enum</span> AncestorRepresentation {\n\n     <span class=\"comment\">/// Generate a default mirror for all ancestor classes.  This is the</span>\n\n     <span class=\"comment\">/// default behavior.</span>\n\n     <span class=\"keyword\">case</span> generated\n\n     <span class=\"comment\">/// Use the nearest ancestor's implementation of `customMirror()` to</span>\n\n     <span class=\"comment\">/// create a mirror for that ancestor.</span>      \n\n     <span class=\"keyword\">case</span> customized(<span class=\"keyword\">@escaping</span> () -&gt; <span class=\"type\">Mirror</span>)\n\n     <span class=\"comment\">/// Suppress the representation of all ancestor classes.  The</span>\n\n     <span class=\"comment\">/// resulting `Mirror`'s `superclassMirror()` is `nil`.</span>\n\n     <span class=\"keyword\">case</span> suppressed\n\n}\n</code></pre></code></pre>\n<p>This <code>enum</code> is used to define how superclasses of the reflected subject\nshould be reflected. I.e. this is only used for subjects of type\n<code>class</code>. The default (as you can see) is that Swift generates an\nadditional mirror for each superclass. However, if you need more\nflexibility here, you can use the <code>AncestorRepresentation enum</code> to\ndefine how superclasses are being mirrored.</p>\n","raw_content":"[frontMatter]\ntitle = \"What is in a Mirror\"\ntags = [\"reflection\", \"mirror\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# What is in a Mirror\n\nThe `Mirror struct` contains several `types` to help you identify the\ninformation you\\'d like to query.\n\nThe first one is the `DisplayStyle` `enum` which tells you the type of\nthe subject:\n\n``` Swift\npublic enum DisplayStyle {\n    case `struct`\n    case `class`\n    case `enum`\n    case tuple\n    case optional\n    case collection\n    case dictionary\n    case set\n}\n```\n\nThose are the supported types of the reflection API. As we saw earlier,\nreflection only requires an `Any` type, and there\\'re many things in the\nSwift standard library that are of type `Any` but aren\\'t listed in the\n`DisplayStyle` enum above. What happens when you try to reflect over one\nof those, say a closure?\n\n``` Swift\nlet closure = { (a: Int) -> Int in return a * 2 }\nlet aMirror = Mirror(reflecting: closure)\n```\n\nIn this case, you\\'d get a mirror, but the `DisplayStyle` would be nil\n[^2]\n\nThere\\'s also a `typealias` for the child elements of a `Mirror`:\n\n``` Swift\npublic typealias Child = (label: String?, value: Any)\n```\n\nSo each child consists out of an optional **label** and a **value** of\ntype `Any`. Why would the label be an `Optional`? If you think about it,\nit makes sense, not all of the structures that are supported by\nreflection have children with names. A `struct` has the property\\'s name\nas the label, but a Collection only has indexes, not names. Tuples are a\nlittle bit special. In Swift values in tuple could have optional labels.\nDoesn\\'t matter if value in tupple is labeled or not, in reflection\ntuple will have labels \\\".0\\\", \\\".1\\\" and so on.\n\nNext up is the `AncestorRepresentation` `enum`:\n\n``` Swift\npublic enum AncestorRepresentation {\n    /// Generate a default mirror for all ancestor classes.  This is the\n    /// default behavior.\n    case generated\n    /// Use the nearest ancestor's implementation of `customMirror()` to\n    /// create a mirror for that ancestor.      \n    case customized(@escaping () -> Mirror)\n    /// Suppress the representation of all ancestor classes.  The\n    /// resulting `Mirror`'s `superclassMirror()` is `nil`.\n    case suppressed\n}\n```\n\nThis `enum` is used to define how superclasses of the reflected subject\nshould be reflected. I.e. this is only used for subjects of type\n`class`. The default (as you can see) is that Swift generates an\nadditional mirror for each superclass. However, if you need more\nflexibility here, you can use the `AncestorRepresentation enum` to\ndefine how superclasses are being mirrored. \n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/toolbar.md":["4b7ab964f6d26078",{"identifier":"b63c6298","filename":"toolbar.md","info":{"title":"How do I create a toolbar?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-create-a-toolbar.html","content":"<h2>Preparations</h2>\n<p>Note that in <em>Beta 2</em> you need to manually import a special bridging header if you want to use <code>NSToolbar</code>. <a href=\"firststeps/bridgingheader.md\">Here's how to do it</a>.</p>\n<p>The best way to insert toolbars is to use the new <code>UIScene</code> API that Apple introduced with iOS 13. The gist is that you use a <code>SceneDelegate</code> and in the <code>scene:willConnectToSession:options</code> method, you can modify a window scene's <code>titlebar</code> by setting a new <code>NSToolbar</code> on it.</p>\n<p>If your project doesn't have a <code>SceneDelegate</code> yet, <a href=\"firststeps/scene_delegate.md\">here's a brief primer on how to set it up.</a>. This delegate is - as far as I'm aware - required to support toolbars.</p>\n<h2>Modifying the Scene</h2>\n<p>The first step is to modify the <code>scene(willConnectTo:options:)</code> method in your <code>SceneDelegate</code> to check if we're running <code>UIKitForMac</code> - after all, iOS doesn't have toolbars - and then make sure that our scene is actually a <code>UIWindowScene</code>:</p>\n<pre class=\"Swift\"><code>  <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n     <span class=\"preprocessing\">#endif</span>\n\n}\n</code></pre></code></pre>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiwindowscene\"><code>UIWindowScene</code></a> objects have a <code>titlebar</code> property on macOS. These <code>UITitleBar</code> objects are currently not documented, but the headers expose a <code>toolbar</code> property that you can use to assign a <code>NSToolbar</code> to your window:</p>\n<pre class=\"Swift\"><code>  <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n     <span class=\"comment\">// Create a new toolbar (see below)</span>\n\n     <span class=\"keyword\">let</span> newToolbar = <span class=\"call\">makeMyFancyToolbar</span>()\n\n\n\n     <span class=\"comment\">// Insert it into the titlebar</span>\n\n     windowScene.<span class=\"property\">titlebar</span>.<span class=\"property\">toolbar</span> = <span class=\"keyword\">self</span>\n\n\n\n     <span class=\"comment\">// Hide the window title, looks nicer</span>\n\n     windowScene.<span class=\"property\">titlebar</span>.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n     <span class=\"preprocessing\">#endif</span>\n\n}\n</code></pre></code></pre>\n<p>So this is how we insert an actual toolbar into our window. The last remaining step is to create such a toolbar, so how does that work?</p>\n<h2>Creating a Toolbar</h2>\n<p>This is actually a multi-step process as toolbars are quit versatile. You begin by instantiating a new toolbar and configuring it accordingly:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Create the toolbar</span>\n\n<span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyFancyToolbar</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// Assign the delegate</span>\n\ntoolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n</code></pre></code></pre>\n<p>As you can see, the configuration is just two lines of code (for now) but toolbars employ a delegate that you can leverage to configure them in much more detail. Lets see how.</p>\n<h2>Implementing the NSToolbarDelegate protocol</h2>\n<p>First, you need an object that can conform to your toolbar delegate. For simplicity, lets just take our <code>SceneDelegate</code>. However, this can be any object and for more complex setups could be, for example, your own <code>MyToolbarController</code> class.</p>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n<span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Again, make sure this code only compiles on macOS. Next, lets implement the bare minimum needed to display a toolbar.</p>\n<p>Toolbars are versatile and allow your users to configure them and modify their contents. Our toolbar will just display a button on the right side. Toolbars identify their contents via toolbar identifiers of type <code>NSToolbarItem.Identifier</code>. Each item in the toolbar has a custom identifier. This makes it easy for the system to understand which items are in the toolbar, which can be customized, removed, etc. So in order for us to add a button, we need an identifier for our button:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private let</span> <span class=\"type\">OurButtonToolbarIdentifier</span> = <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"OurButton</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n<span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Next, we need to implement two methods that are called on the delegate to figure out what to display in the toolbar:</p>\n<ol>\n<li><code>toolbarDefaultItemIdentifiers</code>: This returns the identifiers for the items that should be in the toolbar <em>by default</em></li>\n<li><code>toolbarAllowedItemIdentifiers</code>: This returns the identifiers that are <em>currently</em> allowed in the toolbar</li>\n</ol>\n<p>We will implement default first:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>,\n\n                 <span class=\"type\">OurButtonToolbarIdentifier</span>]\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Here, we're returning an array of two items. The <em>last</em> is our <code>OurButtonToolbarIdentifier</code>. The <em>first</em> is a &quot;flexible space&quot; identifier that will consume as much horizontal space as possible, thus pushing our button all the way to the right.</p>\n<p>For simplicity, the second method, <code>toolbarAllowedItemIdentifiers</code> just calls the first one.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>,\n\n                 <span class=\"type\">OurButtonToolbarIdentifier</span>]\n\n     }\n\n     <span class=\"keyword\">func</span> toolbarAllowedItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> <span class=\"call\">toolbarDefaultItemIdentifiers</span>(toolbar)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Now that we told the toolbar how to display itself, we just need to create those items (in our case just our button):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbar(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>, itemForItemIdentifier itemIdentifier: <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>, willBeInsertedIntoToolbar flag: <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">NSToolbarItem</span>? {\n\n         <span class=\"keyword\">if</span> (itemIdentifier == <span class=\"type\">OurButtonToolbarIdentifier</span>) {\n\n         <span class=\"keyword\">let</span> barButtonItem = <span class=\"type\">UIBarButtonItem</span>(barButtonSystemItem: <span class=\"type\">UIBarButtonItem</span>.<span class=\"type\">SystemItem</span>.<span class=\"property\">add</span>,\n\n                               target: <span class=\"keyword\">self</span>,\n\n                   action: <span class=\"keyword\">#selector</span>(<span class=\"keyword\">self</span>.<span class=\"call\">myFancyAction</span>(sender:)))\n\n             <span class=\"keyword\">let</span> button = <span class=\"type\">NSToolbarItem</span>(itemIdentifier: itemIdentifier, barButtonItem: barButtonItem)\n\n             <span class=\"keyword\">return</span> button\n\n         }\n\n         <span class=\"keyword\">return nil</span>\n\n     }\n</code></pre></code></pre>\n<p>Again, this is simple enough. We just create a <code>UIBarButtonItem</code>, wrap it into a <code>NSToolbarItem</code> and return it. There're a lot of options here that we will not go into, but reading the headers and the documentation will help you along if you need more complex setups.</p>\n<p><a href=\"how/hide_tabbar_with_toolbar.md\">If you want to hide your existing iOS / UIKit toolbar, too, have a look at this section.</a></p>\n<p>If you want to display a nice segmented control your toolbar, like this:</p>\n<p><img src=\"/img-content/catalyst/segmentedcontrol_toolbar.png\" alt=\"\" /></p>\n<p><a href=\"how/segmented_control_toolbar.md\">There's an explanation on how to do this in the following section.</a></p>\n<p>Here's the whole code <code>SceneDelegate</code> in one section:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> UIKit\n\n\n\n<span class=\"keyword\">class</span> SceneDelegate: <span class=\"type\">UIResponder</span>, <span class=\"type\">UIWindowSceneDelegate</span> {\n\n\n\n     <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?\n\n\n\n     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n         <span class=\"keyword\">if let</span> titlebar = windowScene.<span class=\"property\">titlebar</span> {\n\n             titlebar.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n             titlebar.<span class=\"property\">toolbar</span> = <span class=\"call\">makeMyFancyToolbar</span>()\n\n         }\n\n         <span class=\"preprocessing\">#endif</span>\n\n     }\n\n\n\n     <span class=\"keyword\">private func</span> makeMyFancyToolbar() -&gt; <span class=\"type\">NSToolbar</span> {\n\n         <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyToolbar</span>\\<span class=\"string\">\"</span>)\n\n         toolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n         <span class=\"keyword\">return</span> toolbar\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> myFancyAction(sender: <span class=\"type\">UIBarButtonItem</span>) {\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"Button</span> <span class=\"type\">Pressed</span>\\<span class=\"string\">\"</span>)\n\n     }\n\n}\n\n\n\n<span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n\n\n<span class=\"keyword\">private let</span> <span class=\"type\">OurButtonToolbarIdentifier</span> = <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"OurButton</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbar(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>, itemForItemIdentifier itemIdentifier: <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>, willBeInsertedIntoToolbar flag: <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">NSToolbarItem</span>? {\n\n         <span class=\"keyword\">if</span> (itemIdentifier == <span class=\"type\">OurButtonToolbarIdentifier</span>) {\n\n             <span class=\"keyword\">let</span> barButton = <span class=\"type\">UIBarButtonItem</span>(barButtonSystemItem: .<span class=\"dotAccess\">add</span>, target: <span class=\"keyword\">self</span>, action: <span class=\"keyword\">#selector</span>(<span class=\"call\">myFancyAction</span>(sender:)))\n\n             <span class=\"keyword\">let</span> button = <span class=\"type\">NSToolbarItem</span>(itemIdentifier: itemIdentifier, barButtonItem: barButton)\n\n             <span class=\"keyword\">return</span> button\n\n         }\n\n         <span class=\"keyword\">return nil</span>\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>, <span class=\"type\">OurButtonToolbarIdentifier</span>]\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarAllowedItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> <span class=\"call\">toolbarDefaultItemIdentifiers</span>(toolbar)\n\n     }\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I create a toolbar?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\n## Preparations\n\nNote that in *Beta 2* you need to manually import a special bridging header if you want to use `NSToolbar`. [Here's how to do it](firststeps/bridgingheader.md).\n\nThe best way to insert toolbars is to use the new `UIScene` API that Apple introduced with iOS 13. The gist is that you use a `SceneDelegate` and in the `scene:willConnectToSession:options` method, you can modify a window scene's `titlebar` by setting a new `NSToolbar` on it.\n\nIf your project doesn't have a `SceneDelegate` yet, [here's a brief primer on how to set it up.](firststeps/scene_delegate.md). This delegate is - as far as I'm aware - required to support toolbars.\n\n## Modifying the Scene\n\nThe first step is to modify the `scene(willConnectTo:options:)` method in your `SceneDelegate` to check if we're running `UIKitForMac` - after all, iOS doesn't have toolbars - and then make sure that our scene is actually a `UIWindowScene`:\n\n``` swift\n func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        guard let windowScene = (scene as? UIWindowScene) else { return }\n        #if targetEnvironment(UIKitForMac)\n\t#endif\n}\n```\n\n[`UIWindowScene`](https://developer.apple.com/documentation/uikit/uiwindowscene) objects have a `titlebar` property on macOS. These `UITitleBar` objects are currently not documented, but the headers expose a `toolbar` property that you can use to assign a `NSToolbar` to your window:\n\n``` swift\n func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        guard let windowScene = (scene as? UIWindowScene) else { return }\n        #if targetEnvironment(UIKitForMac)\n\t// Create a new toolbar (see below)\n\tlet newToolbar = makeMyFancyToolbar()\n\n\t// Insert it into the titlebar\n\twindowScene.titlebar.toolbar = self\n\n\t// Hide the window title, looks nicer\n\twindowScene.titlebar.titleVisibility = .hidden\n\t#endif\n}\n```\n\nSo this is how we insert an actual toolbar into our window. The last remaining step is to create such a toolbar, so how does that work?\n\n## Creating a Toolbar\n\nThis is actually a multi-step process as toolbars are quit versatile. You begin by instantiating a new toolbar and configuring it accordingly:\n\n``` swift\n// Create the toolbar\nlet toolbar = NSToolbar(identifier: \"MyFancyToolbar\")\n\n// Assign the delegate\ntoolbar.delegate = self\n```\n\nAs you can see, the configuration is just two lines of code (for now) but toolbars employ a delegate that you can leverage to configure them in much more detail. Lets see how.\n\n## Implementing the NSToolbarDelegate protocol\n\nFirst, you need an object that can conform to your toolbar delegate. For simplicity, lets just take our `SceneDelegate`. However, this can be any object and for more complex setups could be, for example, your own `MyToolbarController` class.\n\n``` swift\n#if targetEnvironment(UIKitForMac)\nextension SceneDelegate: NSToolbarDelegate {\n}\n#endif\n```\n\nAgain, make sure this code only compiles on macOS. Next, lets implement the bare minimum needed to display a toolbar.\n\n\nToolbars are versatile and allow your users to configure them and modify their contents. Our toolbar will just display a button on the right side. Toolbars identify their contents via toolbar identifiers of type `NSToolbarItem.Identifier`. Each item in the toolbar has a custom identifier. This makes it easy for the system to understand which items are in the toolbar, which can be customized, removed, etc. So in order for us to add a button, we need an identifier for our button:\n\n``` swift\nprivate let OurButtonToolbarIdentifier = NSToolbarItem.Identifier(rawValue: \"OurButton\")\n\n#if targetEnvironment(UIKitForMac)\nextension SceneDelegate: NSToolbarDelegate {\n}\n#endif\n```\n\nNext, we need to implement two methods that are called on the delegate to figure out what to display in the toolbar:\n\n1. `toolbarDefaultItemIdentifiers`: This returns the identifiers for the items that should be in the toolbar *by default*\n2. `toolbarAllowedItemIdentifiers`: This returns the identifiers that are *currently* allowed in the toolbar\n\nWe will implement default first:\n\n``` swift\nextension SceneDelegate: NSToolbarDelegate {\n    func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return [NSToolbarItem.Identifier.flexibleSpace,\n                OurButtonToolbarIdentifier]\n    }\n}\n```\n\nHere, we're returning an array of two items. The *last* is our `OurButtonToolbarIdentifier`. The *first* is a \"flexible space\" identifier that will consume as much horizontal space as possible, thus pushing our button all the way to the right.\n\nFor simplicity, the second method, `toolbarAllowedItemIdentifiers` just calls the first one.\n\n``` swift\nextension SceneDelegate: NSToolbarDelegate {\n    func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return [NSToolbarItem.Identifier.flexibleSpace,\n                OurButtonToolbarIdentifier]\n    }\n    func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return toolbarDefaultItemIdentifiers(toolbar)\n    }\n}\n```\n\nNow that we told the toolbar how to display itself, we just need to create those items (in our case just our button):\n\n``` swift\nextension SceneDelegate: NSToolbarDelegate {\n    func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -> NSToolbarItem? {\n        if (itemIdentifier == OurButtonToolbarIdentifier) {\n\t    let barButtonItem = UIBarButtonItem(barButtonSystemItem: UIBarButtonItem.SystemItem.add,\n\t                          target: self,\n\t\t\t\t  action: #selector(self.myFancyAction(sender:)))\n            let button = NSToolbarItem(itemIdentifier: itemIdentifier, barButtonItem: barButtonItem)\n            return button\n        }\n        return nil\n    }\n```\n\nAgain, this is simple enough. We just create a `UIBarButtonItem`, wrap it into a `NSToolbarItem` and return it. There're a lot of options here that we will not go into, but reading the headers and the documentation will help you along if you need more complex setups.\n\n[If you want to hide your existing iOS / UIKit toolbar, too, have a look at this section.](how/hide_tabbar_with_toolbar.md)\n\nIf you want to display a nice segmented control your toolbar, like this:\n\n![](/img-content/catalyst/segmentedcontrol_toolbar.png)\n\n[There's an explanation on how to do this in the following section.](how/segmented_control_toolbar.md)\n\nHere's the whole code `SceneDelegate` in one section:\n\n``` swift\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        guard let windowScene = (scene as? UIWindowScene) else { return }\n\n        #if targetEnvironment(UIKitForMac)\n        if let titlebar = windowScene.titlebar {\n            titlebar.titleVisibility = .hidden\n            titlebar.toolbar = makeMyFancyToolbar()\n        }\n        #endif\n    }\n\n    private func makeMyFancyToolbar() -> NSToolbar {\n        let toolbar = NSToolbar(identifier: \"MyToolbar\")\n        toolbar.delegate = self\n        return toolbar\n    }\n\n    @objc func myFancyAction(sender: UIBarButtonItem) {\n        print(\"Button Pressed\")\n    }\n}\n\n#if targetEnvironment(UIKitForMac)\n\nprivate let OurButtonToolbarIdentifier = NSToolbarItem.Identifier(rawValue: \"OurButton\")\n\nextension SceneDelegate: NSToolbarDelegate {\n    func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -> NSToolbarItem? {\n        if (itemIdentifier == OurButtonToolbarIdentifier) {\n            let barButton = UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(myFancyAction(sender:)))\n            let button = NSToolbarItem(itemIdentifier: itemIdentifier, barButtonItem: barButton)\n            return button\n        }\n        return nil\n    }\n\n    func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return [NSToolbarItem.Identifier.flexibleSpace, OurButtonToolbarIdentifier]\n    }\n\n    func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return toolbarDefaultItemIdentifiers(toolbar)\n    }\n}\n#endif\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/diving_in/associated_values.md":["cdb33215d7c89372",{"identifier":"23e824bd","filename":"associated_values.md","info":{"title":"Associated Values","tags":["enum","associated"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-associated-values.html","content":"<h1>Associated Values</h1>\n<p>Associated values are a fantastic way of attaching additional\ninformation to an <code>enum case</code>. Say you're writing a trading engine, and\nthere're two different possible trade types. <code>buy</code> and <code>sell</code>. Each of\nthem would be for a specific stock and amount:</p>\n<h3>Simple Example</h3>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy\n\n     <span class=\"keyword\">case</span> sell\n\n}\n\n<span class=\"keyword\">func</span> trade(tradeType: <span class=\"type\">Trade</span>, stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>) {}\n</code></pre></code></pre>\n<p>However, the stock and amount clearly belong to the trade in question,\nhaving them as separate parameters feels unclean. You could embed it\ninto a <code>struct</code>, but associated values allow for a much cleaner\nsolution:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>)\n\n}\n\n<span class=\"keyword\">func</span> trade(type: <span class=\"type\">Trade</span>) {}\n</code></pre></code></pre>\n<p>This defines two cases, <code>buy</code> and <code>sell</code>. Each of these cases has additional\nvalues attached to it: The <code>stock</code> and amount to buy / sell. These cases cannot exist\nwithout these additional values. You can't do this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"property\">buy</span>\n</code></pre></code></pre>\n<p>You always have to initialize these cases <strong>with the associated</strong> values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(\\<span class=\"string\">\"APPL</span>\\<span class=\"string\">\"</span>, <span class=\"number\">500</span>)\n</code></pre></code></pre>\n<h3>Pattern Matching</h3>\n<p>If you want to access this information, again, <a href=\"lnk::switch\">pattern matching comes\nto the\nrescue</a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(stock: \\<span class=\"string\">\"AAPL</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">500</span>)\n\n\n\n<span class=\"keyword\">if case let</span> <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(stock, amount) = trade {\n\n     <span class=\"call\">print</span>(\\<span class=\"string\">\"buy</span> \\(amount) of \\(stock)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>Here, you're telling the Swift compiler the following:\n&quot;If the <code>trade</code> is of type <code>Trade.buy</code> with the two values <code>stock</code> and <code>amount</code>, then <code>let</code> those\ntwo variables exist with the values&quot;. You kinda have to read this <code>if</code> line from right to left.</p>\n<p>There's an alternative way of writing this with two <code>let</code> statements:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">if case</span> <span class=\"type\">Trade</span>.<span class=\"call\">buy</span>(<span class=\"keyword\">let</span> stock, <span class=\"keyword\">let</span> amount) = trade {\n\n   ...\n\n}\n</code></pre></code></pre>\n<h3>Labels</h3>\n<p>Associated values do not require labels. You can just denote the types you'd like to see in your <code>enum case</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade {\n\n    <span class=\"keyword\">case</span> buy(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)\n\n    <span class=\"keyword\">case</span> sell(<span class=\"type\">String</span>, <span class=\"type\">Int</span>)\n\n}\n\n\n\n<span class=\"comment\">// Initialize without labels</span>\n\n<span class=\"keyword\">let</span> trade = <span class=\"type\">Trade</span>.<span class=\"call\">sell</span>(\\<span class=\"string\">\"APPL</span>\\<span class=\"string\">\"</span>, <span class=\"number\">500</span>)\n</code></pre></code></pre>\n<p>If you don't add labels, you also don't write them out when creating a case.\nIf you add them, though, you'll have to always type them out when creating\nyour enum cases.</p>\n<h3>Use Case Examples</h3>\n<p>Associated Values can be used in a variety of ways. What follows is a list of short examples in\nno particular order.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Cases can have different values</span>\n\n<span class=\"keyword\">enum</span> UserAction {\n\n   <span class=\"keyword\">case</span> openURL(url: <span class=\"type\">NSURL</span>)\n\n   <span class=\"keyword\">case</span> switchProcess(processId: <span class=\"type\">UInt32</span>)\n\n   <span class=\"keyword\">case</span> restart(time: <span class=\"type\">NSDate</span>?, intoCommandLine: <span class=\"type\">Bool</span>)\n\n}\n\n\n\n<span class=\"comment\">// Or imagine you're implementing a powerful text editor that allows you to have</span>\n\n<span class=\"comment\">// multiple selections, like Sublime Text here:</span>\n\n<span class=\"comment\">// https://www.youtube.com/watch?v=i2SVJa2EGIw</span>\n\n<span class=\"keyword\">enum</span> Selection {\n\n   <span class=\"keyword\">case</span> none\n\n   <span class=\"keyword\">case</span> single(<span class=\"type\">Range</span>&lt;<span class=\"type\">Int</span>&gt;)\n\n   <span class=\"keyword\">case</span> multiple([<span class=\"type\">Range</span>&lt;<span class=\"type\">Int</span>&gt;])\n\n}\n\n\n\n<span class=\"comment\">// Or mapping different types of identifier codes</span>\n\n<span class=\"keyword\">enum</span> Barcode {\n\n     <span class=\"keyword\">case</span> <span class=\"type\">UPCA</span>(numberSystem: <span class=\"type\">Int</span>, manufacturer: <span class=\"type\">Int</span>, product: <span class=\"type\">Int</span>, check: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> <span class=\"type\">QRCode</span>(productCode: <span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"comment\">// Or, imagine you're wrapping a C library, like the Kqeue BSD/Darwin notification</span>\n\n<span class=\"comment\">// system: https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</span>\n\n<span class=\"keyword\">enum</span> KqueueEvent {\n\n     <span class=\"keyword\">case</span> userEvent(identifier: <span class=\"type\">UInt</span>, fflags: [<span class=\"type\">UInt32</span>], data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> readFD(fd: <span class=\"type\">UInt</span>, data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> writeFD(fd: <span class=\"type\">UInt</span>, data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> vnodeFD(fd: <span class=\"type\">UInt</span>, fflags: [<span class=\"type\">UInt32</span>], data: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> errorEvent(code: <span class=\"type\">UInt</span>, message: <span class=\"type\">String</span>)\n\n}\n\n\n\n<span class=\"comment\">// Finally, all user-wearable items in an RPG could be mapped with one</span>\n\n<span class=\"comment\">// enum, that encodes for each item the additional armor and weight</span>\n\n<span class=\"comment\">// Now, adding a new material like 'Diamond' is just one line of code and we'll have the option to add several new Diamond-Crafted wearables.</span>\n\n<span class=\"keyword\">enum</span> Wearable {\n\n     <span class=\"keyword\">enum</span> Weight: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">1</span>\n\n         <span class=\"keyword\">case</span> mid = <span class=\"number\">4</span>\n\n         <span class=\"keyword\">case</span> heavy = <span class=\"number\">10</span>\n\n     }\n\n     <span class=\"keyword\">enum</span> Armor: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">case</span> light = <span class=\"number\">2</span>\n\n         <span class=\"keyword\">case</span> strong = <span class=\"number\">8</span>\n\n         <span class=\"keyword\">case</span> heavy = <span class=\"number\">20</span>\n\n     }\n\n     <span class=\"keyword\">case</span> helmet(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n     <span class=\"keyword\">case</span> breastplate(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n     <span class=\"keyword\">case</span> shield(weight: <span class=\"type\">Weight</span>, armor: <span class=\"type\">Armor</span>)\n\n}\n\n<span class=\"keyword\">let</span> woodenHelmet = <span class=\"type\">Wearable</span>.<span class=\"call\">helmet</span>(weight: .<span class=\"dotAccess\">light</span>, armor: .<span class=\"dotAccess\">light</span>)\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Associated Values\"\ntags = [\"enum\", \"associated\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Associated Values\n\nAssociated values are a fantastic way of attaching additional\ninformation to an `enum case`. Say you\\'re writing a trading engine, and\nthere\\'re two different possible trade types. `buy` and `sell`. Each of\nthem would be for a specific stock and amount:\n\n### Simple Example\n\n``` Swift\nenum Trade {\n    case buy\n    case sell\n}\nfunc trade(tradeType: Trade, stock: String, amount: Int) {}\n```\n\nHowever, the stock and amount clearly belong to the trade in question,\nhaving them as separate parameters feels unclean. You could embed it\ninto a `struct`, but associated values allow for a much cleaner\nsolution:\n\n``` Swift\nenum Trade {\n    case buy(stock: String, amount: Int)\n    case sell(stock: String, amount: Int)\n}\nfunc trade(type: Trade) {}\n```\n\nThis defines two cases, `buy` and `sell`. Each of these cases has additional\nvalues attached to it: The `stock` and amount to buy / sell. These cases cannot exist\nwithout these additional values. You can't do this:\n\n``` Swift\nlet trade = Trade.buy\n```\n\nYou always have to initialize these cases **with the associated** values:\n\n``` Swift\nlet trade = Trade.buy(\"APPL\", 500)\n```\n\n### Pattern Matching\n\nIf you want to access this information, again, [pattern matching comes\nto the\nrescue](lnk::switch):\n\n``` Swift\nlet trade = Trade.buy(stock: \"AAPL\", amount: 500)\n\nif case let Trade.buy(stock, amount) = trade {\n    print(\"buy \\(amount) of \\(stock)\")\n}\n```\n\nHere, you're telling the Swift compiler the following:\n\"If the `trade` is of type `Trade.buy` with the two values `stock` and `amount`, then `let` those\ntwo variables exist with the values\". You kinda have to read this `if` line from right to left.\n\nThere's an alternative way of writing this with two `let` statements:\n\n``` Swift\nif case Trade.buy(let stock, let amount) = trade {\n  ...\n}\n```\n\n### Labels\n\nAssociated values do not require labels. You can just denote the types you'd like to see in your `enum case`.\n\n``` Swift\nenum Trade {\n   case buy(String, Int)\n   case sell(String, Int)\n}\n\n// Initialize without labels\nlet trade = Trade.sell(\"APPL\", 500)\n```\n\nIf you don't add labels, you also don't write them out when creating a case. \nIf you add them, though, you\\'ll have to always type them out when creating\nyour enum cases.\n\n### Use Case Examples\n\nAssociated Values can be used in a variety of ways. What follows is a list of short examples in\nno particular order.\n\n``` Swift\n// Cases can have different values\nenum UserAction {\n  case openURL(url: NSURL)\n  case switchProcess(processId: UInt32)\n  case restart(time: NSDate?, intoCommandLine: Bool)\n}\n\n// Or imagine you're implementing a powerful text editor that allows you to have\n// multiple selections, like Sublime Text here:\n// https://www.youtube.com/watch?v=i2SVJa2EGIw\nenum Selection {\n  case none\n  case single(Range<Int>)\n  case multiple([Range<Int>])\n}\n\n// Or mapping different types of identifier codes\nenum Barcode {\n    case UPCA(numberSystem: Int, manufacturer: Int, product: Int, check: Int)\n    case QRCode(productCode: String)\n}\n\n// Or, imagine you're wrapping a C library, like the Kqeue BSD/Darwin notification\n// system: https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2\nenum KqueueEvent {\n    case userEvent(identifier: UInt, fflags: [UInt32], data: Int)\n    case readFD(fd: UInt, data: Int)\n    case writeFD(fd: UInt, data: Int)\n    case vnodeFD(fd: UInt, fflags: [UInt32], data: Int)\n    case errorEvent(code: UInt, message: String)\n}\n\n// Finally, all user-wearable items in an RPG could be mapped with one\n// enum, that encodes for each item the additional armor and weight\n// Now, adding a new material like 'Diamond' is just one line of code and we'll have the option to add several new Diamond-Crafted wearables.\nenum Wearable {\n    enum Weight: Int {\n        case light = 1\n        case mid = 4\n        case heavy = 10\n    }\n    enum Armor: Int {\n        case light = 2\n        case strong = 8\n        case heavy = 20\n    }\n    case helmet(weight: Weight, armor: Armor)\n    case breastplate(weight: Weight, armor: Armor)\n    case shield(weight: Weight, armor: Armor)\n}\nlet woodenHelmet = Wearable.helmet(weight: .light, armor: .light)\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/extensions.md":["4550ab5eb924ae0c",{"identifier":"a8476fb1","filename":"extensions.md","info":{"title":"Extensions","tags":["enum","extension"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-extensions.html","content":"<h1>Extensions</h1>\n<p>Take the following <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Entity {\n\n     <span class=\"keyword\">case</span> soldier(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> tank(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> player(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>As we just saw, enums can also be extended. There're two use cases for this.\nYou've already seen the first one: Conforming to a <code>protocol</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Entity</span>: <span class=\"type\">CustomStringConvertible</span> {\n\n   <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">soldier</span>(x, y): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(x), \\(y)\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">tank</span>(x, y): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(x), \\(y)\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">player</span>(x, y): <span class=\"keyword\">return</span> \\<span class=\"string\">\"</span>\\(x), \\(y)\\<span class=\"string\">\"</span>\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>The other use case\nis keeping <code>enum cases</code> and <code>methods</code> separate, so that a\nreader of your code can easily digest the <code>enum</code> and afterwards\nread the methods.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Entity</span> {\n\n    <span class=\"keyword\">mutating func</span> move(dist: <span class=\"type\">CGVector</span>) {}\n\n    <span class=\"keyword\">mutating func</span> attack() {}\n\n}\n</code></pre></code></pre>\n<h2>Extending</h2>\n<p>Extensions also allow you to add useful code to existing <code>enum</code> types. Either from the Swift standard library, or from third party frameworks, or from yourself if you happen to have a big codebase.</p>\n<p>For example, we can extend the standard library <code>Optional</code> type in order to add useful extensions. If you'd like to learn more about this, <a href=\"lnk::optional\">we have an article that explains this in more detail.</a></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Optional</span> {\n\n     <span class=\"comment\">/// Returns true if the optional is empty</span>\n\n     <span class=\"keyword\">var</span> isNone: <span class=\"type\">Bool</span> {\n\n         <span class=\"keyword\">return self</span> == .<span class=\"dotAccess\">none</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Another example would be addign a convenience extension to one of your own <code>enum</code> types that is <code>fileprivate</code> so that you'd use it only within a specific file:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">fileprivate extension</span> <span class=\"type\">Entity</span> {\n\n   <span class=\"keyword\">mutating func</span> replace(to: <span class=\"type\">Entity</span>) {\n\n     <span class=\"keyword\">self</span> = entity\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Here, we have an extension to your <code>Entity</code> that allows to replace it with a different entity. This would only be used deep within your game engine which is why the scope is limited to one file.</p>\n","raw_content":"[frontMatter]\ntitle = \"Extensions\"\ntags = [\"enum\", \"extension\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Extensions\n\nTake the following `enum`:\n\n``` Swift\nenum Entity {\n    case soldier(x: Int, y: Int)\n    case tank(x: Int, y: Int)\n    case player(x: Int, y: Int)\n}\n```\n\nAs we just saw, enums can also be extended. There're two use cases for this.\nYou've already seen the first one: Conforming to a `protocol`.\n\n``` Swift\nextension Entity: CustomStringConvertible {\n  var description: String {\n    switch self {\n    case let .soldier(x, y): return \"\\(x), \\(y)\"\n    case let .tank(x, y): return \"\\(x), \\(y)\"\n    case let .player(x, y): return \"\\(x), \\(y)\"\n    }\n  }\n}\n```\n\nThe other use case\nis keeping `enum cases` and `methods` separate, so that a\nreader of your code can easily digest the `enum` and afterwards \nread the methods.\n\n``` Swift\nextension Entity {\n   mutating func move(dist: CGVector) {}\n   mutating func attack() {}\n}\n```\n\n## Extending \n\nExtensions also allow you to add useful code to existing `enum` types. Either from the Swift standard library, or from third party frameworks, or from yourself if you happen to have a big codebase.\n\nFor example, we can extend the standard library `Optional` type in order to add useful extensions. If you'd like to learn more about this, [we have an article that explains this in more detail.](lnk::optional)\n\n``` Swift\nextension Optional {\n    /// Returns true if the optional is empty\n    var isNone: Bool {\n        return self == .none\n    }\n}\n```\n\nAnother example would be addign a convenience extension to one of your own `enum` types that is `fileprivate` so that you'd use it only within a specific file:\n\n``` Swift\nfileprivate extension Entity {\n  mutating func replace(to: Entity) {\n    self = entity\n  }\n}\n```\n\nHere, we have an extension to your `Entity` that allows to replace it with a different entity. This would only be used deep within your game engine which is why the scope is limited to one file.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/modify_window.md":["8d3b1f99677b805e",{"identifier":"2a50e799","filename":"modify_window.md","info":{"title":"How do I modify the window?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-modify-the-window.html","content":"<h2>Preparations</h2>\n<p>Note that in <em>Beta 2</em> you need to manually import a special bridging header if you want to modify the title. <a href=\"firststeps/bridgingheader.md\">Here's how to do it</a>.</p>\n<p>The way to modify window titlebars is to use the <code>UIScene</code> API introduced with iOS 13. The gist is that you use a <code>SceneDelegate</code> and in the <code>scene:willConnectToSession:options</code> method, you can modify a window scene's <code>titlebar</code>.</p>\n<p>If your project doesn't have a <code>SceneDelegate</code> yet, <a href=\"firststeps/scene_delegate.md\">here's a brief primer on how to set it up.</a>. This delegate is - as far as I'm aware - required to support toolbars.</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiwindowscene\"><code>UIWindowScene</code></a> objects have a <code>titlebar</code> property on macOS. These <code>UITitleBar</code> objects are currently not documented, but the headers expose several properties:</p>\n<pre class=\"Swift\"><code>  <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n     windowScene.<span class=\"property\">titlebar</span>.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n     <span class=\"preprocessing\">#endif</span>\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I modify the window?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\n## Preparations\n\nNote that in *Beta 2* you need to manually import a special bridging header if you want to modify the title. [Here's how to do it](firststeps/bridgingheader.md).\n\nThe way to modify window titlebars is to use the `UIScene` API introduced with iOS 13. The gist is that you use a `SceneDelegate` and in the `scene:willConnectToSession:options` method, you can modify a window scene's `titlebar`.\n\nIf your project doesn't have a `SceneDelegate` yet, [here's a brief primer on how to set it up.](firststeps/scene_delegate.md). This delegate is - as far as I'm aware - required to support toolbars.\n\n[`UIWindowScene`](https://developer.apple.com/documentation/uikit/uiwindowscene) objects have a `titlebar` property on macOS. These `UITitleBar` objects are currently not documented, but the headers expose several properties:\n\n``` swift\n func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        guard let windowScene = (scene as? UIWindowScene) else { return }\n        #if targetEnvironment(UIKitForMac)\n\twindowScene.titlebar.titleVisibility = .hidden\n\t#endif\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/modify_menubar.md":["8995c823b0bde27a",{"identifier":"302ef8f8","filename":"modify_menubar.md","info":{"title":"How do I modify the menubar?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-modify-the-menubar.html","content":"<p>In the WWDC slides and the sample code, Apple touts a <code>buildCommands</code> method on <code>UIResponder</code> for menus. <a href=\"https://developer.apple.com/documentation/uikit/uiresponder/3175394-buildcommands\">However, this was deprecated with beta 1</a>. Instead, we should use <a href=\"https://developer.apple.com/documentation/uikit/uiresponder/3327317-buildmenu\">buildMenu(with:)</a>. This currently lacks documentation though.</p>\n<p>It seems, currently, the best way to modify the Menubar (or, <code>MainMenu</code>) is by using storyboards and dropping a <code>Main Menu</code> into your storyboard. This new scene will be just like the default menu, but you can edit it.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I modify the menubar?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nIn the WWDC slides and the sample code, Apple touts a `buildCommands` method on `UIResponder` for menus. [However, this was deprecated with beta 1](https://developer.apple.com/documentation/uikit/uiresponder/3175394-buildcommands). Instead, we should use [buildMenu(with:)](https://developer.apple.com/documentation/uikit/uiresponder/3327317-buildmenu). This currently lacks documentation though.\n\nIt seems, currently, the best way to modify the Menubar (or, `MainMenu`) is by using storyboards and dropping a `Main Menu` into your storyboard. This new scene will be just like the default menu, but you can edit it.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/iteration.md":["48cfe94f39197b49",{"identifier":"72ad37e7","filename":"iteration.md","info":{"title":"Iteration","tags":["tuples","reflection"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-iteration.html","content":"<h1>Iteration</h1>\n<p>So far, I've tried to steer clear of calling tuples\nsequences or collections because they aren't. Since every element of a\ntuple can have a different type, there's no type-safe way of looping or\nmapping over the contents of a tuple. Well, no beautiful one, that is.</p>\n<p>Swift does offer <a href=\"lnk::reflection\">limited reflection capabilities</a>, and these allow us to\ninspect the elements of a tuple and loop over them. The downside is that\nthe type checker has no way to figure out what the type of each element\nis, and thus everything is typed as <code>Any</code>. It is your job then to cast\nand match this against your possible types to figure out what to do.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> t = (a: <span class=\"number\">5</span>, b: \\<span class=\"string\">\"String</span>\\<span class=\"string\">\"</span>, c: <span class=\"type\">Date</span>())\n\n\n\n<span class=\"keyword\">let</span> mirror = <span class=\"type\">Mirror</span>(reflecting: t)\n\n<span class=\"keyword\">for</span> (label, value) <span class=\"keyword\">in</span> mirror.<span class=\"property\">children</span> {\n\n     <span class=\"keyword\">switch</span> value {\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">Int</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"int</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">String</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"string</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">NSDate</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"nsdate</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">default</span>: ()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This is not as simple as array iteration, but it does work if you really\nneed it.</p>\n<p>You can also abstract this into a nice function which translate your tuple\ntype into a parseable description.</p>\n","raw_content":"[frontMatter]\ntitle = \"Iteration\"\ntags = [\"tuples\", \"reflection\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Iteration\n\nSo far, I\\'ve tried to steer clear of calling tuples\nsequences or collections because they aren\\'t. Since every element of a\ntuple can have a different type, there\\'s no type-safe way of looping or\nmapping over the contents of a tuple. Well, no beautiful one, that is.\n\nSwift does offer [limited reflection capabilities](lnk::reflection), and these allow us to\ninspect the elements of a tuple and loop over them. The downside is that\nthe type checker has no way to figure out what the type of each element\nis, and thus everything is typed as `Any`. It is your job then to cast\nand match this against your possible types to figure out what to do.\n\n``` Swift\nlet t = (a: 5, b: \"String\", c: Date())\n\nlet mirror = Mirror(reflecting: t)\nfor (label, value) in mirror.children {\n    switch value {\n    case is Int:\n        print(\"int\")\n    case is String:\n        print(\"string\")\n    case is NSDate:\n        print(\"nsdate\")\n    default: ()\n    }\n}\n```\n\nThis is not as simple as array iteration, but it does work if you really\nneed it.\n\nYou can also abstract this into a nice function which translate your tuple\ntype into a parseable description.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/keypath_composition.md":["1889748f88e76418",{"identifier":"97d1f386","filename":"keypath_composition.md","info":{"title":"KeyPath Composition","tags":["keypath","composition"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-keypath-composition.html","content":"<h1>KeyPath Composition</h1>\n<p>The last keypath concept that we should tackle is keypath composition: Swift allows you to dynamically combine <code>KeyPath</code> types at runtime if the types match up.</p>\n<p>In order to showcase this, we will go back to our <code>User</code> and <code>Address</code> struct:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">let</span> address: <span class=\"type\">Address</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Address {\n\n   <span class=\"keyword\">let</span> street: <span class=\"type\">String</span>\n\n}\n</code></pre></code></pre>\n<h3>Example</h3>\n<p>Based on this structure, we will take two different keypaths; first, one to the <code>address</code> property on the <code>User</code>, and then one on the <code>String</code> property on the <code>Address</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> addressKeyPath = \\<span class=\"type\">User</span>.<span class=\"property\">address</span>\n\n\n\n<span class=\"keyword\">let</span> streetKeyPath = \\<span class=\"type\">Address</span>.<span class=\"property\">street</span>\n</code></pre></code></pre>\n<p>Given these two variables, we can now compose them to manifest a new keypath at runtime that goes from <code>User</code> to the <code>street</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> newKeyPath = addressKeyPath.<span class=\"call\">appending</span>(path: streetKeyPath)\n</code></pre></code></pre>\n<p>Here, we created a new <code>KeyPath&lt;User, String&gt;</code> at runtime by joining a <code>KeyPath&lt;User, Address&gt;</code> and a <code>KeyPath&lt;Address, String&gt;</code>. However, what should Swift do if you try to merge a <code>KeyPath&lt;User, String&gt;</code> and a <code>KeyPath&lt;House, Int&gt;</code>. Obviously, there's no relationship between these types. Swift solves this by introducing laws of keypath composition. Lets have a look at them.</p>\n","raw_content":"[frontMatter]\ntitle = \"KeyPath Composition\"\ntags = [\"keypath\", \"composition\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# KeyPath Composition\n\nThe last keypath concept that we should tackle is keypath composition: Swift allows you to dynamically combine `KeyPath` types at runtime if the types match up. \n\nIn order to showcase this, we will go back to our `User` and `Address` struct:\n\n``` Swift\nstruct User {\n  let address: Address\n}\n\nstruct Address {\n  let street: String\n}\n```\n\n### Example\n\nBased on this structure, we will take two different keypaths; first, one to the `address` property on the `User`, and then one on the `String` property on the `Address`:\n\n``` Swift\nlet addressKeyPath = \\User.address\n\nlet streetKeyPath = \\Address.street\n```\n\nGiven these two variables, we can now compose them to manifest a new keypath at runtime that goes from `User` to the `street`:\n\n``` Swift\nlet newKeyPath = addressKeyPath.appending(path: streetKeyPath)\n```\n\nHere, we created a new `KeyPath<User, String>` at runtime by joining a `KeyPath<User, Address>` and a `KeyPath<Address, String>`. However, what should Swift do if you try to merge a `KeyPath<User, String>` and a `KeyPath<House, Int>`. Obviously, there's no relationship between these types. Swift solves this by introducing laws of keypath composition. Lets have a look at them.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/reduce_examples.md":["352112c402ff71d1",{"identifier":"e8497e2b","filename":"reduce_examples.md","info":{"title":"Reduce Examples","tags":["reduce","partition"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-reduce-examples.html","content":"<h1>Reduce Examples</h1>\n<p>Let's start with a favorite of mine, the sum of a list of numbers:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, +)\n\n<span class=\"comment\">// 10</span>\n</code></pre></code></pre>\n<p><code>+</code> is a valid <code>combinator</code> function as it will just add the <code>lhs</code> and\nthe <code>rhs</code> and return the result, which is specifically the requirement\n<code>reduce</code> has.</p>\n<p>Another example is building the product of a list of numbers:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">reduce</span>(<span class=\"number\">1</span>, *)\n\n<span class=\"comment\">// 24</span>\n</code></pre></code></pre>\n<p>Or what about reversing a list:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), { [$1] + $0 })\n\n<span class=\"comment\">// 5, 4, 3, 2, 1</span>\n</code></pre></code></pre>\n<p>Finally, something a tad more complicated. We'd like to partition a\nlist based on a division criteria</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Acc = (l: [<span class=\"type\">Int</span>], r: [<span class=\"type\">Int</span>])\n\n<span class=\"keyword\">func</span> partition(<span class=\"keyword\">_</span> lst: [<span class=\"type\">Int</span>], criteria: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Acc</span> {\n\n    <span class=\"keyword\">return</span> lst.<span class=\"call\">reduce</span>((l: [<span class=\"type\">Int</span>](), r: [<span class=\"type\">Int</span>]()), { (ac: <span class=\"type\">Acc</span>, o: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span> \n\n       <span class=\"keyword\">if</span> <span class=\"call\">criteria</span>(o) {\n\n         <span class=\"keyword\">return</span> (l: ac.<span class=\"property\">l</span> + [o], r: ac.<span class=\"property\">r</span>)\n\n       } <span class=\"keyword\">else</span> {\n\n         <span class=\"keyword\">return</span> (r: ac.<span class=\"property\">r</span> + [o], l: ac.<span class=\"property\">l</span>)\n\n       }\n\n    })\n\n}\n\n<span class=\"call\">partition</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>], criteria: { $0 % <span class=\"number\">2</span> == <span class=\"number\">0</span> })\n\n<span class=\"comment\">//: ([2, 4, 6, 8], [1, 3, 5, 7, 9])</span>\n</code></pre></code></pre>\n<p>The most interesting thing we're doing above is using a <code>tuple</code> as the\naccumulator. As you'll find out, once you start trying to incorporate\n<code>reduce</code> into your daily work-flow, <code>tuples</code> are a great way of quickly\ncombining related data during a reduce operation.</p>\n","raw_content":"[frontMatter]\ntitle = \"Reduce Examples\"\ntags = [\"reduce\", \"partition\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Reduce Examples\n\nLet\\'s start with a favorite of mine, the sum of a list of numbers:\n\n``` Swift\n[0, 1, 2, 3, 4].reduce(0, +)\n// 10\n```\n\n`+` is a valid `combinator` function as it will just add the `lhs` and\nthe `rhs` and return the result, which is specifically the requirement\n`reduce` has.\n\nAnother example is building the product of a list of numbers:\n\n``` Swift\n[1, 2, 3, 4].reduce(1, *)\n// 24\n```\n\nOr what about reversing a list:\n\n``` Swift\n[1, 2, 3, 4, 5].reduce([Int](), { [$1] + $0 })\n// 5, 4, 3, 2, 1\n```\n\nFinally, something a tad more complicated. We\\'d like to partition a\nlist based on a division criteria\n\n``` Swift\ntypealias Acc = (l: [Int], r: [Int])\nfunc partition(_ lst: [Int], criteria: (Int) -> Bool) -> Acc {\n   return lst.reduce((l: [Int](), r: [Int]()), { (ac: Acc, o: Int) -> Acc in \n      if criteria(o) {\n        return (l: ac.l + [o], r: ac.r)\n      } else {\n        return (r: ac.r + [o], l: ac.l)\n      }\n   })\n}\npartition([1, 2, 3, 4, 5, 6, 7, 8, 9], criteria: { $0 % 2 == 0 })\n//: ([2, 4, 6, 8], [1, 3, 5, 7, 9])\n```\n\nThe most interesting thing we\\'re doing above is using a `tuple` as the\naccumulator. As you\\'ll find out, once you start trying to incorporate\n`reduce` into your daily work-flow, `tuples` are a great way of quickly\ncombining related data during a reduce operation.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/logic_preferences.md":["4c9c570bd9023ea0",{"identifier":"f66fc1af","filename":"logic_preferences.md","info":{"title":"How do I implement preferences with additional logic?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-implement-preferences-with-additional-logic.html","content":"<p>Now, if you have more involved logic in your settings, special view controllers, web views, and other things, then this doesn't work well for you. In that case, you basically have three options.</p>\n<ol>\n<li>Don't display the preferences in a window, but present the view controller as a modal form or sheet instead</li>\n<li>Use the <a href=\"firststeps/multiple_windows.md\">new iOS multi window support to</a>, only on macOS, open the settings controller in a new window. This is a bit more involved but certainly the most feasible solution.</li>\n<li>Use AppKit to macOS specific preferences in a separate AppKit bundle and load it at runtime. We won't dive into this here, but you can find <a href=\"https://www.highcaffeinecontent.com/blog/20190607-Beyond-the-Checkbox-with-Catalyst-and-AppKit\">more information on this in Steve Troughton-Smith' excellent article on the topic.</a></li>\n</ol>\n","raw_content":"[frontMatter]\ntitle = \"How do I implement preferences with additional logic?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nNow, if you have more involved logic in your settings, special view controllers, web views, and other things, then this doesn't work well for you. In that case, you basically have three options.\n\n1. Don't display the preferences in a window, but present the view controller as a modal form or sheet instead\n2. Use the [new iOS multi window support to](firststeps/multiple_windows.md), only on macOS, open the settings controller in a new window. This is a bit more involved but certainly the most feasible solution.\n3. Use AppKit to macOS specific preferences in a separate AppKit bundle and load it at runtime. We won't dive into this here, but you can find [more information on this in Steve Troughton-Smith' excellent article on the topic.](https://www.highcaffeinecontent.com/blog/20190607-Beyond-the-Checkbox-with-Catalyst-and-AppKit)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/tips/erase_types.md":["805e8a32120f6fbd",{"identifier":"d6d8c358","filename":"erase_types.md","info":{"title":"Erase Types","tags":["keypath","partialkeypath","anykeypath","erase","type-erase"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-erase-types.html","content":"<h1>1. Erase Types</h1>\n<p>We already saw this, but it is worth mentioning again. One reason why keypaths are so useful is because there're type-erased variants. As we saw in our practical example, the ability to temporarily go to <code>AnyKeyPath</code> offers many more opportunities. So, always remember these types:</p>\n<pre class=\"Swift\"><code><span class=\"type\">KeyPath</span>&lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n\n<span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">A</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n\n<span class=\"type\">AnyKeyPath</span> = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Erase Types\"\ntags = [\"keypath\", \"partialkeypath\", \"anykeypath\", \"erase\", \"type-erase\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# 1. Erase Types\n\nWe already saw this, but it is worth mentioning again. One reason why keypaths are so useful is because there're type-erased variants. As we saw in our practical example, the ability to temporarily go to `AnyKeyPath` offers many more opportunities. So, always remember these types:\n\n``` Swift\nKeyPath<A, B> = \\User.age\nPartialKeyPath<A> = \\User.age\nAnyKeyPath = \\User.age\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/intro.md":["73764311d5673230",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Intro","tags":[],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-intro.html","content":"<h1>Intro</h1>\n<p>Even before Swift was released, iOS / Cocoa developers could use third\nparty frameworks like ObjectiveSugar or ReactiveCocoa in order to gain\nfunctional programming constructs like <code>map</code>, <code>flatMap</code> or <code>filter</code>.</p>\n<p>With Swift, they have become first class language citizens. There are\nmany advantages to using them over a standard <code>for</code> loop. They typically\nexpress your intent better, they require less code, and they can be\nchained together in order to build up complex logic in a clear way.</p>\n<p>In this post, I'd like to show another very cool functional addition to\nSwift which can sometimes be a better solution than <code>map</code> / <code>filter</code>\nconstructs: <code>reduce</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Intro\"\ntags = []\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n---\n\n# Intro\n\nEven before Swift was released, iOS / Cocoa developers could use third\nparty frameworks like ObjectiveSugar or ReactiveCocoa in order to gain\nfunctional programming constructs like `map`, `flatMap` or `filter`.\n\nWith Swift, they have become first class language citizens. There are\nmany advantages to using them over a standard `for` loop. They typically\nexpress your intent better, they require less code, and they can be\nchained together in order to build up complex logic in a clear way.\n\nIn this post, I\\'d like to show another very cool functional addition to\nSwift which can sometimes be a better solution than `map` / `filter`\nconstructs: `reduce`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/darkmode.md":["887ca742ee9b052f",{"identifier":"e6599534","filename":"darkmode.md","info":{"title":"How do I support dark mode?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-support-dark-mode.html","content":"<p>Dark mode works just as the Dark Mode on iOS 13. If your app supports dark mode on iOS 13 (i.e. semantic colors and so on) then dark mode will also work on macOS.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I support dark mode?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nDark mode works just as the Dark Mode on iOS 13. If your app supports dark mode on iOS 13 (i.e. semantic colors and so on) then dark mode will also work on macOS.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/custom_initializers.md":["4fe2f672014b7e77",{"identifier":"d7f454ae","filename":"custom_initializers.md","info":{"title":"Custom Initializers","tags":["enum","init"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-custom-initializers.html","content":"<h1>Custom Initializers</h1>\n<p>Imagine you'd want to initialize an <code>enum</code> with custom data. In our example\nwe have a <code>Device</code> enum that represents Apple devices and we'd like to\nalso initialize them with non-standard names. Here's the <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n   <span class=\"keyword\">case</span> appleWatch\n\n}\n</code></pre></code></pre>\n<p>Now if a user accidentally enters <code>iWatch</code> as their device, we still want to map this\nto the correct <code>AppleWatch</code> case. To do that, we will implement a custom initializer\nthat sets <code>self</code> to the correct type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device { \n\n     <span class=\"keyword\">case</span> appleWatch \n\n     <span class=\"keyword\">init</span>?(term: <span class=\"type\">String</span>) {\n\n       <span class=\"keyword\">if</span> term == \\<span class=\"string\">\"iWatch</span>\\<span class=\"string\">\"</span> {\n\n           <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">appleWatch</span>\n\n       } <span class=\"keyword\">else</span> {\n\n           <span class=\"keyword\">return nil</span>\n\n       }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>In the above example, we used a failable initializer. However, normal\ninitializers work just as well:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> NumberCategory {\n\n    <span class=\"keyword\">case</span> small\n\n    <span class=\"keyword\">case</span> medium\n\n    <span class=\"keyword\">case</span> big\n\n    <span class=\"keyword\">case</span> huge\n\n\n\n    <span class=\"keyword\">init</span>(number n: <span class=\"type\">Int</span>) {\n\n         <span class=\"keyword\">if</span> n &lt; <span class=\"number\">10000</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">small</span> }\n\n         <span class=\"keyword\">else if</span> n &lt; <span class=\"number\">1000000</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">medium</span> }\n\n         <span class=\"keyword\">else if</span> n &lt; <span class=\"number\">100000000</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">big</span> }\n\n         <span class=\"keyword\">else</span> { <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">huge</span> }\n\n    }\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Custom Initializers\"\ntags = [\"enum\", \"init\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Custom Initializers\n\nImagine you'd want to initialize an `enum` with custom data. In our example\nwe have a `Device` enum that represents Apple devices and we'd like to \nalso initialize them with non-standard names. Here's the `enum`:\n\n``` Swift\nenum Device {\n  case appleWatch\n}\n```\n\nNow if a user accidentally enters `iWatch` as their device, we still want to map this\nto the correct `AppleWatch` case. To do that, we will implement a custom initializer\nthat sets `self` to the correct type:\n\n``` Swift\nenum Device { \n    case appleWatch \n    init?(term: String) {\n      if term == \"iWatch\" {\n          self = .appleWatch\n      } else {\n          return nil\n      }\n    }\n}\n```\n\nIn the above example, we used a failable initializer. However, normal\ninitializers work just as well:\n\n``` Swift\nenum NumberCategory {\n   case small\n   case medium\n   case big\n   case huge\n\n   init(number n: Int) {\n        if n < 10000 { self = .small }\n        else if n < 1000000 { self = .medium }\n        else if n < 100000000 { self = .big }\n        else { self = .huge }\n   }\n}\n```\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/generic_enums.md":["addd95aa54e41930",{"identifier":"71f58640","filename":"generic_enums.md","info":{"title":"Generic Enums","tags":["enum","generics","where"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-generic-enums.html","content":"<h1>Generic Enums</h1>\n<p>Enums can also be defined over generic parameters. You'd use them to\nadapt the associated values of an enum. The simplest example comes\nstraight from the Swift standard library, namely the <a href=\"lnk::optional\"><code>Optional</code> type</a>.\nYou probably mostly use it with <strong>optional chaining</strong> (<code>?</code>), <code>if let</code>,\n<code>guard let</code>, or <code>switch</code>, but syntactically you can also use Optionals\nlike so:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> aValue = <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt;.<span class=\"call\">some</span>(<span class=\"number\">5</span>)\n\n<span class=\"keyword\">let</span> noValue = <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt;.<span class=\"property\">none</span>\n\n<span class=\"keyword\">if</span> noValue == <span class=\"type\">Optional</span>.<span class=\"property\">none</span> { <span class=\"call\">print</span>(\\<span class=\"string\">\"No</span> value\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<p>This is the direct usage of an Optional without any of the syntactic\nsugar that Swift adds in order to make your life a tremendous amount\neasier. If you look at the code above, you can probably guess that\ninternally the <code>Optional</code> is defined as follows <sup class=\"footnote-reference\"><a href=\"#5\">1</a></sup>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Simplified implementation of Swift's Optional</span>\n\n<span class=\"keyword\">enum</span> MyOptional&lt;T&gt; {\n\n   <span class=\"keyword\">case</span> some(<span class=\"type\">T</span>)\n\n   <span class=\"keyword\">case</span> none\n\n}\n</code></pre></code></pre>\n<p>What's special here is, that the enum's <strong>associated values</strong> take the\ntype of the generic parameter <code>T</code>, so that optionals can be built for\nany kind you wish to return.</p>\n<p>Enums can have multiple generic parameters. Take the well-known\n<strong>Either</strong> type which is not part of Swift's standard library but\nimplemented in many open source libraries as well as prevalent in other\nfunctional programming languages like Haskell or F#. The idea is that\ninstead of just returning a value or no value (née Optional) you'd\nreturn either one of two different values.</p>\n<p>For example, if you parse user input, the user could enter a name or a number,\nin that case the type of <code>Either</code> would be <code>Either&lt;String, Int&gt;</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Either&lt;T1, T2&gt; {\n\n   <span class=\"keyword\">case</span> left(<span class=\"type\">T1</span>)\n\n   <span class=\"keyword\">case</span> right(<span class=\"type\">T2</span>)\n\n}\n</code></pre></code></pre>\n<p>Finally, all the type constraints that work on classes and structs in\nSwift also work on enums. Here, we have a type <code>Bag</code> that is either empty\nor contains an array of elements. Those elements <strong>have</strong> to be <code>Equatable</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Bag&lt;T: <span class=\"type\">Sequence</span>&gt; <span class=\"keyword\">where</span> <span class=\"type\">T</span>.<span class=\"type\">Iterator</span>.<span class=\"type\">Element</span>==<span class=\"type\">Equatable</span> {\n\n     <span class=\"keyword\">case</span> empty\n\n     <span class=\"keyword\">case</span> full(contents: [<span class=\"type\">T</span>)]\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Generic Enums\"\ntags = [\"enum\", \"generics\", \"where\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Generic Enums\n\nEnums can also be defined over generic parameters. You\\'d use them to\nadapt the associated values of an enum. The simplest example comes\nstraight from the Swift standard library, namely the [`Optional` type](lnk::optional).\nYou probably mostly use it with **optional chaining** (`?`), `if let`,\n`guard let`, or `switch`, but syntactically you can also use Optionals\nlike so:\n\n``` Swift\nlet aValue = Optional<Int>.some(5)\nlet noValue = Optional<Int>.none\nif noValue == Optional.none { print(\"No value\") }\n```\n\nThis is the direct usage of an Optional without any of the syntactic\nsugar that Swift adds in order to make your life a tremendous amount\neasier. If you look at the code above, you can probably guess that\ninternally the `Optional` is defined as follows [^5]:\n\n``` Swift\n// Simplified implementation of Swift's Optional\nenum MyOptional<T> {\n  case some(T)\n  case none\n}\n```\n\nWhat\\'s special here is, that the enum\\'s **associated values** take the\ntype of the generic parameter `T`, so that optionals can be built for\nany kind you wish to return.\n\nEnums can have multiple generic parameters. Take the well-known\n**Either** type which is not part of Swift\\'s standard library but\nimplemented in many open source libraries as well as prevalent in other\nfunctional programming languages like Haskell or F\\#. The idea is that\ninstead of just returning a value or no value (née Optional) you\\'d\nreturn either one of two different values. \n\nFor example, if you parse user input, the user could enter a name or a number,\nin that case the type of `Either` would be `Either<String, Int>`.\n\n``` Swift\nenum Either<T1, T2> {\n  case left(T1)\n  case right(T2)\n}\n```\n\nFinally, all the type constraints that work on classes and structs in\nSwift also work on enums. Here, we have a type `Bag` that is either empty\nor contains an array of elements. Those elements **have** to be `Equatable`.\n\n``` Swift\nenum Bag<T: Sequence> where T.Iterator.Element==Equatable {\n    case empty\n    case full(contents: [T)]\n}\n```\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/map_flatmap_reduce_more/complete_book.html":["e3b0c44298fc1c14",{"identifier":"048a","filename":"complete_book.html","info":{"title":"Map, FlatMap, Reduce & More","tags":[],"keywords":["feature","swift","reduce","map","filter","group","partition","split","interpose","chunk","functional","programming","flatMap","compactMap"],"category":[],"created":"2015-11-30 10:30:30","description":"A practical introduction into the `map`, `compactMap`, `filter`, and `reduce` functions.","description_html":"<p>A practical introduction into the <code>map</code>, <code>compactMap</code>, <code>filter</code>, and <code>reduce</code> functions.</p>\n","published":true,"slug":null,"meta":{"short_code":"<pre class='Swift'><code><span class='source swift'>array<span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'>.</span>reduce(<span class='apvconstant apvnumeric apvinteger apvdecimal swift'>0</span>, { $<span class='apvconstant apvnumeric apvinteger apvdecimal swift'>0</span> <span class='apvkeyword apvoperator apvassignment swift'>+=</span> $<span class='apvconstant apvnumeric apvinteger apvdecimal swift'>1</span> }) </span></code></pre></code></pre>","short_title":"🗺 Map, Reduce & more","swift_version":"5.1"},"created_timestamp":1448879430,"date":"2015-11-30T10:30:30","date_info":{"year":2015,"month":11,"day":30,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/map_flatmap_reduce_more/complete_book.html","content":"<h1>Intro</h1>\n<p>Even before Swift was released, iOS / Cocoa developers could use third\nparty frameworks like ObjectiveSugar or ReactiveCocoa in order to gain\nfunctional programming constructs like <code>map</code>, <code>flatMap</code> or <code>filter</code>.</p>\n<p>With Swift, they have become first class language citizens. There are\nmany advantages to using them over a standard <code>for</code> loop. They typically\nexpress your intent better, they require less code, and they can be\nchained together in order to build up complex logic in a clear way.</p>\n<p>In this post, I'd like to show another very cool functional addition to\nSwift which can sometimes be a better solution than <code>map</code> / <code>filter</code>\nconstructs: <code>reduce</code>.</p>\n<h1>A simple Problem</h1>\n<p>Consider this problem: You're getting a list of persons from a JSON\nendpoint. You'd like to know the average age from all people living in\nCalifornia. The parsed data looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> persons: [[<span class=\"type\">String</span>: <span class=\"type\">Any</span>]] = [[\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Carl</span> <span class=\"type\">Saxon</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"New</span> <span class=\"type\">York</span>, <span class=\"type\">NY</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">44</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Travis</span> <span class=\"type\">Downing</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"El</span> <span class=\"type\">Segundo</span>, <span class=\"type\">CA</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">34</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Liz</span> <span class=\"type\">Parker</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"San</span> <span class=\"type\">Francisco</span>, <span class=\"type\">CA</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">32</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"John</span> <span class=\"type\">Newden</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"New</span> <span class=\"type\">Jersey</span>, <span class=\"type\">NY</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">21</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Hector</span> <span class=\"type\">Simons</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"San</span> <span class=\"type\">Diego</span>, <span class=\"type\">CA</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">37</span>],\n\n  [\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Brian</span> <span class=\"type\">Neo</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">27</span>]]\n</code></pre></code></pre>\n<p>Note the last entry, which omits a <code>city</code> for the person in question.\nThose cases have to be silently ignored.</p>\n<p>The expected result in the example would be 3 persons , as we have three\npersons from California. Let's try to implement this in Swift in terms\nof <code>compactMap</code> and <code>filter</code>. The <code>compactMap</code> is used instead of <code>map</code> as\n<code>compactMap</code> automatically ignores empty optionals. So\n<code>compactMap([0, nil, 1, 2, nil])</code> results in <code>[0, 1, 2]</code>. This eases the\nhandling of persons without a proper city.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> infoFromState(state: <span class=\"type\">String</span>, persons: [[<span class=\"type\">String</span>: <span class=\"type\">Any</span>]]) \n\n      -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">return</span> persons.<span class=\"call\">compactMap</span>( { $0[\\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>]?.<span class=\"call\">componentsSeparatedByString</span>(\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>).<span class=\"property\">last</span> })\n\n            .<span class=\"call\">filter</span>({$0 == state})\n\n            .<span class=\"dotAccess\">count</span>\n\n}\n\n<span class=\"call\">infoFromState</span>(state: \\<span class=\"string\">\"CA</span>\\<span class=\"string\">\"</span>, persons: persons)\n</code></pre></code></pre>\n<p>That's simple enough.</p>\n<p>However, now consider the following complication: You'd like to know\nhow many of those persons live in California, and you'd like to know\ntheir average age. If we try upgrading the above example, we soon\nrealize that his is a slightly harder problem.</p>\n<p>There are various\nsolutions, but they all seem to not fit well with functional constructs.\nA loop-based approach feels much simpler.</p>\n<p>When we think about why this does fit, we realize it is because the\nshape of the data changes. <code>map</code>, <code>compactMap</code>, and <code>filter</code> all keep the\nshape of the data similar. Array goes in, array goes out. The amount and\nthe contents of the array may change, but the array-shape stays. The\nproblem above, however, requires us to change the shape to a <code>struct</code> or\n<code>tuple</code> with an <strong>Integer average</strong> and an <strong>Integer sum</strong>.</p>\n<p>These are the kind of problems where you can apply <code>reduce</code>.\nSo what is reduce? Lets have a look.</p>\n<h1>Reduce</h1>\n<p>Reduce is sort of a generalized version of <code>map</code>, <code>compactMap</code>, <code>flatMap</code>, or\n<code>filter</code>. The basic idea is to <strong>reduce</strong> a sequence into a different\nshape utilizing an <strong>accumulator</strong> that can keep incremental state. To\ndo this, we hand the function a <strong>combinator</strong> closure/function/method\nwhich is called once for each item in the sequence. This may sound\ncomplicated but becomes really easy with a couple of examples.</p>\n<p>It is a method on <code>SequenceType</code> and looks like this (simplified):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> reduce&lt;T&gt;(<span class=\"keyword\">_</span> initialResult: <span class=\"type\">T</span>, <span class=\"keyword\">_</span> nextPartialResult: (<span class=\"type\">T</span>, <span class=\"type\">Self</span>.<span class=\"type\">Generator</span>.<span class=\"type\">Element</span>) -&gt; <span class=\"type\">T</span>) -&gt; <span class=\"type\">T</span>\n</code></pre></code></pre>\n<p>There're two parameters here:</p>\n<ol>\n<li>A <code>initialResult</code> value of generic type <code>T</code></li>\n<li>A closure <code>nextPartialResult</code> that receives two parameters and returns the generic type <code>T</code>. The two parameters are <code>T</code>, once again, and the element type of the array. Imagine we had an array of <code>String</code> and we'd like to <code>reduce</code> it to the count of elements <code>Int</code>. Reduce would look like this:</li>\n</ol>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> reduce(<span class=\"keyword\">_</span> initialResult: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> nextPartialResult: (<span class=\"type\">Int</span>, <span class=\"type\">String</span>) -&gt; <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>\n</code></pre></code></pre>\n<p>So here we have an initial value <code>Int</code>, and we have a closure which expects us to\nreturn the same type as the initial value (<code>Int</code>). The final value of the\noperation is also of the same type as the initial value.</p>\n<p>If we take a very simple reduce operation - counting the elments in an array of <code>String</code> - , the evaluation will look like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> count(accumulator: <span class=\"type\">Int</span>, current: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> {\n\n    <span class=\"keyword\">return</span> accumulator += <span class=\"number\">1</span>\n\n}\n\n[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, count)\n\n\n\n<span class=\"comment\">// The following steps will be performed</span>\n\n<span class=\"call\">count</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) { <span class=\"keyword\">return</span> <span class=\"number\">0</span> + <span class=\"number\">1</span> } = <span class=\"number\">1</span>\n\n<span class=\"call\">count</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>) { <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"number\">1</span> } = <span class=\"number\">2</span>\n\n<span class=\"call\">count</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>) { <span class=\"keyword\">return</span> <span class=\"number\">2</span> + <span class=\"number\">1</span> } = <span class=\"number\">3</span>\n\n= <span class=\"number\">6</span>\n</code></pre></code></pre>\n<p>And if we want to sum up the integer elements in an array of <code>Int</code>, we'd write this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> sum(accumulator: <span class=\"type\">Int</span>, current: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> {\n\n    <span class=\"keyword\">return</span> accumulator + current\n\n}\n\n[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, sum)\n\n<span class=\"comment\">// The following steps will be performed</span>\n\n<span class=\"call\">sum</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) { <span class=\"keyword\">return</span> <span class=\"number\">0</span> + <span class=\"number\">1</span> } = <span class=\"number\">1</span>\n\n<span class=\"call\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>) { <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"number\">2</span> } = <span class=\"number\">3</span>\n\n<span class=\"call\">sum</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>) { <span class=\"keyword\">return</span> <span class=\"number\">3</span> + <span class=\"number\">3</span> } = <span class=\"number\">6</span>\n\n= <span class=\"number\">6</span>\n</code></pre></code></pre>\n<p>The <strong>nextPartialResult</strong> closure (<code>sum</code> in our example) will be called once for each item in the\nlist <code>[1, 2, 3]</code>. The state will be kept in the <strong>accumulator</strong> variable\nwhich is just an Integer.</p>\n<p>Let's start re-implementing some of our other, trusted, functional\nprogramming friends. In order to keep things simple for now, all these\nfunctions will operate on <code>Int</code> or <code>Optional&lt;Int&gt;</code>; i.e. we will ignore\ngenerics in here. Also, keep in mind that the implementations below\nexist to explain the behaviour of <code>reduce</code>. The native Swift\nimplementations are usually much faster compared to the reduce versions\nbelow. Reduce shines in a different set of problems, which will be\nexplained further below.</p>\n<h1>Map</h1>\n<p>Lets re-implement <code>map</code> and call it <code>rmap</code> (short for <code>reduce map</code>)</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rmap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), combine: { \n\n       (<span class=\"keyword\">var</span> acc: [<span class=\"type\">Int</span>], obj: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n        acc.<span class=\"call\">append</span>(<span class=\"call\">transform</span>(obj))\n\n        <span class=\"keyword\">return</span> acc\n\n     })\n\n}\n\n<span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]\n\n<span class=\"keyword\">let</span> output = <span class=\"call\">rmap</span>(input, transform: { $0 * <span class=\"number\">2</span>})\n\n<span class=\"call\">assert</span>(output == [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>])\n</code></pre></code></pre>\n<p>This is a good example to understand the basics of <code>reduce</code>.</p>\n<ul>\n<li>First, we're calling reduce on a sequence of elements\n<code>elements.reduce...</code>.</li>\n<li>Next, We're giving it the accumulator, i.e. an empty Int array,\nwhich will form or return type / result <code>[Int]()</code></li>\n<li>After that, we're handing in the <code>combinator</code> which takes two\nparameters. The first is the accumulator which we just provided\n<code>acc: [Int]</code>, the second is the current object from our sequence\n<code>obj: Int</code>.</li>\n<li>The actual code in the <code>combinator</code> is simple. We simply transform\nthe obj and append it onto the accumulator. We then return the\naccumulator.</li>\n</ul>\n<p>This looks like much more code than just calling <code>map</code>. That's indeed\ntrue, but the version above is extra detailed in order to better explain\nhow <code>reduce</code> works. We can simplify it.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rmap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), combine: {$0 + [<span class=\"call\">transform</span>($1)]})\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">rmap</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], transform: { $0 * <span class=\"number\">2</span>}))\n\n<span class=\"comment\">// [2, 4, 6, 8]</span>\n</code></pre></code></pre>\n<p>This still works fine. What happened here? We're using the convenient\nfact that in Swift, the <code>+</code> operator also works for two sequences. So\n<code>[0, 1, 2] + [transform(4)]</code> takes the left sequence and adds the right\nsequence, consisting out of the transformed element, to it.</p>\n<p>It should be noted that, as of right now, <code>[1, 2, 3] + [4]</code> is slower\nthan <code>[1, 2, 3].append(4)</code>. If you operate on huge lists, instead of\nusing collection + collection, you should have a mutable accumulator and\nmutate it in place:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rmap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), combine: { (<span class=\"keyword\">var</span> ac: [<span class=\"type\">Int</span>], b: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span> \n\n         ac.<span class=\"call\">append</span>(<span class=\"call\">transform</span>(b))\n\n         <span class=\"keyword\">return</span> ac\n\n     })\n\n}\n</code></pre></code></pre>\n<p>In order to better understand <code>reduce</code> we will now go on and also\nimplement <code>compactMap</code> and <code>filter</code>.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rcompactMap(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], transform: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>?) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), \n\n        combine: { <span class=\"keyword\">guard let</span> m = <span class=\"call\">transform</span>($1) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> $0 } \n\n                   <span class=\"keyword\">return</span> $0 + [m]})\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">rcompactMap</span>([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], transform: { <span class=\"keyword\">guard</span> $0 != <span class=\"number\">3</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return nil</span> }; <span class=\"keyword\">return</span> $0 * <span class=\"number\">2</span>}))\n\n<span class=\"comment\">// [2, 8]</span>\n</code></pre></code></pre>\n<p>The main difference is that we're adding a <code>guard</code> to make sure the\noptional contains a value.</p>\n<h1>Filter</h1>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> rFilter(<span class=\"keyword\">_</span> elements: [<span class=\"type\">Int</span>], filter: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; [<span class=\"type\">Int</span>] {\n\n     <span class=\"keyword\">return</span> elements.<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), \n\n        combine: { <span class=\"keyword\">guard</span> filter($1) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> $0 } \n\n                   <span class=\"keyword\">return</span> $0 + [$1]})\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">rFilter</span>([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>], filter: { $0 % <span class=\"number\">2</span> == <span class=\"number\">0</span>}))\n\n<span class=\"comment\">// [4, 6]</span>\n</code></pre></code></pre>\n<p>Again, a simple operation. We're leveraging guard again to make sure\nour filter condition holds.</p>\n<p>Up until now, <code>reduce</code> may feel like a more complicated version of <code>map</code>\nor <code>filter</code> without any major advantages. However, the combinator does\nnot need to be an array. It can be anything. This makes it easy for us\nto implement various reduction operations in a very simple way.</p>\n<h1>Reduce Examples</h1>\n<p>Let's start with a favorite of mine, the sum of a list of numbers:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, +)\n\n<span class=\"comment\">// 10</span>\n</code></pre></code></pre>\n<p><code>+</code> is a valid <code>combinator</code> function as it will just add the <code>lhs</code> and\nthe <code>rhs</code> and return the result, which is specifically the requirement\n<code>reduce</code> has.</p>\n<p>Another example is building the product of a list of numbers:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">reduce</span>(<span class=\"number\">1</span>, *)\n\n<span class=\"comment\">// 24</span>\n</code></pre></code></pre>\n<p>Or what about reversing a list:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].<span class=\"call\">reduce</span>([<span class=\"type\">Int</span>](), { [$1] + $0 })\n\n<span class=\"comment\">// 5, 4, 3, 2, 1</span>\n</code></pre></code></pre>\n<p>Finally, something a tad more complicated. We'd like to partition a\nlist based on a division criteria</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Acc = (l: [<span class=\"type\">Int</span>], r: [<span class=\"type\">Int</span>])\n\n<span class=\"keyword\">func</span> partition(<span class=\"keyword\">_</span> lst: [<span class=\"type\">Int</span>], criteria: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Acc</span> {\n\n    <span class=\"keyword\">return</span> lst.<span class=\"call\">reduce</span>((l: [<span class=\"type\">Int</span>](), r: [<span class=\"type\">Int</span>]()), { (ac: <span class=\"type\">Acc</span>, o: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span> \n\n       <span class=\"keyword\">if</span> <span class=\"call\">criteria</span>(o) {\n\n         <span class=\"keyword\">return</span> (l: ac.<span class=\"property\">l</span> + [o], r: ac.<span class=\"property\">r</span>)\n\n       } <span class=\"keyword\">else</span> {\n\n         <span class=\"keyword\">return</span> (r: ac.<span class=\"property\">r</span> + [o], l: ac.<span class=\"property\">l</span>)\n\n       }\n\n    })\n\n}\n\n<span class=\"call\">partition</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>], criteria: { $0 % <span class=\"number\">2</span> == <span class=\"number\">0</span> })\n\n<span class=\"comment\">//: ([2, 4, 6, 8], [1, 3, 5, 7, 9])</span>\n</code></pre></code></pre>\n<p>The most interesting thing we're doing above is using a <code>tuple</code> as the\naccumulator. As you'll find out, once you start trying to incorporate\n<code>reduce</code> into your daily work-flow, <code>tuples</code> are a great way of quickly\ncombining related data during a reduce operation.</p>\n<h1>Performance</h1>\n<p>Apart from the higher flexibility that <code>reduce</code> offers, it has another\nadvantage: Oftentimes, chaining <code>map</code> and <code>filter</code> induces a performance\npenalty as Swift has to iterate over your collection multiple times in\norder to generate the required data. Imagine the following code:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">map</span>({ $0 + <span class=\"number\">3</span>})\n\n     .<span class=\"call\">filter</span>({ $0 % <span class=\"number\">2</span> == <span class=\"number\">0</span>})\n\n     .<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, +)\n</code></pre></code></pre>\n<p>Apart from being nonsensical, it is also wasting CPU cycles. The initial\nsequence will be iterated over 3 times. First to map it, then to filter\nit, and finally to sum up the contents. Instead, all of this can just as\nwell be implemented as one reduce call, which greatly improves the\nperformance:</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, { (ac: <span class=\"type\">Int</span>, r: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> <span class=\"keyword\">in</span> \n\n    <span class=\"keyword\">if</span> (r + <span class=\"number\">3</span>) % <span class=\"number\">2</span> == <span class=\"number\">0</span> {\n\n      <span class=\"keyword\">return</span> ac + r + <span class=\"number\">3</span>\n\n    } <span class=\"keyword\">else</span> {\n\n      <span class=\"keyword\">return</span> ac\n\n    }\n\n})\n</code></pre></code></pre>\n<p>Here's a quick benchmark of running both versions and the for-loop\nversion below over an list with 100.000 items:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> ux = <span class=\"number\">0</span>\n\n<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>) {\n\n     <span class=\"keyword\">if</span> (i + <span class=\"number\">3</span>) % <span class=\"number\">2</span> == <span class=\"number\">0</span> {\n\n         ux += (i + <span class=\"number\">3</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<style type=\"text/css\">\n.linechart {\n    border: 3px solid white;\n    border-radius: 32px;\n    font-family: Sans-Serif;\n    color: white;\n    font-weight: normal;\n    padding: 4px;\n    margin-bottom: 20px;\n}\n.redxx {\n    background-color: red;\n}\n.greenxx {\n    background-color: green;\n}\n.linechart > span {\n    padding: 4px;\n}\nh3.ggx {\n    font-family: Sans-Serif;\nfont-weight: normal;\n}\n.orangexx {\n    background-color: orange;\n}\n</style>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart greenxx\" style=\"width: 41%\">\n<span>For Loop: 0.030 seconds</span>\n</div>\n<div class=\"linechart orangexx\" style=\"width: 47%\">\n<span>Reduce: 0.034 seconds</span>\n</div>\n<div class=\"linechart redxx\">\n<span>Map/Filter: 0.072 seconds</span>\n</div>\n</div>\n<p>As you can see, the <code>reduce</code> version' performance is very close to the\nmutating for loop and more than twice as fast as the chaining operation.</p>\n<p>However, in other situations, chained operation can greatly outperform\n<code>reduce</code>. Consider the following example where we add <em>3</em> to each entry in the array.</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">map</span>({ $0 + <span class=\"number\">3</span>}).<span class=\"call\">reverse</span>().<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n\n<span class=\"comment\">// 0.027 Seconds</span>\n</code></pre></code></pre>\n<p>And the <code>reduce</code> version:</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">reduce</span>([], { (ac: [<span class=\"type\">Int</span>], r: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">return</span> ac + [r + <span class=\"number\">3</span>]\n\n}).<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n\n\n\n<span class=\"comment\">// 2.927 Seconds</span>\n</code></pre></code></pre>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart\" style=\"width: 100%\">\n<span>For Loop: 0.027 seconds</span>\n</div>\n<div class=\"linechart redxx\" style=\"width: 100%\">\n<span>Reduce: 2.927 seconds</span>\n</div>\n</div>\n<p>Here, we have a stark performance difference of 0.027s for the chained\noperation vs. 2.927s for the reduce operation, what's happening\nhere?</p>\n<p><code>Arrays</code> in Swift are value types with so-called <code>copy on write</code> semantics.</p>\n<h1>Copy on Write</h1>\n<p>Imagine you had a struct <code>User</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> benedikt = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Benedikt</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">var</span> secondBenedikt = benedikt\n\n<span class=\"keyword\">var</span> thirdBenedikt = benedikt\n</code></pre></code></pre>\n<p><code>struct</code> types in Swift are value types. Value type means that each copy\nis a new distinct value. So if I were to change the <code>username</code> value of <code>secondBenedikt</code> to\n<code>Klaus</code>, then the <code>username</code> value of the other two benedikts (<code>benedikt</code>, <code>thirdBenedikt</code>)\nwould still be <code>Benedikt</code> and not <code>Klaus</code>. So, everytime you do a <code>a = b</code>, <code>b</code> is <strong>copied</strong> to <code>a</code>.</p>\n<p>Copy operations, however, are expensive. All that memory has to be copied from <code>a</code> to <code>b</code>. So Swift employs\na smart trick: As long as you don't <strong>mutate / modify</strong> a variable, it will just not copy it.</p>\n<p>So in our example above, <code>benedikt</code>, <code>secondBenedikt</code>, and <code>thirdBenedikt</code> are the same thing, they point\nto the same memory. Only once you change one of them (say <code>benedikt.username = 'Hans'</code>) will they be copied\ninto distinct types.</p>\n<p>So what's all that to do with our <code>reduce</code> issue here?</p>\n<h1>Array Value Types</h1>\n<p>Arrays are <code>value types</code>, too. This means that whenever an array is mutated, a new copy is created.\nSo in our <code>reduce</code> function:</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">reduce</span>([], { (ac: [<span class=\"type\">Int</span>], r: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">return</span> ac + [r + <span class=\"number\">3</span>]\n\n}).<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n</code></pre></code></pre>\n<p>This will copy the array 100000 times. That's why the performance is so abysmal.\nSo how do we fix this?</p>\n<h1>The power of <code>inout</code></h1>\n<p>There's another version of <code>reduce</code> with slightly different parameters. Its function signature\nlooks like this (simplified):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> reduce&lt;Result&gt;(into initialResult: <span class=\"type\">Result</span>, \n\n   <span class=\"keyword\">_</span> updateAccumulatingResult: (<span class=\"keyword\">inout</span> <span class=\"type\">Result</span>, <span class=\"type\">Element</span>) <span class=\"keyword\">throws</span> -&gt; ()) <span class=\"keyword\">rethrows</span> -&gt; <span class=\"type\">Result</span>\n</code></pre></code></pre>\n<p>The magic is the <code>inout Result</code>. Inout is a special attribute that you can use\nin function signatures to denote to Swift that you wish to refer to the same instance of\na type without making copies. The name implies how it works: When the function is called, the\nvalue is <code>moved in</code> to the function, when the function is done, the value is <code>moved out</code> again.</p>\n<p>In the case of our arrays, instead of making multiple copies, we will always modify the same array.</p>\n<p>So if we rewrite our <code>reduce</code> from above with <code>reduce(into:)</code> what is the performance?</p>\n<p>Here is the updated code:</p>\n<pre class=\"Swift\"><code><span class=\"type\">Array</span>(<span class=\"number\">0</span>...<span class=\"number\">100000</span>).<span class=\"call\">reduce</span>(into: [<span class=\"type\">Int</span>](), { ac, r <span class=\"keyword\">in</span>\n\n                 <span class=\"keyword\">return</span> ac.<span class=\"call\">append</span>(r + <span class=\"number\">3</span>)\n\n             }).<span class=\"call\">prefix</span>(<span class=\"number\">3</span>)\n</code></pre></code></pre>\n<p>And this is the new performance:</p>\n<div style=\"background-color: #ccc; padding: 20px; border-radius: 16px; margin-bottom: 20px;\">\n<div class=\"linechart\" style=\"width: 100%\">\n<span>Map: 0.0295 seconds</span>\n</div>\n<div class=\"linechart\" style=\"width: 100%\">\n<span>Reduce Into: 0.0376 seconds</span>\n</div>\n<div class=\"linechart redxx\" style=\"width: 100%\">\n<span>Reduce: 1.49 seconds</span>\n</div>\n</div>\n<p>We're almost reached the speed of the simpler <code>map</code> implementation. It is much\nfaster now. Awesome!</p>\n<p>We can now go back to our initial count &amp; average problem and try to\nsolve it with <code>reduce</code>.</p>\n<h1>InfoFromState, take two</h1>\n<pre class=\"Swift\"><code>\n\n   <span class=\"keyword\">func</span> infoFromState(state: <span class=\"type\">String</span>, persons: [[<span class=\"type\">String</span>: <span class=\"type\">Any</span>]]) \n\n       -&gt; (count: <span class=\"type\">Int</span>, age: <span class=\"type\">Float</span>) {\n\n\n\n       <span class=\"comment\">// The type alias in the function will keep the code cleaner</span>\n\n       <span class=\"keyword\">typealias</span> Acc = (count: <span class=\"type\">Int</span>, age: <span class=\"type\">Float</span>)\n\n\n\n       <span class=\"comment\">// reduce into a temporary variable</span>\n\n       <span class=\"keyword\">let</span> u = persons.<span class=\"call\">reduce</span>((count: <span class=\"number\">0</span>, age: <span class=\"number\">0.0</span>)) {\n\n           (ac: <span class=\"type\">Acc</span>, p) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span>\n\n\n\n           <span class=\"comment\">// Retrive the state and the age</span>\n\n           <span class=\"keyword\">guard let</span> personState = (p[\\<span class=\"string\">\"city</span>\\<span class=\"string\">\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span>)?.<span class=\"call\">componentsSeparatedByString</span>(\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>).<span class=\"property\">last</span>,\n\n                 personAge = p[\\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">Int</span>\n\n\n\n             <span class=\"comment\">// make sure the person is from the correct state</span>\n\n             <span class=\"keyword\">where</span> personState == state\n\n\n\n             <span class=\"comment\">// if age or state are missing, or personState!=state, leave</span>\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> ac }\n\n\n\n           <span class=\"comment\">// Finally, accumulate the acount and the age</span>\n\n           <span class=\"keyword\">return</span> (count: ac.<span class=\"property\">count</span> + <span class=\"number\">1</span>, age: ac.<span class=\"property\">age</span> + <span class=\"type\">Float</span>(personAge))\n\n       }\n\n\n\n   <span class=\"comment\">// our result is the count and the age divided by count</span>\n\n   <span class=\"keyword\">return</span> (age: u.<span class=\"property\">age</span> / <span class=\"type\">Float</span>(u.<span class=\"property\">count</span>), count: u.<span class=\"property\">count</span>)\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">infoFromState</span>(state: \\<span class=\"string\">\"CA</span>\\<span class=\"string\">\"</span>, persons: persons))\n\n<span class=\"comment\">// prints: (count: 3, age: 34.3333)</span>\n</code></pre></code></pre>\n<p>As in earlier examples above, we're once again using a <code>tuple</code> to share\nstate in the accumulator. Apart from that, the code is easy to\nunderstand.</p>\n<p>We also defined a <code>typealias</code> <strong>Acc</strong> within the <code>func</code> in order to\nsimplify the type annotations a bit.</p>\n<h1>More Examples</h1>\n<p>This was a short overview of the power behind the <code>reduce</code> method. It is\nparticularly helpful if you end up chaining a lot of functional methods\ntogether, <strong>or</strong> when output shape of your data differs from the input\nshape. We'll finish this guide with more reduce examples to give you\ninspirations for various use cases where reduce can easily be applied.</p>\n<h1>Unique</h1>\n<p>Return a list with all duplicates removed. The better solution would be\nto use a <code>Set</code>.</p>\n<pre class=\"Swift\"><code>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>].<span class=\"call\">reduce</span>([], { (a: [<span class=\"type\">Int</span>], b: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">Int</span>] <span class=\"keyword\">in</span>\n\n   <span class=\"keyword\">if</span> a.<span class=\"call\">contains</span>(b) {\n\n     <span class=\"keyword\">return</span> a\n\n   } <span class=\"keyword\">else</span> {\n\n     <span class=\"keyword\">return</span> a + [b]\n\n   }\n\n})\n\n<span class=\"comment\">// prints: 1, 2, 5, 7</span>\n</code></pre></code></pre>\n<h1>Group By</h1>\n<p>Go over a list and return a new list with the previous list' items\ngrouped by a discriminator function. The function in question needs to\nreturn a <code>Hashable</code> type so that we can differentiate keys. The order of\nthe items will be preserved while the order of the groups won't\nnecessarily be preserved.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> groupby&lt;T, H: <span class=\"type\">Hashable</span>&gt;(<span class=\"keyword\">_</span> items: [<span class=\"type\">T</span>], f: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">H</span>) -&gt; [<span class=\"type\">H</span>: [<span class=\"type\">T</span>]] {\n\n    <span class=\"keyword\">return</span> items.<span class=\"call\">reduce</span>([:], { (<span class=\"keyword\">var</span> ac: [<span class=\"type\">H</span>: [<span class=\"type\">T</span>]], o: <span class=\"type\">T</span>) -&gt; [<span class=\"type\">H</span>: [<span class=\"type\">T</span>]] <span class=\"keyword\">in</span> \n\n        <span class=\"keyword\">let</span> h = <span class=\"call\">f</span>(o)\n\n        <span class=\"keyword\">if var</span> c = ac[h] {\n\n            c.<span class=\"call\">append</span>(o)\n\n            ac.<span class=\"call\">updateValue</span>(c, forKey: h)\n\n        } <span class=\"keyword\">else</span> {\n\n            ac.<span class=\"call\">updateValue</span>([o], forKey: h)\n\n        }\n\n        <span class=\"keyword\">return</span> ac\n\n    })\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">groupby</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>], f: { $0 % <span class=\"number\">3</span> }))\n\n<span class=\"comment\">// prints: [2: [2, 5, 8, 11], 0: [3, 6, 9, 12], 1: [1, 4, 7, 10]]</span>\n\n<span class=\"call\">print</span>(<span class=\"call\">groupby</span>([\\<span class=\"string\">\"Carl</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Cozy</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Bethlehem</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Belem</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Brand</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Zara</span>\\<span class=\"string\">\"</span>], f: { $0.<span class=\"property\">characters</span>.<span class=\"property\">first</span>! }))\n\n<span class=\"comment\">// prints: [\\\"C\\\" : [\\\"Carl\\\" , \\\"Cozy\\\"] , \\\"B\\\" : [\\\"Bethlehem\\\" , \\\"Belem\\\" , \\\"Brand\\\"] , \\\"Z\\\" : [\\\"Zara\\\"]]</span>\n</code></pre></code></pre>\n<h1>Interpose</h1>\n<p>This function returns the given <code>items</code>, with <code>element</code> inserted between\nevery <code>count</code> items. The implementation below makes sure that the\nelements are only interposed and not appended at the end.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> interpose&lt;T&gt;(items: [<span class=\"type\">T</span>], element: <span class=\"type\">T</span>, count: <span class=\"type\">Int</span> = <span class=\"number\">1</span>) -&gt; [<span class=\"type\">T</span>] {\n\n    <span class=\"keyword\">typealias</span> Acc = (ac: [<span class=\"type\">T</span>], cur: <span class=\"type\">Int</span>, cnt: <span class=\"type\">Int</span>)\n\n    <span class=\"keyword\">return</span> items.<span class=\"call\">reduce</span>((ac: [], cur: <span class=\"number\">0</span>, cnt: <span class=\"number\">1</span>), { (a: <span class=\"type\">Acc</span>, o: <span class=\"type\">T</span>) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span> \n\n        <span class=\"keyword\">switch</span> a {\n\n        <span class=\"comment\">// the last item will not have any interposition</span>\n\n        <span class=\"keyword\">case let</span> (ac, cur, <span class=\"keyword\">_</span>) <span class=\"keyword\">where</span> (cur+<span class=\"number\">1</span>) == items.<span class=\"property\">count</span>: <span class=\"keyword\">return</span> (ac + [o], <span class=\"number\">0</span>, <span class=\"number\">0</span>)\n\n        <span class=\"comment\">// interpose</span>\n\n        <span class=\"keyword\">case let</span> (ac, cur, c) <span class=\"keyword\">where</span> c == count:\n\n           <span class=\"keyword\">return</span> (ac + [o, element], cur + <span class=\"number\">1</span>, <span class=\"number\">1</span>)\n\n        <span class=\"comment\">// next</span>\n\n        <span class=\"keyword\">case let</span> (ac, cur, c):\n\n           <span class=\"keyword\">return</span> (ac + [o], cur + <span class=\"number\">1</span>, c + <span class=\"number\">1</span>)\n\n        }\n\n    }).<span class=\"property\">ac</span>\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">interpose</span>(items: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], element: <span class=\"number\">9</span>))\n\n<span class=\"comment\">// : [1, 9, 2, 9, 3, 9, 4, 9, 5]</span>\n\n<span class=\"call\">print</span>(<span class=\"call\">interpose</span>(items: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], element: <span class=\"number\">9</span>, count: <span class=\"number\">2</span>))\n\n<span class=\"comment\">// : [1, 2, 9, 3, 4, 9, 5]</span>\n</code></pre></code></pre>\n<h1>Interdig</h1>\n<p>This function allows you to combine two sequences by alternately\nselecting elements from each.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> interdig&lt;T&gt;(list1: [<span class=\"type\">T</span>], list2: [<span class=\"type\">T</span>]) -&gt; [<span class=\"type\">T</span>] {\n\n    <span class=\"keyword\">return</span> <span class=\"call\">zip</span>(list1, list2).<span class=\"call\">reduce</span>([], { (ac: [<span class=\"type\">T</span>], o: (<span class=\"type\">T</span>, <span class=\"type\">T</span>)) -&gt; [<span class=\"type\">T</span>] <span class=\"keyword\">in</span> \n\n         <span class=\"keyword\">return</span> ac + [o.<span class=\"number\">0</span>, o.<span class=\"number\">1</span>]\n\n    })\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">interdig</span>(list1: [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>], list2: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]))\n\n<span class=\"comment\">// : [1, 2, 3, 4, 5, 6]</span>\n</code></pre></code></pre>\n<h1>Chunk</h1>\n<p>This function returns self, broken up into non-overlapping arrays of\nlength <code>n</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> chunk&lt;T&gt;(<span class=\"keyword\">_</span> list: [<span class=\"type\">T</span>], length: <span class=\"type\">Int</span>) -&gt; [[<span class=\"type\">T</span>]] {\n\n    <span class=\"comment\">// Simplify the type signature by introducing a `typealias`</span>\n\n    <span class=\"keyword\">typealias</span> Acc = (stack: [[<span class=\"type\">T</span>]], cur: [<span class=\"type\">T</span>], cnt: <span class=\"type\">Int</span>)\n\n    \n\n    <span class=\"comment\">// Start with a `cnt` of 0</span>\n\n    <span class=\"keyword\">let</span> reducedList = list.<span class=\"call\">reduce</span>((stack: [], cur: [], cnt: <span class=\"number\">0</span>), { (ac: <span class=\"type\">Acc</span>, o: <span class=\"type\">T</span>) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span>\n\n       <span class=\"keyword\">if</span> ac.<span class=\"property\">cnt</span> == length {\n\n           <span class=\"keyword\">return</span> (stack: ac.<span class=\"property\">stack</span> + [ac.<span class=\"property\">cur</span>], cur: [o], cnt: <span class=\"number\">1</span>)\n\n       } <span class=\"keyword\">else</span> {\n\n           <span class=\"keyword\">return</span> (stack: ac.<span class=\"property\">stack</span>, cur: ac.<span class=\"property\">cur</span> + [o], cnt: ac.<span class=\"property\">cnt</span> + <span class=\"number\">1</span>)\n\n       }\n\n    })\n\n    <span class=\"keyword\">return</span> reducedList.<span class=\"property\">stack</span> + [reducedList.<span class=\"property\">cur</span>]\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">chunk</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>], length: <span class=\"number\">2</span>))\n\n<span class=\"comment\">// [[1, 2], [3, 4], [5, 6], [7]]</span>\n</code></pre></code></pre>\n<p>This function uses a more complicated <code>accumulator</code> consisting out of a\nstack, the current list, and the count.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/applying_ranges.md":["534395485f0cee68",{"identifier":"8cd1016d","filename":"applying_ranges.md","info":{"title":"Applying ranges for grading","tags":["pattern matching","switch","range"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-applying-ranges-for-grading.html","content":"<h1>Applying ranges for grading</h1>\n<p>So you're writing the grading iOS app for your local Highschool. The\nteachers want to enter a number value from 0 to 100 and receive the\ngrade character for it (A - F). Pattern Matching to the rescue:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> aGrade = <span class=\"number\">84</span>\n\n\n\n<span class=\"keyword\">switch</span> aGrade {\n\n<span class=\"keyword\">case</span> <span class=\"number\">90</span>...<span class=\"number\">100</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"A</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">80</span>...<span class=\"number\">90</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"B</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">70</span>...<span class=\"number\">80</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"C</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">60</span>...<span class=\"number\">70</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"D</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> <span class=\"number\">0</span>...<span class=\"number\">60</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"F</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Incorrect</span> <span class=\"type\">Grade</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>You can also always have ranges as parts of nested types, such as tuples or even\n<code>struct</code> types, when you implement the <a href=\"lnk::match-operator\"><code>~=</code></a> operator.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> student = (name: \\<span class=\"string\">\"John</span> <span class=\"type\">Donar</span>\\<span class=\"string\">\"</span>, grades: (english: <span class=\"number\">77</span>, chemistry: <span class=\"number\">21</span>, math: <span class=\"number\">60</span>, sociology: <span class=\"number\">42</span>))\n\n<span class=\"keyword\">switch</span> student {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> name, (<span class=\"number\">90</span>...<span class=\"number\">100</span>, <span class=\"number\">0</span>...<span class=\"number\">50</span>, <span class=\"number\">0</span>...<span class=\"number\">50</span>, <span class=\"keyword\">_</span>)): <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(name) <span class=\"keyword\">is</span> good at arts\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> name, (<span class=\"number\">0</span>...<span class=\"number\">50</span>, <span class=\"number\">90</span>...<span class=\"number\">100</span>, <span class=\"number\">90</span>...<span class=\"number\">100</span>, <span class=\"keyword\">_</span>)): <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(name) <span class=\"keyword\">is</span> good at sciences\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Applying ranges for grading\"\ntags = [\"pattern matching\", \"switch\", \"range\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Applying ranges for grading\n\nSo you\\'re writing the grading iOS app for your local Highschool. The\nteachers want to enter a number value from 0 to 100 and receive the\ngrade character for it (A - F). Pattern Matching to the rescue:\n\n``` Swift\nlet aGrade = 84\n\nswitch aGrade {\ncase 90...100: print(\"A\")\ncase 80...90: print(\"B\")\ncase 70...80: print(\"C\")\ncase 60...70: print(\"D\")\ncase 0...60: print(\"F\")\ndefault: print(\"Incorrect Grade\")\n}\n```\n\nYou can also always have ranges as parts of nested types, such as tuples or even\n`struct` types, when you implement the [`~=`](lnk::match-operator) operator.\n\n``` Swift\nlet student = (name: \"John Donar\", grades: (english: 77, chemistry: 21, math: 60, sociology: 42))\nswitch student {\ncase (let name, (90...100, 0...50, 0...50, _)): print(\"\\(name) is good at arts\")\ncase (let name, (0...50, 90...100, 90...100, _)): print(\"\\(name) is good at sciences\")\ndefault: ()\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/intro/first_steps.md":["b3e060d0aa86adb9",{"identifier":"2803472b","filename":"first_steps.md","info":{"title":"First Steps","tags":["keypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-first-steps.html","content":"<h1>KeyPaths 101</h1>\n<p>We will start with a very, very simple example. Below, we create a <code>User</code> type that has just one property, the username. Then, we initialize the user as <code>firstUser</code> and want to print out <code>firstUser</code>s <code>username</code>.</p>\n<p>Normally, we would do <code>print(firstUser.username)</code> but instead we're doing something else. Have a look:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n\n\n<span class=\"keyword\">let</span> firstUser = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Player</span> <span class=\"number\">1</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"call\">print</span>(firstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>])\n</code></pre></code></pre>\n<p>You'll easily see the difference. Instead of using <code>firstUser.username</code> we're using a very weird syntax:</p>\n<pre class=\"Swift\"><code>firstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>]\n</code></pre></code></pre>\n<p>This tells Swift that we want to access the contents of the property <code>username</code> of the type <code>User</code> on the instance <code>firstUser</code>.</p>\n<p>It is comparable to dictionary access (<code>dict[&quot;Hello&quot;]</code>), only that you don't use <code>String</code> keys (&quot;Hello&quot;) but something type-safe. Namely, a Swift keypath.</p>\n<p>At first glance, this looks like an overly verbose version of direct access, so what else can it do? For one, we can abstract the access away. We can store the <code>KeyPath</code> in a variable:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> userKeyPath = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n\n\n\n<span class=\"call\">print</span>(firstUser[keyPath: userKeyPath])\n</code></pre></code></pre>\n<p>By doing so, we implement generic abstraction between the property and the type. But, what is the type of this <code>userKeyPath</code> variable? The full type signature looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> keyPath: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">username</span>\n</code></pre></code></pre>\n<p><code>KeyPath</code> has two generic types:</p>\n<ol>\n<li>The <code>Root</code>. It is the <code>struct</code>, <code>class</code>, or <code>enum</code> whose property you want to have a <code>KeyPath</code> to. A <code>Person</code>, a <code>UIViewController</code>, a <code>String</code>, or something else</li>\n<li>This is the <code>Value</code>. It is a property on the <code>Root</code> type. For example a <code>Person</code>'s <code>name</code>, or a <code>UIViewController</code>'s <code>title</code>, or a <code>String</code>'s <code>count</code>.</li>\n</ol>\n<p>So in our example, the <code>Root</code> is <code>User</code>, and the <code>Value</code> is <code>String</code> because <code>username</code> is of type <code>String</code>. Here is an overview.</p>\n<p><img src=\"/img-content/keypaths_type_overview.gif\" alt=\"Setup\" /></p>\n","raw_content":"[frontMatter]\ntitle = \"First Steps\"\ntags = [\"keypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# KeyPaths 101\n\nWe will start with a very, very simple example. Below, we create a `User` type that has just one property, the username. Then, we initialize the user as `firstUser` and want to print out `firstUser`s `username`. \n\nNormally, we would do `print(firstUser.username)` but instead we're doing something else. Have a look:\n\n``` Swift\nstruct User {\n  var username: String\n}\n\nlet firstUser = User(username: \"Player 1\")\n\nprint(firstUser[keyPath: \\User.username])\n```\n\nYou'll easily see the difference. Instead of using `firstUser.username` we're using a very weird syntax:\n\n``` Swift\nfirstUser[keyPath: \\User.username]\n```\n\nThis tells Swift that we want to access the contents of the property `username` of the type `User` on the instance `firstUser`. \n\nIt is comparable to dictionary access (`dict[\"Hello\"]`), only that you don't use `String` keys (\"Hello\") but something type-safe. Namely, a Swift keypath.\n\nAt first glance, this looks like an overly verbose version of direct access, so what else can it do? For one, we can abstract the access away. We can store the `KeyPath` in a variable:\n\n``` Swift\nlet userKeyPath = \\User.username\n\nprint(firstUser[keyPath: userKeyPath])\n```\n\nBy doing so, we implement generic abstraction between the property and the type. But, what is the type of this `userKeyPath` variable? The full type signature looks like this:\n\n``` Swift\nlet keyPath: KeyPath<User, String> = \\User.username\n```\n\n`KeyPath` has two generic types:\n\n1. The `Root`. It is the `struct`, `class`, or `enum` whose property you want to have a `KeyPath` to. A `Person`, a `UIViewController`, a `String`, or something else\n2. This is the `Value`. It is a property on the `Root` type. For example a `Person`'s `name`, or a `UIViewController`'s `title`, or a `String`'s `count`.\n\nSo in our example, the `Root` is `User`, and the `Value` is `String` because `username` is of type `String`. Here is an overview.\n\n![Setup](/img-content/keypaths_type_overview.gif)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/custom_data_types.md":["ca214b93c667d6ee",{"identifier":"f52159d4","filename":"custom_data_types.md","info":{"title":"Custom Data Types","tags":["enum","literal","ExpressibleByStringLiteral"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-custom-data-types.html","content":"<h1>Custom Data Types</h1>\n<p>If we neglect <code>associated values</code>, then the value of an enum can only be\nan Integer, Floating Point, String, or Boolean. If you need to support\nsomething else, you can do so by implementing the\n<code>ExpressibleByStringLiteral</code> protocol which allows the type in question to\nbe serialized to and from String.</p>\n<p>As an example, imagine you'd like to store the different screen sizes\nof iOS devices in an enum:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Devices: <span class=\"type\">CGSize</span> {\n\n    <span class=\"keyword\">case</span> iPhone3GS = <span class=\"type\">CGSize</span>(width: <span class=\"number\">320</span>, height: <span class=\"number\">480</span>)\n\n    <span class=\"keyword\">case</span> iPhone5 = <span class=\"type\">CGSize</span>(width: <span class=\"number\">320</span>, height: <span class=\"number\">568</span>)\n\n    <span class=\"keyword\">case</span> iPhone6 = <span class=\"type\">CGSize</span>(width: <span class=\"number\">375</span>, height: <span class=\"number\">667</span>)\n\n    <span class=\"keyword\">case</span> iPhone6Plus = <span class=\"type\">CGSize</span>(width: <span class=\"number\">414</span>, height: <span class=\"number\">736</span>)\n\n}\n</code></pre></code></pre>\n<p>However, this doesn't compile because <code>CGSize</code> is not a <code>literal</code> and can't be\nused as an enum value. Instead, what you need to do is add a type\nextension for the <code>ExpressibleByStringLiteral</code> protocol.</p>\n<p>The protocol\nrequires us to implement an initializer that receives a <code>String</code>. Next, we need to\ntake this <code>String</code> an convert it into a <code>CGSize</code>. Not any <code>String</code> can be a <code>CGSize</code>.\nSo if the value is wrong, we will crash with an error as this code will be executed\nby Swift during application startup. Our string format for sizes is: <code>width,height</code></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">CGSize</span>: <span class=\"type\">ExpressibleByStringLiteral</span> {\n\n     <span class=\"keyword\">public init</span>(stringLiteral value: <span class=\"type\">String</span>) {\n\n         <span class=\"keyword\">let</span> components = rawValue.<span class=\"call\">split</span>(separator: \\<span class=\"string\">\"</span>,\\<span class=\"string\">\"</span>)\n\n         <span class=\"keyword\">guard</span> components.<span class=\"property\">count</span> == <span class=\"number\">2</span>,\n\n             <span class=\"keyword\">let</span> width = <span class=\"type\">Int</span>(components[<span class=\"number\">0</span>]),\n\n             <span class=\"keyword\">let</span> height = <span class=\"type\">Int</span>(components[<span class=\"number\">1</span>])\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Invalid</span> <span class=\"type\">Format</span> \\(value)\\<span class=\"string\">\"</span>) }\n\n         <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(width: size.<span class=\"property\">width</span>, height: size.<span class=\"property\">height</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Now, we can write our <code>enum</code>, with one downside though: The initial\nvalues have to be written as a String, since that's what the enum will\nuse (remember, we complied with <code>ExpressibleByStringLiteral</code>, so that the\n<strong>String</strong> can be converted to our <code>CGSize</code> type.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Devices: <span class=\"type\">CGSize</span> {\n\n    <span class=\"keyword\">case</span> iPhone3GS = \\<span class=\"string\">\"320</span>,<span class=\"number\">480</span>\\<span class=\"string\">\"</span>\n\n    <span class=\"keyword\">case</span> iPhone5 = \\<span class=\"string\">\"320</span>,<span class=\"number\">568</span>\\<span class=\"string\">\"</span>\n\n    <span class=\"keyword\">case</span> iPhone6 = \\<span class=\"string\">\"375</span>,<span class=\"number\">667</span>\\<span class=\"string\">\"</span>\n\n    <span class=\"keyword\">case</span> iPhone6Plus = \\<span class=\"string\">\"414</span>,<span class=\"number\">736</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>This, finally, allows us to use our <code>CGSize</code> enum. Keep in mind that in\norder to get the actual <code>CGSize</code> value, we have to access the <code>rawValue</code>\nof the enum.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> a = <span class=\"type\">Devices</span>.<span class=\"property\">iPhone5</span>\n\n<span class=\"keyword\">let</span> b = a.<span class=\"property\">rawValue</span>\n\n<span class=\"call\">print</span>(\\<span class=\"string\">\"the</span> phone size string <span class=\"keyword\">is</span> \\(a), width <span class=\"keyword\">is</span> \\(b.<span class=\"property\">width</span>), height <span class=\"keyword\">is</span> \\(b.<span class=\"property\">height</span>)\\<span class=\"string\">\"</span>)\n</code></pre></code></pre>\n<p>This works, because we explicitly told Swift that a <code>CGSize</code> can be created\nfrom any <code>String</code>.</p>\n<p>A different option to hook into custom types it the <code>RawRepresentable</code> protocol, we will tackle this next.</p>\n","raw_content":"[frontMatter]\ntitle = \"Custom Data Types\"\ntags = [\"enum\", \"literal\", \"ExpressibleByStringLiteral\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Custom Data Types\n\nIf we neglect `associated values`, then the value of an enum can only be\nan Integer, Floating Point, String, or Boolean. If you need to support\nsomething else, you can do so by implementing the\n`ExpressibleByStringLiteral` protocol which allows the type in question to\nbe serialized to and from String.\n\nAs an example, imagine you\\'d like to store the different screen sizes\nof iOS devices in an enum:\n\n``` Swift\nenum Devices: CGSize {\n   case iPhone3GS = CGSize(width: 320, height: 480)\n   case iPhone5 = CGSize(width: 320, height: 568)\n   case iPhone6 = CGSize(width: 375, height: 667)\n   case iPhone6Plus = CGSize(width: 414, height: 736)\n}\n```\n\nHowever, this doesn\\'t compile because `CGSize` is not a `literal` and can\\'t be\nused as an enum value. Instead, what you need to do is add a type\nextension for the `ExpressibleByStringLiteral` protocol. \n\nThe protocol\nrequires us to implement an initializer that receives a `String`. Next, we need to\ntake this `String` an convert it into a `CGSize`. Not any `String` can be a `CGSize`.\nSo if the value is wrong, we will crash with an error as this code will be executed\nby Swift during application startup. Our string format for sizes is: `width,height`\n\n``` Swift\nextension CGSize: ExpressibleByStringLiteral {\n    public init(stringLiteral value: String) {\n        let components = rawValue.split(separator: \",\")\n        guard components.count == 2,\n            let width = Int(components[0]),\n            let height = Int(components[1])\n            else { return fatalError(\"Invalid Format \\(value)\") }\n        self.init(width: size.width, height: size.height)\n    }\n}\n```\n\nNow, we can write our `enum`, with one downside though: The initial\nvalues have to be written as a String, since that\\'s what the enum will\nuse (remember, we complied with `ExpressibleByStringLiteral`, so that the\n**String** can be converted to our `CGSize` type.\n\n``` Swift\nenum Devices: CGSize {\n   case iPhone3GS = \"320,480\"\n   case iPhone5 = \"320,568\"\n   case iPhone6 = \"375,667\"\n   case iPhone6Plus = \"414,736\"\n}\n```\n\nThis, finally, allows us to use our `CGSize` enum. Keep in mind that in\norder to get the actual `CGSize` value, we have to access the `rawValue`\nof the enum.\n\n``` Swift\nlet a = Devices.iPhone5\nlet b = a.rawValue\nprint(\"the phone size string is \\(a), width is \\(b.width), height is \\(b.height)\")\n```\n\nThis works, because we explicitly told Swift that a `CGSize` can be created\nfrom any `String`. \n\nA different option to hook into custom types it the `RawRepresentable` protocol, we will tackle this next.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/best_practices_code.md":["edb823cd54dda6d6",{"identifier":"0700094e","filename":"best_practices_code.md","info":{"title":"What are some coding best practices for macOS support?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-what-are-some-coding-best-practices-for-macos-support.html","content":"<p>Catalyst is still a fresh technology. So far, based on our current knowledge, the following best practices have emerged:</p>\n<ul>\n<li>Try to use conditional compilation (via <code>#if targetEnvironment(UIKitForMac</code>) sparringly</li>\n<li>Your view redraw code should be fast as macOS users frequently resize windows (in a dynamic manner)</li>\n<li>Have proper autolayout support for bigger and smaller sizes as windows can be resized in a variety of ways</li>\n<li>Be aware of the <a href=\"how/responder_chain.md\">responder chain</a> as multiple view controllers can be on the screen at the same time</li>\n<li>Your app can run forever, memory leaks can pile up</li>\n</ul>\n","raw_content":"[frontMatter]\ntitle = \"What are some coding best practices for macOS support?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nCatalyst is still a fresh technology. So far, based on our current knowledge, the following best practices have emerged:\n\n- Try to use conditional compilation (via `#if targetEnvironment(UIKitForMac`) sparringly\n- Your view redraw code should be fast as macOS users frequently resize windows (in a dynamic manner)\n- Have proper autolayout support for bigger and smaller sizes as windows can be resized in a variety of ways\n- Be aware of the [responder chain](how/responder_chain.md) as multiple view controllers can be on the screen at the same time\n- Your app can run forever, memory leaks can pile up\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/protocols.md":["89b81b0587aa912d",{"identifier":"1875db68","filename":"protocols.md","info":{"title":"Protocols","tags":["protocol","enum"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-protocols.html","content":"<h1>Protocols</h1>\n<p>We already mentioned the similarity between the <code>struct</code> and <code>enum</code> types. In\naddition to the ability to add methods, Swift also allows you to use\n<strong>Protocols</strong> and <strong>Protocol Extensions</strong> with enums.</p>\n<p>Swift protocols define an interface that types can\nconform to. In this case our <code>enum</code> can conform to it. For a start,\nlet's take a protocol from the Swift standard library.</p>\n<p><code>CustomStringConvertible</code> is a type with a customized textual\nrepresentation suitable for printing purposes:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> CustomStringConvertible {\n\n   <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n}\n</code></pre></code></pre>\n<p>It has only one requirement, namely a <strong>getter</strong> for a string. We can\nimplement this on an enum quite easily:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trade: <span class=\"type\">CustomStringConvertible</span> {\n\n    <span class=\"keyword\">case</span> buy, sell\n\n    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> {\n\n        <span class=\"keyword\">switch self</span> {\n\n        <span class=\"keyword\">case</span> .<span class=\"dotAccess\">buy</span>: <span class=\"keyword\">return</span> \\<span class=\"string\">\"We</span>'re buying something\\<span class=\"string\">\"</span>\n\n        <span class=\"keyword\">case</span> .<span class=\"dotAccess\">sell</span>: <span class=\"keyword\">return</span> \\<span class=\"string\">\"We</span>'re selling something\\<span class=\"string\">\"</span>\n\n        }\n\n    }\n\n}\n</code></pre></code></pre>\n<p>Some protocol implementations may need internal state handling to cope\nwith the requirements. Imagine a protocol that manages a bank account:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> AccountCompatible {\n\n   <span class=\"keyword\">var</span> remainingFunds: <span class=\"type\">Int</span> { <span class=\"keyword\">get</span> }\n\n   <span class=\"keyword\">mutating func</span> addFunds(amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n   <span class=\"keyword\">mutating func</span> removeFunds(amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span>\n\n}\n</code></pre></code></pre>\n<p>You could easily fulfill this protocol with a <code>struct</code>, but in the\ncontext of your application, an <code>enum</code> is the more sensible approach.</p>\n<p>However, you can't add properties like <code>var remainingFunds: Int</code> to an\n<code>enum</code>, so how would you model that? The answer is actually easy, you\ncan use associated values for this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Account {\n\n   <span class=\"keyword\">case</span> empty\n\n   <span class=\"keyword\">case</span> funds(remaining: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> credit(amount: <span class=\"type\">Int</span>)\n\n\n\n   <span class=\"keyword\">var</span> remainingFunds: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">switch self</span> {\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">empty</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">funds</span>(<span class=\"keyword\">let</span> remaining): <span class=\"keyword\">return</span> remaining\n\n     <span class=\"keyword\">case</span> .<span class=\"dotAccess\">credit</span>(<span class=\"keyword\">let</span> amount): <span class=\"keyword\">return</span> amount\n\n     }\n\n   }\n\n}\n</code></pre></code></pre>\n<p>To keep things clean, we can then define the required protocol functions\nin a protocol extension on the <code>enum</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">Account</span>: <span class=\"type\">AccountCompatible</span> {\n\n\n\n   <span class=\"keyword\">mutating func</span> addFunds(amount: <span class=\"type\">Int</span>) {\n\n     <span class=\"keyword\">var</span> newAmount = amount\n\n     <span class=\"keyword\">if case let</span> .<span class=\"call\">funds</span>(remaining) = <span class=\"keyword\">self</span> {\n\n       newAmount += remaining\n\n     }\n\n     <span class=\"keyword\">if</span> newAmount &lt; <span class=\"number\">0</span> {\n\n       <span class=\"keyword\">self</span> = .<span class=\"call\">credit</span>(newAmount)\n\n     } <span class=\"keyword\">else if</span> newAmount == <span class=\"number\">0</span> {\n\n       <span class=\"keyword\">self</span> = .<span class=\"dotAccess\">empty</span>\n\n     } <span class=\"keyword\">else</span> {\n\n       <span class=\"keyword\">self</span> = .<span class=\"call\">funds</span>(remaining: newAmount)\n\n     }\n\n   }\n\n\n\n   <span class=\"keyword\">mutating func</span> removeFunds(amount: <span class=\"type\">Int</span>) <span class=\"keyword\">throws</span> {\n\n     <span class=\"keyword\">try self</span>.<span class=\"call\">addFunds</span>(amount * -<span class=\"number\">1</span>)\n\n   }\n\n\n\n}\n\n\n\n<span class=\"keyword\">var</span> account = <span class=\"type\">Account</span>.<span class=\"call\">funds</span>(remaining: <span class=\"number\">20</span>)\n\n<span class=\"keyword\">try</span>? account.<span class=\"call\">addFunds</span>(amount:<span class=\"number\">10</span>)\n\n<span class=\"keyword\">try</span>? account.<span class=\"call\">removeFunds</span>(amount:<span class=\"number\">15</span>)\n</code></pre></code></pre>\n<p>As you can see, we implemented all the protocol requirements by storing\nour values within our <code>enum cases</code>. A very nifty side effect of this is,\nthat now you can test for an empty account with a simple pattern match\nall over your code base. You don't have to see whether the\n<code>remainingFunds</code> are zero.</p>\n<p>We're also implementing the protocol in an extension. We'll learn more about\nextensions on <code>enum</code> types in the next chapter.</p>\n","raw_content":"[frontMatter]\ntitle = \"Protocols\"\ntags = [\"protocol\", \"enum\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Protocols\n\nWe already mentioned the similarity between the `struct` and `enum` types. In\naddition to the ability to add methods, Swift also allows you to use\n**Protocols** and **Protocol Extensions** with enums.\n\nSwift protocols define an interface that types can\nconform to. In this case our `enum` can conform to it. For a start,\nlet\\'s take a protocol from the Swift standard library.\n\n`CustomStringConvertible` is a type with a customized textual\nrepresentation suitable for printing purposes:\n\n``` Swift\nprotocol CustomStringConvertible {\n  var description: String { get }\n}\n```\n\nIt has only one requirement, namely a **getter** for a string. We can\nimplement this on an enum quite easily:\n\n``` Swift\nenum Trade: CustomStringConvertible {\n   case buy, sell\n   var description: String {\n       switch self {\n       case .buy: return \"We're buying something\"\n       case .sell: return \"We're selling something\"\n       }\n   }\n}\n```\n\nSome protocol implementations may need internal state handling to cope\nwith the requirements. Imagine a protocol that manages a bank account:\n\n``` Swift\nprotocol AccountCompatible {\n  var remainingFunds: Int { get }\n  mutating func addFunds(amount: Int) throws\n  mutating func removeFunds(amount: Int) throws\n}\n```\n\nYou could easily fulfill this protocol with a `struct`, but in the\ncontext of your application, an `enum` is the more sensible approach.\n\nHowever, you can\\'t add properties like `var remainingFunds: Int` to an\n`enum`, so how would you model that? The answer is actually easy, you\ncan use associated values for this:\n\n``` Swift\nenum Account {\n  case empty\n  case funds(remaining: Int)\n  case credit(amount: Int)\n\n  var remainingFunds: Int {\n    switch self {\n    case .empty: return 0\n    case .funds(let remaining): return remaining\n    case .credit(let amount): return amount\n    }\n  }\n}\n```\n\nTo keep things clean, we can then define the required protocol functions\nin a protocol extension on the `enum`:\n\n``` Swift\nextension Account: AccountCompatible {\n\n  mutating func addFunds(amount: Int) {\n    var newAmount = amount\n    if case let .funds(remaining) = self {\n      newAmount += remaining\n    }\n    if newAmount < 0 {\n      self = .credit(newAmount)\n    } else if newAmount == 0 {\n      self = .empty\n    } else {\n      self = .funds(remaining: newAmount)\n    }\n  }\n\n  mutating func removeFunds(amount: Int) throws {\n    try self.addFunds(amount * -1)\n  }\n\n}\n\nvar account = Account.funds(remaining: 20)\ntry? account.addFunds(amount:10)\ntry? account.removeFunds(amount:15)\n```\n\nAs you can see, we implemented all the protocol requirements by storing\nour values within our `enum cases`. A very nifty side effect of this is,\nthat now you can test for an empty account with a simple pattern match\nall over your code base. You don\\'t have to see whether the\n`remainingFunds` are zero.\n\nWe're also implementing the protocol in an extension. We'll learn more about\nextensions on `enum` types in the next chapter.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/linked_lists.md":["35bede232a8d7ab4",{"identifier":"bd440fed","filename":"linked_lists.md","info":{"title":"Linked Lists","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-linked-lists.html","content":"<h1>Linked Lists</h1>\n<p><a href=\"http://airspeedvelocity.net/tag/swift/\">Airspeed Velocity has a great writeup on how to implement a Linked List\nwith an <code>enum</code>.</a> Most of the\ncode in his post goes far beyond enums and touches a lot of interesting\ntopics <sup class=\"footnote-reference\"><a href=\"#9\">1</a></sup>, but the basis of his linked list looks kinda like this (I\nsimplified it a bit):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> List {\n\n     <span class=\"keyword\">case</span> end\n\n     <span class=\"keyword\">indirect case</span> node(<span class=\"type\">Int</span>, next: <span class=\"type\">List</span>)\n\n}\n</code></pre></code></pre>\n<p>Each <code>node case</code> points to the next case, and by using an <code>enum</code> instead\nof something else, you don't have to use an optional for the <code>next</code>\nvalue to signify the termination of the list.</p>\n<p>Airspeed Velocity also wrote a great post about the implementation of a\nred black tree with indirect Swift enums, so while you're already\nreading his blog, <a href=\"http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/\">you may just as well also read this\none.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"Linked Lists\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Linked Lists\n\n[Airspeed Velocity has a great writeup on how to implement a Linked List\nwith an `enum`.](http://airspeedvelocity.net/tag/swift/) Most of the\ncode in his post goes far beyond enums and touches a lot of interesting\ntopics [^9], but the basis of his linked list looks kinda like this (I\nsimplified it a bit):\n\n``` Swift\nenum List {\n    case end\n    indirect case node(Int, next: List)\n}\n```\n\nEach `node case` points to the next case, and by using an `enum` instead\nof something else, you don\\'t have to use an optional for the `next`\nvalue to signify the termination of the list.\n\nAirspeed Velocity also wrote a great post about the implementation of a\nred black tree with indirect Swift enums, so while you\\'re already\nreading his blog, [you may just as well also read this\none.](http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/best_practices_design.md":["97ac069da42fbf25",{"identifier":"aba0d700","filename":"best_practices_design.md","info":{"title":"What are some design best practices for macOS support?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-what-are-some-design-best-practices-for-macos-support.html","content":"<p>These guidelines are based on information that Apple shared in different WWDC keynotes</p>\n<ul>\n<li>Most Important: <a href=\"https://developer.apple.com/design/human-interface-guidelines/ios/overview/ipad-apps-for-mac/\">Apple has Human Interface Guidelines for <em>iPad Apps for Mac</em></a></li>\n<li>Macs don't have dynamic type. Everything is &quot;Large&quot;</li>\n<li>Mac users have many windows open. Therefore you should set focus on the contents of the window. This means using less color so that the contents can shine</li>\n<li>Use side bars and toolbars instead of a UITabBar</li>\n<li>Try to take advantage of the bigger macOS windows. You can utilize different layouts and use the space wisely</li>\n<li>Default font size on macOS is 13pt compared to 17pt on iOS. This is handled automatically for you though, as each app is scaled to 77% of its actual size</li>\n</ul>\n","raw_content":"[frontMatter]\ntitle = \"What are some design best practices for macOS support?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nThese guidelines are based on information that Apple shared in different WWDC keynotes\n\n- Most Important: [Apple has Human Interface Guidelines for *iPad Apps for Mac*](https://developer.apple.com/design/human-interface-guidelines/ios/overview/ipad-apps-for-mac/)\n- Macs don't have dynamic type. Everything is \"Large\"\n- Mac users have many windows open. Therefore you should set focus on the contents of the window. This means using less color so that the contents can shine\n- Use side bars and toolbars instead of a UITabBar\n- Try to take advantage of the bigger macOS windows. You can utilize different layouts and use the space wisely\n- Default font size on macOS is 13pt compared to 17pt on iOS. This is handled automatically for you though, as each app is scaled to 77% of its actual size\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/mouse_hovering.md":["e55793b52470628e",{"identifier":"e47b7054","filename":"mouse_hovering.md","info":{"title":"How do I support mouse hovering?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-support-mouse-hovering.html","content":"<p><img src=\"/img-content/catalyst/hover.png\" alt=\"\" /></p>\n<p>Apple supports hovering in Catalyst via a new gesture recognizer, the so-called <code>UIHoverGestureRecognizer</code>. It works in a very simple manner.</p>\n<ol>\n<li>First you initialize a new hover gesture recognizer</li>\n<li>Then, you add it to your view</li>\n<li>Finally, you implement the method to be called when the user hovers</li>\n</ol>\n<p>Now, for every mouse movement within the containment of the view, your method will be called and you can query the gesture recognizer for the position in order to implement custom logic (as Apple does in the Stocks.app when you hover over a Stock's price history).</p>\n<p>Below is a simple implementation:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> MyHoverViewController: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">override func</span> viewDidLoad() {\n\n         <span class=\"keyword\">super</span>.<span class=\"call\">viewDidLoad</span>()\n\n         <span class=\"comment\">// Create the recognizer</span>\n\n         <span class=\"keyword\">let</span> hover = <span class=\"type\">UIHoverGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: <span class=\"keyword\">#selector</span>(<span class=\"call\">mouseDidMove</span>(with:)))\n\n         <span class=\"comment\">// Add it to the view</span>\n\n         view.<span class=\"call\">addGestureRecognizer</span>(hover)\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> mouseDidMove(with recognizer: <span class=\"type\">UIHoverGestureRecognizer</span>) {\n\n         <span class=\"keyword\">guard let</span> view = recognizer.<span class=\"property\">view</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"comment\">// Calculate the location</span>\n\n         <span class=\"keyword\">let</span> locationInView = recognizer.<span class=\"call\">location</span>(in: view)\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"Hovering</span> at location \\(locationInView)\\<span class=\"string\">\"</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I support mouse hovering?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n![](/img-content/catalyst/hover.png)\n\n\nApple supports hovering in Catalyst via a new gesture recognizer, the so-called `UIHoverGestureRecognizer`. It works in a very simple manner.\n\n1. First you initialize a new hover gesture recognizer\n2. Then, you add it to your view\n3. Finally, you implement the method to be called when the user hovers\n\nNow, for every mouse movement within the containment of the view, your method will be called and you can query the gesture recognizer for the position in order to implement custom logic (as Apple does in the Stocks.app when you hover over a Stock's price history).\n\nBelow is a simple implementation:\n\n``` Swift\nfinal class MyHoverViewController: UIViewController {\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Create the recognizer\n        let hover = UIHoverGestureRecognizer(target: self, action: #selector(mouseDidMove(with:)))\n        // Add it to the view\n        view.addGestureRecognizer(hover)\n    }\n\n    @objc func mouseDidMove(with recognizer: UIHoverGestureRecognizer) {\n        guard let view = recognizer.view else { return }\n        // Calculate the location\n        let locationInView = recognizer.location(in: view)\n        print(\"Hovering at location \\(locationInView)\")\n    }\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/context_menus.md":["9b22d0beec849408",{"identifier":"2aa34849","filename":"context_menus.md","info":{"title":"How do I create context menus?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-create-context-menus.html","content":"<p>Context Menus in Catalyst are implemented via the new <a href=\"https://developer.apple.com/documentation/uikit/uicontextmenuinteraction\"><code>UIContextMenuInteraction</code> API that Apple shipped on iOS as part of iOS 13.</a>. <a href=\"https://developer.apple.com/documentation/uikit/menus_and_shortcuts\">They work hand in hand with menu and shortcut system that is documented here</a>.</p>\n<p>If you support context menus with <code>UIContextMenuInteraction</code>, they will automatically convert into right click context menus in your Catalyst app. Here's a simple example of how that works in action:</p>\n<p>For simplicity, <code>UITableView</code> (and also <code>UICollectionView</code>) have new delegate methods that allow you to return a <code>UIContextMenuInteraction</code> instance that will be used for 3D touch or long presses on iOS or context menus on macOS. Here is an example of a very simple menu that has two entries &quot;Move Priority Up&quot; and &quot;Move Priority Down&quot;:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">MyViewController</span>: <span class=\"type\">UITableViewDelegate</span> {\n\n     <span class=\"keyword\">public override func</span> tableView(<span class=\"keyword\">_</span> tableView: <span class=\"type\">UITableView</span>, contextMenuConfigurationForRowAt indexPath: <span class=\"type\">IndexPath</span>, point: <span class=\"type\">CGPoint</span>) -&gt; <span class=\"type\">UIContextMenuConfiguration</span>? {\n\n         <span class=\"comment\">// Action providers are closures that generate action menus. They are called lazily only</span>\n\n     <span class=\"comment\">// when the menu is actually invoked.</span>\n\n         <span class=\"keyword\">let</span> actionProvider: ([<span class=\"type\">UIMenuElement</span>]) -&gt; <span class=\"type\">UIMenu</span>? = { <span class=\"keyword\">_ in</span>\n\n             <span class=\"keyword\">let</span> upAction = <span class=\"type\">UIAction</span>(__title: \\<span class=\"string\">\"Move</span> <span class=\"type\">Priority Up</span>\\<span class=\"string\">\"</span>,\n\n                                     image: <span class=\"type\">UIImage</span>(systemName: \\<span class=\"string\">\"square</span>.<span class=\"property\">and</span>.<span class=\"property\">arrow</span>.<span class=\"property\">up</span>\\<span class=\"string\">\"</span>))\n\n             { [<span class=\"keyword\">weak self</span>] <span class=\"keyword\">_ in</span>\n\n                 <span class=\"keyword\">self</span>?.<span class=\"call\">changePriority</span>(.<span class=\"dotAccess\">up</span>, indexPath)\n\n             }\n\n             <span class=\"keyword\">let</span> downAction = <span class=\"type\">UIAction</span>(__title: \\<span class=\"string\">\"Move</span> <span class=\"type\">Priority Down</span>\\<span class=\"string\">\"</span>,\n\n                                       image: <span class=\"type\">UIImage</span>(systemName: \\<span class=\"string\">\"square</span>.<span class=\"property\">and</span>.<span class=\"property\">arrow</span>.<span class=\"property\">down</span>\\<span class=\"string\">\"</span>))\n\n             { [<span class=\"keyword\">weak self</span>] <span class=\"keyword\">_ in</span>\n\n                 <span class=\"keyword\">self</span>?.<span class=\"call\">changePriority</span>(.<span class=\"dotAccess\">down</span>, indexPath)\n\n             }\n\n\n\n         <span class=\"keyword\">let</span> actions = [upAction, downAction]\n\n\n\n             <span class=\"comment\">// We generate a new menu with our two actions</span>\n\n             <span class=\"keyword\">return</span> <span class=\"type\">UIMenu</span>(__title: \\<span class=\"string\">\"Actions</span>\\<span class=\"string\">\"</span>, image: <span class=\"keyword\">nil</span>, identifier: <span class=\"keyword\">nil</span>, children: actions)\n\n         }\n\n\n\n     <span class=\"comment\">// A context menu can have a `identifier`, a `previewProvider`,</span>\n\n     <span class=\"comment\">// and, finally, the `actionProvider that creates the menu</span>\n\n         <span class=\"keyword\">return</span> <span class=\"type\">UIContextMenuConfiguration</span>(identifier: <span class=\"keyword\">nil</span>,\n\n                                           previewProvider: <span class=\"keyword\">nil</span>,\n\n                                           actionProvider: actionProvider)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>That's all you need to support context menus in your tableView. <a href=\"https://developer.apple.com/documentation/uikit/menus_and_shortcuts\">For more complex use cases, refer to the detailed documentation on menus:</a>, and on <a href=\"https://developer.apple.com/documentation/uikit/uicontextmenuinteraction\"><code>UIContextMenuInteraction</code></a></p>\n","raw_content":"[frontMatter]\ntitle = \"How do I create context menus?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nContext Menus in Catalyst are implemented via the new [`UIContextMenuInteraction` API that Apple shipped on iOS as part of iOS 13.](https://developer.apple.com/documentation/uikit/uicontextmenuinteraction). [They work hand in hand with menu and shortcut system that is documented here](https://developer.apple.com/documentation/uikit/menus_and_shortcuts).\n\nIf you support context menus with `UIContextMenuInteraction`, they will automatically convert into right click context menus in your Catalyst app. Here's a simple example of how that works in action:\n\nFor simplicity, `UITableView` (and also `UICollectionView`) have new delegate methods that allow you to return a `UIContextMenuInteraction` instance that will be used for 3D touch or long presses on iOS or context menus on macOS. Here is an example of a very simple menu that has two entries \"Move Priority Up\" and \"Move Priority Down\":\n\n``` swift\nextension MyViewController: UITableViewDelegate {\n    public override func tableView(_ tableView: UITableView, contextMenuConfigurationForRowAt indexPath: IndexPath, point: CGPoint) -> UIContextMenuConfiguration? {\n        // Action providers are closures that generate action menus. They are called lazily only\n\t// when the menu is actually invoked.\n        let actionProvider: ([UIMenuElement]) -> UIMenu? = { _ in\n            let upAction = UIAction(__title: \"Move Priority Up\",\n                                    image: UIImage(systemName: \"square.and.arrow.up\"))\n            { [weak self] _ in\n                self?.changePriority(.up, indexPath)\n            }\n            let downAction = UIAction(__title: \"Move Priority Down\",\n                                      image: UIImage(systemName: \"square.and.arrow.down\"))\n            { [weak self] _ in\n                self?.changePriority(.down, indexPath)\n            }\n\n\t    let actions = [upAction, downAction]\n\n            // We generate a new menu with our two actions\n            return UIMenu(__title: \"Actions\", image: nil, identifier: nil, children: actions)\n        }\n\n\t// A context menu can have a `identifier`, a `previewProvider`,\n\t// and, finally, the `actionProvider that creates the menu\n        return UIContextMenuConfiguration(identifier: nil,\n                                          previewProvider: nil,\n                                          actionProvider: actionProvider)\n    }\n}\n```\n\nThat's all you need to support context menus in your tableView. [For more complex use cases, refer to the detailed documentation on menus:](https://developer.apple.com/documentation/uikit/menus_and_shortcuts), and on [`UIContextMenuInteraction`](https://developer.apple.com/documentation/uikit/uicontextmenuinteraction)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/reduce.md":["0b360dd62654c779",{"identifier":"c948079f","filename":"reduce.md","info":{"title":"Reduce","tags":["map","compactMap","filter","reduce"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-reduce.html","content":"<h1>Reduce</h1>\n<p>Reduce is sort of a generalized version of <code>map</code>, <code>compactMap</code>, <code>flatMap</code>, or\n<code>filter</code>. The basic idea is to <strong>reduce</strong> a sequence into a different\nshape utilizing an <strong>accumulator</strong> that can keep incremental state. To\ndo this, we hand the function a <strong>combinator</strong> closure/function/method\nwhich is called once for each item in the sequence. This may sound\ncomplicated but becomes really easy with a couple of examples.</p>\n<p>It is a method on <code>SequenceType</code> and looks like this (simplified):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> reduce&lt;T&gt;(<span class=\"keyword\">_</span> initialResult: <span class=\"type\">T</span>, <span class=\"keyword\">_</span> nextPartialResult: (<span class=\"type\">T</span>, <span class=\"type\">Self</span>.<span class=\"type\">Generator</span>.<span class=\"type\">Element</span>) -&gt; <span class=\"type\">T</span>) -&gt; <span class=\"type\">T</span>\n</code></pre></code></pre>\n<p>There're two parameters here:</p>\n<ol>\n<li>A <code>initialResult</code> value of generic type <code>T</code></li>\n<li>A closure <code>nextPartialResult</code> that receives two parameters and returns the generic type <code>T</code>. The two parameters are <code>T</code>, once again, and the element type of the array. Imagine we had an array of <code>String</code> and we'd like to <code>reduce</code> it to the count of elements <code>Int</code>. Reduce would look like this:</li>\n</ol>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> reduce(<span class=\"keyword\">_</span> initialResult: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> nextPartialResult: (<span class=\"type\">Int</span>, <span class=\"type\">String</span>) -&gt; <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>\n</code></pre></code></pre>\n<p>So here we have an initial value <code>Int</code>, and we have a closure which expects us to\nreturn the same type as the initial value (<code>Int</code>). The final value of the\noperation is also of the same type as the initial value.</p>\n<p>If we take a very simple reduce operation - counting the elments in an array of <code>String</code> - , the evaluation will look like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> count(accumulator: <span class=\"type\">Int</span>, current: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> {\n\n    <span class=\"keyword\">return</span> accumulator += <span class=\"number\">1</span>\n\n}\n\n[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, count)\n\n\n\n<span class=\"comment\">// The following steps will be performed</span>\n\n<span class=\"call\">count</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) { <span class=\"keyword\">return</span> <span class=\"number\">0</span> + <span class=\"number\">1</span> } = <span class=\"number\">1</span>\n\n<span class=\"call\">count</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>) { <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"number\">1</span> } = <span class=\"number\">2</span>\n\n<span class=\"call\">count</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>) { <span class=\"keyword\">return</span> <span class=\"number\">2</span> + <span class=\"number\">1</span> } = <span class=\"number\">3</span>\n\n= <span class=\"number\">6</span>\n</code></pre></code></pre>\n<p>And if we want to sum up the integer elements in an array of <code>Int</code>, we'd write this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> sum(accumulator: <span class=\"type\">Int</span>, current: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> {\n\n    <span class=\"keyword\">return</span> accumulator + current\n\n}\n\n[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, sum)\n\n<span class=\"comment\">// The following steps will be performed</span>\n\n<span class=\"call\">sum</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>) { <span class=\"keyword\">return</span> <span class=\"number\">0</span> + <span class=\"number\">1</span> } = <span class=\"number\">1</span>\n\n<span class=\"call\">sum</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>) { <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"number\">2</span> } = <span class=\"number\">3</span>\n\n<span class=\"call\">sum</span>(<span class=\"number\">3</span>, <span class=\"number\">3</span>) { <span class=\"keyword\">return</span> <span class=\"number\">3</span> + <span class=\"number\">3</span> } = <span class=\"number\">6</span>\n\n= <span class=\"number\">6</span>\n</code></pre></code></pre>\n<p>The <strong>nextPartialResult</strong> closure (<code>sum</code> in our example) will be called once for each item in the\nlist <code>[1, 2, 3]</code>. The state will be kept in the <strong>accumulator</strong> variable\nwhich is just an Integer.</p>\n<p>Let's start re-implementing some of our other, trusted, functional\nprogramming friends. In order to keep things simple for now, all these\nfunctions will operate on <code>Int</code> or <code>Optional&lt;Int&gt;</code>; i.e. we will ignore\ngenerics in here. Also, keep in mind that the implementations below\nexist to explain the behaviour of <code>reduce</code>. The native Swift\nimplementations are usually much faster compared to the reduce versions\nbelow. Reduce shines in a different set of problems, which will be\nexplained further below.</p>\n","raw_content":"[frontMatter]\ntitle = \"Reduce\"\ntags = [\"map\", \"compactMap\", \"filter\", \"reduce\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Reduce\n\nReduce is sort of a generalized version of `map`, `compactMap`, `flatMap`, or\n`filter`. The basic idea is to **reduce** a sequence into a different\nshape utilizing an **accumulator** that can keep incremental state. To\ndo this, we hand the function a **combinator** closure/function/method\nwhich is called once for each item in the sequence. This may sound\ncomplicated but becomes really easy with a couple of examples.\n\nIt is a method on `SequenceType` and looks like this (simplified):\n\n``` Swift\nfunc reduce<T>(_ initialResult: T, _ nextPartialResult: (T, Self.Generator.Element) -> T) -> T\n```\n\nThere're two parameters here:\n1. A `initialResult` value of generic type `T`\n2. A closure `nextPartialResult` that receives two parameters and returns the generic type `T`. The two parameters are `T`, once again, and the element type of the array. Imagine we had an array of `String` and we'd like to `reduce` it to the count of elements `Int`. Reduce would look like this:\n\n``` Swift\nfunc reduce(_ initialResult: Int, _ nextPartialResult: (Int, String) -> Int) -> Int\n```\n\nSo here we have an initial value `Int`, and we have a closure which expects us to\nreturn the same type as the initial value (`Int`). The final value of the\noperation is also of the same type as the initial value.\n\nIf we take a very simple reduce operation - counting the elments in an array of `String` - , the evaluation will look like this:\n\n``` Swift\nfunc count(accumulator: Int, current: Int) -> Int {\n   return accumulator += 1\n}\n[1, 2, 3].reduce(0, count)\n\n// The following steps will be performed\ncount(0, 1) { return 0 + 1 } = 1\ncount(1, 2) { return 1 + 1 } = 2\ncount(2, 3) { return 2 + 1 } = 3\n= 6\n```\n\nAnd if we want to sum up the integer elements in an array of `Int`, we'd write this:\n\n``` Swift\nfunc sum(accumulator: Int, current: Int) -> Int {\n   return accumulator + current\n}\n[1, 2, 3].reduce(0, sum)\n// The following steps will be performed\nsum(0, 1) { return 0 + 1 } = 1\nsum(1, 2) { return 1 + 2 } = 3\nsum(3, 3) { return 3 + 3 } = 6\n= 6\n```\n\nThe **nextPartialResult** closure (`sum` in our example) will be called once for each item in the\nlist `[1, 2, 3]`. The state will be kept in the **accumulator** variable\nwhich is just an Integer.\n\nLet\\'s start re-implementing some of our other, trusted, functional\nprogramming friends. In order to keep things simple for now, all these\nfunctions will operate on `Int` or `Optional<Int>`; i.e. we will ignore\ngenerics in here. Also, keep in mind that the implementations below\nexist to explain the behaviour of `reduce`. The native Swift\nimplementations are usually much faster compared to the reduce versions\nbelow. Reduce shines in a different set of problems, which will be\nexplained further below.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/advanced_tuples/private_state.md":["5dfa0ed182ec99e4",{"identifier":"6c2960a9","filename":"private_state.md","info":{"title":"Private State","tags":["tuples","closure"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-private-state.html","content":"<h1>Private State</h1>\n<p>In addition to the previous example, there are also use cases where\nusing tuples beyond a temporary scope is useful. As\nlong as the scope is private and the tuple's type isn't littered all\nover the implementation, using tuples to store internal state can be\nfine.</p>\n<p>A simple and contrived example would be storing a static UITableView\nstructure that displays various information from a user profile and\ncontains the key path to the actual value as well as a flag noting\nwhether the value can be edited when tapping on the cell.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> tableViewValues = [\n\n     (title: \\<span class=\"string\">\"Age</span>\\<span class=\"string\">\"</span>, value: \\<span class=\"string\">\"user</span>.<span class=\"property\">age</span>\\<span class=\"string\">\"</span>, editable: <span class=\"keyword\">true</span>),\n\n     (\\<span class=\"string\">\"Name</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"user</span>.<span class=\"property\">name</span>.<span class=\"property\">combinedName</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">true</span>),\n\n     (\\<span class=\"string\">\"Username</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"user</span>.<span class=\"property\">name</span>.<span class=\"property\">username</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">false</span>),\n\n     (\\<span class=\"string\">\"ProfilePicture</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"user</span>.<span class=\"property\">pictures</span>.<span class=\"property\">thumbnail</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">false</span>)]\n</code></pre></code></pre>\n<p>The alternative would be to define a struct, but if the data is a purely\nprivate implementation detail, a tuple works just as well.</p>\n<p>A better example is when you define an object and want to add the\nability to add multiple change listeners to your object. Each listener\nconsists of a name and the closure to be called upon any change:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Action = (<span class=\"keyword\">_</span> change: <span class=\"type\">Any</span>?) -&gt; <span class=\"type\">Void</span>\n\n<span class=\"keyword\">func</span> addListener(name: <span class=\"type\">String</span>, action: <span class=\"keyword\">@escaping</span> <span class=\"type\">Action</span>) { }\n\n<span class=\"keyword\">func</span> removeListener(name: <span class=\"type\">String</span>) { }\n</code></pre></code></pre>\n<p>How will you store these listeners in your object? The obvious solution\nwould be to define a struct, but this is a very limited scope, and the\nstruct will only be internal, and it will be used in only three cases.\nHere, using a tuple may even be the better solution, as the\ndestructuring makes things simpler:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> ListenerStuff {\n\n\n\n     <span class=\"keyword\">typealias</span> Action = (<span class=\"keyword\">_</span> change: <span class=\"type\">Any</span>?) -&gt; <span class=\"type\">Void</span>\n\n\n\n     <span class=\"keyword\">var</span> listeners: [(<span class=\"type\">String</span>, <span class=\"type\">Action</span>)] = []\n\n\n\n     <span class=\"keyword\">func</span> addListener(name: <span class=\"type\">String</span>, action: <span class=\"keyword\">@escaping</span> <span class=\"type\">Action</span>) {\n\n         listeners.<span class=\"call\">append</span>((name, action))\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> removeListener(name: <span class=\"type\">String</span>) {\n\n         <span class=\"keyword\">if let</span> idx = listeners.<span class=\"call\">index</span>(where: { $0.<span class=\"number\">0</span> == name }) {\n\n             listeners.<span class=\"call\">remove</span>(at: idx)\n\n         }\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> execute(change: <span class=\"type\">Int</span>) {\n\n         <span class=\"keyword\">for</span> (<span class=\"keyword\">_</span>, listener) <span class=\"keyword\">in</span> listeners {\n\n             <span class=\"call\">listener</span>(change <span class=\"keyword\">as</span> <span class=\"type\">Any</span>?)\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">var</span> stuff = <span class=\"type\">ListenerStuff</span>()\n\n<span class=\"keyword\">let</span> ourAction: <span class=\"type\">ListenerStuff</span>.<span class=\"type\">Action</span> = { x <span class=\"keyword\">in</span> <span class=\"call\">print</span>(\\<span class=\"string\">\"Change</span> <span class=\"keyword\">is</span> \\(x ?? \\\"NONE\\<span class=\"string\">\"</span>).\\<span class=\"string\">\"</span>) }\n\nstuff.<span class=\"call\">addListener</span>(name: \\<span class=\"string\">\"xx</span>\\<span class=\"string\">\"</span>, action: ourAction)\n\nstuff.<span class=\"call\">execute</span>(change: <span class=\"number\">17</span>)\n</code></pre></code></pre>\n<p>As you can see in the <code>execute</code> function, the destructuring abilities\nmake tuples especially useful in this case, as the contents are directly\ndestructured into the local scope.</p>\n","raw_content":"[frontMatter]\ntitle = \"Private State\"\ntags = [\"tuples\", \"closure\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Private State\n\nIn addition to the previous example, there are also use cases where\nusing tuples beyond a temporary scope is useful. As\nlong as the scope is private and the tuple\\'s type isn\\'t littered all\nover the implementation, using tuples to store internal state can be\nfine.\n\nA simple and contrived example would be storing a static UITableView\nstructure that displays various information from a user profile and\ncontains the key path to the actual value as well as a flag noting\nwhether the value can be edited when tapping on the cell.\n\n``` Swift\nlet tableViewValues = [\n    (title: \"Age\", value: \"user.age\", editable: true),\n    (\"Name\", \"user.name.combinedName\", true),\n    (\"Username\", \"user.name.username\", false),\n    (\"ProfilePicture\", \"user.pictures.thumbnail\", false)]\n```\n\nThe alternative would be to define a struct, but if the data is a purely\nprivate implementation detail, a tuple works just as well.\n\nA better example is when you define an object and want to add the\nability to add multiple change listeners to your object. Each listener\nconsists of a name and the closure to be called upon any change:\n\n``` Swift\ntypealias Action = (_ change: Any?) -> Void\nfunc addListener(name: String, action: @escaping Action) { }\nfunc removeListener(name: String) { }\n```\n\nHow will you store these listeners in your object? The obvious solution\nwould be to define a struct, but this is a very limited scope, and the\nstruct will only be internal, and it will be used in only three cases.\nHere, using a tuple may even be the better solution, as the\ndestructuring makes things simpler:\n\n``` Swift\nclass ListenerStuff {\n\n    typealias Action = (_ change: Any?) -> Void\n\n    var listeners: [(String, Action)] = []\n\n    func addListener(name: String, action: @escaping Action) {\n        listeners.append((name, action))\n    }\n\n    func removeListener(name: String) {\n        if let idx = listeners.index(where: { $0.0 == name }) {\n            listeners.remove(at: idx)\n        }\n    }\n\n    func execute(change: Int) {\n        for (_, listener) in listeners {\n            listener(change as Any?)\n        }\n    }\n}\n\nvar stuff = ListenerStuff()\nlet ourAction: ListenerStuff.Action = { x in print(\"Change is \\(x ?? \"NONE\").\") }\nstuff.addListener(name: \"xx\", action: ourAction)\nstuff.execute(change: 17)\n```\n\nAs you can see in the `execute` function, the destructuring abilities\nmake tuples especially useful in this case, as the contents are directly\ndestructured into the local scope.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/type_erasure/putting_it_all_together.md":["6a187a6319d5f5ed",{"identifier":"bdc4971e","filename":"putting_it_all_together.md","info":{"title":"Puttting it all together","tags":["box","associated","generics","erasure"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-puttting-it-all-together.html","content":"<h1>Puttting it all together</h1>\n<p>In the next and final step, we're building the actual type that will be\nused as the proverbial type eraser. Just as before, lets have a look at\nthe code first:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> AnyComputer&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">private let</span> box: <span class=\"type\">AnyComputerBase</span>&lt;<span class=\"type\">Processor</span>&gt;\n\n     <span class=\"keyword\">var</span> processor: <span class=\"type\">Processor</span> {\n\n         <span class=\"keyword\">return</span> box.<span class=\"property\">processor</span>\n\n     }\n\n     <span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> {\n\n         <span class=\"keyword\">return</span> box.<span class=\"property\">processorCount</span>\n\n     }\n\n     <span class=\"keyword\">init</span>&lt;Concrete: <span class=\"type\">Computer</span>&gt;(<span class=\"keyword\">_</span> computer: <span class=\"type\">Concrete</span>) \n\n         <span class=\"keyword\">where</span> <span class=\"type\">Concrete</span>.<span class=\"type\">ProcessorType</span> == <span class=\"type\">Processor</span> {\n\n       box = <span class=\"type\">AnyComputerBox</span>(computer)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This <code>AnyComputer</code> conforms to the <code>Computer</code> protocol and is generic\nover the <code>CPU</code> type that the protocol requires. Once again, we implement\nthe protocol requirements (<code>processor</code>, and <code>processorCount</code>) and\nforward to a boxed type. This time we're forwarding to\n<code>private let box: AnyComputerBase&lt;Processor&gt;</code>. This <code>box</code> is set in the\ninitializer where most of the magic happens:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">init</span>&lt;Concrete: <span class=\"type\">Computer</span>&gt;(<span class=\"keyword\">_</span> computer: <span class=\"type\">Concrete</span>) \n\n     <span class=\"keyword\">where</span> <span class=\"type\">Concrete</span>.<span class=\"type\">ProcessorType</span> == <span class=\"type\">Processor</span> {\n\n   box = <span class=\"type\">AnyComputerBox</span>(computer)\n\n}\n</code></pre></code></pre>\n<p>The problem with protocols with <code>associated types</code> is that you can't\nuse them as property types. Here, <code>init</code> requires any type conforming to\nthe <code>Computer</code> protocol. This is done by having a method-generic type\n<code>Concrete</code> that requires <code>Computer</code> conformance. Even more, we also add\na constraint that makes sure that the generic <code>Processor</code> type of the\nnew <code>AnyComputer</code> class is the same type as the <code>associated type</code> of the\n<code>Concrete</code> <code>Computer</code> type.</p>\n<p>And now comes the kicker: Since we cannot set a property as being of\ntype <code>Computer</code> we, instead, have a property that is of\n<code>AnyComputerBase</code> with a generic type for the <code>Processor</code>. As our\n<code>AnyComputerBox</code> type is a subclass of <code>AnyComputerBase</code> we can\nliterally put <strong>any</strong> box (that is a subclass of <code>AnyComputerBase</code> into\nthis property. In this case, we're creating a new box with the\n<code>Concrete</code> <code>Computer</code>.</p>\n<p>Then we return the implementations of the contents of the box (i.e. the\nactual <code>Concrete</code> <code>Computer</code>) in our <code>Computer</code> implementations:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> {\n\n     <span class=\"keyword\">return</span> box.<span class=\"property\">processorCount</span>\n\n}\n</code></pre></code></pre>\n<h2>Using It</h2>\n<p>With all this machinery in place, we can finally use this in order to\nhave different types (which share an associated type) in one container:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> powerComputers: [<span class=\"type\">AnyComputer</span>&lt;<span class=\"type\">PowerPC</span>&gt;] = \n\n     [<span class=\"type\">AnyComputer</span>(<span class=\"type\">PowerMacG5</span>()), <span class=\"type\">AnyComputer</span>(<span class=\"type\">Xbox360</span>())]\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Puttting it all together\"\ntags = [\"box\", \"associated\", \"generics\", \"erasure\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Puttting it all together\n\nIn the next and final step, we\\'re building the actual type that will be\nused as the proverbial type eraser. Just as before, lets have a look at\nthe code first:\n\n``` Swift\nfinal class AnyComputer<Processor: CPU>: Computer {\n    private let box: AnyComputerBase<Processor>\n    var processor: Processor {\n        return box.processor\n    }\n    var processorCount: Int {\n        return box.processorCount\n    }\n    init<Concrete: Computer>(_ computer: Concrete) \n        where Concrete.ProcessorType == Processor {\n      box = AnyComputerBox(computer)\n    }\n}\n```\n\nThis `AnyComputer` conforms to the `Computer` protocol and is generic\nover the `CPU` type that the protocol requires. Once again, we implement\nthe protocol requirements (`processor`, and `processorCount`) and\nforward to a boxed type. This time we\\'re forwarding to\n`private let box: AnyComputerBase<Processor>`. This `box` is set in the\ninitializer where most of the magic happens:\n\n``` Swift\ninit<Concrete: Computer>(_ computer: Concrete) \n    where Concrete.ProcessorType == Processor {\n  box = AnyComputerBox(computer)\n}\n```\n\nThe problem with protocols with `associated types` is that you can\\'t\nuse them as property types. Here, `init` requires any type conforming to\nthe `Computer` protocol. This is done by having a method-generic type\n`Concrete` that requires `Computer` conformance. Even more, we also add\na constraint that makes sure that the generic `Processor` type of the\nnew `AnyComputer` class is the same type as the `associated type` of the\n`Concrete` `Computer` type.\n\nAnd now comes the kicker: Since we cannot set a property as being of\ntype `Computer` we, instead, have a property that is of\n`AnyComputerBase` with a generic type for the `Processor`. As our\n`AnyComputerBox` type is a subclass of `AnyComputerBase` we can\nliterally put **any** box (that is a subclass of `AnyComputerBase` into\nthis property. In this case, we\\'re creating a new box with the\n`Concrete` `Computer`.\n\nThen we return the implementations of the contents of the box (i.e. the\nactual `Concrete` `Computer`) in our `Computer` implementations:\n\n``` Swift\nvar processorCount: Int {\n    return box.processorCount\n}\n```\n\n## Using It\n\nWith all this machinery in place, we can finally use this in order to\nhave different types (which share an associated type) in one container:\n\n``` Swift\nlet powerComputers: [AnyComputer<PowerPC>] = \n    [AnyComputer(PowerMacG5()), AnyComputer(Xbox360())]\n```\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/trading_engine.md":["98e35be43ac2552c",{"identifier":"b3db1ad4","filename":"trading_engine.md","info":{"title":"A Trading Engine","tags":["pattern matching","switch"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-a-trading-engine.html","content":"<h1>A Trading Engine</h1>\n<p>So a Wall Street company contacts you, they need a new trading platform running\non iOS devices. As it is a trading platform, you define an <code>enum</code> for\ntrades.</p>\n<h2>First Draft</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Trades {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>)\n\n}\n</code></pre></code></pre>\n<p>You were also handed the following API to handle trades. <strong>Notice how\nsell orders are just negative amounts</strong>.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/**</span>\n\n  - parameter stock: <span class=\"type\">The</span> stock name\n\n  - parameter amount: <span class=\"type\">The</span> amount, negative number = sell, positive = buy\n\n<span class=\"comment\">*/</span>\n\n<span class=\"keyword\">func</span> process(stock: <span class=\"type\">String</span>, <span class=\"keyword\">_</span> amount: <span class=\"type\">Int</span>) {\n\n     print (\\<span class=\"string\">\"</span>\\(amount) of \\(stock)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>The next step is to process those trades. You see the potential for\nusing pattern matching and write this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> aTrade = <span class=\"type\">Trades</span>.<span class=\"call\">buy</span>(stock: \\<span class=\"string\">\"APPL</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">200</span>, stockPrice: <span class=\"number\">115.5</span>)\n\n\n\n<span class=\"keyword\">switch</span> aTrade {\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">buy</span>(<span class=\"keyword\">let</span> stock, <span class=\"keyword\">let</span> amount, <span class=\"keyword\">_</span>):\n\n     <span class=\"call\">process</span>(stock, amount)\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">sell</span>(<span class=\"keyword\">let</span> stock, <span class=\"keyword\">let</span> amount, <span class=\"keyword\">_</span>):\n\n     <span class=\"call\">process</span>(stock, amount * -<span class=\"number\">1</span>)\n\n}\n\n<span class=\"comment\">// Prints \\\"buy 200 of APPL\\\"</span>\n</code></pre></code></pre>\n<p>Swift lets us conveniently only destructure / extract the information\nfrom the <code>enum</code> that we really want. In this case only the stock and the\namount.</p>\n<p>Awesome, you visit Wall Street to show of your fantastic trading\nplatform. However, as always, the reality is much more cumbersome than\nthe beautiful theory. Trades aren't trades you learn.</p>\n<ul>\n<li>You have to calculate in a fee which is different based on the\ntrader type.</li>\n<li>The smaller the institution the higher the fee.</li>\n<li>Also, bigger institutions get a higher priority.</li>\n</ul>\n<p>They also realized that you'll need a new API for this, so you were\nhanded this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> processSlow(stock: <span class=\"type\">String</span>, <span class=\"keyword\">_</span> amount: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> fee: <span class=\"type\">Float</span>) { <span class=\"call\">print</span>(\\<span class=\"string\">\"slow</span>\\<span class=\"string\">\"</span>) }\n\n<span class=\"keyword\">func</span> processFast(stock: <span class=\"type\">String</span>, <span class=\"keyword\">_</span> amount: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> fee: <span class=\"type\">Float</span>) { <span class=\"call\">print</span>(\\<span class=\"string\">\"fast</span>\\<span class=\"string\">\"</span>) }\n</code></pre></code></pre>\n<h2>Trader Types</h2>\n<p>So you go back to the drawing board and add another <code>enum</code>. The trader\ntype is part of every trade, too.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> TraderType {\n\n<span class=\"keyword\">case</span> singleGuy\n\n<span class=\"keyword\">case</span> company\n\n} \n\n\n\n<span class=\"keyword\">enum</span> Trades {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>, type: <span class=\"type\">TraderType</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">String</span>, amount: <span class=\"type\">Int</span>, stockPrice: <span class=\"type\">Float</span>, type: <span class=\"type\">TraderType</span>)\n\n}\n\n\n</code></pre></code></pre>\n<p>So, how do you best implement this new restriction? You could just have\nan <code>if</code> / <code>else</code> switch for buy and for sell, but that would lead to\nnested code which quickly lacks clarity - and who knows maybe these Wall\nStreet guys come up with further complications. So you define it instead\nas additional requirements on the pattern matches:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">let</span> aTrade = <span class=\"type\">Trades</span>.<span class=\"call\">sell</span>(stock: \\<span class=\"string\">\"GOOG</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">100</span>, stockPrice: <span class=\"number\">666.0</span>, type: <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>)\n\n\n\n<span class=\"keyword\">switch</span> aTrade {\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, amount, <span class=\"number\">2.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">2.0</span>)\n\n}\n</code></pre></code></pre>\n<p>The beauty of this is that there's a very succinct flow describing the\ndifferent possible combinations. Also, note how we changed\n<code>.buy(let stock, let amount)</code> into <code>let .buy(stock, amount)</code> in order to\nkeep things simpler. This will destructure the <code>enum</code> just as before,\nonly with less syntax.</p>\n<h2>Guards! Guards!</h2>\n<p>Once again you present your development to your Wall Street customer,\nand once again a new issue pops up (you really should have asked for a\nmore detailed project description).</p>\n<ul>\n<li>Sell orders exceeding a total value of $1.000.000 do always get\nfast handling, even if it's just a single guy.</li>\n<li>Buy orders under a total value of $1.000 do always get slow\nhandling.</li>\n</ul>\n<p>With traditional nested <code>if</code> syntax, this would already become a bit\nmessy. Not so with <code>switch</code>. Swift includes guards for <code>switch cases</code>\nwhich allow you to further restrict the possible matching of those\ncases.</p>\n<p>You only need to modify your <code>switch</code> a little bit to accommodate for\nthose new changes</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">let</span> aTrade = <span class=\"type\">Trades</span>.<span class=\"call\">buy</span>(stock: \\<span class=\"string\">\"GOOG</span>\\<span class=\"string\">\"</span>, amount: <span class=\"number\">1000</span>, stockPrice: <span class=\"number\">666.0</span>, type: <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>)\n\n\n\n<span class=\"keyword\">switch</span> aTrade {\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, price, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>)\n\n     <span class=\"keyword\">where</span> price*<span class=\"type\">Float</span>(amount) &gt; <span class=\"number\">1000000</span>:\n\n     <span class=\"call\">processFast</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">singleGuy</span>):\n\n     <span class=\"call\">processSlow</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">5.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, price, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>)\n\n     <span class=\"keyword\">where</span> price*<span class=\"type\">Float</span>(amount) &lt; <span class=\"number\">1000</span>:\n\n     <span class=\"call\">processSlow</span>(stock, amount, <span class=\"number\">2.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">buy</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, amount, <span class=\"number\">2.0</span>)\n\n<span class=\"keyword\">case let</span> .<span class=\"call\">sell</span>(stock, amount, <span class=\"keyword\">_</span>, <span class=\"type\">TraderType</span>.<span class=\"property\">company</span>):\n\n     <span class=\"call\">processFast</span>(stock, -<span class=\"number\">1</span> * amount, <span class=\"number\">2.0</span>)\n\n}\n</code></pre></code></pre>\n<p>This code is quite structured, still rather easy to read, and wraps up\nthe complex cases quite well.</p>\n<p>That's it, we've successfully implemented our trading engine. However,\nthis solution still has a bit of repetition; we wonder if there're\npattern matching ways to improve upon that. So, let's look into pattern\nmatching a bit more.</p>\n","raw_content":"[frontMatter]\ntitle = \"A Trading Engine\"\ntags = [\"pattern matching\", \"switch\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# A Trading Engine\n\nSo a Wall Street company contacts you, they need a new trading platform running\non iOS devices. As it is a trading platform, you define an `enum` for\ntrades.\n\n## First Draft\n\n``` Swift\nenum Trades {\n    case buy(stock: String, amount: Int, stockPrice: Float)\n    case sell(stock: String, amount: Int, stockPrice: Float)\n}\n```\n\nYou were also handed the following API to handle trades. **Notice how\nsell orders are just negative amounts**. \n\n``` Swift\n/**\n - parameter stock: The stock name\n - parameter amount: The amount, negative number = sell, positive = buy\n*/\nfunc process(stock: String, _ amount: Int) {\n    print (\"\\(amount) of \\(stock)\")\n}\n```\n\nThe next step is to process those trades. You see the potential for\nusing pattern matching and write this:\n\n``` Swift\nlet aTrade = Trades.buy(stock: \"APPL\", amount: 200, stockPrice: 115.5)\n\nswitch aTrade {\ncase .buy(let stock, let amount, _):\n    process(stock, amount)\ncase .sell(let stock, let amount, _):\n    process(stock, amount * -1)\n}\n// Prints \"buy 200 of APPL\"\n```\n\nSwift lets us conveniently only destructure / extract the information\nfrom the `enum` that we really want. In this case only the stock and the\namount.\n\nAwesome, you visit Wall Street to show of your fantastic trading\nplatform. However, as always, the reality is much more cumbersome than\nthe beautiful theory. Trades aren\\'t trades you learn.\n\n-   You have to calculate in a fee which is different based on the\n    trader type.\n-   The smaller the institution the higher the fee.\n-   Also, bigger institutions get a higher priority.\n\nThey also realized that you\\'ll need a new API for this, so you were\nhanded this:\n\n``` Swift\nfunc processSlow(stock: String, _ amount: Int, _ fee: Float) { print(\"slow\") }\nfunc processFast(stock: String, _ amount: Int, _ fee: Float) { print(\"fast\") }\n```\n\n## Trader Types\n\nSo you go back to the drawing board and add another `enum`. The trader\ntype is part of every trade, too.\n\n``` Swift\nenum TraderType {\ncase singleGuy\ncase company\n} \n\nenum Trades {\n    case buy(stock: String, amount: Int, stockPrice: Float, type: TraderType)\n    case sell(stock: String, amount: Int, stockPrice: Float, type: TraderType)\n}\n\n```\n\nSo, how do you best implement this new restriction? You could just have\nan `if` / `else` switch for buy and for sell, but that would lead to\nnested code which quickly lacks clarity - and who knows maybe these Wall\nStreet guys come up with further complications. So you define it instead\nas additional requirements on the pattern matches:\n\n``` Swift\n\nlet aTrade = Trades.sell(stock: \"GOOG\", amount: 100, stockPrice: 666.0, type: TraderType.company)\n\nswitch aTrade {\ncase let .buy(stock, amount, _, TraderType.singleGuy):\n    processSlow(stock, amount, 5.0)\ncase let .sell(stock, amount, _, TraderType.singleGuy):\n    processSlow(stock, -1 * amount, 5.0)\ncase let .buy(stock, amount, _, TraderType.company):\n    processFast(stock, amount, 2.0)\ncase let .sell(stock, amount, _, TraderType.company):\n    processFast(stock, -1 * amount, 2.0)\n}\n```\n\nThe beauty of this is that there\\'s a very succinct flow describing the\ndifferent possible combinations. Also, note how we changed\n`.buy(let stock, let amount)` into `let .buy(stock, amount)` in order to\nkeep things simpler. This will destructure the `enum` just as before,\nonly with less syntax.\n\n## Guards! Guards!\n\nOnce again you present your development to your Wall Street customer,\nand once again a new issue pops up (you really should have asked for a\nmore detailed project description).\n\n-   Sell orders exceeding a total value of \\$1.000.000 do always get\n    fast handling, even if it\\'s just a single guy.\n-   Buy orders under a total value of \\$1.000 do always get slow\n    handling.\n\nWith traditional nested `if` syntax, this would already become a bit\nmessy. Not so with `switch`. Swift includes guards for `switch cases`\nwhich allow you to further restrict the possible matching of those\ncases.\n\nYou only need to modify your `switch` a little bit to accommodate for\nthose new changes\n\n``` Swift\n\nlet aTrade = Trades.buy(stock: \"GOOG\", amount: 1000, stockPrice: 666.0, type: TraderType.singleGuy)\n\nswitch aTrade {\ncase let .buy(stock, amount, _, TraderType.singleGuy):\n    processSlow(stock, amount, 5.0)\ncase let .sell(stock, amount, price, TraderType.singleGuy)\n    where price*Float(amount) > 1000000:\n    processFast(stock, -1 * amount, 5.0)\ncase let .sell(stock, amount, _, TraderType.singleGuy):\n    processSlow(stock, -1 * amount, 5.0)\ncase let .buy(stock, amount, price, TraderType.company)\n    where price*Float(amount) < 1000:\n    processSlow(stock, amount, 2.0)\ncase let .buy(stock, amount, _, TraderType.company):\n    processFast(stock, amount, 2.0)\ncase let .sell(stock, amount, _, TraderType.company):\n    processFast(stock, -1 * amount, 2.0)\n}\n```\n\nThis code is quite structured, still rather easy to read, and wraps up\nthe complex cases quite well.\n\nThat\\'s it, we\\'ve successfully implemented our trading engine. However,\nthis solution still has a bit of repetition; we wonder if there\\'re\npattern matching ways to improve upon that. So, let\\'s look into pattern\nmatching a bit more.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2017-10-08-taming-sourcekitd.md":["223d7254354b7fd8",{"identifier":"e773a5c5","filename":"2017-10-08-taming-sourcekitd.md","info":{"title":"Taming SourceKitService for Less Xcode Memory Consumption","tags":[],"keywords":["xcode","sourcekit","swift","SourceKitService"],"category":["Swift Tricks","All"],"created":"2017-10-08 10:30:30","description":"Taming SourceKitService for less Xcode memory consumption","description_html":"<p>Taming SourceKitService for less Xcode memory consumption</p>\n","published":true,"slug":"2017-10-08-taming-sourcekitd.html","meta":{"swift_version":"4.0"},"created_timestamp":1507458630,"date":"2017-10-08T10:30:30","date_info":{"year":2017,"month":10,"day":8,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2017-10-08-taming-sourcekitd.html","content":"<h1>Update [10/15/2017]</h1>\n<p><a href=\"<https://t.co/aJc8ZZSm9c>\">It seems that Xcode 9.1 beta 2\nfixes this issue.</a></p>\n<p>In my preliminary testing, everything worked fine. This feels really\ngood.</p>\n<h1>Original Article</h1>\n<p>There were recently two popular Swift posts on Hacker News<sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup> <sup class=\"footnote-reference\"><a href=\"#2\">2</a></sup>, and\none issue I saw coming up multiple times was the memory consumption of\nthe tooling nee Xcode. One particular problem is that for some codebases\nthe Swift sourcecode process <code>SourceKitService</code> consumes a huge amount\nof memory. I've had it rise to 30GB and beyond - at which point my\nsystem usually stalls and I'm not able to continue working for a couple\nof minutes.</p>\n<p>Oftentimes memory issues like these can be solved by reviewing your\nsourcecode with the same tools you also use to reduce your compile\ntimes. See:</p>\n<ul>\n<li><a href=\"https://www.jessesquires.com/blog/measuring-compile-times-xcode9/\">https://www.jessesquires.com/blog/measuring-compile-times-xcode9/</a></li>\n<li><a href=\"https://www.swiftbysundell.com/posts/improving-swift-compile-times\">https://www.swiftbysundell.com/posts/improving-swift-compile-times</a></li>\n</ul>\n<p>However, for some, complex, codebases this may not be enough. I've\nemployed an <strong>awful</strong> little hack in order to at least keep my machine\nfrom stalling. I wrote a small little bash script that check the memory\nconsumption of the <code>SourceKitService</code> every <code>n</code> seconds and if it goes\nbeyond <code>x</code> megabytes of memory (by default <strong>5.000</strong>) I restart it. I\nfeel that this may be useful to some others so I'm sharing it here for\nposterity. Note that this is an awful hack and future versions of\n<code>SourceKitService</code> will probably (hopefully!) not need this anymore.\nMeanwhile, this might be of help to others:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoucomment techouline techounumber-sign techoushell\"><span class=\"techoupunctuation techoudefinition techoucomment techoubegin techoushell\">#</span></span><span class=\"techoucomment techouline techounumber-sign techoushell\">!/bin/bash</span><span class=\"techoucomment techouline techounumber-sign techoushell\">\n</span>\n<span class=\"techoucomment techouline techounumber-sign techoushell\"><span class=\"techoupunctuation techoudefinition techoucomment techoubegin techoushell\">#</span></span><span class=\"techoucomment techouline techounumber-sign techoushell\"> Amount of seconds to wait between measures</span><span class=\"techoucomment techouline techounumber-sign techoushell\">\n</span><span class=\"techouvariable techouother techoureadwrite techouassignment techoushell\">n</span><span class=\"techoukeyword techouoperator techouassignment techoushell\">=</span><span class=\"techoustring techouunquoted techoushell\">1</span>\n<span class=\"techoucomment techouline techounumber-sign techoushell\"><span class=\"techoupunctuation techoudefinition techoucomment techoubegin techoushell\">#</span></span><span class=\"techoucomment techouline techounumber-sign techoushell\"> Limit memory consumption to this many megabytes before killing the process</span><span class=\"techoucomment techouline techounumber-sign techoushell\">\n</span><span class=\"techouvariable techouother techoureadwrite techouassignment techoushell\">x</span><span class=\"techoukeyword techouoperator techouassignment techoushell\">=</span><span class=\"techoustring techouunquoted techoushell\">5000</span>\n\n<span class=\"techouvariable techouother techoureadwrite techouassignment techoushell\">name</span><span class=\"techoukeyword techouoperator techouassignment techoushell\">=</span><span class=\"techoustring techouunquoted techoushell\"><span class=\"techoustring techouquoted techoudouble techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&quot;</span>SourceKitService<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&quot;</span></span></span>\n<span class=\"techoukeyword techoucontrol techouwhile techoushell\">while</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">true</span></span><span class=\"techoukeyword techouoperator techoulogical techoucontinue techoushell\">;</span> <span class=\"techoukeyword techoucontrol techoudo techoushell\">do</span> \n  <span class=\"techouvariable techouother techoureadwrite techouassignment techoushell\">fields</span><span class=\"techoukeyword techouoperator techouassignment techoushell\">=</span><span class=\"techoustring techouunquoted techoushell\"><span class=\"techoumeta techougroup techouexpansion techoucommand techoubackticks techoushell\"><span class=\"techoupunctuation techousection techougroup techoubegin techoushell\">`</span><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">ps</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> aux<span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>m</span></span> <span class=\"techoukeyword techouoperator techoulogical techoupipe techoushell\">|</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">grep</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>v</span> grep</span> <span class=\"techoukeyword techouoperator techoulogical techoupipe techoushell\">|</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">grep</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>i</span> <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">name</span></span></span> <span class=\"techoukeyword techouoperator techoulogical techoupipe techoushell\">|</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">tr</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>s</span> <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span> <span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span></span><span class=\"techoupunctuation techousection techougroup techouend techoushell\">`</span></span></span>\n  <span class=\"techouvariable techouother techoureadwrite techouassignment techoushell\">mem</span><span class=\"techoukeyword techouoperator techouassignment techoushell\">=</span><span class=\"techoustring techouunquoted techoushell\"><span class=\"techoumeta techougroup techouexpansion techoucommand techoubackticks techoushell\"><span class=\"techoupunctuation techousection techougroup techoubegin techoushell\">`</span><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techousupport techoufunction techouecho techoushell\">echo</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">fields</span></span></span> <span class=\"techoukeyword techouoperator techoulogical techoupipe techoushell\">|</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">cut</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>d</span> <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span> <span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>s</span><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>f</span> 6</span><span class=\"techoukeyword techouoperator techoulogical techoupipe techoushell\">|</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">awk</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>{$1=$1/1024; print $1;}<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span></span> <span class=\"techoukeyword techouoperator techoulogical techoupipe techoushell\">|</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">cut</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>d</span> <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>.<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>f</span> 1</span><span class=\"techoupunctuation techousection techougroup techouend techoushell\">`</span></span></span>\n  <span class=\"techouvariable techouother techoureadwrite techouassignment techoushell\">pid</span><span class=\"techoukeyword techouoperator techouassignment techoushell\">=</span><span class=\"techoustring techouunquoted techoushell\"><span class=\"techoumeta techougroup techouexpansion techoucommand techoubackticks techoushell\"><span class=\"techoupunctuation techousection techougroup techoubegin techoushell\">`</span><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techousupport techoufunction techouecho techoushell\">echo</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">fields</span></span></span> <span class=\"techoukeyword techouoperator techoulogical techoupipe techoushell\">|</span> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">cut</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>d</span> <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span> <span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>s</span><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>f</span> 2</span><span class=\"techoupunctuation techousection techougroup techouend techoushell\">`</span></span></span>\n  <span class=\"techoukeyword techoucontrol techouif techoubegin techoushell\">if</span> <span class=\"techousupport techoufunction techoutest techoubegin techoushell\">[</span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\">-</span>z</span> <span class=\"techoustring techouquoted techoudouble techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&quot;</span><span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">mem</span></span><span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&quot;</span></span> <span class=\"techousupport techoufunction techoutest techouend techoushell\">]</span></span><span class=\"techoukeyword techouoperator techoulogical techoucontinue techoushell\">;</span> <span class=\"techoukeyword techoucontrol techouif techouthen techoushell\">then</span>\n      <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techousupport techoufunction techouecho techoushell\">echo</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoustring techouquoted techoudouble techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&quot;</span><span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">name</span></span> not running<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&quot;</span></span></span>\n      <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">sleep</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> 15</span>\n      <span class=\"techoukeyword techoucontrol techoucontinue techoushell\">continue</span>\n  <span class=\"techoukeyword techoucontrol techouif techouend techoushell\">fi</span>\n  <span class=\"techoukeyword techoucontrol techouif techoubegin techoushell\">if</span> <span class=\"techousupport techoufunction techoutest techoubegin techoushell\">[</span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoustring techouquoted techoudouble techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&quot;</span><span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">mem</span></span><span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&quot;</span></span> <span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\">-</span>gt</span> <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">x</span></span> <span class=\"techousupport techoufunction techoutest techouend techoushell\">]</span></span><span class=\"techoukeyword techouoperator techoulogical techoucontinue techoushell\">;</span> <span class=\"techoukeyword techoucontrol techouif techouthen techoushell\">then</span>\n      <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techousupport techoufunction techouecho techoushell\">echo</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoustring techouquoted techoudouble techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&quot;</span>Killing <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">name</span></span> pid <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">pid</span></span> with mem <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">mem</span></span><span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&quot;</span></span></span>\n      <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techousupport techoufunction techoukill techoushell\">kill</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> -9 <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">pid</span></span></span>\n      <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">sleep</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> 5</span>\n  <span class=\"techoukeyword techoucontrol techouif techouend techoushell\">fi</span>\n  <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">sleep</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> <span class=\"techoumeta techougroup techouexpansion techouparameter techoushell\"><span class=\"techoupunctuation techoudefinition techouvariable techoushell\">$</span><span class=\"techouvariable techouother techoureadwrite techoushell\">n</span></span></span>\n<span class=\"techoukeyword techoucontrol techoudone techoushell\">done</span>\n</span></code></pre></code></pre>\n<p>To use this just paste that code into a file (say <code>sourcekill.sh</code>) and\ndo:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">chmod</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> +x ./sourcekill.sh</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">./sourcekill.sh</span></span>\n</span></code></pre></code></pre>\n<p>If you want to kill it, just hit <code>CTRL=C</code>.</p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>Why many developers still prefer Objective-C\n<a href=\"https://news.ycombinator.com/item?id=15421073\">https://news.ycombinator.com/item?id=15421073</a></p>\n</div>\n<div class=\"footnote-definition\" id=\"2\"><sup class=\"footnote-definition-label\">2</sup>\n<p>Dictionary and Set Improvements in Swift 4.0\n<a href=\"https://news.ycombinator.com/item?id=15403882\">https://news.ycombinator.com/item?id=15403882</a></p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"Taming SourceKitService for less Xcode memory consumption\"\ntitle = \"Taming SourceKitService for Less Xcode Memory Consumption\"\ncreated = \"2017-10-08\"\npublished = true\nkeywords = [\"xcode\", \"sourcekit\", \"swift\", \"SourceKitService\"]\nslug = \"2017-10-08-taming-sourcekitd.html\"\ntags = []\ncategory = [\"Swift Tricks\", \"All\"]\n\n[meta]\nswift_version = \"4.0\"\n---\n\n# Update \\[10/15/2017\\]\n\n<a href=\"<https://t.co/aJc8ZZSm9c>\">It seems that Xcode 9.1 beta 2\nfixes this issue.</a>\n\nIn my preliminary testing, everything worked fine. This feels really\ngood.\n\n# Original Article\n\nThere were recently two popular Swift posts on Hacker News[^1] [^2], and\none issue I saw coming up multiple times was the memory consumption of\nthe tooling nee Xcode. One particular problem is that for some codebases\nthe Swift sourcecode process `SourceKitService` consumes a huge amount\nof memory. I\\'ve had it rise to 30GB and beyond - at which point my\nsystem usually stalls and I\\'m not able to continue working for a couple\nof minutes.\n\nOftentimes memory issues like these can be solved by reviewing your\nsourcecode with the same tools you also use to reduce your compile\ntimes. See:\n\n-   <https://www.jessesquires.com/blog/measuring-compile-times-xcode9/>\n-   <https://www.swiftbysundell.com/posts/improving-swift-compile-times>\n\nHowever, for some, complex, codebases this may not be enough. I\\'ve\nemployed an **awful** little hack in order to at least keep my machine\nfrom stalling. I wrote a small little bash script that check the memory\nconsumption of the `SourceKitService` every `n` seconds and if it goes\nbeyond `x` megabytes of memory (by default **5.000**) I restart it. I\nfeel that this may be useful to some others so I\\'m sharing it here for\nposterity. Note that this is an awful hack and future versions of\n`SourceKitService` will probably (hopefully!) not need this anymore.\nMeanwhile, this might be of help to others:\n\n``` bash\n#!/bin/bash\n\n# Amount of seconds to wait between measures\nn=1\n# Limit memory consumption to this many megabytes before killing the process\nx=5000\n\nname=\"SourceKitService\"\nwhile true; do \n  fields=`ps aux -m | grep -v grep | grep -i $name | tr -s ' '`\n  mem=`echo $fields | cut -d ' ' -s -f 6| awk '{$1=$1/1024; print $1;}' | cut -d '.' -f 1`\n  pid=`echo $fields | cut -d ' ' -s -f 2`\n  if [ -z \"$mem\" ]; then\n      echo \"$name not running\"\n      sleep 15\n      continue\n  fi\n  if [ \"$mem\" -gt $x ]; then\n      echo \"Killing $name pid $pid with mem $mem\"\n      kill -9 $pid\n      sleep 5\n  fi\n  sleep $n\ndone\n```\n\nTo use this just paste that code into a file (say `sourcekill.sh`) and\ndo:\n\n``` bash\nchmod +x ./sourcekill.sh\n./sourcekill.sh\n```\n\nIf you want to kill it, just hit `CTRL=C`.\n\n[^1]: Why many developers still prefer Objective-C\n    <https://news.ycombinator.com/item?id=15421073>\n\n[^2]: Dictionary and Set Improvements in Swift 4.0\n    <https://news.ycombinator.com/item?id=15403882>\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/introduction.md":["2dd5cd974cdb8dd1",{"identifier":"f90b081e","filename":"introduction.md","info":{"title":"Introduction","tags":["tuples"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-introduction.html","content":"<h1>Introduction</h1>\n<p>Tuples are one of Swift's less visible language features. They occupy a\nsmall space between Structs and Arrays. In addition, there's no\ncomparable construct in Objective-C (or many other languages). Finally,\nthe usage of tuples in the standard library and in Apple's example code\nis sparse. One could get the impression that their raison d'être in\nSwift is pattern matching, but we disgress.</p>\n<p>Most tuple explanations concentrate on three tuple use cases (pattern\nmatching, return values, destructuring) and leave it at that. The\nfollowing guide tries to give a more comprehensive overview of tuples\nwith best practices of when to use them and when not to use them.</p>\n","raw_content":"[frontMatter]\ntitle = \"Introduction\"\ntags = [\"tuples\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Introduction\n\nTuples are one of Swift\\'s less visible language features. They occupy a\nsmall space between Structs and Arrays. In addition, there\\'s no\ncomparable construct in Objective-C (or many other languages). Finally,\nthe usage of tuples in the standard library and in Apple\\'s example code\nis sparse. One could get the impression that their raison d\\'être in\nSwift is pattern matching, but we disgress.\n\nMost tuple explanations concentrate on three tuple use cases (pattern\nmatching, return values, destructuring) and leave it at that. The\nfollowing guide tries to give a more comprehensive overview of tuples\nwith best practices of when to use them and when not to use them. \n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/app_lifecycle.md":["2eed7e34c1dba640",{"identifier":"fdda37b7","filename":"app_lifecycle.md","info":{"title":"How does the iOS app lifecycle work on macOS?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-does-the-ios-app-lifecycle-work-on-macos.html","content":"<p>The <a href=\"https://developer.apple.com/videos/play/wwdc2019/235/\">&quot;Taking iPad apps for Mac to the Next Level&quot; talk at WWDC 2019</a> has a fantastic overview of all the changes. Here is a brief overview:</p>\n<ul>\n<li>The <code>UIApplication</code> lifecycle is fully supported on macOS</li>\n<li>The sequence is the same as on macOS</li>\n<li>State changes, however, do affect the Mac less, as are almost always <em>Foreground</em> + <em>Active</em> on macOS.</li>\n<li>Apps only enter background during termination and inactive when launching in the background.</li>\n<li>Your app should still take <a href=\"https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/AppNap.html\">App Napp</a> into account</li>\n<li>Background modes are allowed to finish when an app closes. The background tasks continue even though the app is already not visible anymore to the user</li>\n<li>Apps are not killed when they consume too much memory</li>\n<li>Background audio is not supported because users expect audio to stop when they quit an app</li>\n</ul>\n<p>So, in short, your app is always in <code>Foreground + Active</code> except when it is (mostly) launching or terminating.</p>\n","raw_content":"[frontMatter]\ntitle = \"How does the iOS app lifecycle work on macOS?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nThe [\"Taking iPad apps for Mac to the Next Level\" talk at WWDC 2019](https://developer.apple.com/videos/play/wwdc2019/235/) has a fantastic overview of all the changes. Here is a brief overview:\n\n- The `UIApplication` lifecycle is fully supported on macOS\n- The sequence is the same as on macOS\n- State changes, however, do affect the Mac less, as are almost always *Foreground* + *Active* on macOS.\n- Apps only enter background during termination and inactive when launching in the background.\n- Your app should still take [App Napp](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/AppNap.html) into account\n- Background modes are allowed to finish when an app closes. The background tasks continue even though the app is already not visible anymore to the user\n- Apps are not killed when they consume too much memory\n- Background audio is not supported because users expect audio to stop when they quit an app\n\nSo, in short, your app is always in `Foreground + Active` except when it is (mostly) launching or terminating.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/bridgingheader.md":["6d453ed81b89e0b6",{"identifier":"d1a6e127","filename":"bridgingheader.md","info":{"title":"How do I use the touchbar or toolbar classes?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-use-the-touchbar-or-toolbar-classes.html","content":"<p>There is one issue on beta 2 which means that you need to add a <em>bridging header</em> to your project and import a header file in there if you want to use the <code>NSTouchbar</code> or <code>NSToolbar</code> APIs.</p>\n<ol>\n<li>Add a new bridging header to your project, say <code>bridge-me.h</code> (If you don't have a bridging header yet)</li>\n<li>In your target Build Settings set the <code>Objective-C Bridging Header</code> value to your new bridging header (&quot;MyApp/bridge-me.h&quot;)</li>\n</ol>\n<p>Make sure to have the right path for the bridging header.</p>\n<h2>Then, insert the following code in your bridging header:</h2>\n<pre class=\"C\"><code><span class=\"techousource techouc\"><span class=\"techoumeta techoupreprocessor techouinclude techouc\"><span class=\"techoukeyword techoucontrol techouimport techouinclude techouc\">#import</span> <span class=\"techoustring techouquoted techouother techoult-gt techouinclude techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&lt;</span>Foundation/Foundation.h<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&gt;</span></span>\n</span><span class=\"techoumeta techoupreprocessor techouinclude techouc\"><span class=\"techoukeyword techoucontrol techouimport techouinclude techouc\">#import</span> <span class=\"techoustring techouquoted techouother techoult-gt techouinclude techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&lt;</span>UIKit/NSToolbar+UIKitAdditions.h<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&gt;</span></span>\n</span><span class=\"techoumeta techoupreprocessor techouinclude techouc\"><span class=\"techoukeyword techoucontrol techouimport techouinclude techouc\">#import</span> <span class=\"techoustring techouquoted techouother techoult-gt techouinclude techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&lt;</span>UIKit/NSTouchbar+UIKitAdditions.h<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&gt;</span></span>\n</span></span></code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I use the touchbar or toolbar classes?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nThere is one issue on beta 2 which means that you need to add a *bridging header* to your project and import a header file in there if you want to use the `NSTouchbar` or `NSToolbar` APIs.\n\n1. Add a new bridging header to your project, say `bridge-me.h` (If you don't have a bridging header yet)\n2. In your target Build Settings set the `Objective-C Bridging Header` value to your new bridging header (\"MyApp/bridge-me.h\")\n\nMake sure to have the right path for the bridging header.\n\n## Then, insert the following code in your bridging header:\n\n``` C\n#import <Foundation/Foundation.h>\n#import <UIKit/NSToolbar+UIKitAdditions.h>\n#import <UIKit/NSTouchbar+UIKitAdditions.h>\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/working_around_associated_type_issues/hiding_behind_protocols.md":["b733b988dee50d0c",{"identifier":"60a66876","filename":"hiding_behind_protocols.md","info":{"title":"Hiding Behind Protocols","tags":["box","associated","protocol"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-hiding-behind-protocols.html","content":"<h1>Hiding Behind Protocols</h1>\n<p>This is an especially useful and flexible pattern. It can be used in\nmany situations where you want to use protocols with <code>associated types</code>\nlike a normal, full fledged type, but still be able to opt in to the\ngeneric part if necessary. The idea here is that you define two\nprotocols that share common methods. Only one of those protocols\ncontains <code>associated types</code>, the other does not. Your types conform to\nboth protocols. This means that you can use the <strong>normal</strong> protocol as a\ntype for all situations. If you, then, need to use the parts of the type\nthat only affect the <code>associated type</code>, you can do so by means of a\nruntime cast.</p>\n<p>Begin by defining an <code>associated</code> Protocol <code>ExampleAssociatedProtocol</code>\nthat is shadowed by a <code>normal</code> Protocol <code>ExampleProtocol</code>.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// The `Normal` Protocol</span>\n\n<span class=\"keyword\">protocol</span> ExampleProtocol {\n\n   <span class=\"keyword\">var</span> anyValue: <span class=\"type\">Any</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"comment\">/// The Protocol with an associated type</span>\n\n<span class=\"keyword\">protocol</span> ExampleAssociatedProtocol: <span class=\"type\">ExampleProtocol</span> {\n\n   <span class=\"keyword\">associatedtype</span> Value\n\n\n\n   <span class=\"comment\">/// Retrieving the actual associated type</span>\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">Value</span> { <span class=\"keyword\">get</span> }\n\n}\n\n\n\n<span class=\"comment\">/// Conform to the `ExampleProtocol`</span>\n\n<span class=\"keyword\">extension</span> <span class=\"type\">ExampleAssociatedProtocol</span> {\n\n   <span class=\"keyword\">var</span> anyValue: <span class=\"type\">Any</span> {\n\n     <span class=\"keyword\">return</span> value\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Now, you can use the <code>ExampleProtocol</code> as a normal type throughout your\napp in all situations where a protocol with an <code>associated type</code> would\notherwise fail:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> World {\n\n   <span class=\"keyword\">var</span> examples: [<span class=\"type\">ExampleProtocol</span>]\n\n\n\n   <span class=\"keyword\">let</span> example: <span class=\"type\">ExampleProtocol</span>\n\n\n\n   <span class=\"keyword\">func</span> generate() -&gt; <span class=\"type\">ExampleProtocol</span> { \n\n     <span class=\"keyword\">return</span> example\n\n   }\n\n}\n</code></pre></code></pre>\n<p>However, if you need to access the property that is specific to the\n<code>ExampleAssociatedProtocol</code> (<code>value</code>) then you can do so through at\nruntime.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Custom type implementing `ExampleAssociatedProtocol`</span>\n\n<span class=\"keyword\">struct</span> IntExample: <span class=\"type\">ExampleAssociatedProtocol</span> {\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span>\n\n}\n\n\n\n<span class=\"comment\">/// Custom type implementing `ExampleAssociatedProtocol`</span>\n\n<span class=\"keyword\">struct</span> StringExample: <span class=\"type\">ExampleAssociatedProtocol</span> {\n\n   <span class=\"keyword\">var</span> value: <span class=\"type\">String</span>\n\n}\n\n\n\n<span class=\"comment\">/// Shadowing via `ExampleProtocol`</span>\n\n<span class=\"keyword\">let</span> myExamples: [<span class=\"type\">ExampleProtocol</span>] = \n\n     [<span class=\"type\">StringExample</span>(value: \\<span class=\"string\">\"A</span>\\<span class=\"string\">\"</span>), <span class=\"type\">IntExample</span>(value: <span class=\"number\">10</span>)]\n\n\n\n<span class=\"comment\">/// Runtime Casting</span>\n\n<span class=\"keyword\">for</span> aNormalExample <span class=\"keyword\">in</span> myExamples {\n\n   <span class=\"keyword\">if let</span> anAssociatedExample = aNormalExample <span class=\"keyword\">as</span>? <span class=\"type\">IntExample</span> {\n\n     <span class=\"call\">print</span>(anAssociatedExample.<span class=\"property\">value</span>)\n\n   }\n\n   <span class=\"keyword\">if let</span> anAssociatedExample = aNormalExample <span class=\"keyword\">as</span>? <span class=\"type\">StringExample</span> {\n\n     <span class=\"call\">print</span>(anAssociatedExample.<span class=\"property\">value</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>This will print &quot;A10&quot; as both types (<code>IntExample</code> and <code>StringExample</code>)\nare being identified at runtime via a cast from <code>ExampleProtocol</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Hiding Behind Protocols\"\ntags = [\"box\", \"associated\", \"protocol\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Hiding Behind Protocols\n\nThis is an especially useful and flexible pattern. It can be used in\nmany situations where you want to use protocols with `associated types`\nlike a normal, full fledged type, but still be able to opt in to the\ngeneric part if necessary. The idea here is that you define two\nprotocols that share common methods. Only one of those protocols\ncontains `associated types`, the other does not. Your types conform to\nboth protocols. This means that you can use the **normal** protocol as a\ntype for all situations. If you, then, need to use the parts of the type\nthat only affect the `associated type`, you can do so by means of a\nruntime cast.\n\nBegin by defining an `associated` Protocol `ExampleAssociatedProtocol`\nthat is shadowed by a `normal` Protocol `ExampleProtocol`.\n\n``` Swift\n/// The `Normal` Protocol\nprotocol ExampleProtocol {\n  var anyValue: Any { get }\n}\n\n/// The Protocol with an associated type\nprotocol ExampleAssociatedProtocol: ExampleProtocol {\n  associatedtype Value\n\n  /// Retrieving the actual associated type\n  var value: Value { get }\n}\n\n/// Conform to the `ExampleProtocol`\nextension ExampleAssociatedProtocol {\n  var anyValue: Any {\n    return value\n  }\n}\n```\n\nNow, you can use the `ExampleProtocol` as a normal type throughout your\napp in all situations where a protocol with an `associated type` would\notherwise fail:\n\n``` Swift\nstruct World {\n  var examples: [ExampleProtocol]\n\n  let example: ExampleProtocol\n\n  func generate() -> ExampleProtocol { \n    return example\n  }\n}\n```\n\nHowever, if you need to access the property that is specific to the\n`ExampleAssociatedProtocol` (`value`) then you can do so through at\nruntime.\n\n``` Swift\n/// Custom type implementing `ExampleAssociatedProtocol`\nstruct IntExample: ExampleAssociatedProtocol {\n  var value: Int\n}\n\n/// Custom type implementing `ExampleAssociatedProtocol`\nstruct StringExample: ExampleAssociatedProtocol {\n  var value: String\n}\n\n/// Shadowing via `ExampleProtocol`\nlet myExamples: [ExampleProtocol] = \n    [StringExample(value: \"A\"), IntExample(value: 10)]\n\n/// Runtime Casting\nfor aNormalExample in myExamples {\n  if let anAssociatedExample = aNormalExample as? IntExample {\n    print(anAssociatedExample.value)\n  }\n  if let anAssociatedExample = aNormalExample as? StringExample {\n    print(anAssociatedExample.value)\n  }\n}\n```\n\nThis will print \\\"A10\\\" as both types (`IntExample` and `StringExample`)\nare being identified at runtime via a cast from `ExampleProtocol`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2020-06-17-a-touch-of-combine.md":["045e82a6f049c4c6",{"identifier":"92fe55fc","filename":"2020-06-17-a-touch-of-combine.md","info":{"title":"A touch of Combine","tags":[],"keywords":["swift","combine"],"category":[],"created":"2020-06-17 10:30:30","description":"A simple way of introducing Combine into your codebase","description_html":"<p>A simple way of introducing Combine into your codebase</p>\n","published":true,"slug":null,"meta":{"feature_image":"https://appventure.me/img-content/title_combine.jpg"},"created_timestamp":1592389830,"date":"2020-06-17T10:30:30","date_info":{"year":2020,"month":6,"day":17,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2020-6-17-a-touch-of-combine.html","content":"<p>Combine was released at WWDC 2019, therefore it only targets iOS 13 and up. There're even <a href=\"https://github.com/broadwaylamb/OpenCombine\">Open Source Combine solutions</a> that target earlier iOS versions. Combine is a very well-designed framework, but it solves problems in a very different way then you'd normally do on iOS (if you weren't using RxSwift already). Nevertheless, you might want to start using Combine from time to time, especially once you can drop iOS 12 support in your app.</p>\n<p>This article shows a way of using Combine in a very limited approach within your code, mostly to handle events within the scope of a single controller.\nYou can obviouly do much more with Combine, but oftentimes this requires bigger changes to more components than just one function within an existing controller.</p>\n<h2>Debounce and Throttle</h2>\n<p>One pattern that Combine solves in a nice way is controlling the flow of events. Say you have an app with a slider which the user can use to change a value that forces a redraw of your UI. If the user moves the slider very slowly, events are emitted at a very slow rate. If the user moves the slider really fast, though, events are emitted at a very fast rate. Now lets imagine that your redraw operation is very expensive (say you're rendering an image with a simple raytracer). In this case, having too many render operations at once will overload your CPU.</p>\n<p>Another, similar problem is if you download something from the network when the user taps a button. That's fine if the user taps the button once, but if the user taps it 50 times in 10 seconds, then you might be overloading something</p>\n<p>The usual solution for this problem is to have a cancellation token that remembers the last event:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private class</span> Cancellation {\n\n   <span class=\"keyword\">var</span> cancelled: <span class=\"type\">Bool</span> = <span class=\"keyword\">false</span>\n\n}\n\n\n\n<span class=\"keyword\">private var</span> lastCancellation: <span class=\"type\">Cancellation</span>?\n\n\n\n<span class=\"keyword\">func</span> event() {\n\n   lastCancellation?.<span class=\"property\">cancelled</span> = <span class=\"keyword\">true</span>\n\n   <span class=\"keyword\">let</span> newToken = <span class=\"type\">Cancellation</span>()\n\n   lastCancellation = newToken\n\n   downloader.<span class=\"call\">downloadOperation</span> { result <span class=\"keyword\">in</span> \n\n     <span class=\"keyword\">if</span> newToken.<span class=\"property\">cancelled</span> { <span class=\"keyword\">return</span> \n\n   }\n\n   ...\n\n}\n\n\n</code></pre></code></pre>\n<p>This works mostly fine. However, it hides a clear responsibility between multiple lines of code. Especially once this code is split up over multiple places in a large controller, the clear meaning becomes harder to understand. Also, it lacks a lot of control. Maybe you want every 10th event to go through, and more.</p>\n<h2>Enter Combine</h2>\n<p>Combine offers a nice way of controlling the event flow in this case via the <code>throttle</code> and <code>debounce</code> operators:</p>\n<h3>Throttle:</h3>\n<p><a href=\"https://developer.apple.com/documentation/combine/passthroughsubject/3204657-throttle\">The docs say:</a></p>\n<blockquote>\n<p>Publishes either the most-recent or first element published by the upstream publisher in the specified time interval.</p>\n</blockquote>\n<h3>Debounce:</h3>\n<p><a href=\"https://developer.apple.com/documentation/combine/anypublisher/3204205-debounce\">The docs say:</a></p>\n<blockquote>\n<p>Publishes elements only after a specified time interval elapses between events.</p>\n</blockquote>\n<h2>Using Throttle and Combine</h2>\n<p>There's an easy way of introducing throttle and combine into your view controller without exposing much of Combine to other parts of your code. What we're doing here is creating a Combine Subject and a Combine Cancellation token at the same time. We're also using a closure as the type of the Subject. By doing it this way, we can use it for any action which should be throttled. I'll first list the code and then explain it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> delayedDebounce: (\n\n    publisher: <span class=\"type\">PassthroughSubject</span>&lt;() -&gt; <span class=\"type\">Void</span>, <span class=\"type\">Never</span>&gt;,\n\n    cancellable: <span class=\"type\">AnyCancellable</span>?\n\n    ) = {\n\n        <span class=\"keyword\">let</span> publisher: <span class=\"type\">PassthroughSubject</span>&lt;() -&gt; <span class=\"type\">Void</span>, <span class=\"type\">Never</span>&gt; = <span class=\"type\">PassthroughSubject</span>()\n\n        <span class=\"keyword\">let</span> sink = publisher\n\n          .<span class=\"call\">debounce</span>(for: .<span class=\"call\">milliseconds</span>(<span class=\"number\">400</span>), scheduler: <span class=\"type\">RunLoop</span>.<span class=\"property\">main</span>)\n\n          .<span class=\"call\">sink</span> { action <span class=\"keyword\">in</span>\n\n              <span class=\"call\">action</span>()\n\n    }\n\n    <span class=\"keyword\">return</span> (publisher, sink)\n\n}()\n\n\n</code></pre></code></pre>\n<p>In the first line, we're creating a <code>Tuple</code> named <code>delayedDebounce. The tuple will only have two items, the</code>Subject<code>and the</code>AnyCancellable` cancellation token:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> delayedDebounce: (publisher: <span class=\"type\">PassthroughSubject</span>, cancellable: <span class=\"type\">AnyCancellable</span>?)\n</code></pre></code></pre>\n<p><code>PassthroughSubject</code> is a default Combine <code>Subject</code> which does not have a default value. Any value it receives will be forwarded through the Combine stream. A subject is a Combine <code>Publisher</code> that exposes a method for outside callers to publish elements.</p>\n<p>Next up, we're initializing the <code>Tuple</code> with a lazy evaluated closure:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> delayedDebounce: (publisher: <span class=\"type\">PassthroughSubject</span>, cancellable: <span class=\"type\">AnyCancellable</span>?) = { ... }()\n</code></pre></code></pre>\n<p>Within this closure, we're setting up the actual publisher. Lets inspect this code in detail:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> publisher: <span class=\"type\">PassthroughSubject</span>&lt;() -&gt; <span class=\"type\">Void</span>, <span class=\"type\">Never</span>&gt; = <span class=\"type\">PassthroughSubject</span>()\n\n<span class=\"keyword\">let</span> sink = publisher\n\n    .<span class=\"call\">debounce</span>(for: .<span class=\"call\">milliseconds</span>(<span class=\"number\">400</span>), scheduler: <span class=\"type\">RunLoop</span>.<span class=\"property\">main</span>)\n\n    .<span class=\"call\">sink</span> { action <span class=\"keyword\">in</span>\n\n      <span class=\"call\">action</span>()\n\n}\n</code></pre></code></pre>\n<p>Initially, we need to create our <code>PassthroughSubject</code> (which is a <code>Publisher</code>). It generic over two types, the <code>Output</code> it will <strong>pass through</strong> and the <code>Failure</code> that can happen. In our case, we don't expect any errors so the <code>Failure</code> type is <code>Never</code>. The <code>Output</code> we want to pass through is an action that will be executed: <code>() -&gt; Void</code>.</p>\n<p>Now that we have our publisher, we can use it to <a href=\"https://developer.apple.com/documentation/combine/publisher\">perform any of the methods that are exposed on the <code>Publisher</code> protocol</a>. In our case, <code>debounce</code> or  <code>throttle</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> sink = publisher.<span class=\"call\">debounce</span>(for: .<span class=\"call\">milliseconds</span>(<span class=\"number\">400</span>), scheduler: <span class=\"type\">RunLoop</span>.<span class=\"property\">main</span>)\n</code></pre></code></pre>\n<p>In the example above, we tell it to wait 400 milliseconds between events before a event is passed through. So the final thing we need is to execute the action that was delayed and debounced by 400 milliseconds. That's what the <code>sink</code> is for:</p>\n<pre class=\"Swift\"><code>.<span class=\"call\">sink</span> { action <span class=\"keyword\">in</span>\n\n      <span class=\"call\">action</span>()\n\n}\n</code></pre></code></pre>\n<p>With this setup, we can execute actions and rest assured that there's a 400ms interval between events. We use the <code>send</code> method of the <code>Subject</code> to achive this:</p>\n<pre class=\"Swift\"><code>delayedDebounce.<span class=\"property\">publisher</span>.<span class=\"call\">send</span> { \n\n   view.<span class=\"call\">layoutIfNeeded</span>()\n\n}\n\n\n</code></pre></code></pre>\n<h1>Abstractions</h1>\n<p>This code already works. However, if you use it a lot, you might want to abstract it into a simple <code>struct</code> that simplifies the setup even more:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Debouncer {\n\n   <span class=\"keyword\">private var</span> delayedDebounce: (\n\n      publisher: <span class=\"type\">PassthroughSubject</span>&lt;() -&gt; <span class=\"type\">Void</span>, <span class=\"type\">Never</span>&gt;,\n\n      cancellable: <span class=\"type\">AnyCancellable</span>?\n\n      ) = {\n\n          <span class=\"keyword\">let</span> publisher: <span class=\"type\">PassthroughSubject</span>&lt;() -&gt; <span class=\"type\">Void</span>, <span class=\"type\">Never</span>&gt; = <span class=\"type\">PassthroughSubject</span>()\n\n          <span class=\"keyword\">let</span> sink = publisher\n\n            .<span class=\"call\">debounce</span>(for: .<span class=\"call\">milliseconds</span>(<span class=\"number\">400</span>), scheduler: <span class=\"type\">RunLoop</span>.<span class=\"property\">main</span>)\n\n            .<span class=\"call\">sink</span> { action <span class=\"keyword\">in</span>\n\n                <span class=\"call\">action</span>()\n\n      }\n\n      <span class=\"keyword\">return</span> (publisher, sink)\n\n   }()\n\n\n\n   <span class=\"keyword\">func</span> execute(<span class=\"keyword\">_</span> action: () -&gt; <span class=\"type\">Void</span>) {\n\n     delayedDebounce.<span class=\"property\">publisher</span>.<span class=\"call\">send</span>(action)\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Doing it this way has the downside that you can't configure the Combine stream any more. For example, with the initial implementation, you could also do this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> delayedDebounce: (\n\n    publisher: <span class=\"type\">PassthroughSubject</span>&lt;() -&gt; <span class=\"type\">Void</span>, <span class=\"type\">Never</span>&gt;,\n\n    cancellable: <span class=\"type\">AnyCancellable</span>?\n\n    ) = {\n\n        <span class=\"keyword\">let</span> publisher: <span class=\"type\">PassthroughSubject</span>&lt;() -&gt; <span class=\"type\">Void</span>, <span class=\"type\">Never</span>&gt; = <span class=\"type\">PassthroughSubject</span>()\n\n        <span class=\"keyword\">let</span> sink = publisher\n\n          .<span class=\"call\">debounce</span>(for: .<span class=\"call\">milliseconds</span>(<span class=\"number\">400</span>), scheduler: <span class=\"type\">RunLoop</span>.<span class=\"property\">main</span>)\n\n          .<span class=\"call\">throttle</span>(for: .<span class=\"call\">milliseconds</span>(<span class=\"number\">20</span>), scheduler: <span class=\"type\">RunLoop</span>.<span class=\"property\">main</span>, latest: <span class=\"keyword\">true</span>)\n\n          .<span class=\"call\">delay</span>(for: <span class=\"number\">2</span>, scheduler: <span class=\"type\">RunLoop</span>.<span class=\"property\">main</span>)\n\n          .<span class=\"call\">sink</span> { action <span class=\"keyword\">in</span>\n\n              <span class=\"call\">action</span>()\n\n    }\n\n    <span class=\"keyword\">return</span> (publisher, sink)\n\n}()\n</code></pre></code></pre>\n<p>Here, we're first debouncing, then throttling, and finally delaying for 2 seconds. This is only for illustrative purposes.</p>\n","raw_content":"[frontMatter]\ndescription = \"A simple way of introducing Combine into your codebase\"\ntitle = \"A touch of Combine\"\ncreated = \"2020-06-17\"\npublished = true\nkeywords = [\"swift\", \"combine\"]\ntags = []\n\n[meta]\nfeature_image = \"https://appventure.me/img-content/title_combine.jpg\"\n---\n\nCombine was released at WWDC 2019, therefore it only targets iOS 13 and up. There're even [Open Source Combine solutions](https://github.com/broadwaylamb/OpenCombine) that target earlier iOS versions. Combine is a very well-designed framework, but it solves problems in a very different way then you'd normally do on iOS (if you weren't using RxSwift already). Nevertheless, you might want to start using Combine from time to time, especially once you can drop iOS 12 support in your app.\n\nThis article shows a way of using Combine in a very limited approach within your code, mostly to handle events within the scope of a single controller. \nYou can obviouly do much more with Combine, but oftentimes this requires bigger changes to more components than just one function within an existing controller.\n\n## Debounce and Throttle\n\nOne pattern that Combine solves in a nice way is controlling the flow of events. Say you have an app with a slider which the user can use to change a value that forces a redraw of your UI. If the user moves the slider very slowly, events are emitted at a very slow rate. If the user moves the slider really fast, though, events are emitted at a very fast rate. Now lets imagine that your redraw operation is very expensive (say you're rendering an image with a simple raytracer). In this case, having too many render operations at once will overload your CPU. \n\nAnother, similar problem is if you download something from the network when the user taps a button. That's fine if the user taps the button once, but if the user taps it 50 times in 10 seconds, then you might be overloading something\n\nThe usual solution for this problem is to have a cancellation token that remembers the last event:\n\n``` swift\nprivate class Cancellation {\n  var cancelled: Bool = false\n}\n\nprivate var lastCancellation: Cancellation?\n\nfunc event() {\n  lastCancellation?.cancelled = true\n  let newToken = Cancellation()\n  lastCancellation = newToken\n  downloader.downloadOperation { result in \n    if newToken.cancelled { return \n  }\n  ...\n}\n\n```\n\nThis works mostly fine. However, it hides a clear responsibility between multiple lines of code. Especially once this code is split up over multiple places in a large controller, the clear meaning becomes harder to understand. Also, it lacks a lot of control. Maybe you want every 10th event to go through, and more.\n\n## Enter Combine\n\nCombine offers a nice way of controlling the event flow in this case via the `throttle` and `debounce` operators:\n\n### Throttle:\n\n[The docs say:](https://developer.apple.com/documentation/combine/passthroughsubject/3204657-throttle)\n\n> Publishes either the most-recent or first element published by the upstream publisher in the specified time interval.\n\n### Debounce:\n\n[The docs say:](https://developer.apple.com/documentation/combine/anypublisher/3204205-debounce)\n\n> Publishes elements only after a specified time interval elapses between events.\n\n## Using Throttle and Combine\n\nThere's an easy way of introducing throttle and combine into your view controller without exposing much of Combine to other parts of your code. What we're doing here is creating a Combine Subject and a Combine Cancellation token at the same time. We're also using a closure as the type of the Subject. By doing it this way, we can use it for any action which should be throttled. I'll first list the code and then explain it:\n\n``` swift\nvar delayedDebounce: (\n   publisher: PassthroughSubject<() -> Void, Never>,\n   cancellable: AnyCancellable?\n   ) = {\n       let publisher: PassthroughSubject<() -> Void, Never> = PassthroughSubject()\n       let sink = publisher\n         .debounce(for: .milliseconds(400), scheduler: RunLoop.main)\n         .sink { action in\n             action()\n   }\n   return (publisher, sink)\n}()\n\n```\n\nIn the first line, we're creating a `Tuple` named `delayedDebounce. The tuple will only have two items, the `Subject` and the `AnyCancellable` cancellation token:\n\n``` swift\nvar delayedDebounce: (publisher: PassthroughSubject, cancellable: AnyCancellable?)\n```\n\n`PassthroughSubject` is a default Combine `Subject` which does not have a default value. Any value it receives will be forwarded through the Combine stream. A subject is a Combine `Publisher` that exposes a method for outside callers to publish elements.\n\nNext up, we're initializing the `Tuple` with a lazy evaluated closure:\n\n``` swift\nvar delayedDebounce: (publisher: PassthroughSubject, cancellable: AnyCancellable?) = { ... }()\n```\n\nWithin this closure, we're setting up the actual publisher. Lets inspect this code in detail:\n\n``` swift\nlet publisher: PassthroughSubject<() -> Void, Never> = PassthroughSubject()\nlet sink = publisher\n   .debounce(for: .milliseconds(400), scheduler: RunLoop.main)\n   .sink { action in\n     action()\n}\n```\n\nInitially, we need to create our `PassthroughSubject` (which is a `Publisher`). It generic over two types, the `Output` it will **pass through** and the `Failure` that can happen. In our case, we don't expect any errors so the `Failure` type is `Never`. The `Output` we want to pass through is an action that will be executed: `() -> Void`.\n\nNow that we have our publisher, we can use it to [perform any of the methods that are exposed on the `Publisher` protocol](https://developer.apple.com/documentation/combine/publisher). In our case, `debounce` or  `throttle`:\n\n``` swift\nlet sink = publisher.debounce(for: .milliseconds(400), scheduler: RunLoop.main)\n```\n\nIn the example above, we tell it to wait 400 milliseconds between events before a event is passed through. So the final thing we need is to execute the action that was delayed and debounced by 400 milliseconds. That's what the `sink` is for:\n\n``` swift\n.sink { action in\n     action()\n}\n````\n\nWith this setup, we can execute actions and rest assured that there's a 400ms interval between events. We use the `send` method of the `Subject` to achive this:\n\n``` swift\ndelayedDebounce.publisher.send { \n  view.layoutIfNeeded()\n}\n\n```\n\n# Abstractions\n\nThis code already works. However, if you use it a lot, you might want to abstract it into a simple `struct` that simplifies the setup even more:\n\n``` swift\nstruct Debouncer {\n  private var delayedDebounce: (\n     publisher: PassthroughSubject<() -> Void, Never>,\n     cancellable: AnyCancellable?\n     ) = {\n         let publisher: PassthroughSubject<() -> Void, Never> = PassthroughSubject()\n         let sink = publisher\n           .debounce(for: .milliseconds(400), scheduler: RunLoop.main)\n           .sink { action in\n               action()\n     }\n     return (publisher, sink)\n  }()\n\n  func execute(_ action: () -> Void) {\n    delayedDebounce.publisher.send(action)\n  }\n}\n```\n\nDoing it this way has the downside that you can't configure the Combine stream any more. For example, with the initial implementation, you could also do this:\n\n\n``` swift\nvar delayedDebounce: (\n   publisher: PassthroughSubject<() -> Void, Never>,\n   cancellable: AnyCancellable?\n   ) = {\n       let publisher: PassthroughSubject<() -> Void, Never> = PassthroughSubject()\n       let sink = publisher\n         .debounce(for: .milliseconds(400), scheduler: RunLoop.main)\n         .throttle(for: .milliseconds(20), scheduler: RunLoop.main, latest: true)\n         .delay(for: 2, scheduler: RunLoop.main)\n         .sink { action in\n             action()\n   }\n   return (publisher, sink)\n}()\n```\n\nHere, we're first debouncing, then throttling, and finally delaying for 2 seconds. This is only for illustrative purposes.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/observer_pattern.md":["bb815392017791fc",{"identifier":"e8820851","filename":"observer_pattern.md","info":{"title":"Observer Pattern","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-observer-pattern.html","content":"<h1>Observer Pattern</h1>\n<p>There're various ways of modelling observation in Swift. If you include\n<code>@objc</code> compatibility, you can use <code>NotificationCenter</code> or <strong>KVO</strong>.\nEven if not, the <code>didSet</code> syntax makes it easy to implement simple\nobservation. Enums can be used here in order to make the type of change\nthat happens to the observed object clearer. Imagine collection\nobservation. If we think about it, we only have a couple of possible\ncases: One or more items are inserted, one or more items are deleted,\none or more items are updated. This sounds like a job for an enum:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Change {\n\n      <span class=\"keyword\">case</span> insertion(items: [<span class=\"type\">Item</span>])\n\n      <span class=\"keyword\">case</span> deletion(items: [<span class=\"type\">Item</span>])\n\n      <span class=\"keyword\">case</span> update(items: [<span class=\"type\">Item</span>])\n\n}\n</code></pre></code></pre>\n<p>Then, the observing object can receive the concrete information of what\nhappened in a very clean way. This could easily be extended by adding\n<strong>oldValue</strong> and <strong>newValue</strong>, too.</p>\n","raw_content":"[frontMatter]\ntitle = \"Observer Pattern\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Observer Pattern\n\nThere\\'re various ways of modelling observation in Swift. If you include\n`@objc` compatibility, you can use `NotificationCenter` or **KVO**.\nEven if not, the `didSet` syntax makes it easy to implement simple\nobservation. Enums can be used here in order to make the type of change\nthat happens to the observed object clearer. Imagine collection\nobservation. If we think about it, we only have a couple of possible\ncases: One or more items are inserted, one or more items are deleted,\none or more items are updated. This sounds like a job for an enum:\n\n``` Swift\nenum Change {\n     case insertion(items: [Item])\n     case deletion(items: [Item])\n     case update(items: [Item])\n}\n```\n\nThen, the observing object can receive the concrete information of what\nhappened in a very clean way. This could easily be extended by adding\n**oldValue** and **newValue**, too.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/conclusion.md":["63799f9d2d544f1c",{"identifier":"c97953ae","filename":"conclusion.md","info":{"title":"Conclusion","tags":["box","associated"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-conclusion.html","content":"<h1>Conclusion</h1>\n<p><code>Associated types</code> are a powerful concept however they come with a fair\nshare of difficulties. Most notably, as soon as you introduce an\n<code>associated type</code> you can't use it like you'd use normal full types.\nThis article provided several patterns that make it a bit easier to\nhandle <code>associated type</code> problems in your codebase. Each of these\npatterns has downsides though. In general, if you intend to use\n<code>associated types</code> in a <code>protocol</code>, one of the best solutions is to try\nto only use the types that implement this <code>protocol</code> instead of the\n<code>protocol</code> itself. Because then you don't even need those patterns.</p>\n","raw_content":"[frontMatter]\ntitle = \"Conclusion\"\ntags = [\"box\", \"associated\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Conclusion\n\n`Associated types` are a powerful concept however they come with a fair\nshare of difficulties. Most notably, as soon as you introduce an\n`associated type` you can\\'t use it like you\\'d use normal full types.\nThis article provided several patterns that make it a bit easier to\nhandle `associated type` problems in your codebase. Each of these\npatterns has downsides though. In general, if you intend to use\n`associated types` in a `protocol`, one of the best solutions is to try\nto only use the types that implement this `protocol` instead of the\n`protocol` itself. Because then you don\\'t even need those patterns.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/multiple_different_windows.md":["cc331ca188ceda63",{"identifier":"812e5e69","filename":"multiple_different_windows.md","info":{"title":"How do I support multiple *different* windows?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-support-multiple-different-windows.html","content":"<h2>How do I setup the a new scene?</h2>\n<p>A new scene needs a new, different scene configuration. The creation of scene configurations</p>\n<p>First, you have to define a user activity and tell your application in the <code>info.plist</code> to accept it by adding it to the list of user activities:</p>\n<p><img src=\"/img-content/catalyst/useractivity.png\" alt=\"\" /></p>\n<p>Then, you need to define a new scene configuration in your <em>plist</em>:</p>\n<p><img src=\"/img-content/catalyst/multiscene.png\" alt=\"\" /></p>\n<p>Here you have the chance to load a different storyboard. Because, after all, we want the new window to be a different window. So it should also be a different storyboard.</p>\n<p>Next up, say we have a button that you can click in order to spawn the new window. This is what you do:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> userActivity = <span class=\"type\">NSUserActivity</span>(activityType: \\<span class=\"string\">\"com</span>.<span class=\"property\">stylemac</span>.<span class=\"property\">nerau</span>.<span class=\"property\">openResult</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// If you need custom data for your new window initialization, you can</span>\n\n<span class=\"comment\">// put it into the userInfo here</span>\n\nuserActivity.<span class=\"property\">userInfo</span> = [\\<span class=\"string\">\"userid</span>\\<span class=\"string\">\"</span>: <span class=\"number\">1234</span>]\n\n\n\n<span class=\"type\">UIApplication</span>.<span class=\"property\">shared</span>.<span class=\"call\">requestSceneSessionActivation</span>(<span class=\"keyword\">nil</span>, userActivity: userActivity, options: <span class=\"keyword\">nil</span>) { (e) <span class=\"keyword\">in</span>\n\n   <span class=\"comment\">// If we happen to have an error</span>\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"error</span>\\<span class=\"string\">\"</span>, e)\n\n}\n</code></pre></code></pre>\n<p>So, what's happening here. We create a new user activity. We told <code>UIApplication</code> to initialize a new scene with that activity. The activity can include an additional payload for the new window (user id, etc)</p>\n<p>Finally, we need to tell the system that this new scene that we're creating should use the other scene configuration. We can do that in our app delegate:</p>\n<pre class=\"Swift\"><code>   <span class=\"keyword\">func</span> application(<span class=\"keyword\">_</span> application: <span class=\"type\">UIApplication</span>,\n\n                    configurationForConnecting connectingSceneSession: <span class=\"type\">UISceneSession</span>,\n\n                    options: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) -&gt; <span class=\"type\">UISceneConfiguration</span> {\n\n     <span class=\"keyword\">if</span> options.<span class=\"property\">userActivities</span>.<span class=\"property\">first</span>?.<span class=\"property\">activityType</span> == \\<span class=\"string\">\"com</span>.<span class=\"property\">stylemac</span>.<span class=\"property\">nerau</span>.<span class=\"property\">openResult</span>\\<span class=\"string\">\"</span> {\n\n       <span class=\"comment\">// Load our new window configuration</span>\n\n       <span class=\"keyword\">return</span> <span class=\"type\">UISceneConfiguration</span>(name: \\<span class=\"string\">\"New</span> <span class=\"type\">Configuration</span>\\<span class=\"string\">\"</span>, sessionRole: connectingSceneSession.<span class=\"property\">role</span>)\n\n     }\n\n     <span class=\"comment\">// Load our default configuration</span>\n\n     <span class=\"keyword\">return</span> <span class=\"type\">UISceneConfiguration</span>(name: \\<span class=\"string\">\"Default</span> <span class=\"type\">Configuration</span>\\<span class=\"string\">\"</span>, sessionRole: connectingSceneSession.<span class=\"property\">role</span>)\n\n   }\n</code></pre></code></pre>\n<p>By doing it this way, you can create multiple, different windows. Note that in beta 2, sometimes the user activities disappear <em>on route</em> with Catalysts. So if your <code>options.userActivities</code> is empty, then wait for another beta .. or look at <em>Other Approaches</em> below.</p>\n<h2>Other Approaches</h2>\n<p>Another, simpler approach to doing this is to just replace the <code>rootViewController</code> of the <code>UIWindow</code> in the <code>SceneDelegate</code>'s</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n   window?.<span class=\"property\">rootViewController</span> = <span class=\"type\">MyCustomUIViewController</span>()\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I support multiple *different* windows?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\n## How do I setup the a new scene?\n\nA new scene needs a new, different scene configuration. The creation of scene configurations\n\nFirst, you have to define a user activity and tell your application in the `info.plist` to accept it by adding it to the list of user activities:\n\n![](/img-content/catalyst/useractivity.png)\n\nThen, you need to define a new scene configuration in your *plist*:\n\n![](/img-content/catalyst/multiscene.png)\n\nHere you have the chance to load a different storyboard. Because, after all, we want the new window to be a different window. So it should also be a different storyboard.\n\nNext up, say we have a button that you can click in order to spawn the new window. This is what you do:\n\n``` swift\nlet userActivity = NSUserActivity(activityType: \"com.stylemac.nerau.openResult\")\n\n// If you need custom data for your new window initialization, you can\n// put it into the userInfo here\nuserActivity.userInfo = [\"userid\": 1234]\n\nUIApplication.shared.requestSceneSessionActivation(nil, userActivity: userActivity, options: nil) { (e) in\n  // If we happen to have an error\n  print(\"error\", e)\n}\n```\n\nSo, what's happening here. We create a new user activity. We told `UIApplication` to initialize a new scene with that activity. The activity can include an additional payload for the new window (user id, etc)\n\nFinally, we need to tell the system that this new scene that we're creating should use the other scene configuration. We can do that in our app delegate:\n\n``` swift\n  func application(_ application: UIApplication,\n                   configurationForConnecting connectingSceneSession: UISceneSession,\n                   options: UIScene.ConnectionOptions) -> UISceneConfiguration {\n    if options.userActivities.first?.activityType == \"com.stylemac.nerau.openResult\" {\n      // Load our new window configuration\n      return UISceneConfiguration(name: \"New Configuration\", sessionRole: connectingSceneSession.role)\n    }\n    // Load our default configuration\n    return UISceneConfiguration(name: \"Default Configuration\", sessionRole: connectingSceneSession.role)\n  }\n```\n\nBy doing it this way, you can create multiple, different windows. Note that in beta 2, sometimes the user activities disappear *on route* with Catalysts. So if your `options.userActivities` is empty, then wait for another beta .. or look at *Other Approaches* below.\n\n## Other Approaches\n\nAnother, simpler approach to doing this is to just replace the `rootViewController` of the `UIWindow` in the `SceneDelegate`'s\n\n``` swift\nfunc scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n  window?.rootViewController = MyCustomUIViewController()\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/intro.md":["747611b82bfdd7fa",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Real World Examples","tags":["pattern matching","switch"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-real-world-examples.html","content":"<h1>Real World Examples</h1>\n<p>Swift's pattern matching is very helpful in order to write cleaner code.\nSometimes it can be a bit tricky to rethink common programming patterns in a way\nthat makes them applicable to pattern matching. This guide will help you along\nby introducing various real world examples that clearly benefit from\npattern matching.</p>\n","raw_content":"[frontMatter]\ntitle = \"Real World Examples\"\ntags = [\"pattern matching\", \"switch\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Real World Examples\n\nSwift's pattern matching is very helpful in order to write cleaner code.\nSometimes it can be a bit tricky to rethink common programming patterns in a way\nthat makes them applicable to pattern matching. This guide will help you along\nby introducing various real world examples that clearly benefit from\npattern matching.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2015-12-08-swift-ubuntu-x11-window-app.md":["4e749d4331dc209b",{"identifier":"d7e61cfb","filename":"2015-12-08-swift-ubuntu-x11-window-app.md","info":{"title":"Swift Package Manager: Create and Use a X11 package on Linux","tags":["package"],"keywords":["linux","x11","swift","libx11","xserver","xorg"],"category":["Hands On","All"],"created":"2015-12-08 10:30:30","description":"A tutorial on how to create a Swift Package for X11 on Linux and use it to write a simple X11 app","description_html":"<p>A tutorial on how to create a Swift Package for X11 on Linux and use it to write a simple X11 app</p>\n","published":true,"slug":"2015-12-08-swift-ubuntu-x11-window-app.html","meta":{"thumbnail":"/img-content/thumb-swift-ubuntu-x11.png","feature_image":"https://appventure.me/img-content/2015-12-08-swift-ubuntu-x11-window-app-feature-image.jpg","swift_version":"2.3"},"created_timestamp":1449570630,"date":"2015-12-08T10:30:30","date_info":{"year":2015,"month":12,"day":8,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2015-12-08-swift-ubuntu-x11-window-app.html","content":"<p>Now that Swift is open source, many interested users might be installing\nand testing it on their Linux systems. However, currently the Foundation\nframework is still very much a work-in-progress so if you're interested\nin developing more than a simple shell app, you'll need to link against\nexisting Linux libraries like GTK, Cairo, or libpng in order to gain\naccess to useful functionality.</p>\n<p>I just finished implementing a simple Swift app which links against\n<code>X11</code>, the most basic Unix UI library <sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>. In this short tutorial,\nI'll show how to write a simple X11 app, and how you can utilize this\nto link against other libraries.</p>\n<p>In the process, we'll also use the new Swift package manager to create\na simple re-usable package for the X11 library.</p>\n<p>Here's a screenshot of the finished app in action<sup class=\"footnote-reference\"><a href=\"#2\">2</a></sup>:</p>\n<p><img src=\"https://raw.githubusercontent.com/terhechte/swift-x11-example/master/screenshot.png\" alt=\"\" /></p>\n<h1>Swift Packages</h1>\n<p>Before we write our actual X11 app, we need to <a href=\"https://github.com/apple/swift-package-manager\">define a Swift\npackage</a> which defines\nthe links against the X11 library. Once this is done, we can easily\nshare this package with other users, or re-use it in other projects. We\nhave to differentiate between defining a package and using a package.\nLet's start with the first and then see how we can use that package.</p>\n<h2>Defining a package</h2>\n<p>Create a new folder which will host our package. Since we're linking\nagainst a C library, <a href=\"https://github.com/apple/swift-package-manager/blob/master/Documentation/SystemModules.md\">we follow the guidance of the Swift Package\nManager documentation and prefix our library with the letter\n<strong>C</strong></a><sup class=\"footnote-reference\"><a href=\"#3\">3</a></sup>.\nWe'll name our library <code>CX11.swift</code></p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">mkdir</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> CX11.swift</span>\n</span></code></pre></code></pre>\n<p>In our case, we want to link against an existing C API and we do not\nintend to write any Swift wrapper code. Linking against C libraries and\nheaders is achieved via the <code>module.modulemap</code> file which contains the\nnecessary directives for the Swift compiler to perform the correct\nlinking. <a href=\"http://clang.llvm.org/docs/Modules.html\">The documentation for the modulemap syntax can be found\nhere</a>. We create the module map\nfile, and edit the contents (via an editor of your choice, in this case\nwe're using <code>nano</code>):</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">touch</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> CX11.swift/module.modulemap</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">nano</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> CX11.swift/module.modulemap</span>\n</span></code></pre></code></pre>\n<p>X11 is a huge library with a lot of functionality. You can see the\ncontents if you head over to <code>/usr/include/X11</code>. For our example, we\ndon't need to include all the header files in there, instead we really\nonly need two of them: <code>Xlib.h</code> and <code>X.h</code>. For different other\nlibraries, you may need to include more headers. There is a convenient\nway to include all the headers in a directory which I'll point out\nbelow. Apart from including the headers, we also need to tell Swift\nwhich library to link against. We're using the <code>link</code> keyword for that.\nOur <code>modulemap</code> looks like this:</p>\n<pre class=\"Swift\"><code>module <span class=\"type\">CX11</span> [system] {\n\n   module <span class=\"type\">Xlib</span> {\n\n       header \\<span class=\"string\">\"</span>/usr/include/<span class=\"type\">X11</span>/<span class=\"type\">Xlib</span>.<span class=\"property\">h</span>\\<span class=\"string\">\"</span>\n\n   }\n\n   module <span class=\"type\">X</span> {\n\n       header \\<span class=\"string\">\"</span>/usr/include/<span class=\"type\">X11</span>/<span class=\"type\">X</span>.<span class=\"property\">h</span>\\<span class=\"string\">\"</span>\n\n   }\n\n   link \\<span class=\"string\">\"X11</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>We're naming our module <code>CX11</code> and we're creating two submodules. One\nfor the Xlib and one for X. Each submodule defines the header it needs\nto import. Finally, we're linking against libx11 via the <code>link</code>\nstatement.</p>\n<p>But what if we have not just one header file, but many of them. Module\nmaps allow you to define an umbrella header or an umbrella directory.</p>\n<p><strong>Umbrella Header</strong> This is a header that contains just references to\nother headers (via <code>#include</code>) commands. A good example is\n<code>&lt;Cocoa/Cocoa.h&gt;</code> or <code>&lt;Foundation/Foundation.h&gt;</code> or <code>&lt;gtk/gtk.h&gt;</code>.\nUmbrella headers are defined via the umbrella keyword:</p>\n<pre class=\"Swift\"><code>umbrella header \\<span class=\"string\">\"</span>/usr/include/gtk/gtk.<span class=\"property\">h</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p><strong>Umbrella Directory</strong> Sometimes you have a directory of headers but no\numbrella header. In this case you just point Swift to the directory of\nheaders:</p>\n<pre class=\"Swift\"><code>umbrella \\<span class=\"string\">\"</span>/usr/include/<span class=\"type\">X11</span>/\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>In addition to the modulemap, we'll also need a <strong>Package.swift</strong> file,\notherwise building will fail. This file can be empty though:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">touch</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> CX11.swift/Package.swift</span>\n</span></code></pre></code></pre>\n<p>The Swift package manager uses Git and Git Tags in order to manage\npackages. So before we're done, we need to create a Git repository for\nour Package, add all the files, and create a version tag. This is fairly\neasy though:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techousupport techoufunction techoucd techoushell\">cd</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> CX11.swift</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">git</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> init</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">git</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> add .</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">git</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> commit<span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>m</span> <span class=\"techoustring techouquoted techoudouble techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&quot;</span>Initial Import<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&quot;</span></span></span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">git</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> tag 1.0.0</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techousupport techoufunction techoucd techoushell\">cd</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> ..</span>\n</span></code></pre></code></pre>\n<p>The commands above go into the folder, create a new Git repository, add\nall the files to it, create a first commit, and finally add a version\ntag (<code>1.0.0</code>) for this commit.</p>\n<p>That's it, our package is defined, but how do we use it?</p>\n<h2>Using Packages</h2>\n<p>In order to use a package, we need to define a <code>Package.swift</code> file\nwhich will tell Swift which packages we intend to import for our\nproject. But first, we need to create a directory for our project.</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">mkdir</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> swift-x11</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">touch</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> swift-x11/Package.swift</span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">touch</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> swift-x11/main.swift</span>\n</span></code></pre></code></pre>\n<p>Keep in mind that (for this example to work) the <code>swift-x11</code> folder has\nto be next to the <code>CX11.swift</code> folder. I.e.:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">ls</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"><span class=\"techouvariable techouparameter techouoption techoushell\"><span class=\"techoupunctuation techoudefinition techouparameter techoushell\"> -</span>l</span></span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">CX11.swift</span></span>\n<span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">swift-x11</span></span>\n</span></code></pre></code></pre>\n<p>Before we start writing the actual Swift code to interact with X11, we\nneed to tell our <code>swift-x11</code> project how to import the <code>CX11</code> package.\nThis is done, as explained below, via the <code>swift-x11/Package.swift</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> PackageDescription\n\n\n\n<span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(\n\n   dependencies: [\n\n     .<span class=\"call\">Package</span>(url: \\<span class=\"string\">\"</span>../<span class=\"type\">CX11</span>.<span class=\"property\">swift</span>\\<span class=\"string\">\"</span>, majorVersion: <span class=\"number\">1</span>)\n\n   ]\n\n)\n</code></pre></code></pre>\n<p>This tells Swift that the package we intend to use is located in the\n<code>../CX11.swift</code> folder.</p>\n<p>The <code>url</code> (as the name suggests) does not need to be a local one. <a href=\"https://github.com/terhechte/CX11.swift\">I've\nuploaded my own CX11.swift to\nGitHub</a>, and you could\nalternatively link directly to the GitHub version as follows:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> PackageDescription\n\n\n\n<span class=\"keyword\">let</span> package = <span class=\"type\">Package</span>(\n\n   dependencies: [\n\n     .<span class=\"call\">Package</span>(url: \\<span class=\"string\">\"https</span>://github.<span class=\"property\">com</span>/terhechte/<span class=\"type\">CX11</span>.<span class=\"property\">swift</span>.<span class=\"property\">git</span>\\<span class=\"string\">\"</span>, majorVersion: <span class=\"number\">1</span>)\n\n   ]\n\n)\n</code></pre></code></pre>\n<h1>Using X11</h1>\n<p>Now that we defined an X11 package, and set up the package manager\ndefinitions, we want to write our first X11 application.</p>\n<p>One issue which I could not solve is that macro definitions in the X11\nheader file are not imported into Swift. The <code>Xlib.h</code> defines many\nshortcut macros like:</p>\n<pre class=\"C\"><code><span class=\"techousource techouc\"><span class=\"techoumeta techoupreprocessor techoumacro techouc\"><span class=\"techoukeyword techoucontrol techouimport techoudefine techouc\">#define</span></span><span class=\"techoumeta techoupreprocessor techoumacro techouc\"> <span class=\"techouentity techouname techoufunction techoupreprocessor techouc\">RootWindow</span></span><span class=\"techoumeta techoupreprocessor techoumacro techouparameters techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span><span class=\"techouvariable techouparameter techouc\">dpy</span><span class=\"techoupunctuation techouseparator techouc\">,</span> <span class=\"techouvariable techouparameter techouc\">src</span><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoumeta techoupreprocessor techoumacro techouc\"> <span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techouvariable techoufunction techouc\">ScreenOfDisplay</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\">dpy<span class=\"techoupunctuation techouseparator techouc\">,</span> src</span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouaccessor techouc\">-&gt;</span>root<span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span>\n<span class=\"techoumeta techoupreprocessor techoumacro techouc\"><span class=\"techoukeyword techoucontrol techouimport techoudefine techouc\">#define</span></span><span class=\"techoumeta techoupreprocessor techoumacro techouc\"> <span class=\"techouentity techouname techoufunction techoupreprocessor techouc\">ScreenOfDisplay</span></span><span class=\"techoumeta techoupreprocessor techoumacro techouparameters techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span><span class=\"techouvariable techouparameter techouc\">dpy</span><span class=\"techoupunctuation techouseparator techouc\">,</span> <span class=\"techouvariable techouparameter techouc\">scr</span><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoumeta techoupreprocessor techoumacro techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span><span class=\"techoukeyword techouoperator techouc\">&amp;</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span>_XPrivDisplay<span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span>dpy<span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span><span class=\"techoupunctuation techouaccessor techouc\">-&gt;</span>screens<span class=\"techoumeta techoubrackets techouc\"><span class=\"techoupunctuation techousection techoubrackets techoubegin techouc\">[</span>scr<span class=\"techoupunctuation techousection techoubrackets techouend techouc\">]</span></span><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span>\n</span></code></pre></code></pre>\n<p>As these were not imported, I decided instead to always write out the\ncontents of the macro. All the code below has to be put into the\n<code>main.swift</code> file. <a href=\"https://github.com/terhechte/swift-x11-example\">You can also see the finished version here on\nGitHub</a>. Please note\nthat this is a simple and non-memory-safe example. This mostly serves to\nexplain how to use C libraries under Linux. Also, my X11 knowledge is\nrather limited. I did Linux X11 programming more than 10 years ago and\nforgot most of it, so there may be factual errors in the explanation\nbelow. If you find them, <a href=\"https://github.com/terhechte/appventure-blog/tree/master/resources/posts/2015-12-08-swift-ubuntu-x11-window-app.org\">feel free to open a PR on this repo\n:)</a></p>\n<p>We begin by importing the <code>CX11</code> library which we defined above:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> CX11.<span class=\"type\">Xlib</span>\n\n<span class=\"keyword\">import</span> CX11.<span class=\"type\">X</span>\n</code></pre></code></pre>\n<h2>Setting up state</h2>\n<p>After this, we have to define a couple of variables.</p>\n<ul>\n<li>\n<p>We need the X11 display (i.e. roughly speaking the X11 server\nconnection). This will be the <code>d</code> variable</p>\n</li>\n<li>\n<p>We need a placeholder for the X11 window which we create. This will\nbe the <code>w</code> variable.</p>\n</li>\n<li>\n<p>We also need to set aside a bit of memory for the X11 Server to\nstore X11 input events. This is the <code>e</code> variable.</p>\n</li>\n<li>\n<p>We should also already store the text which we want to display in\nour window. This is the <code>msg</code> variable</p>\n</li>\n<li>\n<p>We need a place to store the current X11 screen (a X11 Display can\nhave multiple screens). This will be the <code>s</code> variable.</p>\n</li>\n<li>\n<p>Finally, we need a pointer to the X11 root window, which houses the\nother windows. This is the <code>rootWindow</code> variable.</p>\n</li>\n</ul>\n<pre class=\"Swift\"><code><span class=\"comment\">// The X11 Display</span>\n\n<span class=\"keyword\">var</span> d: <span class=\"type\">_XPrivDisplay</span>\n\n\n\n<span class=\"comment\">// The window which we will create</span>\n\n<span class=\"keyword\">var</span> w: <span class=\"type\">Window</span>\n\n\n\n<span class=\"comment\">// The events which X11 generates for us will be stored here</span>\n\n<span class=\"keyword\">var</span> e = <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">_XEvent</span>&gt;.<span class=\"call\">alloc</span>(<span class=\"number\">1</span>)\n\n\n\n<span class=\"comment\">// The text to display</span>\n\n<span class=\"keyword\">var</span> msg = \\<span class=\"string\">\"Hello</span> <span class=\"type\">Swift World</span>\\<span class=\"string\">\"</span>\n\n\n\n<span class=\"comment\">// A pointer to the current X11 Screen</span>\n\n<span class=\"keyword\">var</span> s: <span class=\"type\">UnsafeMutablePointer</span>&lt;<span class=\"type\">Screen</span>&gt;\n</code></pre></code></pre>\n<p>Now that we defined our variables, we need to open our connection to the\nX11 Server. However, as users can also run this app when no X server is\nrunning (i.e. in console mode) we need to make sure that the connection\nsucceeded:</p>\n<pre class=\"Swift\"><code>d = <span class=\"type\">XOpenDisplay</span>(<span class=\"keyword\">nil</span>)\n\n<span class=\"keyword\">if</span> d == <span class=\"keyword\">nil</span> {\n\n     <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"cannot</span> <span class=\"keyword\">open</span> display\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>After we opened the display, we'd like to get the current default\nscreen as well as the current root window. The <code>RootWindow</code> macro is not\navailable<sup class=\"footnote-reference\"><a href=\"#4\">4</a></sup>, so we will access the memory section of the <code>C struct</code>\ndirectly. However, as the current screen <code>s</code> is a\n<code>UnsafeMutablePointer</code>, we need to add the <code>memory</code> property in order to\naccess the <code>root</code> instance.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Get the default screen</span>\n\ns = <span class=\"type\">XDefaultScreenOfDisplay</span>(d)\n\n\n\n<span class=\"comment\">// And the current root window on that screen</span>\n\n<span class=\"keyword\">let</span> rootWindow = s.<span class=\"property\">memory</span>.<span class=\"property\">root</span>\n</code></pre></code></pre>\n<h2>Creating a Window</h2>\n<p>Finally we have everything in place to create our own window and place\nit on the screen. We're <a href=\"http://linux.die.net/man/3/xcreatesimplewindow\">using the <code>XCreateSimpleWindow</code> function for\nthat</a>. The function has\nthe following parameters:</p>\n<pre class=\"C\"><code><span class=\"techousource techouc\"><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techouvariable techoufunction techouc\">XCreateSimpleWindow</span><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techoubegin techouc\">(</span></span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\">Display <span class=\"techoukeyword techouoperator techouc\">*</span>display<span class=\"techoupunctuation techouseparator techouc\">,</span> Window parent<span class=\"techoupunctuation techouseparator techouc\">,</span> <span class=\"techoustorage techoutype techouc\">int</span> x<span class=\"techoupunctuation techouseparator techouc\">,</span> <span class=\"techoustorage techoutype techouc\">int</span> y<span class=\"techoupunctuation techouseparator techouc\">,</span> \n  <span class=\"techoustorage techoutype techouc\">unsigned</span> <span class=\"techoustorage techoutype techouc\">int</span> width<span class=\"techoupunctuation techouseparator techouc\">,</span> <span class=\"techoustorage techoutype techouc\">unsigned</span> <span class=\"techoustorage techoutype techouc\">int</span> height<span class=\"techoupunctuation techouseparator techouc\">,</span> <span class=\"techoustorage techoutype techouc\">unsigned</span> <span class=\"techoustorage techoutype techouc\">int</span> border_width<span class=\"techoupunctuation techouseparator techouc\">,</span> \n  <span class=\"techoustorage techoutype techouc\">unsigned</span> <span class=\"techoustorage techoutype techouc\">long</span> border<span class=\"techoupunctuation techouseparator techouc\">,</span> <span class=\"techoustorage techoutype techouc\">unsigned</span> <span class=\"techoustorage techoutype techouc\">long</span> background</span></span><span class=\"techoumeta techoufunction-call techouc\"><span class=\"techoumeta techougroup techouc\"><span class=\"techoupunctuation techousection techougroup techouend techouc\">)</span></span></span><span class=\"techoupunctuation techouterminator techouc\">;</span>\n</span></code></pre></code></pre>\n<p><code>border</code> and <code>background</code> are color values. In order to not think about\ncolor creation, we will simply pass in a reference to the default black\nand white colors which are defined on the current screen. We have to use\nthe <code>.memory</code> property again.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Create our window</span>\n\nw = <span class=\"type\">XCreateSimpleWindow</span>(d, rootWindow, <span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">200</span>, <span class=\"number\">100</span>, <span class=\"number\">1</span>, \n\n   s.<span class=\"property\">memory</span>.<span class=\"property\">black_pixel</span>, s.<span class=\"property\">memory</span>.<span class=\"property\">white_pixel</span>)\n</code></pre></code></pre>\n<p>This will create a new window on the <code>rootWindow</code> position 10/10 of\nwidth 200 and height 100. The borders will be black, the background will\nbe white.</p>\n<h2>Input Events</h2>\n<p>Of course, we also want to receive input events from the Xserver. In our\ncase we'd like to know when the window is being displayed so that we\ncan draw it, and we'd like to know when the user pressed a key so that\nwe can quit the app. The first event is the <code>Expose</code> event, the second\none is the <code>KeyPress</code> event. <a href=\"http://tronche.com/gui/x/xlib/event-handling/XSelectInput.html\">Receiving events works by registering\nevent masks via the <code>XSelectInput</code>\nfunction</a>:</p>\n<pre class=\"Swift\"><code><span class=\"type\">XSelectInput</span>(d, w, <span class=\"type\">ExposureMask</span> | <span class=\"type\">KeyPressMask</span>)\n</code></pre></code></pre>\n<p>Now that we created our window, we want to display it. <a href=\"http://tronche.com/gui/x/xlib/window/XMapWindow.html\">This is done via\nthe <code>XMapWindow</code>\nfunction</a>:</p>\n<pre class=\"Swift\"><code><span class=\"type\">XMapWindow</span>(d, w)\n</code></pre></code></pre>\n<h2>Event Loop</h2>\n<p>Finally we do have everything in place to run our event loop while the\nwindow is being displayed. For this, we're using a <code>while</code> loop which\ncontinously pulls the <code>XNextEvent</code> function to get new X11 events. Then,\nwe'll test the event to see whether it is a <code>Expose</code> or a <code>KeyPress</code>\nevent<sup class=\"footnote-reference\"><a href=\"#5\">5</a></sup>. We're testing the events using the swift <code>switch</code> statement:</p>\n<pre class=\"Swift\"><code>loop: <span class=\"keyword\">while true</span> {\n\n\n\n   <span class=\"comment\">// Wait for the next event</span>\n\n   <span class=\"type\">XNextEvent</span>(d, e)\n\n\n\n   <span class=\"keyword\">switch</span> e.<span class=\"property\">memory</span>.<span class=\"property\">type</span> {\n\n   <span class=\"comment\">// The window has to be drawn</span>\n\n   <span class=\"keyword\">case</span> <span class=\"type\">Expose</span>:\n\n   <span class=\"comment\">// draw a small black rectangle</span>\n\n   <span class=\"type\">XFillRectangle</span>(d, w, s.<span class=\"property\">memory</span>.<span class=\"property\">default_gc</span>, <span class=\"number\">20</span>, <span class=\"number\">20</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>) \n\n   <span class=\"comment\">// draw the text</span>\n\n   <span class=\"type\">XDrawString</span>(d, w, s.<span class=\"property\">memory</span>.<span class=\"property\">default_gc</span>, <span class=\"number\">10</span>, <span class=\"number\">70</span>, msg, <span class=\"type\">Int32</span>(msg.<span class=\"property\">characters</span>.<span class=\"property\">count</span>)) \n\n\n\n   <span class=\"comment\">// The user did press a key</span>\n\n   <span class=\"keyword\">case</span> <span class=\"type\">KeyPress</span>:\n\n   <span class=\"keyword\">break</span> loop\n\n\n\n   <span class=\"comment\">// We never signed up for this event</span>\n\n   <span class=\"keyword\">default</span>: <span class=\"call\">fatalError</span>(\\<span class=\"string\">\"Unknown</span> <span class=\"type\">Event</span>\\<span class=\"string\">\"</span>)\n\n\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Our <code>e</code> event structure is - again - a <code>UnsafeMutablePointer</code>, so we\nhave to access the actual structure via the <code>memory</code> property. The\n<code>Expose</code> event means that the window is visible, so we have to re-draw\nit. Our drawing is very simple: We're using the <code>XFillRectangle</code> call\nto draw a small black box, and the <code>XDrawString</code> call to draw our\ninitial <code>msg</code> text in the window at position 10, 70. Please note that I\ndon't know whether X11 expects unicode or ascii, so the\n<code>Int32(msg.characters.count)</code> is probably wrong, but it works in this\nexample.</p>\n<p>The other event, <code>KeyPress</code> allows us to break the outer <code>while</code> loop\nand quit the app once the user enters a key.</p>\n<h1>Running It</h1>\n<p>To use this, simply check out the repo (preferrably on Linux) and do the\nfollowing in the folder:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">swift</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> build</span>\n</span></code></pre></code></pre>\n<p>This will clone the <code>CX11.swift</code> package and build the binary in the\n<code>.build/debug</code> folder.</p>\n<p>Run it via:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">.build/debug/swift-x11-example</span></span>\n</span></code></pre></code></pre>\n<p>This will execute the binary, and a small X11 Window should appear on\nyour desktop:</p>\n<p><img src=\"https://raw.githubusercontent.com/terhechte/swift-x11-example/master/screenshot.png\" alt=\"\" /></p>\n<h1>Conclusion</h1>\n<p>This was a very simple example of how to use Swift under Linux to write\nan X11 app. This will also work for all kind of other apps using other\nlibraries, of course. This tutorial also explained how the new Swift\nPackage manager works by creating and using a simple <code>X11</code> package.</p>\n<p><a href=\"https://github.com/terhechte/swift-x11-example\">The full example of the X11 app can be found\nhere.</a></p>\n<p><a href=\"https://github.com/terhechte/CX11.swift\">The full example of the X11 package can be found\nhere.</a></p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>I started with GTK3, but could not get that to work</p>\n</div>\n<div class=\"footnote-definition\" id=\"2\"><sup class=\"footnote-definition-label\">2</sup>\n<p>Spectacular, isn't it ;)</p>\n</div>\n<div class=\"footnote-definition\" id=\"3\"><sup class=\"footnote-definition-label\">3</sup>\n<p>&quot;The convention we hope the community will adopt is to prefix\nsuch modules with C and to camelcase the modules as per Swift module\nname conventions. Then the community is free to name another module\nsimply JPEG which contains more &quot;Swifty&quot; function wrappers around\nthe raw C interface.&quot;</p>\n</div>\n<div class=\"footnote-definition\" id=\"4\"><sup class=\"footnote-definition-label\">4</sup>\n<p>See above, I couldn't figure out why</p>\n</div>\n<div class=\"footnote-definition\" id=\"5\"><sup class=\"footnote-definition-label\">5</sup>\n<p>Remember those are the only events we signed up for</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"A tutorial on how to create a Swift Package for X11 on Linux and use it to write a simple X11 app\"\ntitle = \"Swift Package Manager: Create and Use a X11 package on Linux\"\ncreated = \"2015-12-08\"\npublished = true\nkeywords = [\"linux\", \"x11\", \"swift\", \"libx11\", \"xserver\", \"xorg\"]\nslug = \"2015-12-08-swift-ubuntu-x11-window-app.html\"\ntags = [\"package\"]\ncategory = [\"Hands On\", \"All\"]\n\n[meta]\nswift_version = \"2.3\"\nthumbnail = \"/img-content/thumb-swift-ubuntu-x11.png\"\nfeature_image = \"https://appventure.me/img-content/2015-12-08-swift-ubuntu-x11-window-app-feature-image.jpg\"\n---\n\nNow that Swift is open source, many interested users might be installing\nand testing it on their Linux systems. However, currently the Foundation\nframework is still very much a work-in-progress so if you\\'re interested\nin developing more than a simple shell app, you\\'ll need to link against\nexisting Linux libraries like GTK, Cairo, or libpng in order to gain\naccess to useful functionality.\n\nI just finished implementing a simple Swift app which links against\n`X11`, the most basic Unix UI library [^1]. In this short tutorial,\nI\\'ll show how to write a simple X11 app, and how you can utilize this\nto link against other libraries.\n\nIn the process, we\\'ll also use the new Swift package manager to create\na simple re-usable package for the X11 library.\n\nHere\\'s a screenshot of the finished app in action[^2]:\n\n![](https://raw.githubusercontent.com/terhechte/swift-x11-example/master/screenshot.png)\n\n# Swift Packages\n\nBefore we write our actual X11 app, we need to [define a Swift\npackage](https://github.com/apple/swift-package-manager) which defines\nthe links against the X11 library. Once this is done, we can easily\nshare this package with other users, or re-use it in other projects. We\nhave to differentiate between defining a package and using a package.\nLet\\'s start with the first and then see how we can use that package.\n\n## Defining a package\n\nCreate a new folder which will host our package. Since we\\'re linking\nagainst a C library, [we follow the guidance of the Swift Package\nManager documentation and prefix our library with the letter\n**C**](https://github.com/apple/swift-package-manager/blob/master/Documentation/SystemModules.md)[^3].\nWe\\'ll name our library `CX11.swift`\n\n``` bash\nmkdir CX11.swift\n```\n\nIn our case, we want to link against an existing C API and we do not\nintend to write any Swift wrapper code. Linking against C libraries and\nheaders is achieved via the `module.modulemap` file which contains the\nnecessary directives for the Swift compiler to perform the correct\nlinking. [The documentation for the modulemap syntax can be found\nhere](http://clang.llvm.org/docs/Modules.html). We create the module map\nfile, and edit the contents (via an editor of your choice, in this case\nwe\\'re using `nano`):\n\n``` bash\ntouch CX11.swift/module.modulemap\nnano CX11.swift/module.modulemap\n```\n\nX11 is a huge library with a lot of functionality. You can see the\ncontents if you head over to `/usr/include/X11`. For our example, we\ndon\\'t need to include all the header files in there, instead we really\nonly need two of them: `Xlib.h` and `X.h`. For different other\nlibraries, you may need to include more headers. There is a convenient\nway to include all the headers in a directory which I\\'ll point out\nbelow. Apart from including the headers, we also need to tell Swift\nwhich library to link against. We\\'re using the `link` keyword for that.\nOur `modulemap` looks like this:\n\n``` Swift\nmodule CX11 [system] {\n  module Xlib {\n      header \"/usr/include/X11/Xlib.h\"\n  }\n  module X {\n      header \"/usr/include/X11/X.h\"\n  }\n  link \"X11\"\n}\n```\n\nWe\\'re naming our module `CX11` and we\\'re creating two submodules. One\nfor the Xlib and one for X. Each submodule defines the header it needs\nto import. Finally, we\\'re linking against libx11 via the `link`\nstatement.\n\nBut what if we have not just one header file, but many of them. Module\nmaps allow you to define an umbrella header or an umbrella directory.\n\n**Umbrella Header** This is a header that contains just references to\nother headers (via `#include`) commands. A good example is\n`<Cocoa/Cocoa.h>` or `<Foundation/Foundation.h>` or `<gtk/gtk.h>`.\nUmbrella headers are defined via the umbrella keyword:\n\n``` Swift\numbrella header \"/usr/include/gtk/gtk.h\"\n```\n\n**Umbrella Directory** Sometimes you have a directory of headers but no\numbrella header. In this case you just point Swift to the directory of\nheaders:\n\n``` Swift\numbrella \"/usr/include/X11/\"\n```\n\nIn addition to the modulemap, we\\'ll also need a **Package.swift** file,\notherwise building will fail. This file can be empty though:\n\n``` bash\ntouch CX11.swift/Package.swift\n```\n\nThe Swift package manager uses Git and Git Tags in order to manage\npackages. So before we\\'re done, we need to create a Git repository for\nour Package, add all the files, and create a version tag. This is fairly\neasy though:\n\n``` bash\ncd CX11.swift\ngit init\ngit add .\ngit commit -m \"Initial Import\"\ngit tag 1.0.0\ncd ..\n```\n\nThe commands above go into the folder, create a new Git repository, add\nall the files to it, create a first commit, and finally add a version\ntag (`1.0.0`) for this commit.\n\nThat\\'s it, our package is defined, but how do we use it?\n\n## Using Packages\n\nIn order to use a package, we need to define a `Package.swift` file\nwhich will tell Swift which packages we intend to import for our\nproject. But first, we need to create a directory for our project.\n\n``` bash\nmkdir swift-x11\ntouch swift-x11/Package.swift\ntouch swift-x11/main.swift\n```\n\nKeep in mind that (for this example to work) the `swift-x11` folder has\nto be next to the `CX11.swift` folder. I.e.:\n\n``` bash\nls -l\nCX11.swift\nswift-x11\n```\n\nBefore we start writing the actual Swift code to interact with X11, we\nneed to tell our `swift-x11` project how to import the `CX11` package.\nThis is done, as explained below, via the `swift-x11/Package.swift`:\n\n``` Swift\nimport PackageDescription\n\nlet package = Package(\n  dependencies: [\n    .Package(url: \"../CX11.swift\", majorVersion: 1)\n  ]\n)\n```\n\nThis tells Swift that the package we intend to use is located in the\n`../CX11.swift` folder.\n\nThe `url` (as the name suggests) does not need to be a local one. [I\\'ve\nuploaded my own CX11.swift to\nGitHub](https://github.com/terhechte/CX11.swift), and you could\nalternatively link directly to the GitHub version as follows:\n\n``` Swift\nimport PackageDescription\n\nlet package = Package(\n  dependencies: [\n    .Package(url: \"https://github.com/terhechte/CX11.swift.git\", majorVersion: 1)\n  ]\n)\n```\n\n# Using X11\n\nNow that we defined an X11 package, and set up the package manager\ndefinitions, we want to write our first X11 application.\n\nOne issue which I could not solve is that macro definitions in the X11\nheader file are not imported into Swift. The `Xlib.h` defines many\nshortcut macros like:\n\n``` C\n#define RootWindow(dpy, src) (ScreenOfDisplay(dpy, src)->root)\n#define ScreenOfDisplay(dpy, scr)(&((_XPrivDisplay)dpy)->screens[scr])\n```\n\nAs these were not imported, I decided instead to always write out the\ncontents of the macro. All the code below has to be put into the\n`main.swift` file. [You can also see the finished version here on\nGitHub](https://github.com/terhechte/swift-x11-example). Please note\nthat this is a simple and non-memory-safe example. This mostly serves to\nexplain how to use C libraries under Linux. Also, my X11 knowledge is\nrather limited. I did Linux X11 programming more than 10 years ago and\nforgot most of it, so there may be factual errors in the explanation\nbelow. If you find them, [feel free to open a PR on this repo\n:)](https://github.com/terhechte/appventure-blog/tree/master/resources/posts/2015-12-08-swift-ubuntu-x11-window-app.org)\n\nWe begin by importing the `CX11` library which we defined above:\n\n``` Swift\nimport CX11.Xlib\nimport CX11.X\n```\n\n## Setting up state\n\nAfter this, we have to define a couple of variables.\n\n-   We need the X11 display (i.e. roughly speaking the X11 server\n    connection). This will be the `d` variable\n\n-   We need a placeholder for the X11 window which we create. This will\n    be the `w` variable.\n\n-   We also need to set aside a bit of memory for the X11 Server to\n    store X11 input events. This is the `e` variable.\n\n-   We should also already store the text which we want to display in\n    our window. This is the `msg` variable\n\n-   We need a place to store the current X11 screen (a X11 Display can\n    have multiple screens). This will be the `s` variable.\n\n-   Finally, we need a pointer to the X11 root window, which houses the\n    other windows. This is the `rootWindow` variable.\n\n``` Swift\n// The X11 Display\nvar d: _XPrivDisplay\n\n// The window which we will create\nvar w: Window\n\n// The events which X11 generates for us will be stored here\nvar e = UnsafeMutablePointer<_XEvent>.alloc(1)\n\n// The text to display\nvar msg = \"Hello Swift World\"\n\n// A pointer to the current X11 Screen\nvar s: UnsafeMutablePointer<Screen>\n```\n\nNow that we defined our variables, we need to open our connection to the\nX11 Server. However, as users can also run this app when no X server is\nrunning (i.e. in console mode) we need to make sure that the connection\nsucceeded:\n\n``` Swift\nd = XOpenDisplay(nil)\nif d == nil {\n    fatalError(\"cannot open display\")\n}\n```\n\nAfter we opened the display, we\\'d like to get the current default\nscreen as well as the current root window. The `RootWindow` macro is not\navailable[^4], so we will access the memory section of the `C struct`\ndirectly. However, as the current screen `s` is a\n`UnsafeMutablePointer`, we need to add the `memory` property in order to\naccess the `root` instance.\n\n``` Swift\n// Get the default screen\ns = XDefaultScreenOfDisplay(d)\n\n// And the current root window on that screen\nlet rootWindow = s.memory.root\n```\n\n## Creating a Window\n\nFinally we have everything in place to create our own window and place\nit on the screen. We\\'re [using the `XCreateSimpleWindow` function for\nthat](http://linux.die.net/man/3/xcreatesimplewindow). The function has\nthe following parameters:\n\n``` C\nXCreateSimpleWindow(Display *display, Window parent, int x, int y, \n  unsigned int width, unsigned int height, unsigned int border_width, \n  unsigned long border, unsigned long background);\n```\n\n`border` and `background` are color values. In order to not think about\ncolor creation, we will simply pass in a reference to the default black\nand white colors which are defined on the current screen. We have to use\nthe `.memory` property again.\n\n``` Swift\n// Create our window\nw = XCreateSimpleWindow(d, rootWindow, 10, 10, 200, 100, 1, \n  s.memory.black_pixel, s.memory.white_pixel)\n```\n\nThis will create a new window on the `rootWindow` position 10/10 of\nwidth 200 and height 100. The borders will be black, the background will\nbe white.\n\n## Input Events\n\nOf course, we also want to receive input events from the Xserver. In our\ncase we\\'d like to know when the window is being displayed so that we\ncan draw it, and we\\'d like to know when the user pressed a key so that\nwe can quit the app. The first event is the `Expose` event, the second\none is the `KeyPress` event. [Receiving events works by registering\nevent masks via the `XSelectInput`\nfunction](http://tronche.com/gui/x/xlib/event-handling/XSelectInput.html):\n\n``` Swift\nXSelectInput(d, w, ExposureMask | KeyPressMask)\n```\n\nNow that we created our window, we want to display it. [This is done via\nthe `XMapWindow`\nfunction](http://tronche.com/gui/x/xlib/window/XMapWindow.html):\n\n``` Swift\nXMapWindow(d, w)\n```\n\n## Event Loop\n\nFinally we do have everything in place to run our event loop while the\nwindow is being displayed. For this, we\\'re using a `while` loop which\ncontinously pulls the `XNextEvent` function to get new X11 events. Then,\nwe\\'ll test the event to see whether it is a `Expose` or a `KeyPress`\nevent[^5]. We\\'re testing the events using the swift `switch` statement:\n\n``` Swift\nloop: while true {\n\n  // Wait for the next event\n  XNextEvent(d, e)\n\n  switch e.memory.type {\n  // The window has to be drawn\n  case Expose:\n  // draw a small black rectangle\n  XFillRectangle(d, w, s.memory.default_gc, 20, 20, 10, 10) \n  // draw the text\n  XDrawString(d, w, s.memory.default_gc, 10, 70, msg, Int32(msg.characters.count)) \n\n  // The user did press a key\n  case KeyPress:\n  break loop\n\n  // We never signed up for this event\n  default: fatalError(\"Unknown Event\")\n\n  }\n}\n```\n\nOur `e` event structure is - again - a `UnsafeMutablePointer`, so we\nhave to access the actual structure via the `memory` property. The\n`Expose` event means that the window is visible, so we have to re-draw\nit. Our drawing is very simple: We\\'re using the `XFillRectangle` call\nto draw a small black box, and the `XDrawString` call to draw our\ninitial `msg` text in the window at position 10, 70. Please note that I\ndon\\'t know whether X11 expects unicode or ascii, so the\n`Int32(msg.characters.count)` is probably wrong, but it works in this\nexample.\n\nThe other event, `KeyPress` allows us to break the outer `while` loop\nand quit the app once the user enters a key.\n\n# Running It\n\nTo use this, simply check out the repo (preferrably on Linux) and do the\nfollowing in the folder:\n\n``` bash\nswift build\n```\n\nThis will clone the `CX11.swift` package and build the binary in the\n`.build/debug` folder.\n\nRun it via:\n\n``` bash\n.build/debug/swift-x11-example\n```\n\nThis will execute the binary, and a small X11 Window should appear on\nyour desktop:\n\n![](https://raw.githubusercontent.com/terhechte/swift-x11-example/master/screenshot.png)\n\n# Conclusion\n\nThis was a very simple example of how to use Swift under Linux to write\nan X11 app. This will also work for all kind of other apps using other\nlibraries, of course. This tutorial also explained how the new Swift\nPackage manager works by creating and using a simple `X11` package.\n\n[The full example of the X11 app can be found\nhere.](https://github.com/terhechte/swift-x11-example)\n\n[The full example of the X11 package can be found\nhere.](https://github.com/terhechte/CX11.swift)\n\n[^1]: I started with GTK3, but could not get that to work\n\n[^2]: Spectacular, isn\\'t it ;)\n\n[^3]: \\\"The convention we hope the community will adopt is to prefix\n    such modules with C and to camelcase the modules as per Swift module\n    name conventions. Then the community is free to name another module\n    simply JPEG which contains more \"Swifty\" function wrappers around\n    the raw C interface.\\\"\n\n[^4]: See above, I couldn\\'t figure out why\n\n[^5]: Remember those are the only events we signed up for\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/value_binding_pattern.md":["0defcc5aefb7ffef",{"identifier":"3494e3e5","filename":"value_binding_pattern.md","info":{"title":"Value-Binding Pattern","tags":["pattern matching","switch","where"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-valuebinding-pattern.html","content":"<h1>Value-Binding Pattern</h1>\n<p>This is the very same as binding values to variables via <code>let</code> or <code>var</code>.\nOnly in a switch statement. You've already seen this before, so I'll\nprovide a very short example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> (<span class=\"number\">4</span>, <span class=\"number\">5</span>) {\n\n<span class=\"keyword\">case let</span> (x, y): <span class=\"call\">print</span>(\\<span class=\"string\">\"</span>\\(x) \\(y)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>The <code>let (x, y)</code> in the example above will take the values of our <code>(4, 5)</code> <a href=\"lnk::tuple\">tuple</a> and write them into two new variables named <code>x</code> and <code>y</code>.</p>\n<p>We can easily combine this with the other pattern matching operations to develop very powerful patterns. Imagine you have a function that returns an optional tuple <code>(username: String, password: String)?</code>. You'd like to match it and make sure if the password is correct:</p>\n<p>First, our fantastic function (just a prototype):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> usernameAndPassword() \n\n     -&gt; (username: <span class=\"type\">String</span>, password: <span class=\"type\">String</span>)? {... }\n</code></pre></code></pre>\n<p>Now, the <code>switch</code> example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> usernameAndPassword() {\n\n<span class=\"keyword\">case let</span> (<span class=\"keyword\">_</span>, password)? <span class=\"keyword\">where</span> password == \\<span class=\"string\">\"12345</span>\\<span class=\"string\">\"</span>: <span class=\"call\">login</span>()\n\n<span class=\"keyword\">default</span>: <span class=\"call\">logout</span>()\n\n}\n</code></pre></code></pre>\n<p>See how we combined multiple Swift features here, we will go through them step by step:</p>\n<ol>\n<li>We use <code>case let</code> to create new variables</li>\n<li>We use the <code>?</code> operator to <strong>only</strong> match if the optional return value from the\n<code>usernameAndPassword</code> function is not empty.</li>\n<li>We ignore the <code>username</code> part via <code>_</code>, because we're only interested in the <code>password</code></li>\n<li>We use <code>where</code> to make sure our highly secure password is correct</li>\n<li>We use <code>default</code> for all the other cases that fail.</li>\n</ol>\n","raw_content":"[frontMatter]\ntitle = \"Value-Binding Pattern\"\ntags = [\"pattern matching\", \"switch\", \"where\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Value-Binding Pattern\n\nThis is the very same as binding values to variables via `let` or `var`.\nOnly in a switch statement. You\\'ve already seen this before, so I\\'ll\nprovide a very short example:\n\n``` Swift\nswitch (4, 5) {\ncase let (x, y): print(\"\\(x) \\(y)\")\n}\n```\n\nThe `let (x, y)` in the example above will take the values of our `(4, 5)` [tuple](lnk::tuple) and write them into two new variables named `x` and `y`.\n\nWe can easily combine this with the other pattern matching operations to develop very powerful patterns. Imagine you have a function that returns an optional tuple `(username: String, password: String)?`. You'd like to match it and make sure if the password is correct:\n\nFirst, our fantastic function (just a prototype):\n\n``` Swift\nfunc usernameAndPassword() \n    -> (username: String, password: String)? {... }\n```\n\nNow, the `switch` example:\n\n``` Swift\nswitch usernameAndPassword() {\ncase let (_, password)? where password == \"12345\": login()\ndefault: logout()\n}\n```\n\nSee how we combined multiple Swift features here, we will go through them step by step:\n\n1. We use `case let` to create new variables\n2. We use the `?` operator to **only** match if the optional return value from the\n   `usernameAndPassword` function is not empty.\n3. We ignore the `username` part via `_`, because we're only interested in the `password`\n4. We use `where` to make sure our highly secure password is correct\n5. We use `default` for all the other cases that fail.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2016-04-23-associated-types-enum-raw-value-initializers.md":["0d5b538392dcf425",{"identifier":"a24eeed3","filename":"2016-04-23-associated-types-enum-raw-value-initializers.md","info":{"title":"Raw value initializers for enums with associated types","tags":["enum","init","associated"],"keywords":["swift","optional","enum","raw","value","initializers","associated","type"],"category":["Swift Tricks","All"],"created":"2016-04-23 10:30:30","description":"Once you add associated types to an enum the task of creating instances quickly becomes very repetitive. See how a simple trick can greatly simplify this","description_html":"<p>Once you add associated types to an enum the task of creating instances quickly becomes very repetitive. See how a simple trick can greatly simplify this</p>\n","published":true,"slug":"2016-04-23-associated-types-enum-raw-value-initializers.html","meta":{"swift_version":"5.0","feature_image":"https://appventure.me/img-content/2016-04-23-associated-types-enum-raw-value-initializers-feature-image.jpg"},"created_timestamp":1461407430,"date":"2016-04-23T10:30:30","date_info":{"year":2016,"month":4,"day":23,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2016-04-23-associated-types-enum-raw-value-initializers.html","content":"<p><a href=\"lnk::enum\">Enums</a>\nare a beautiful way of structuring information in Swift. Sometimes you\nfind yourself initializing enums from raw values, maybe because the\nvalues were intermittendly stored somewhere else, say in the\n<code>NSUserDefaults</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device: <span class=\"type\">String</span> {\n\n   <span class=\"keyword\">case</span> phone, tablet, watch\n\n}\n\n<span class=\"keyword\">let</span> aDevice = <span class=\"type\">Device</span>(rawValue: \\<span class=\"string\">\"phone</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"call\">print</span>(aDevice)\n</code></pre></code></pre>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">Prints Optional(main.Device.phone)\n</span></code></pre></code></pre>\n<h2>The Problem</h2>\n<p>As soon as you're using associated values in your enums, this doesn't\nwork anymore:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Example {\n\n    <span class=\"keyword\">case</span> <span class=\"type\">Factory</span>(workers: <span class=\"type\">Int</span>)\n\n    <span class=\"keyword\">case</span> <span class=\"type\">House</span>(street: <span class=\"type\">String</span>)\n\n}\n</code></pre></code></pre>\n<p>Swift can't create an instance of <code>Example</code> because the two cases,\n<em>Factory</em> and <em>House</em> have different associated types (the <code>workers</code>\ninteger and the <code>street</code> string. Each invocation of <code>Example</code> requires\ndifferent parameters, so this can't be generalized.</p>\n<p>However, that's not the case when your associated types all match up:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Device {\n\n     <span class=\"keyword\">case</span> phone(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n     <span class=\"keyword\">case</span> watch(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n     <span class=\"keyword\">case</span> tablet(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n}\n</code></pre></code></pre>\n<p>In thise case, all the <code>associated types</code> are the same. There're a\nmyriad of other ways to model this, but I found the device <code>enum</code> to be\na concise example for what I'm about to explain. Even though every\n<code>Device</code> invocation is the same now, you still can't just call it with\nsome sort of raw value and expect the correct type. Instead, what you\nhave to do is perform a\n<a href=\"https://appventure.me/2015/08/20/swift-pattern-matching-in-detail/\">match</a>\nin order to create the correct instance:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> Foundation\n\n\n\n<span class=\"keyword\">enum</span> Device {\n\n     <span class=\"keyword\">case</span> phone(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n     <span class=\"keyword\">case</span> watch(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n     <span class=\"keyword\">case</span> tablet(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n\n\n     <span class=\"keyword\">static func</span> fromDefaults(rawValue: <span class=\"type\">String</span>, name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>) -&gt; <span class=\"type\">Device</span>? {\n\n         <span class=\"keyword\">switch</span> rawValue {\n\n         <span class=\"keyword\">case</span> \\<span class=\"string\">\"phone</span>\\<span class=\"string\">\"</span>: <span class=\"keyword\">return</span> <span class=\"type\">Device</span>.<span class=\"call\">phone</span>(name: name, screenSize: screenSize)\n\n         <span class=\"keyword\">case</span> \\<span class=\"string\">\"watch</span>\\<span class=\"string\">\"</span>: <span class=\"keyword\">return</span> <span class=\"type\">Device</span>.<span class=\"call\">watch</span>(name: name, screenSize: screenSize)\n\n         <span class=\"keyword\">case</span> \\<span class=\"string\">\"tablet</span>\\<span class=\"string\">\"</span>: <span class=\"keyword\">return</span> <span class=\"type\">Device</span>.<span class=\"call\">tablet</span>(name: name, screenSize: screenSize)\n\n         <span class=\"keyword\">default</span>: <span class=\"keyword\">return nil</span>\n\n         }\n\n     }\n\n}\n\n<span class=\"keyword\">let</span> b = <span class=\"type\">Device</span>.<span class=\"call\">fromDefaults</span>(rawValue: \\<span class=\"string\">\"phone</span>\\<span class=\"string\">\"</span>, name: \\<span class=\"string\">\"iPhone</span> <span class=\"type\">SE</span>\\<span class=\"string\">\"</span>, screenSize: <span class=\"type\">CGSize</span>(width: <span class=\"number\">640</span>, height: <span class=\"number\">1136</span>))\n\n<span class=\"call\">print</span>(b)\n</code></pre></code></pre>\n<pre class=\"Swift\"><code>prints <span class=\"type\">Optional</span>(main.<span class=\"type\">Device</span>.<span class=\"call\">phone</span>(\\<span class=\"string\">\"iPhone</span> <span class=\"type\">SE</span>\\<span class=\"string\">\"</span>, (<span class=\"number\">640.0</span>, <span class=\"number\">1136.0</span>)))\n</code></pre></code></pre>\n<p>This looks ok, but it <strong>is</strong> already a bit of repetitive code. Once you\ndevelop more than just three enum cases / two associated types, this\nwill quickly get out of hand.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Vehicle {\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">car</span>(wheels: <span class=\"type\">Int</span>, capacity: <span class=\"type\">Int</span>, weight: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, color: <span class=\"type\">Int</span>, name: <span class=\"type\">Int</span>, producer: <span class=\"type\">Int</span>, creation: <span class=\"type\">NSDate</span>, amountOfProducedUnits: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">ship</span>(wheels: <span class=\"type\">Int</span>, capacity: <span class=\"type\">Int</span>, weight: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, color: <span class=\"type\">Int</span>, name: <span class=\"type\">Int</span>, producer: <span class=\"type\">Int</span>, creation: <span class=\"type\">NSDate</span>, amountOfProducedUnits: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">yacht</span>(wheels: <span class=\"type\">Int</span>, capacity: <span class=\"type\">Int</span>, weight: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, color: <span class=\"type\">Int</span>, name: <span class=\"type\">Int</span>, producer: <span class=\"type\">Int</span>, creation: <span class=\"type\">NSDate</span>, amountOfProducedUnits: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">truck</span>(wheels: <span class=\"type\">Int</span>, capacity: <span class=\"type\">Int</span>, weight: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, color: <span class=\"type\">Int</span>, name: <span class=\"type\">Int</span>, producer: <span class=\"type\">Int</span>, creation: <span class=\"type\">NSDate</span>, amountOfProducedUnits: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">motorbike</span>(wheels: <span class=\"type\">Int</span>, capacity: <span class=\"type\">Int</span>, weight: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, color: <span class=\"type\">Int</span>, name: <span class=\"type\">Int</span>, producer: <span class=\"type\">Int</span>, creation: <span class=\"type\">NSDate</span>, amountOfProducedUnits: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">helicopter</span>(wheels: <span class=\"type\">Int</span>, capacity: <span class=\"type\">Int</span>, weight: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, color: <span class=\"type\">Int</span>, name: <span class=\"type\">Int</span>, producer: <span class=\"type\">Int</span>, creation: <span class=\"type\">NSDate</span>, amountOfProducedUnits: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> .<span class=\"dotAccess\">train</span>(wheels: <span class=\"type\">Int</span>, capacity: <span class=\"type\">Int</span>, weight: <span class=\"type\">Int</span>, length: <span class=\"type\">Int</span>, height: <span class=\"type\">Int</span>, width: <span class=\"type\">Int</span>, color: <span class=\"type\">Int</span>, name: <span class=\"type\">Int</span>, producer: <span class=\"type\">Int</span>, creation: <span class=\"type\">NSDate</span>, amountOfProducedUnits: <span class=\"type\">Int</span>)\n\n   ...\n\n}\n</code></pre></code></pre>\n<p>I think you get my point.</p>\n<h2>The Solution</h2>\n<p>So.. how do we solve this? Interestingly, there's a quirky similarity\nbetween the initializer of an associated type and a closure. Take this\ncode:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Example {\n\n   <span class=\"keyword\">case</span> test(x: <span class=\"type\">Int</span>)\n\n}\n\n<span class=\"keyword\">let</span> exampleClosure = <span class=\"type\">Example</span>.<span class=\"property\">test</span>\n</code></pre></code></pre>\n<p>What is the type of <code>exampleClosure</code> here? The type is\n<code>(Int) -&gt; Example</code>. That's right, calling an associated value <code>enum</code>\ncase without any parameters will yield a closure that, when called with\nthe correct types, will return an instance of said type.</p>\n<p>This means that, the following is valid, working Swift:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Fruit {\n\n   <span class=\"keyword\">case</span> apple(amount: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> orange(amount: <span class=\"type\">Int</span>)\n\n}\n\n<span class=\"keyword\">let</span> appleMaker = <span class=\"type\">Fruit</span>.<span class=\"property\">apple</span>\n\n<span class=\"keyword\">let</span> firstApple = <span class=\"call\">appleMaker</span>(amount: <span class=\"number\">10</span>)\n\n<span class=\"keyword\">let</span> secondApple = <span class=\"call\">appleMaker</span>(amount: <span class=\"number\">12</span>)\n\n\n\n<span class=\"call\">print</span>(firstApple, secondApple)\n</code></pre></code></pre>\n<p>So, how would that help us simplify the gross code duplication problem\nabove? Have a look:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> Foundation\n\n\n\n<span class=\"keyword\">enum</span> Device {\n\n     <span class=\"keyword\">case</span> phone(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n     <span class=\"keyword\">case</span> watch(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n     <span class=\"keyword\">case</span> tablet(name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>)\n\n\n\n     <span class=\"keyword\">private static var</span> initializers: [<span class=\"type\">String</span>: (name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>) -&gt; <span class=\"type\">Device</span>] = {\n\n         <span class=\"keyword\">return</span> [\\<span class=\"string\">\"phone</span>\\<span class=\"string\">\"</span>: <span class=\"type\">Device</span>.<span class=\"property\">phone</span>, \\<span class=\"string\">\"watch</span>\\<span class=\"string\">\"</span>: <span class=\"type\">Device</span>.<span class=\"property\">watch</span>, \\<span class=\"string\">\"tablet</span>\\<span class=\"string\">\"</span>: <span class=\"type\">Device</span>.<span class=\"property\">tablet</span>]\n\n     }()\n\n\n\n     <span class=\"keyword\">static func</span> fromDefaults(rawValue: <span class=\"type\">String</span>, name: <span class=\"type\">String</span>, screenSize: <span class=\"type\">CGSize</span>) -&gt; <span class=\"type\">Device</span>? {\n\n         <span class=\"keyword\">return</span> <span class=\"type\">Device</span>.<span class=\"property\">initializers</span>[rawValue]?(name: name, screenSize: screenSize)\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">let</span> iPhone = <span class=\"type\">Device</span>.<span class=\"call\">fromDefaults</span>(rawValue: \\<span class=\"string\">\"phone</span>\\<span class=\"string\">\"</span>, name: \\<span class=\"string\">\"iPhone</span> <span class=\"type\">SE</span>\\<span class=\"string\">\"</span>, screenSize: <span class=\"type\">CGSize</span>(width: <span class=\"number\">640</span>, height: <span class=\"number\">1134</span>))\n\n<span class=\"call\">print</span>(iPhone)\n</code></pre></code></pre>\n<pre class=\"Swift\"><code><span class=\"type\">Optional</span>(main.<span class=\"type\">Device</span>.<span class=\"call\">phone</span>(\\<span class=\"string\">\"iPhone</span> <span class=\"type\">SE</span>\\<span class=\"string\">\"</span>, (<span class=\"number\">640.0</span>, <span class=\"number\">1134.0</span>)))\n</code></pre></code></pre>\n<p>So, let's try to figure out what happened here. We have a new property\n<code>initializers</code> on our <code>Device</code>. It's a <code>Dictionary</code> of type\n<code>[String: (name: String, screenSize: CGSize) -&gt; Device]</code>. I.e. something\nthat maps from a <code>String</code> key to a closure with the same type as our\n<code>Device</code> cases. The dictionary contains the initializers of each of our\ndistinct cases, simply by using the same trick as above, just handing in\nthe closure: <code>phone:Device.phone</code></p>\n<p>The <code>fromDefaults</code> function, then, only has to know the key of the\ndevice we'd like to create, and it can call the appropriate closure.\nThis leads to a much shorter implementation, especially for bigger enums\n(like our <strong>Vehicle</strong> example above). As you can see, creating a\n<code>Device</code> instance is then as simple as:</p>\n<pre class=\"Swift\"><code><span class=\"type\">Device</span>.<span class=\"property\">initializers</span>[\\<span class=\"string\">\"phone</span>\\<span class=\"string\">\"</span>]?(name: \\<span class=\"string\">\"iPhone</span> <span class=\"number\">5</span>\\<span class=\"string\">\"</span>, screenSize: <span class=\"type\">CGSize</span>(width: <span class=\"number\">640</span>, height: <span class=\"number\">1134</span>)))\n</code></pre></code></pre>\n<p>Just as with raw values, in case there is no <code>enum</code> case <strong>phone</strong> we'd\njust get an empty optional back.</p>\n<p>This solution isn't perfect of course. You still have to have the\n<code>initializers</code> dictionary, however it will be much less repetitve than\nhaving to <code>match</code> over all cases manually.</p>\n<p>Finally, I suppose it goes without saying that the code above ignores an\nimportant best practice to be concise and to be able to concentrate on\nthe task at hand; Nevertheless: having stringified code like\n<code>Device.initializers[&quot;phone&quot;]</code> is not the best way to write this.\nInstead, those keys should be properly defined somewhere else.</p>\n","raw_content":"[frontMatter]\ndescription = \"Once you add associated types to an enum the task of creating instances quickly becomes very repetitive. See how a simple trick can greatly simplify this\"\ntitle = \"Raw value initializers for enums with associated types\"\ncreated = \"2016-04-23\"\npublished = true\nkeywords = [\"swift\", \"optional\", \"enum\", \"raw\", \"value\", \"initializers\", \"associated\", \"type\"]\nslug = \"2016-04-23-associated-types-enum-raw-value-initializers.html\"\ntags = [\"enum\", \"init\", \"associated\"]\ncategory = [\"Swift Tricks\", \"All\"]\n\n[meta]\nswift_version = \"5.0\"\nfeature_image = \"https://appventure.me/img-content/2016-04-23-associated-types-enum-raw-value-initializers-feature-image.jpg\"\n---\n\n[Enums](lnk::enum)\nare a beautiful way of structuring information in Swift. Sometimes you\nfind yourself initializing enums from raw values, maybe because the\nvalues were intermittendly stored somewhere else, say in the\n`NSUserDefaults`:\n\n``` Swift\nenum Device: String {\n  case phone, tablet, watch\n}\nlet aDevice = Device(rawValue: \"phone\")\nprint(aDevice)\n```\n\n``` {.example}\nPrints Optional(main.Device.phone)\n```\n\n## The Problem\n\nAs soon as you\\'re using associated values in your enums, this doesn\\'t\nwork anymore:\n\n``` Swift\nenum Example {\n   case Factory(workers: Int)\n   case House(street: String)\n}\n```\n\nSwift can\\'t create an instance of `Example` because the two cases,\n*Factory* and *House* have different associated types (the `workers`\ninteger and the `street` string. Each invocation of `Example` requires\ndifferent parameters, so this can\\'t be generalized.\n\nHowever, that\\'s not the case when your associated types all match up:\n\n``` Swift\nenum Device {\n    case phone(name: String, screenSize: CGSize)\n    case watch(name: String, screenSize: CGSize)\n    case tablet(name: String, screenSize: CGSize)\n}\n```\n\nIn thise case, all the `associated types` are the same. There\\'re a\nmyriad of other ways to model this, but I found the device `enum` to be\na concise example for what I\\'m about to explain. Even though every\n`Device` invocation is the same now, you still can\\'t just call it with\nsome sort of raw value and expect the correct type. Instead, what you\nhave to do is perform a\n[match](https://appventure.me/2015/08/20/swift-pattern-matching-in-detail/)\nin order to create the correct instance:\n\n``` Swift\nimport Foundation\n\nenum Device {\n    case phone(name: String, screenSize: CGSize)\n    case watch(name: String, screenSize: CGSize)\n    case tablet(name: String, screenSize: CGSize)\n\n    static func fromDefaults(rawValue: String, name: String, screenSize: CGSize) -> Device? {\n        switch rawValue {\n        case \"phone\": return Device.phone(name: name, screenSize: screenSize)\n        case \"watch\": return Device.watch(name: name, screenSize: screenSize)\n        case \"tablet\": return Device.tablet(name: name, screenSize: screenSize)\n        default: return nil\n        }\n    }\n}\nlet b = Device.fromDefaults(rawValue: \"phone\", name: \"iPhone SE\", screenSize: CGSize(width: 640, height: 1136))\nprint(b)\n```\n\n``` Swift\nprints Optional(main.Device.phone(\"iPhone SE\", (640.0, 1136.0)))\n```\n\nThis looks ok, but it **is** already a bit of repetitive code. Once you\ndevelop more than just three enum cases / two associated types, this\nwill quickly get out of hand.\n\n``` Swift\nenum Vehicle {\n  case .car(wheels: Int, capacity: Int, weight: Int, length: Int, height: Int, width: Int, color: Int, name: Int, producer: Int, creation: NSDate, amountOfProducedUnits: Int)\n  case .ship(wheels: Int, capacity: Int, weight: Int, length: Int, height: Int, width: Int, color: Int, name: Int, producer: Int, creation: NSDate, amountOfProducedUnits: Int)\n  case .yacht(wheels: Int, capacity: Int, weight: Int, length: Int, height: Int, width: Int, color: Int, name: Int, producer: Int, creation: NSDate, amountOfProducedUnits: Int)\n  case .truck(wheels: Int, capacity: Int, weight: Int, length: Int, height: Int, width: Int, color: Int, name: Int, producer: Int, creation: NSDate, amountOfProducedUnits: Int)\n  case .motorbike(wheels: Int, capacity: Int, weight: Int, length: Int, height: Int, width: Int, color: Int, name: Int, producer: Int, creation: NSDate, amountOfProducedUnits: Int)\n  case .helicopter(wheels: Int, capacity: Int, weight: Int, length: Int, height: Int, width: Int, color: Int, name: Int, producer: Int, creation: NSDate, amountOfProducedUnits: Int)\n  case .train(wheels: Int, capacity: Int, weight: Int, length: Int, height: Int, width: Int, color: Int, name: Int, producer: Int, creation: NSDate, amountOfProducedUnits: Int)\n  ...\n}\n```\n\nI think you get my point.\n\n## The Solution\n\nSo.. how do we solve this? Interestingly, there\\'s a quirky similarity\nbetween the initializer of an associated type and a closure. Take this\ncode:\n\n``` Swift\nenum Example {\n  case test(x: Int)\n}\nlet exampleClosure = Example.test\n```\n\nWhat is the type of `exampleClosure` here? The type is\n`(Int) -> Example`. That\\'s right, calling an associated value `enum`\ncase without any parameters will yield a closure that, when called with\nthe correct types, will return an instance of said type.\n\nThis means that, the following is valid, working Swift:\n\n``` Swift\nenum Fruit {\n  case apple(amount: Int)\n  case orange(amount: Int)\n}\nlet appleMaker = Fruit.apple\nlet firstApple = appleMaker(amount: 10)\nlet secondApple = appleMaker(amount: 12)\n\nprint(firstApple, secondApple)\n```\n\nSo, how would that help us simplify the gross code duplication problem\nabove? Have a look:\n\n``` Swift\nimport Foundation\n\nenum Device {\n    case phone(name: String, screenSize: CGSize)\n    case watch(name: String, screenSize: CGSize)\n    case tablet(name: String, screenSize: CGSize)\n\n    private static var initializers: [String: (name: String, screenSize: CGSize) -> Device] = {\n        return [\"phone\": Device.phone, \"watch\": Device.watch, \"tablet\": Device.tablet]\n    }()\n\n    static func fromDefaults(rawValue: String, name: String, screenSize: CGSize) -> Device? {\n        return Device.initializers[rawValue]?(name: name, screenSize: screenSize)\n    }\n}\n\nlet iPhone = Device.fromDefaults(rawValue: \"phone\", name: \"iPhone SE\", screenSize: CGSize(width: 640, height: 1134))\nprint(iPhone)\n```\n\n``` Swift\nOptional(main.Device.phone(\"iPhone SE\", (640.0, 1134.0)))\n```\n\nSo, let\\'s try to figure out what happened here. We have a new property\n`initializers` on our `Device`. It\\'s a `Dictionary` of type\n`[String: (name: String, screenSize: CGSize) -> Device]`. I.e. something\nthat maps from a `String` key to a closure with the same type as our\n`Device` cases. The dictionary contains the initializers of each of our\ndistinct cases, simply by using the same trick as above, just handing in\nthe closure: `phone:Device.phone`\n\nThe `fromDefaults` function, then, only has to know the key of the\ndevice we\\'d like to create, and it can call the appropriate closure.\nThis leads to a much shorter implementation, especially for bigger enums\n(like our **Vehicle** example above). As you can see, creating a\n`Device` instance is then as simple as:\n\n``` Swift\nDevice.initializers[\"phone\"]?(name: \"iPhone 5\", screenSize: CGSize(width: 640, height: 1134)))\n```\n\nJust as with raw values, in case there is no `enum` case **phone** we\\'d\njust get an empty optional back.\n\nThis solution isn\\'t perfect of course. You still have to have the\n`initializers` dictionary, however it will be much less repetitve than\nhaving to `match` over all cases manually.\n\nFinally, I suppose it goes without saying that the code above ignores an\nimportant best practice to be concise and to be able to concentrate on\nthe task at hand; Nevertheless: having stringified code like\n`Device.initializers[\"phone\"]` is not the best way to write this.\nInstead, those keys should be properly defined somewhere else.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/legacy_api.md":["c03434912a98a643",{"identifier":"b2ed7e7c","filename":"legacy_api.md","info":{"title":"Legacy API and Value Extractions","tags":["pattern matching","switch","where"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-legacy-api-and-value-extractions.html","content":"<h1>Legacy API and Value Extractions</h1>\n<p>Oftentimes, when you get data from an external source, like a library,\nor an API, it is not only good practice but usually even required that\nyou check the data for consistency before interpreting it. You need to\nmake sure that all keys exists or that the data is of the correct type,\nor the arrays have the required length. Not doing so can lead from buggy\nbehaviour (missing key) to crash of the app (indexing non-existent array\nitems). The classic way to do this is by nesting <code>if</code> statements.</p>\n<p>Let's imagine an API that returns a user. However, there're two types\nof users: System users - like the administrator, or the postmaster - and\nlocal users - like &quot;John B&quot;, &quot;Bill Gates&quot;, etc. Due to the way the\nsystem was designed and grew, there're a couple of nuisances that API\nconsumers have to deal with:</p>\n<ul>\n<li><code>system</code> and <code>local</code> users come via the same API call.</li>\n<li>the <code>department</code> key may not exist, since early versions of the db\ndid not have that field and early employees never had to fill it\nout.</li>\n<li>the <code>name</code> array contains either 4 items (username, middlename,\nlastname, firstname) or 2 items (full name, username) depending on\nwhen the user was created.</li>\n<li>the <code>age</code> is an Integer with the age of the user</li>\n</ul>\n<p>Our system needs to create user accounts for all system users from this\nAPI with only the following information: username, department. We only\nneed users born before 1980. If no department is given, &quot;Corp&quot; is\nassumed.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> legacyAPI(id: <span class=\"type\">Int</span>) -&gt; [<span class=\"type\">String</span>: <span class=\"type\">Any</span>] {\n\n     <span class=\"keyword\">return</span> [\\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"department</span>\\<span class=\"string\">\"</span>: \\<span class=\"string\">\"Dark</span> <span class=\"type\">Arts</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>: <span class=\"number\">57</span>, \n\n            \\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>: [\\<span class=\"string\">\"voldemort</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Tom</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Marvolo</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Riddle</span>\\<span class=\"string\">\"</span>]] \n\n}\n</code></pre></code></pre>\n<p>Given these constraints, let's develop a pattern match for it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> item = <span class=\"call\">legacyAPI</span>(<span class=\"number\">4</span>)\n\n<span class=\"keyword\">switch</span> (item[\\<span class=\"string\">\"type</span>\\<span class=\"string\">\"</span>], item[\\<span class=\"string\">\"department</span>\\<span class=\"string\">\"</span>], item[\\<span class=\"string\">\"age</span>\\<span class=\"string\">\"</span>], item[\\<span class=\"string\">\"name</span>\\<span class=\"string\">\"</span>]) {\n\n<span class=\"keyword\">case let</span> (sys <span class=\"keyword\">as</span> <span class=\"type\">String</span>, dep <span class=\"keyword\">as</span> <span class=\"type\">String</span>, age <span class=\"keyword\">as</span> <span class=\"type\">Int</span>, name <span class=\"keyword\">as</span> [<span class=\"type\">String</span>]) <span class=\"keyword\">where</span> \n\n   age &lt; <span class=\"number\">1980</span> &amp;&amp;\n\n   sys == \\<span class=\"string\">\"system</span>\\<span class=\"string\">\"</span>:\n\n   <span class=\"call\">createSystemUser</span>(name.<span class=\"property\">count</span> == <span class=\"number\">2</span> ? name.<span class=\"property\">last</span>! : name.<span class=\"property\">first</span>!, dep: dep ?? \\<span class=\"string\">\"Corp</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>:()\n\n}\n\n\n\n<span class=\"comment\">// returns (\\\"voldemort\\\", \\\"Dark Arts\\\")</span>\n</code></pre></code></pre>\n<p>Note that this code makes one dangerous assumption, which is that if the\nname array does not have 2 items, it <strong>must</strong> have 4 items. If that case\ndoesn't hold, and we get a zero item name array, this would crash.</p>\n<p>Other than that, it is a nice example of how pattern matching even with\njust one case can help you write cleaner code and simplify value\nextractions.</p>\n<p>Also, see how we're writing <code>let</code> at the beginning right after the\ncase, and don't have to repeat it for each assignment within the case.</p>\n","raw_content":"[frontMatter]\ntitle = \"Legacy API and Value Extractions\"\ntags = [\"pattern matching\", \"switch\", \"where\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Legacy API and Value Extractions\n\nOftentimes, when you get data from an external source, like a library,\nor an API, it is not only good practice but usually even required that\nyou check the data for consistency before interpreting it. You need to\nmake sure that all keys exists or that the data is of the correct type,\nor the arrays have the required length. Not doing so can lead from buggy\nbehaviour (missing key) to crash of the app (indexing non-existent array\nitems). The classic way to do this is by nesting `if` statements.\n\nLet\\'s imagine an API that returns a user. However, there\\'re two types\nof users: System users - like the administrator, or the postmaster - and\nlocal users - like \\\"John B\\\", \\\"Bill Gates\\\", etc. Due to the way the\nsystem was designed and grew, there\\'re a couple of nuisances that API\nconsumers have to deal with:\n\n-   `system` and `local` users come via the same API call.\n-   the `department` key may not exist, since early versions of the db\n    did not have that field and early employees never had to fill it\n    out.\n-   the `name` array contains either 4 items (username, middlename,\n    lastname, firstname) or 2 items (full name, username) depending on\n    when the user was created.\n-   the `age` is an Integer with the age of the user\n\nOur system needs to create user accounts for all system users from this\nAPI with only the following information: username, department. We only\nneed users born before 1980. If no department is given, \\\"Corp\\\" is\nassumed.\n\n``` Swift\nfunc legacyAPI(id: Int) -> [String: Any] {\n    return [\"type\": \"system\", \"department\": \"Dark Arts\", \"age\": 57, \n           \"name\": [\"voldemort\", \"Tom\", \"Marvolo\", \"Riddle\"]] \n}\n```\n\nGiven these constraints, let\\'s develop a pattern match for it:\n\n``` Swift\nlet item = legacyAPI(4)\nswitch (item[\"type\"], item[\"department\"], item[\"age\"], item[\"name\"]) {\ncase let (sys as String, dep as String, age as Int, name as [String]) where \n  age < 1980 &&\n  sys == \"system\":\n  createSystemUser(name.count == 2 ? name.last! : name.first!, dep: dep ?? \"Corp\")\ndefault:()\n}\n\n// returns (\"voldemort\", \"Dark Arts\")\n```\n\nNote that this code makes one dangerous assumption, which is that if the\nname array does not have 2 items, it **must** have 4 items. If that case\ndoesn\\'t hold, and we get a zero item name array, this would crash.\n\nOther than that, it is a nice example of how pattern matching even with\njust one case can help you write cleaner code and simplify value\nextractions.\n\nAlso, see how we\\'re writing `let` at the beginning right after the\ncase, and don\\'t have to repeat it for each assignment within the case.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/tips/intro.md":["9fe3d67fedfebb00",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Tips for using KeyPaths","tags":["keypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-tips-for-using-keypaths.html","content":"<h1>Three tips for using KeyPaths</h1>\n<p>This chapter will highlight a couple of very useful tricks that you can keep in mind writing code in order to identify situations where keypaths are helpful.</p>\n","raw_content":"[frontMatter]\ntitle = \"Tips for using KeyPaths\"\ntags = [\"keypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Three tips for using KeyPaths\n\nThis chapter will highlight a couple of very useful tricks that you can keep in mind writing code in order to identify situations where keypaths are helpful.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/tuples/complete_book.html":["e3b0c44298fc1c14",{"identifier":"9696","filename":"complete_book.html","info":{"title":"Tuples in Swift, Advanced Usage and Best Practices","tags":[],"keywords":["swift","tuples","generics","feature"],"category":[],"created":"2015-07-19 10:30:30","description":"A brief introduction into Swift's tuples including a basic introduction and several useful tips for advanced usage.","description_html":"<p>A brief introduction into Swift's tuples including a basic introduction and several useful tips for advanced usage.</p>\n","published":true,"slug":"2015-07-19-tuples-swift-advanced-usage-best-practices.html","meta":{"swift_version":"5.1","short_code":"<pre class='Swift'><code><span class='source swift'>(<span class='apvconstant apvnumeric apvinteger apvdecimal apvswift'>18</span>, <span class='apvmeta apvliteral apvstring swift'><span class='apvstring apvquoted apvdouble swift'>&quot;</span><span class='apvstring apvquoted apvdouble swift'>C</span><span class='apvstring apvquoted apvdouble swift'>a</span><span class='apvstring apvquoted apvdouble swift'>r</span><span class='apvstring apvquoted apvdouble swift'>l</span><span class='apvstring apvquoted apvdouble swift'>&quot;</span></span>, [<span class='apvconstant apvnumeric apvinteger apvdecimal swift'>3</span>, <span class='apvconstant apvnumeric apvinteger apvdecimal swift'>5</span>, <span class='apvconstant apvnumeric apvinteger apvdecimal swift'>1</span>]) </span></code></pre></code></pre>","short_title":"🍱 Tuples"},"created_timestamp":1437301830,"date":"2015-07-19T10:30:30","date_info":{"year":2015,"month":7,"day":19,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/tuples/complete_book.html","content":"<h1>Introduction</h1>\n<p>Tuples are one of Swift's less visible language features. They occupy a\nsmall space between Structs and Arrays. In addition, there's no\ncomparable construct in Objective-C (or many other languages). Finally,\nthe usage of tuples in the standard library and in Apple's example code\nis sparse. One could get the impression that their raison d'être in\nSwift is pattern matching, but we disgress.</p>\n<p>Most tuple explanations concentrate on three tuple use cases (pattern\nmatching, return values, destructuring) and leave it at that. The\nfollowing guide tries to give a more comprehensive overview of tuples\nwith best practices of when to use them and when not to use them.</p>\n<h1>The absolute Basics</h1>\n<p>A tuple can combine different types into one. Where an array is a sequence\nof a certain type (<code>let x: [Int] = [1, 2, 3, 4, 5]</code>) a tuple can have\na different type for each element: <code>let x: (Int, Double, String) = (5, 2.0, &quot;Hey&quot;)</code>.</p>\n<p>Tuples are a very simple manner of grouping related data items together without having\nto create a struct.</p>\n<p>They are value types and even though they look like sequences they aren't.\nOne main difference is that you can't easily loop over the contents of a tuple.</p>\n<p>We'll start with a quick primer on how to create and use tuples.</p>\n<h1>Creating and Accessing Tuples</h1>\n<pre class=\"Swift\"><code><span class=\"comment\">// Constructing a simple tuple</span>\n\n<span class=\"keyword\">let</span> tuple1 = (<span class=\"number\">2</span>, <span class=\"number\">3</span>)\n\n<span class=\"keyword\">let</span> tuple2 = (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)\n\n\n\n<span class=\"comment\">// Constructing a named tuple</span>\n\n<span class=\"keyword\">let</span> tupl3 = (x: <span class=\"number\">5</span>, y: <span class=\"number\">3</span>)\n\n\n\n<span class=\"comment\">// Different types</span>\n\n<span class=\"keyword\">let</span> tuple4 = (name: \\<span class=\"string\">\"Carl</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">78</span>, pets: [\\<span class=\"string\">\"Bonny</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Houdon</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Miki</span>\\<span class=\"string\">\"</span>])\n\n\n</code></pre></code></pre>\n<p>Once you've created some tuples, you can access their elements:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Accessing tuple elements</span>\n\n<span class=\"keyword\">let</span> tuple5 = (<span class=\"number\">13</span>, <span class=\"number\">21</span>)\n\ntuple5.<span class=\"number\">0</span> <span class=\"comment\">// 13</span>\n\ntuple5.<span class=\"number\">1</span> <span class=\"comment\">// 21</span>\n\n\n\n<span class=\"comment\">// Access by name</span>\n\n<span class=\"keyword\">let</span> tuple6 = (x: <span class=\"number\">21</span>, y: <span class=\"number\">33</span>)\n\ntuple6.<span class=\"property\">x</span> <span class=\"comment\">// 21</span>\n\ntuple6.<span class=\"property\">y</span> <span class=\"comment\">// 33</span>\n</code></pre></code></pre>\n<p>Nice, so now you can create tuples and access their elements. But what would you\nuse them for? The use case we will discuss is for <code>pattern matching</code>.</p>\n<h1>Tuples for Pattern Matching</h1>\n<p>Pattern matching oftentimes feels like the strongest use case for\ntuples. Swift's <code>switch</code> statement offers a really powerful yet easy\nway to define complex conditionals without cluttering up the source\ncode. You can then match for the type, existence, and value of multiple\nvariables in one statement.</p>\n<p>We wrote a game where both players have to take a quiz. After each question we evaluate\nwho won or lost. There're four states:</p>\n<ul>\n<li>Player 1 is correct</li>\n<li>Player 2 is correct</li>\n<li>Both were correct</li>\n<li>Both were wrong</li>\n</ul>\n<p>We can model this logic very nicely with a <code>switch</code> statement such as the following:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> player1 = <span class=\"keyword\">true</span>\n\n<span class=\"keyword\">let</span> player2 = <span class=\"keyword\">false</span>\n\n<span class=\"keyword\">switch</span> (player1, player2) {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Player</span> <span class=\"number\">1</span> won\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Player</span> <span class=\"number\">2</span> won\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Draw</span>, both won\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Draw</span>, both lost\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>Here, we create a tuple <code>(player1, player2)</code> and then match each of\nthe possible cases.</p>\n<p>Much more complex matchings are also possible. Below, we will match over\na tuple that has the type <code>(Int, String?, Any)</code>.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Contrived example</span>\n\n<span class=\"comment\">// These would be return values from various functions.</span>\n\n<span class=\"keyword\">let</span> age: <span class=\"type\">Int</span> = <span class=\"number\">23</span>\n\n<span class=\"keyword\">let</span> job: <span class=\"type\">String</span>? = \\<span class=\"string\">\"Operator</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> payload: <span class=\"type\">Any</span> = [\\<span class=\"string\">\"cars</span>\\<span class=\"string\">\"</span>: <span class=\"number\">1</span>]\n</code></pre></code></pre>\n<p>In the code above, we want to find the persons younger than 30 with a\njob and a Dictionary payload. Imagine the payload as something from the\nObjective-C world, it could be a Dictionary or an Array or a Number,\nweakly typed code that somebody else wrote years ago, and you have to interact with\nit now.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> (age, job, payload) {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> age, <span class=\"keyword\">_</span>?, <span class=\"keyword\">_ as</span> <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">AnyHashable</span>, <span class=\"type\">Any</span>&gt;) <span class=\"keyword\">where</span> age &lt; <span class=\"number\">30</span>:\n\n     <span class=\"call\">print</span>(age)\n\n<span class=\"keyword\">default</span>:\n\n     <span class=\"keyword\">break</span>\n\n}\n</code></pre></code></pre>\n<p>By constructing the switch argument as a tuple <code>(age, job, payload)</code> we\ncan query for specific or nonspecific attributes of all tuple elements\nat once. This allows for elaborately constrained conditionals.</p>\n<h1>Tuples as Return Types</h1>\n<p>Probably the next-best tuple use case is using them to return one-time\nstructures. Tuples as return types makes sense when you need to return\nmultiple return types.</p>\n<p>The following function is required to return a <code>User</code> from our database.\nHowever, in order to speed up processing, the user may be loaded from the\ncache instead of a query. If that's the case, the caller of the function\nshould also receive the information that the <code>User</code> was cached, and how\nlong it was since the last update from the database. We can easily do this\nwith tuples:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> userFromDatabase(id: <span class=\"type\">Int</span>) -&gt; (user: <span class=\"type\">User</span>, cached: <span class=\"type\">Bool</span>, updated: <span class=\"type\">Date</span>) {\n\n    ...\n\n}\n</code></pre></code></pre>\n<p>This function returns three values, the actual user <code>user</code>, whether the user is\ncached <code>cached</code> and when the user was lasted <code>updated</code>.</p>\n<p>This also saves you from introducing a new <code>struct</code> type.</p>\n<p>Since tuples can also be deconstructed on the fly, this even allows re-introducing\nthe variables at the call site:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> (user, cached, lastUpdated) = <span class=\"call\">userFromDatabase</span>()\n</code></pre></code></pre>\n<p>This will create three new variables in the current scope: <code>user</code>, <code>cached</code>, and <code>lastUpdated</code>.\nWe will describe this <code>destructuring</code> in more detail in the next chapter.</p>\n<h1>Tuple Destructuring</h1>\n<p>Swift took a lot of inspiration from different programming languages,\nand this is something that Python has been doing for years. While the\nprevious examples mostly showed how to easily get something into a\ntuple, destructuring is a swifty way of getting something out of a\ntuple, and in line with the <code>abc</code> example above, it looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> abc() -&gt; (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>) {\n\n   <span class=\"keyword\">return</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n\n}\n\n<span class=\"keyword\">let</span> (a, b, c) = <span class=\"call\">abc</span>()\n\n<span class=\"call\">print</span>(a) <span class=\"comment\">// prints 1</span>\n</code></pre></code></pre>\n<p>Another example is getting several function calls into one line:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> (a, b, c) = (<span class=\"call\">a</span>(), <span class=\"call\">b</span>(), <span class=\"call\">c</span>())\n</code></pre></code></pre>\n<p>Or, an easy way to swap two values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> v1: <span class=\"type\">Int</span>\n\n<span class=\"keyword\">var</span> v2: <span class=\"type\">Int</span>\n\n(v1, v2) = (<span class=\"number\">5</span>, <span class=\"number\">4</span>)\n\n(a: v1, b: v2) = (a: v2, b: v1) <span class=\"comment\">// swapped: v1 == 4, v2 == 5</span>\n\n(v1, v2) = (<span class=\"number\">5</span>, <span class=\"number\">4</span>)\n\n(a: v1, b: v2) = (b: v1, a: v2) <span class=\"comment\">// swapped: v1 == 4, v2 == 5</span>\n</code></pre></code></pre>\n<h1>Advanced Tuples</h1>\n<p>Now that we've seen the basics of how to use tuples, we will\nlook at more advanced use cases. This also means there will be\nless often situations where you can apply those patterns.</p>\n<p>Nevertheless, it is still very valuable to have them in your\ntoolbox.</p>\n<h1>Anonymous Structs</h1>\n<p>Tuples as well as structs allow you to combine different types into one\ntype:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> user1 = (name: \\<span class=\"string\">\"Carl</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">40</span>)\n\n<span class=\"comment\">// vs.</span>\n\n<span class=\"keyword\">struct</span> User {\n\n     <span class=\"keyword\">let</span> name: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">let</span> age: <span class=\"type\">Int</span>\n\n}\n\n<span class=\"keyword\">let</span> user2 = <span class=\"type\">User</span>(name: \\<span class=\"string\">\"Steve</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">39</span>)\n</code></pre></code></pre>\n<p>As you can see, these two types are similar, but whereas the tuple\nexists simply as an instance, the struct requires both a struct\ndeclaration and a struct initializer. This similarity can be leveraged\nwhenever you have the need to define a temporary struct inside a\nfunction or method. As the Swift docs say:</p>\n<blockquote>\n<p>Tuples are useful for temporary groups of related values. (...) If\nyour data structure is likely to persist beyond a temporary scope,\nmodel it as a class or structure (...)</p>\n</blockquote>\n<p>As an example of this, consider the following situation where the return\nvalues from several functions first need to be uniquely collected and\nthen inserted:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> zipForUser(userid: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> { <span class=\"keyword\">return</span> \\<span class=\"string\">\"12124</span>\\<span class=\"string\">\"</span> }\n\n<span class=\"keyword\">func</span> streetForUser(userid: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> { <span class=\"keyword\">return</span> \\<span class=\"string\">\"Charles</span> <span class=\"type\">Street</span>\\<span class=\"string\">\"</span> }\n\n<span class=\"keyword\">let</span> users = [user1]\n\n\n\n<span class=\"comment\">// Find all unique streets in our userbase</span>\n\n<span class=\"keyword\">var</span> streets: [<span class=\"type\">String</span>: (zip: <span class=\"type\">String</span>, street: <span class=\"type\">String</span>, count: <span class=\"type\">Int</span>)] = [:]\n\n<span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> users {\n\n     <span class=\"keyword\">let</span> zip = <span class=\"call\">zipForUser</span>(userid: user.<span class=\"property\">name</span>)\n\n     <span class=\"keyword\">let</span> street = <span class=\"call\">streetForUser</span>(userid: user.<span class=\"property\">name</span>)\n\n     <span class=\"keyword\">let</span> key = \\<span class=\"string\">\"</span>\\(zip)-\\(street)\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">if let</span> (<span class=\"keyword\">_</span>, <span class=\"keyword\">_</span>, count) = streets[key] {\n\n         streets[key] = (zip, street, count + <span class=\"number\">1</span>)\n\n     } <span class=\"keyword\">else</span> {\n\n         streets[key] = (zip, street, <span class=\"number\">1</span>)\n\n     }\n\n}\n\n\n\n<span class=\"comment\">// drawStreetsOnMap(streets.values)</span>\n\n<span class=\"keyword\">for</span> street <span class=\"keyword\">in</span> streets.<span class=\"property\">values</span> { <span class=\"call\">print</span>(street) }\n</code></pre></code></pre>\n<p>Here, the tuple is being used as a simple structure for a short-duration\nuse case. Defining a struct would also be possible but not strictly\nnecessary.</p>\n<p>Another example would be a class that handles algorithmic data, and\nyou're moving a temporary result from one method to the next one.\nDefining an extra struct for something only used once (in between two or\nthree methods) may not be required.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Made up algorithm</span>\n\n<span class=\"keyword\">func</span> calculateInterim(values: [<span class=\"type\">Int</span>]) -&gt; \n\n     (r: <span class=\"type\">Int</span>, alpha: <span class=\"type\">CGFloat</span>, chi: (<span class=\"type\">CGFloat</span>, <span class=\"type\">CGFloat</span>)) {\n\n     <span class=\"keyword\">return</span> (values[<span class=\"number\">0</span>], <span class=\"number\">2</span>, (<span class=\"number\">4</span>, <span class=\"number\">8</span>))\n\n}\n\n<span class=\"keyword\">func</span> expandInterim(interim: (r: <span class=\"type\">Int</span>, \n\n                          alpha: <span class=\"type\">CGFloat</span>, \n\n                            chi: (<span class=\"type\">CGFloat</span>, <span class=\"type\">CGFloat</span>))) -&gt; <span class=\"type\">CGFloat</span> {\n\n     <span class=\"keyword\">return</span> <span class=\"type\">CGFloat</span>(interim.<span class=\"property\">r</span>) + interim.<span class=\"property\">alpha</span> + interim.<span class=\"property\">chi</span>.<span class=\"number\">0</span> + interim.<span class=\"property\">chi</span>.<span class=\"number\">1</span>\n\n}\n\n\n\n<span class=\"call\">print</span>(<span class=\"call\">expandInterim</span>(interim: <span class=\"call\">calculateInterim</span>(values: [<span class=\"number\">1</span>])))\n</code></pre></code></pre>\n<p>There is, of course, a fine line here. Defining a struct for one\ninstance is overly complex; defining a tuple 4 times instead of one\nstruct is overly complex too. Finding the sweet spot depends.</p>\n<h1>Private State</h1>\n<p>In addition to the previous example, there are also use cases where\nusing tuples beyond a temporary scope is useful. As\nlong as the scope is private and the tuple's type isn't littered all\nover the implementation, using tuples to store internal state can be\nfine.</p>\n<p>A simple and contrived example would be storing a static UITableView\nstructure that displays various information from a user profile and\ncontains the key path to the actual value as well as a flag noting\nwhether the value can be edited when tapping on the cell.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> tableViewValues = [\n\n     (title: \\<span class=\"string\">\"Age</span>\\<span class=\"string\">\"</span>, value: \\<span class=\"string\">\"user</span>.<span class=\"property\">age</span>\\<span class=\"string\">\"</span>, editable: <span class=\"keyword\">true</span>),\n\n     (\\<span class=\"string\">\"Name</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"user</span>.<span class=\"property\">name</span>.<span class=\"property\">combinedName</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">true</span>),\n\n     (\\<span class=\"string\">\"Username</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"user</span>.<span class=\"property\">name</span>.<span class=\"property\">username</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">false</span>),\n\n     (\\<span class=\"string\">\"ProfilePicture</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"user</span>.<span class=\"property\">pictures</span>.<span class=\"property\">thumbnail</span>\\<span class=\"string\">\"</span>, <span class=\"keyword\">false</span>)]\n</code></pre></code></pre>\n<p>The alternative would be to define a struct, but if the data is a purely\nprivate implementation detail, a tuple works just as well.</p>\n<p>A better example is when you define an object and want to add the\nability to add multiple change listeners to your object. Each listener\nconsists of a name and the closure to be called upon any change:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Action = (<span class=\"keyword\">_</span> change: <span class=\"type\">Any</span>?) -&gt; <span class=\"type\">Void</span>\n\n<span class=\"keyword\">func</span> addListener(name: <span class=\"type\">String</span>, action: <span class=\"keyword\">@escaping</span> <span class=\"type\">Action</span>) { }\n\n<span class=\"keyword\">func</span> removeListener(name: <span class=\"type\">String</span>) { }\n</code></pre></code></pre>\n<p>How will you store these listeners in your object? The obvious solution\nwould be to define a struct, but this is a very limited scope, and the\nstruct will only be internal, and it will be used in only three cases.\nHere, using a tuple may even be the better solution, as the\ndestructuring makes things simpler:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> ListenerStuff {\n\n\n\n     <span class=\"keyword\">typealias</span> Action = (<span class=\"keyword\">_</span> change: <span class=\"type\">Any</span>?) -&gt; <span class=\"type\">Void</span>\n\n\n\n     <span class=\"keyword\">var</span> listeners: [(<span class=\"type\">String</span>, <span class=\"type\">Action</span>)] = []\n\n\n\n     <span class=\"keyword\">func</span> addListener(name: <span class=\"type\">String</span>, action: <span class=\"keyword\">@escaping</span> <span class=\"type\">Action</span>) {\n\n         listeners.<span class=\"call\">append</span>((name, action))\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> removeListener(name: <span class=\"type\">String</span>) {\n\n         <span class=\"keyword\">if let</span> idx = listeners.<span class=\"call\">index</span>(where: { $0.<span class=\"number\">0</span> == name }) {\n\n             listeners.<span class=\"call\">remove</span>(at: idx)\n\n         }\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> execute(change: <span class=\"type\">Int</span>) {\n\n         <span class=\"keyword\">for</span> (<span class=\"keyword\">_</span>, listener) <span class=\"keyword\">in</span> listeners {\n\n             <span class=\"call\">listener</span>(change <span class=\"keyword\">as</span> <span class=\"type\">Any</span>?)\n\n         }\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">var</span> stuff = <span class=\"type\">ListenerStuff</span>()\n\n<span class=\"keyword\">let</span> ourAction: <span class=\"type\">ListenerStuff</span>.<span class=\"type\">Action</span> = { x <span class=\"keyword\">in</span> <span class=\"call\">print</span>(\\<span class=\"string\">\"Change</span> <span class=\"keyword\">is</span> \\(x ?? \\\"NONE\\<span class=\"string\">\"</span>).\\<span class=\"string\">\"</span>) }\n\nstuff.<span class=\"call\">addListener</span>(name: \\<span class=\"string\">\"xx</span>\\<span class=\"string\">\"</span>, action: ourAction)\n\nstuff.<span class=\"call\">execute</span>(change: <span class=\"number\">17</span>)\n</code></pre></code></pre>\n<p>As you can see in the <code>execute</code> function, the destructuring abilities\nmake tuples especially useful in this case, as the contents are directly\ndestructured into the local scope.</p>\n<h1>Fixed-Size Sequences</h1>\n<p>Another area where tuples can be used is when you intend to constrain a\ntype to a fixed number of items. Imagine an object that calculates\nvarious statistics for each month in a year. You need to store a certain\nInteger value for each month separately. The solution that comes to mind\nfirst would of course be:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> monthValuesArray: [<span class=\"type\">Int</span>]\n</code></pre></code></pre>\n<p>However, in this case we don't know whether the property indeed\ncontains 12 elements. A user of our object could accidentally insert 13\nvalues, or 11. We can't tell the type checker that this is a fixed size\narray of 12 items. With a tuple, this specific constraint can easily\nbe put into place:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> monthValues: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)\n</code></pre></code></pre>\n<p>The alternative would be to have the constraining logic in the object's\nfunctionality (say via a <code>guard</code> statement); however, this would be a\nrun time check. The tuple check happens at compile time; your code\nwon't even compile if you try to give 11 months to your object.</p>\n<h1>Variable Arguments</h1>\n<p>Varargs i.e. variable function arguments are a very useful technique for\nsituations where the number of function parameters is unknown.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// classic example</span>\n\n<span class=\"keyword\">func</span> sum(of numbers: <span class=\"type\">Int</span>...) -&gt; <span class=\"type\">Int</span> {\n\n     <span class=\"comment\">// add up all numbers with the + operator</span>\n\n     <span class=\"keyword\">return</span> numbers.<span class=\"call\">reduce</span>(<span class=\"number\">0</span>, +)\n\n}\n\n\n\n<span class=\"keyword\">let</span> theSum = <span class=\"call\">sum</span>(of: <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>) <span class=\"comment\">// 24</span>\n</code></pre></code></pre>\n<p>A tuple can be useful here if your requirement goes beyond simple\nintegers. Take this function, which does a batch update of <code>n</code> entities\nin a database:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> batchUpdate(updates: (<span class=\"type\">String</span>, <span class=\"type\">Int</span>)...) {\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">db</span>.<span class=\"call\">begin</span>()\n\n     <span class=\"keyword\">for</span> (key, value) <span class=\"keyword\">in</span> updates {\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">db</span>.<span class=\"call\">set</span>(key, value)\n\n     }\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">db</span>.<span class=\"call\">end</span>()\n\n}\n\n\n\n<span class=\"call\">batchUpdate</span>(updates: (\\<span class=\"string\">\"tk1</span>\\<span class=\"string\">\"</span>, <span class=\"number\">5</span>), \n\n        (\\<span class=\"string\">\"tk7</span>\\<span class=\"string\">\"</span>, <span class=\"number\">9</span>), \n\n        (\\<span class=\"string\">\"tk21</span>\\<span class=\"string\">\"</span>, <span class=\"number\">44</span>), \n\n        (\\<span class=\"string\">\"tk88</span>\\<span class=\"string\">\"</span>, <span class=\"number\">12</span>))\n</code></pre></code></pre>\n<p>This pattern allows us to model the insertions in a very simple\nmanner without having to introduce additional struct types.</p>\n<h1>Iteration</h1>\n<p>So far, I've tried to steer clear of calling tuples\nsequences or collections because they aren't. Since every element of a\ntuple can have a different type, there's no type-safe way of looping or\nmapping over the contents of a tuple. Well, no beautiful one, that is.</p>\n<p>Swift does offer <a href=\"lnk::reflection\">limited reflection capabilities</a>, and these allow us to\ninspect the elements of a tuple and loop over them. The downside is that\nthe type checker has no way to figure out what the type of each element\nis, and thus everything is typed as <code>Any</code>. It is your job then to cast\nand match this against your possible types to figure out what to do.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> t = (a: <span class=\"number\">5</span>, b: \\<span class=\"string\">\"String</span>\\<span class=\"string\">\"</span>, c: <span class=\"type\">Date</span>())\n\n\n\n<span class=\"keyword\">let</span> mirror = <span class=\"type\">Mirror</span>(reflecting: t)\n\n<span class=\"keyword\">for</span> (label, value) <span class=\"keyword\">in</span> mirror.<span class=\"property\">children</span> {\n\n     <span class=\"keyword\">switch</span> value {\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">Int</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"int</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">String</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"string</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">case is</span> <span class=\"type\">NSDate</span>:\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"nsdate</span>\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">default</span>: ()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This is not as simple as array iteration, but it does work if you really\nneed it.</p>\n<p>You can also abstract this into a nice function which translate your tuple\ntype into a parseable description.</p>\n<h1>Generics</h1>\n<p>There's no <code>Tuple</code> type available in Swift. If you wonder why that is,\nthink about it: every tuple is a totally different type, depending on\nthe types within it. So instead of defining a generic tuple requirement,\nyou define the specific but generic incarnation of the tuple you intend\nto use:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> wantsTuple&lt;T1, T2&gt;(<span class=\"keyword\">_</span> tuple: (<span class=\"type\">T1</span>, <span class=\"type\">T2</span>)) -&gt; <span class=\"type\">T1</span> {\n\n     <span class=\"keyword\">return</span> tuple.<span class=\"number\">0</span>\n\n}\n\n\n\n<span class=\"call\">wantsTuple</span>((\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>)) <span class=\"comment\">// \\\"a\\\"</span>\n\n<span class=\"call\">wantsTuple</span>((<span class=\"number\">1</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// 1</span>\n</code></pre></code></pre>\n<p>You can also use tuples in <code>typealiases</code>, thus allowing subclasses to\nfill out your types with details. This looks fairly useless and\ncomplicated, but I've already had a use case where I need to do exactly\nthis.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> BaseClass&lt;A,B&gt; {\n\n     <span class=\"keyword\">typealias</span> Element = (<span class=\"type\">A</span>, <span class=\"type\">B</span>)\n\n     <span class=\"keyword\">func</span> add(<span class=\"keyword\">_</span> elm: <span class=\"type\">Element</span>) {\n\n         <span class=\"call\">print</span>(elm)\n\n     }\n\n}\n\n\n\n<span class=\"keyword\">class</span> IntegerClass&lt;B&gt; : <span class=\"type\">BaseClass</span>&lt;<span class=\"type\">Int</span>, <span class=\"type\">B</span>&gt; {\n\n}\n\n\n\n<span class=\"keyword\">let</span> example = <span class=\"type\">IntegerClass</span>&lt;<span class=\"type\">String</span>&gt;()\n\nexample.<span class=\"call\">add</span>((<span class=\"number\">5</span>, \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>))\n\n<span class=\"comment\">// Prints (5, \\\"\\\")</span>\n</code></pre></code></pre>\n<p>You can also define a <code>typealias</code> with generic parameters\nlike in this example where we introduce a custom <code>Either</code> type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> MyEither&lt;A, B&gt; = (left: <span class=\"type\">A</span>, right: <span class=\"type\">B</span>)\n</code></pre></code></pre>\n<h1>Type Aliases</h1>\n<p>In many of the earlier examples, we rewrote a certain tuple type like\n<code>(Int, Int, String)</code> multiple times. This, of course, is not necessary,\nas we could define a <code>typealias</code> for it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Example = (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">String</span>)\n\n<span class=\"keyword\">func</span> add(elm: <span class=\"type\">Example</span>) { }\n</code></pre></code></pre>\n<p>However, if you're using a certain tuple construction so often that you\nthink about adding a typealias for it, you might really be better off\ndefining a struct.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/enumeration_case_pattern.md":["9d2bfd769f51fe47",{"identifier":"84dfcd81","filename":"enumeration_case_pattern.md","info":{"title":"Enumeration Case Pattern","tags":["pattern matching","switch","enum"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-enumeration-case-pattern.html","content":"<h1>Enumeration Case Pattern</h1>\n<p>As you saw in our trading example, pattern matching works <strong>really\ngreat</strong> with Swift's <code>enums</code>. That's because <code>enum cases</code> are like\nsealed, immutable, destructable structs. Much like with <code>tuples</code>, you\ncan unwrap the contents of an individual case right in the match and\nonly extract the information you need.</p>\n<p>Imagine you're writing a game in a functional style and you have a\ncouple of entities that you need to define. You could use <code>structs</code> but\nas your entities will have very little state, you feel that that's a\nbit of an overkill.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Entities {\n\n     <span class=\"keyword\">case</span> soldier(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> tank(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> player(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)\n\n}\n</code></pre></code></pre>\n<p>Now you need to implement the drawing loop. Here, we only need the X and\nY position:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> <span class=\"call\">entities</span>() {\n\n     <span class=\"keyword\">switch</span> e {\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">soldier</span>(x, y):\n\n       <span class=\"call\">drawImage</span>(\\<span class=\"string\">\"soldier</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>, x, y)\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">tank</span>(x, y):\n\n       <span class=\"call\">drawImage</span>(\\<span class=\"string\">\"tank</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>, x, y)\n\n     <span class=\"keyword\">case let</span> .<span class=\"call\">player</span>(x, y):\n\n       <span class=\"call\">drawImage</span>(\\<span class=\"string\">\"player</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>, x, y)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This is the gist of it. The <code>enumeration case pattern</code> is really just\nusing <code>enum</code> cases in the <code>switch</code> statement.</p>\n","raw_content":"[frontMatter]\ntitle = \"Enumeration Case Pattern\"\ntags = [\"pattern matching\", \"switch\", \"enum\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Enumeration Case Pattern\n\nAs you saw in our trading example, pattern matching works **really\ngreat** with Swift\\'s `enums`. That\\'s because `enum cases` are like\nsealed, immutable, destructable structs. Much like with `tuples`, you\ncan unwrap the contents of an individual case right in the match and\nonly extract the information you need.\n\nImagine you\\'re writing a game in a functional style and you have a\ncouple of entities that you need to define. You could use `structs` but\nas your entities will have very little state, you feel that that\\'s a\nbit of an overkill.\n\n``` Swift\nenum Entities {\n    case soldier(x: Int, y: Int)\n    case tank(x: Int, y: Int)\n    case player(x: Int, y: Int)\n}\n```\n\nNow you need to implement the drawing loop. Here, we only need the X and\nY position:\n\n``` Swift\nfor e in entities() {\n    switch e {\n    case let .soldier(x, y):\n      drawImage(\"soldier.png\", x, y)\n    case let .tank(x, y):\n      drawImage(\"tank.png\", x, y)\n    case let .player(x, y):\n      drawImage(\"player.png\", x, y)\n    }\n}\n```\n\nThis is the gist of it. The `enumeration case pattern` is really just\nusing `enum` cases in the `switch` statement.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/generic_settings/intro.md":["072a99abb9a740bf",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Example: Generic Settings","tags":["keypath","abstraction"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-example-generic-settings.html","content":"<h1>Generic Settings</h1>\n<p>Our first practical example showcases how keypaths, protocols, and keypath composition work together to allow you to handle app settings in a generic manner. Here is the problem we're trying to solve, have a look at these different settings screens for our <code>Chat</code> app:</p>\n<p><img src=\"/img-content/keypaths_settings.gif\" alt=\"Image\" /></p>\n<p>Lets map those settings as a type:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">final class</span> ProfileSettings {\n\n   <span class=\"keyword\">var</span> displayName: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">var</span> shareUpdates: <span class=\"type\">Bool</span>\n\n}\n\n\n\n<span class=\"keyword\">final class</span> PrivacySettings {\n\n   <span class=\"keyword\">var</span> passcode: <span class=\"type\">Bool</span>\n\n   <span class=\"keyword\">var</span> addByID: <span class=\"type\">Bool</span>\n\n}\n\n\n\n<span class=\"keyword\">final class</span> Settings {\n\n   <span class=\"keyword\">var</span> profileSettings: <span class=\"type\">ProfileSettings</span>\n\n   <span class=\"keyword\">var</span> privacySettings: <span class=\"type\">PrivacySettings</span>\n\n}\n</code></pre></code></pre>\n<p>If we want to find a generic abstraction for these settings, it would be very difficult. That's because they're all so very different. Their types are <code>String, Bool</code>, <code>Bool, Bool</code>, and <code>ProfileSettings, PrivacySettings</code>.\nEven more, as we expand our settings they will become more and more different.\nLets try to find a nice solution for this by utilizing keypaths.</p>\n","raw_content":"[frontMatter]\ntitle = \"Example: Generic Settings\"\ntags = [\"keypath\", \"abstraction\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Generic Settings\n\nOur first practical example showcases how keypaths, protocols, and keypath composition work together to allow you to handle app settings in a generic manner. Here is the problem we're trying to solve, have a look at these different settings screens for our `Chat` app:\n\n![Image](/img-content/keypaths_settings.gif)\n\nLets map those settings as a type:\n\n``` Swift\n\nfinal class ProfileSettings {\n  var displayName: String\n  var shareUpdates: Bool\n}\n\nfinal class PrivacySettings {\n  var passcode: Bool\n  var addByID: Bool\n}\n\nfinal class Settings {\n  var profileSettings: ProfileSettings\n  var privacySettings: PrivacySettings\n}\n```\n\nIf we want to find a generic abstraction for these settings, it would be very difficult. That's because they're all so very different. Their types are `String, Bool`, `Bool, Bool`, and `ProfileSettings, PrivacySettings`. \nEven more, as we expand our settings they will become more and more different. \nLets try to find a nice solution for this by utilizing keypaths.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/mirrors/creating_a_mirror.md":["bf688222e476e2ce",{"identifier":"b4a245c3","filename":"creating_a_mirror.md","info":{"title":"Creating a Mirror","tags":["reflection","mirror"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-creating-a-mirror.html","content":"<h1>Creating a Mirror</h1>\n<p>The easiest way of creating a mirror is the <code>reflecting</code> initializer:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">public init</span>(reflecting: <span class=\"type\">Any</span>)\n</code></pre></code></pre>\n<p>Lets use it with our <code>Bookmark</code> <code>struct</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> myMirror = <span class=\"type\">Mirror</span>(reflecting: aBookmark)\n\n<span class=\"call\">print</span>(myMirror)\n\n<span class=\"comment\">// prints : Mirror for Bookmark</span>\n</code></pre></code></pre>\n<p>So this creates a <code>Mirror for Bookmark</code>. As you can see, the type of the\nsubject is <code>Any</code>. This is the most general type in Swift. Anything under\nthe Swift Sun is at least of type <code>Any</code> <sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>. So this makes the mirror\ncompatible with <code>struct</code>, <code>class</code>, <code>enum</code>, <code>Tuple</code>, <code>Array</code>,\n<code>Dictionary</code>, <code>Set</code>, etc.</p>\n<p>There are three additional initializers in the Mirror struct, however\nthose are mostly used for circumstances where you'd want to provide\nyour own, custom mirror.</p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>In particular, <code>Any</code> is an empty protocol and everything implicitly conforms to this protocol</p>\n</div>\n","raw_content":"[frontMatter]\ntitle = \"Creating a Mirror\"\ntags = [\"reflection\", \"mirror\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Creating a Mirror\n\nThe easiest way of creating a mirror is the `reflecting` initializer:\n\n``` Swift\npublic init(reflecting: Any)\n```\n\nLets use it with our `Bookmark` `struct`:\n\n``` Swift\nlet myMirror = Mirror(reflecting: aBookmark)\nprint(myMirror)\n// prints : Mirror for Bookmark\n```\n\nSo this creates a `Mirror for Bookmark`. As you can see, the type of the\nsubject is `Any`. This is the most general type in Swift. Anything under\nthe Swift Sun is at least of type `Any` [^1]. So this makes the mirror\ncompatible with `struct`, `class`, `enum`, `Tuple`, `Array`,\n`Dictionary`, `Set`, etc.\n\nThere are three additional initializers in the Mirror struct, however\nthose are mostly used for circumstances where you\\'d want to provide\nyour own, custom mirror.\n\n[^1]: In particular, `Any` is an empty protocol and everything implicitly conforms to this protocol\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/absolute_basics/tuple_destructuring.md":["81b6664075022260",{"identifier":"d03ccf22","filename":"tuple_destructuring.md","info":{"title":"Tuple Destructuring","tags":["tuples"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-tuple-destructuring.html","content":"<h1>Tuple Destructuring</h1>\n<p>Swift took a lot of inspiration from different programming languages,\nand this is something that Python has been doing for years. While the\nprevious examples mostly showed how to easily get something into a\ntuple, destructuring is a swifty way of getting something out of a\ntuple, and in line with the <code>abc</code> example above, it looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> abc() -&gt; (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>) {\n\n   <span class=\"keyword\">return</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n\n}\n\n<span class=\"keyword\">let</span> (a, b, c) = <span class=\"call\">abc</span>()\n\n<span class=\"call\">print</span>(a) <span class=\"comment\">// prints 1</span>\n</code></pre></code></pre>\n<p>Another example is getting several function calls into one line:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> (a, b, c) = (<span class=\"call\">a</span>(), <span class=\"call\">b</span>(), <span class=\"call\">c</span>())\n</code></pre></code></pre>\n<p>Or, an easy way to swap two values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> v1: <span class=\"type\">Int</span>\n\n<span class=\"keyword\">var</span> v2: <span class=\"type\">Int</span>\n\n(v1, v2) = (<span class=\"number\">5</span>, <span class=\"number\">4</span>)\n\n(a: v1, b: v2) = (a: v2, b: v1) <span class=\"comment\">// swapped: v1 == 4, v2 == 5</span>\n\n(v1, v2) = (<span class=\"number\">5</span>, <span class=\"number\">4</span>)\n\n(a: v1, b: v2) = (b: v1, a: v2) <span class=\"comment\">// swapped: v1 == 4, v2 == 5</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Tuple Destructuring\"\ntags = [\"tuples\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Tuple Destructuring\n\nSwift took a lot of inspiration from different programming languages,\nand this is something that Python has been doing for years. While the\nprevious examples mostly showed how to easily get something into a\ntuple, destructuring is a swifty way of getting something out of a\ntuple, and in line with the `abc` example above, it looks like this:\n\n``` Swift\nfunc abc() -> (Int, Int, Int) {\n  return (1, 2, 3)\n}\nlet (a, b, c) = abc()\nprint(a) // prints 1\n```\n\nAnother example is getting several function calls into one line:\n\n``` Swift\nlet (a, b, c) = (a(), b(), c())\n```\n\nOr, an easy way to swap two values:\n\n``` Swift\nvar v1: Int\nvar v2: Int\n(v1, v2) = (5, 4)\n(a: v1, b: v2) = (a: v2, b: v1) // swapped: v1 == 4, v2 == 5\n(v1, v2) = (5, 4)\n(a: v1, b: v2) = (b: v1, a: v2) // swapped: v1 == 4, v2 == 5\n```\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/debugprinter_intermezzo.md":["4f9d3d203df605d3",{"identifier":"0b284c17","filename":"debugprinter_intermezzo.md","info":{"title":"A DebugPrinter","tags":["keypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-a-debugprinter.html","content":"<h1>DebugPrinter Intermezzo</h1>\n<p>Now that we have our writable <code>KeyPath</code> types, we'd like to introduce a type that allows us to define the logging behaviour of an object. We'd like to define which properties should be printed when our debug print function is called. It will be a very simple example.</p>\n<p>We will actually start by looking at how we would invoke the code before we write it. This will make it easier to understand what is going on here. The class we will define is called <code>DebugPrinter</code> and it is used to dynamically change how to debug print and object at runtime.</p>\n<p>Say, if you will, that you're working on a Presentation app (aka something like Keynote). You have one structure that represents the current state of a presentation.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> Presentation {\n\n   <span class=\"keyword\">class</span> Slide {\n\n     <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> number: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">var</span> template: <span class=\"type\">Template</span>\n\n     <span class=\"keyword\">var</span> backgroundColor: <span class=\"type\">UIColor</span>\n\n     <span class=\"keyword\">var</span> content: <span class=\"type\">String</span>\n\n     <span class=\"keyword\">var</span> leftImage: <span class=\"type\">UIImage</span>?\n\n     <span class=\"keyword\">var</span> rightImage: <span class=\"type\">UIImage</span>?\n\n   }\n\n   <span class=\"keyword\">var</span> currentSlide: <span class=\"type\">Slide</span>\n\n   <span class=\"keyword\">var</span> currentSlideIndex: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">var</span> slides: [<span class=\"type\">Slide</span>]\n\n   <span class=\"keyword\">var</span> title: <span class=\"type\">String</span>\n\n   <span class=\"keyword\">var</span> startedPresenting: <span class=\"type\">Date</span>?\n\n   <span class=\"keyword\">var</span> isAnimating: <span class=\"type\">Bool</span>\n\n}\n</code></pre></code></pre>\n<p>Now, you'd like to define at runtime which of the properties of this type to print. For example depending on whether a user is currently presenting or editing slides. This is, how we would do that:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> state = <span class=\"type\">Presentation</span>(...) <span class=\"comment\">// we need a presentation instance</span>\n\n<span class=\"keyword\">let</span> printer = <span class=\"type\">DebugPrinter</span>(\\<span class=\"string\">\"State</span>\\<span class=\"string\">\"</span>, for: state)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">currentSlideIndex</span>, prefix: \\<span class=\"string\">\"Current</span>\\<span class=\"string\">\"</span>)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">isAnimating</span>)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">currentSlide</span>.<span class=\"property\">name</span>)\n\nprinter.<span class=\"call\">addLog</span>(\\<span class=\"type\">Presentation</span>.<span class=\"property\">currentSlide</span>.<span class=\"property\">leftImage</span>)\n\n\n\nprinter.<span class=\"call\">log</span>()\n</code></pre></code></pre>\n<p>So here, we first create a <code>printer</code> that holds a reference to our <code>state</code> (an instance of our <code>Presentation</code>). Next, we define which parts of the <code>animation</code> we want to print (including an optional prefix). Here, we want to print, for example, the current slide, whether we're currently animating, the name of the current slide and, finally, the optional image of the current slide.</p>\n<p>So, how would we implement this <code>DebugPrinter</code>? here is the code.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Dynamically define a debug description for an object</span>\n\n<span class=\"keyword\">class</span> DebugPrinter&lt;T&gt; <span class=\"keyword\">where</span> <span class=\"type\">T</span>: <span class=\"type\">AnyObject</span> {\n\n     <span class=\"comment\">/// 1</span>\n\n     <span class=\"keyword\">var</span> keyPaths: [(<span class=\"type\">String</span>?, <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">String</span>&gt;)] = []\n\n     <span class=\"keyword\">let</span> reference: <span class=\"type\">T</span>\n\n     <span class=\"keyword\">let</span> prefix: <span class=\"type\">String</span>\n\n\n\n     <span class=\"comment\">/// 2</span>\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> prefixString: <span class=\"type\">String</span>, for instance: <span class=\"type\">T</span>) {\n\n         reference = instance\n\n         prefix = prefixString\n\n     }\n\n\n\n     <span class=\"comment\">/// 3</span>\n\n     <span class=\"keyword\">func</span> addLog(<span class=\"keyword\">_</span> path: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">String</span>&gt;, prefix: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>) {\n\n         keyPaths.<span class=\"call\">append</span>((prefix, path))\n\n     }\n\n\n\n     <span class=\"comment\">/// 4</span>\n\n     <span class=\"keyword\">func</span> log() {\n\n         <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>: \\<span class=\"string\">\"</span>)\n\n         <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> keyPaths {\n\n           <span class=\"keyword\">if let</span> prefix = entry.<span class=\"number\">0</span> { <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>) }\n\n           <span class=\"call\">print</span>(reference[keyPath: entry.<span class=\"number\">1</span>], terminator: \\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>)\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>So lets go through step by step. First, we're creating a new <code>class</code> that is generic over the type <code>T</code> so that we can store keypaths of type <code>KeyPath&lt;T, String&gt;</code> in our <code>keyPaths</code> array [1]. Each keypath is stored in a <a href=\"lnk::tuple\">tuple</a> with an optional prefix.</p>\n<p>Then, we can initialize a <code>DebugPrinter</code> with a <code>prefix</code> <code>String</code> - which will be printed at the beginning of each future print invocation - and a reference to the actual instance we want to debug <code>T</code> [2].</p>\n<p>The <code>addLog</code> function, then, inserts a new <code>KeyPath</code> into our <code>keyPaths</code> array (again, including the optional <code>prefix</code>) [3].</p>\n<p>Finally, the <code>log</code> function, when called, iterates over all the keypaths and, for each of them, prints the contents of the <code>KeyPath</code> in our <code>reference</code> (including the prefix).</p>\n<p>Before you move on, have a brief look at the implementation of the <code>DebugPrinter</code> and at the usage example. Would this actually work?</p>\n<hr />\n<p>No, it actually doesn't. The problem is that our <code>Presentation</code> state has properties of various types: <code>currentSlideIndex: Int</code>, <code>title: String</code>, <code>leftImage: UIImage?</code>. However, our <code>DebugPrinter</code> only stores keypaths of the type <code>KeyPath&lt;T, String&gt;</code>. We could try to make the second parameter generic as well, but that still doesn't help, because it would be generic for the full instance of <code>DebugPrinter</code>, for example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> DebugPrinter&lt;Root, Value&gt; {\n\n   <span class=\"keyword\">var</span> keyPaths: [<span class=\"type\">KeyPath</span>&lt;<span class=\"type\">Root</span>, <span class=\"type\">Value</span>&gt;]\n\n}\n</code></pre></code></pre>\n<p>Here, our <code>KeyPath</code> still have to be of the same type. All <code>Int</code>, all <code>String</code>, etc. What we actually want is a keypath that doesn't care about the <code>Value</code> type! A KeyPath that just cares about the <code>Root</code> type (our <code>reference</code>). This is, what the <code>PartialKeyPath</code> is for. Lets have a look at it.</p>\n","raw_content":"[frontMatter]\ntitle = \"A DebugPrinter\"\ntags = [\"keypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# DebugPrinter Intermezzo\n\nNow that we have our writable `KeyPath` types, we'd like to introduce a type that allows us to define the logging behaviour of an object. We'd like to define which properties should be printed when our debug print function is called. It will be a very simple example.\n\nWe will actually start by looking at how we would invoke the code before we write it. This will make it easier to understand what is going on here. The class we will define is called `DebugPrinter` and it is used to dynamically change how to debug print and object at runtime.\n\nSay, if you will, that you're working on a Presentation app (aka something like Keynote). You have one structure that represents the current state of a presentation.\n\n``` Swift\nclass Presentation {\n  class Slide {\n    var name: String\n    var number: Int\n    var template: Template\n    var backgroundColor: UIColor\n    var content: String\n    var leftImage: UIImage?\n    var rightImage: UIImage?\n  }\n  var currentSlide: Slide\n  var currentSlideIndex: Int\n  var slides: [Slide]\n  var title: String\n  var startedPresenting: Date?\n  var isAnimating: Bool\n}\n```\n\nNow, you'd like to define at runtime which of the properties of this type to print. For example depending on whether a user is currently presenting or editing slides. This is, how we would do that:\n\n``` Swift\nlet state = Presentation(...) // we need a presentation instance\nlet printer = DebugPrinter(\"State\", for: state)\nprinter.addLog(\\Presentation.currentSlideIndex, prefix: \"Current\")\nprinter.addLog(\\Presentation.isAnimating)\nprinter.addLog(\\Presentation.currentSlide.name)\nprinter.addLog(\\Presentation.currentSlide.leftImage)\n\nprinter.log()\n```\n\nSo here, we first create a `printer` that holds a reference to our `state` (an instance of our `Presentation`). Next, we define which parts of the `animation` we want to print (including an optional prefix). Here, we want to print, for example, the current slide, whether we're currently animating, the name of the current slide and, finally, the optional image of the current slide.\n\nSo, how would we implement this `DebugPrinter`? here is the code.\n\n``` Swift\n/// Dynamically define a debug description for an object\nclass DebugPrinter<T> where T: AnyObject {\n    /// 1\n    var keyPaths: [(String?, KeyPath<T, String>)] = []\n    let reference: T\n    let prefix: String\n\n    /// 2\n    init(_ prefixString: String, for instance: T) {\n        reference = instance\n        prefix = prefixString\n    }\n\n    /// 3\n    func addLog(_ path: KeyPath<T, String>, prefix: String? = nil) {\n        keyPaths.append((prefix, path))\n    }\n\n    /// 4\n    func log() {\n        print(prefix, terminator: \": \")\n        for entry in keyPaths {\n          if let prefix = entry.0 { print(prefix, terminator: \"\") }\n          print(reference[keyPath: entry.1], terminator: \", \")\n        }\n    }\n}\n```\n\nSo lets go through step by step. First, we're creating a new `class` that is generic over the type `T` so that we can store keypaths of type `KeyPath<T, String>` in our `keyPaths` array [1]. Each keypath is stored in a [tuple](lnk::tuple) with an optional prefix.\n\nThen, we can initialize a `DebugPrinter` with a `prefix` `String` - which will be printed at the beginning of each future print invocation - and a reference to the actual instance we want to debug `T` [2].\n\nThe `addLog` function, then, inserts a new `KeyPath` into our `keyPaths` array (again, including the optional `prefix`) [3].\n\nFinally, the `log` function, when called, iterates over all the keypaths and, for each of them, prints the contents of the `KeyPath` in our `reference` (including the prefix).\n\nBefore you move on, have a brief look at the implementation of the `DebugPrinter` and at the usage example. Would this actually work? \n\n---\n\nNo, it actually doesn't. The problem is that our `Presentation` state has properties of various types: `currentSlideIndex: Int`, `title: String`, `leftImage: UIImage?`. However, our `DebugPrinter` only stores keypaths of the type `KeyPath<T, String>`. We could try to make the second parameter generic as well, but that still doesn't help, because it would be generic for the full instance of `DebugPrinter`, for example:\n\n``` Swift\nclass DebugPrinter<Root, Value> {\n  var keyPaths: [KeyPath<Root, Value>]\n}\n```\n\nHere, our `KeyPath` still have to be of the same type. All `Int`, all `String`, etc. What we actually want is a keypath that doesn't care about the `Value` type! A KeyPath that just cares about the `Root` type (our `reference`). This is, what the `PartialKeyPath` is for. Lets have a look at it.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2014-06-08-writing-simple-syntax-extensions-in-swift.md":["1d3c8a66d768f7eb",{"identifier":"8f51562e","filename":"2014-06-08-writing-simple-syntax-extensions-in-swift.md","info":{"title":"Using @autoclosure to write a Swift syntax extension","tags":["autoclosure"],"keywords":["clojure","lisp","swift","cond","syntax","macro","extension","cocoa","ios","feature"],"category":["Language","All"],"created":"2014-06-08 10:30:30","description":"Swift's @autoclosure allows to extend the Swift syntax in fantastic ways. Observe how we re-implement the `cond` function from Lisp","description_html":"<p>Swift's @autoclosure allows to extend the Swift syntax in fantastic ways. Observe how we re-implement the <code>cond</code> function from Lisp</p>\n","published":true,"slug":"2014-06-08-writing-simple-syntax-extensions-in-swift.html","meta":{"swift_version":"1.0"},"created_timestamp":1402223430,"date":"2014-06-08T10:30:30","date_info":{"year":2014,"month":6,"day":8,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2014-06-08-writing-simple-syntax-extensions-in-swift.html","content":"<h2>Note</h2>\n<p>This article is severly outdated. I'm keeping it for posterity the way it is because\nit was writting at WWDC 2014 when Swift was released.</p>\n<h2>Endnote</h2>\n<p>It has been less than a week since Apple announced Swift, and people are\nalready writing libraries, snippet collections, or best practice posts.\nI suppose most did not even find the time to thouroughly read the Swift\nBook yet <sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>.</p>\n<p>Some Examples are the <a href=\"https://github.com/grant/swift-cheat-sheet\">Swift\nCheatsheet</a>, <a href=\"https://github.com/maxpow4h/swiftz\">Swiftz, a\nfunctional programming paradigm library for\nSwift</a>, or <a href=\"http://nategriswold.blogspot.com/2014/06/couple-swift-notes-from-wwdc.html\">blog posts like this\none.</a></p>\n<h3>Simple Custom Syntax</h3>\n<p>One Swift cricitism has been the lack of a macro system that would allow\nusers to freely extend the language like Lisp (and other homoiconic)\nlanguages do. While this is indeed not possible, there is a hidden gem\nin the Swift language that gives us some flexibility in this domain. If\nyou look at the Swift documentation for the various operators, you'll\nfind this line:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> &amp;&amp;(lhs: <span class=\"type\">LogicValue</span>, rhs: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">LogicValue</span>) -&gt; <span class=\"type\">Bool</span>\n</code></pre></code></pre>\n<p>The <code>&amp;&amp;</code> operator has two arguments: The left hand side and the right\nhand side. Swift first checks the left hand side. If this evaluates to\ntrue, only then will it evaluate the right hand side. This means that\nthe right hand side expression will defer evaluation until the left hand\nside was evaluated.</p>\n<p>How does Swift do this? Through the magic <code>@auto_closure</code> syntax. This\ntells Swift to wrap the expression into a closure and only evaluate it\nif explicitly told to do so. The full function might look something like\nthis</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> &amp;&amp;(lhs: <span class=\"type\">LogicValue</span>, rhs: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">LogicValue</span>) -&gt; <span class=\"type\">Bool</span> {\n\n   <span class=\"comment\">// Proof for left hand side</span>\n\n   <span class=\"keyword\">if</span> lhs {\n\n     <span class=\"comment\">// Only then execute and thus proof right hand side</span>\n\n     <span class=\"keyword\">if</span> <span class=\"call\">rhs</span>() == <span class=\"keyword\">true</span> {\n\n       <span class=\"keyword\">return true</span>\n\n     }\n\n   }\n\n   <span class=\"keyword\">return false</span>\n\n}\n</code></pre></code></pre>\n<p>This is an interesting feature and allows us to implement more complex\nconstructs with a bit of tinkering. How about implementing something\nnew, namely the <code>cond</code> expression from Lisp?</p>\n<h3>Writing a cond expression for Swift</h3>\n<p>In Lisp, <code>cond</code> works as follows:</p>\n<pre class=\"Clojure\"><code><span class=\"techousource techouclojure\"><span class=\"techoumeta techousexpr techouclojure\">(<span class=\"techoukeyword techoucontrol techouclojure\">cond</span> <span class=\"techoumeta techousexpr techouclojure\">(<span class=\"techoumeta techousexpr techouclojure\">(<span class=\"techoukeyword techouoperator techouclojure\">=</span> <span class=\"techousource techousymbol techouclojure\">a</span> <span class=\"techouconstant techounumeric techoufloat techouclojure\">1</span>)</span> <span class=\"techoustring techouquoted techoudouble techouclojure\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouclojure\">&quot;</span>a is one<span class=\"techoupunctuation techoudefinition techoustring techouend techouclojure\">&quot;</span></span>)</span>\n      <span class=\"techoumeta techousexpr techouclojure\">(<span class=\"techoumeta techousexpr techouclojure\">(<span class=\"techoukeyword techouoperator techouclojure\">=</span> <span class=\"techousource techousymbol techouclojure\">a</span> <span class=\"techouconstant techounumeric techoufloat techouclojure\">2</span>)</span> <span class=\"techoustring techouquoted techoudouble techouclojure\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouclojure\">&quot;</span>a is two<span class=\"techoupunctuation techoudefinition techoustring techouend techouclojure\">&quot;</span></span>)</span>\n      <span class=\"techoumeta techousexpr techouclojure\">(<span class=\"techoumeta techousexpr techouclojure\">(<span class=\"techoukeyword techouoperator techouclojure\">=</span> <span class=\"techousource techousymbol techouclojure\">a</span> <span class=\"techouconstant techounumeric techoufloat techouclojure\">4</span>)</span> <span class=\"techoustring techouquoted techoudouble techouclojure\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouclojure\">&quot;</span>a is four<span class=\"techoupunctuation techoudefinition techoustring techouend techouclojure\">&quot;</span></span>)</span>)</span>\n</span></code></pre></code></pre>\n<p>Much like a <code>switch</code> statement, different cases are being tested for.\nEach line defines a test and after that a expression result. So if a\nequals 2 the switch statement will return &quot;a is two&quot;. If a equals 1,\nit will return &quot;a is one&quot;. In comparison to <code>switch</code>, <code>cond</code> also\nallows to test for different variables in one statement (i.e. is a 2 or\nis b 3). Another difference is that <code>cond</code> returns a value, while the\nSwift <code>switch</code> statement does not (<a href=\"http://nategriswold.blogspot.com/2014/06/couple-swift-notes-from-wwdc.html\">there's actually a rdar bug for\nthis</a>)</p>\n<p>Given the <code>@auto_closure</code> feature from above, we can actually implement\n<code>cond</code> in Swift ourselves.</p>\n<ul>\n<li>We need an expression that evaluates to bool <code>() -&gt; Bool</code></li>\n<li>We need an expression that evaluates to Any result type <code>() -&gt; Any</code></li>\n</ul>\n<p>These should be wrapped into closures, so that they will be evaluated\nsequentially and only if necessary. Lets start with a simple\nimplementation and build upon that.</p>\n<p>Imagine the following situation: You're processing user input, and you\nwant to delete something from either the memory or the database,\ndepending on what the user selected.</p>\n<p>We want something that works for the current theoretical code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> a = <span class=\"call\">get_user_input</span>()\n\n<span class=\"keyword\">var</span> b = <span class=\"call\">get_current_entity</span>()\n\n<span class=\"comment\">// delete fro memory or db depending on what user selected</span>\n\n<span class=\"keyword\">var</span> result = <span class=\"call\">cond</span>(a == <span class=\"number\">1</span>, <span class=\"call\">delete_from_db</span>(b),\n\n                   a == <span class=\"number\">2</span>, <span class=\"call\">delete_from_memory</span>(b))\n\n<span class=\"comment\">// make sure we deleted the correct one</span>\n\n<span class=\"keyword\">if</span> result != b ....\n</code></pre></code></pre>\n<p>The important part here is that <code>delete_from_db</code> and\n<code>delete_from_memory</code> are only being executed if the condition 'a == ?'\nis true for the selected case. Under no circumstance do we want our\nentity to be deleted from the db and the memory.</p>\n<h3>A first version</h3>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> cond_1 (a1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>,\n\n     a2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>,\n\n     bf: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>) -&gt; <span class=\"type\">Any</span> {\n\n         <span class=\"keyword\">if</span> <span class=\"call\">a1</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b1</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a2</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b2</span>()\n\n         }\n\n         <span class=\"keyword\">return</span> <span class=\"call\">bf</span>()\n\n}\n</code></pre></code></pre>\n<p>There's our expression. We can hand it two different cases and a\ndefault expression (as a fallback). Lets see how it works. We will\ndefine two simple functions that perform side effects (imagine deleting\na file, or writing to a file).</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> perform_side_effects1() -&gt; <span class=\"type\">Any</span> {\n\n     <span class=\"call\">println</span>(\\<span class=\"string\">\"modify</span> a state\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">return</span> <span class=\"number\">1</span>\n\n}\n\n<span class=\"keyword\">func</span> perform_side_effects2() -&gt; <span class=\"type\">Any</span> {\n\n     <span class=\"call\">println</span>(\\<span class=\"string\">\"modify</span> another state\\<span class=\"string\">\"</span>)\n\n     <span class=\"keyword\">return</span> <span class=\"number\">2</span>\n\n}\n\n\n\n<span class=\"keyword\">var</span> a = <span class=\"number\">1</span>\n\n<span class=\"keyword\">var</span> ctest = <span class=\"call\">cond_1</span>(a == <span class=\"number\">1</span>, <span class=\"number\">2</span> + <span class=\"call\">perform_side_effects1</span>(),\n\n                   a == <span class=\"number\">2</span>, <span class=\"number\">3</span> + <span class=\"call\">perform_side_effects2</span>(),\n\n                   <span class=\"number\">0</span>)\n\n<span class=\"comment\">// ctest is 3 (2 + 1)</span>\n\n<span class=\"comment\">// prints only \\\"modify a state\\\"</span>\n\nctest\n\n\n</code></pre></code></pre>\n<h3>Handling more cases</h3>\n<p>This works fine, but it has a limitation in that it only works for two\ncases. This is clearly not optimal. Thankfully, Swift is pretty good at\nfunction overloading so we can simply define more functions with more\ncases and let swift do the hard work of figuring out which one to\nchoose:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> cond_2 (a1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>,\n\n     a2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>,\n\n     bf: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>) -&gt; <span class=\"type\">Any</span> {\n\n         <span class=\"keyword\">if</span> <span class=\"call\">a1</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b1</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a2</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b2</span>()\n\n         }\n\n         <span class=\"keyword\">return</span> <span class=\"call\">bf</span>()\n\n}\n\n\n\n<span class=\"keyword\">func</span> cond_2 (a1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>,\n\n     a2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>,\n\n     a3: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b3: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>,\n\n     bf: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Any</span>) -&gt; <span class=\"type\">Any</span> {\n\n         <span class=\"keyword\">if</span> <span class=\"call\">a1</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b1</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a2</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b2</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a3</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">a3</span>()\n\n         }\n\n         <span class=\"keyword\">return</span> <span class=\"call\">bf</span>()\n\n}\n</code></pre></code></pre>\n<p>You can then extend this to ever more cases. Of course, this smells like\ncode duplication and there is a way around this, but that currently\ncrashes the Swift Compiler. I'll come back to how to (at least\ntheoretically) do this at the end. First, there is another issue that we\nneed to address.</p>\n<h3>Making it generic</h3>\n<p>Our current version succumbs every variable down to the <code>Any</code> type which\nmeans that the compiler won't be able to perform advanced type\ninference for anything that comes out of this function. For example, the\nfollowing will not work because even though we're clearly returning\n<code>Int</code> our actual function is set to return <code>Any</code></p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Causes an error</span>\n\n<span class=\"keyword\">var</span> b:<span class=\"type\">Int</span> = <span class=\"call\">cond_2</span>(<span class=\"number\">0</span> == <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span> == <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n\n<span class=\"comment\">// Works fine</span>\n\n<span class=\"keyword\">var</span> b:<span class=\"type\">Any</span> = <span class=\"call\">cond_2</span>(<span class=\"number\">0</span> == <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span> == <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n</code></pre></code></pre>\n<p>Since types give us safety we'd rather have a funcion that tells us if\nwe accidentally try to do something wrong here. Thankfully, Swift has\nsupport for <a href=\"http://en.wikipedia.org/wiki/Generic_programming\">Generic\nProgramming</a> and only\na simple change is necessary for this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> cond_3&lt;T&gt; (a1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>,\n\n     a2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>,\n\n     bf: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>) -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">if</span> <span class=\"call\">a1</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b1</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a2</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b2</span>()\n\n         }\n\n         <span class=\"keyword\">return</span> <span class=\"call\">bf</span>()\n\n}\n\n\n\n<span class=\"comment\">// Works fine!</span>\n\n<span class=\"keyword\">var</span> b:<span class=\"type\">Int</span> = <span class=\"call\">cond_3</span>(<span class=\"number\">0</span> == <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span> == <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n</code></pre></code></pre>\n<p>That's it, now we're telling Swift that this function handles items of\ntype T and that the very same type T is the return type of this funcion.</p>\n<p>Through this, we can use our cond~3~ function on types of any kind like\nString, Array, Int, or custom types.</p>\n<h3>Wrap up</h3>\n<p>That's it! We've implemented our own syntax extension for Swift! Now\nwe can write code this as this</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> a = <span class=\"call\">get_user_input</span>()\n\n<span class=\"keyword\">var</span> b = <span class=\"call\">get_current_entity</span>()\n\n<span class=\"comment\">// delete fro memory or db depending on what user selected</span>\n\n<span class=\"keyword\">var</span> result = <span class=\"call\">cond</span>(a == <span class=\"number\">1</span>, <span class=\"call\">delete_from_db</span>(b),\n\n                   a == <span class=\"number\">2</span>, <span class=\"call\">delete_from_memory</span>(b))\n\n<span class=\"comment\">// make sure we deelted the correct one</span>\n\n<span class=\"keyword\">if</span> result != b ....\n</code></pre></code></pre>\n<p>Now, the entity would only be deleted from db or from memory if a\ncontains the correct variable. Keep in mind that this was only a simple\nexample. Much more is possible if you use this in a smart way.</p>\n<p>Even better if one combines this in a neat way with the first closure as\nbody mechanism or with operators. I'm sure that we can already create\nsome pretty stunning syntax extensions with this. However, this, only if\nit doesn't crash the compiler, which brings us to the next and final\nsection.</p>\n<h3>Limitations</h3>\n<p>All current Swift projects suffer from the current slightly beta state\nof the build tools and the Swift compiler. This leads to much code that\nlooks a bit cumbersome but can easily be improved in the future. In this\ncase, here's some untested code, that wraps the complete logic in one\nbig function and only defines additional lightweight wrappers to deal\nwith the parameters variations. Still not optimal but much more\nreadable. Sadly, this crashes the compiler (actually it kills Xcode the\nminute you type it in, which is pretty impressive.<sup class=\"footnote-reference\"><a href=\"#2\">2</a></sup>).</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> _cond&lt;T&gt; (a1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>?,\n\n     a2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>?,\n\n     a3: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b3: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>?,\n\n     a4: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b4: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>?,\n\n     a5: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b5: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>?\n\n) -&gt; <span class=\"type\">T</span>? {\n\n         <span class=\"keyword\">if</span> <span class=\"call\">a1</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b1</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a2</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b2</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a3</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b3</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a4</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">b4</span>()\n\n         } <span class=\"keyword\">else if</span> <span class=\"call\">a5</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">a5</span>()\n\n         }\n\n         <span class=\"keyword\">return nil</span>\n\n}\n\n<span class=\"comment\">// two parameter implementation</span>\n\n<span class=\"keyword\">func</span> cond&lt;T&gt;(a1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>,\n\n     a2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>,\n\n     bf: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>) -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">if let</span> r = <span class=\"call\">_cond</span>(a1, b1, a2, b2, <span class=\"keyword\">false</span>, {}(), <span class=\"keyword\">false</span>, {}(), <span class=\"keyword\">false</span>, {}()) {\n\n             <span class=\"keyword\">return</span> r\n\n         }\n\n         <span class=\"keyword\">return</span> <span class=\"call\">bf</span>()\n\n}\n\n<span class=\"comment\">// three parameter implementation</span>\n\n<span class=\"keyword\">func</span> cond&lt;T&gt;(a1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b1: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>,\n\n     a2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b2: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>,\n\n     a3: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, b3: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>,\n\n     bf: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>) -&gt; <span class=\"type\">T</span> {\n\n         <span class=\"keyword\">if let</span> r = <span class=\"call\">_cond</span>(a1, b1, a2, b2, a3, b3, <span class=\"keyword\">false</span>, {}(), <span class=\"keyword\">false</span>, {}()) {\n\n             <span class=\"keyword\">return</span> r\n\n         }\n\n         <span class=\"keyword\">return</span> <span class=\"call\">bf</span>()\n\n}\n</code></pre></code></pre>\n<p>I'm not sure if this would lead to correct results if it would work,\nbut based on my current understanding of the language it should be fine.</p>\n<h3>Update</h3>\n<p><a href=\"https://news.ycombinator.com/user?id%3Dbjustin\">bjustin</a> offered <a href=\"https://news.ycombinator.com/item?id%3D7865603\">this\nslight modification</a>\nthat makes it easy to use unlimited cases. The only downside is that the\nfallback has to be the first item.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> cond&lt;T&gt;(#fallback: <span class=\"type\">T</span>, testsAndExprs: (test: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">Bool</span>, expr: <span class=\"keyword\">@auto_closure</span> () -&gt; <span class=\"type\">T</span>)...) -&gt; <span class=\"type\">T</span> {\n\n     <span class=\"keyword\">for</span> (t, e) <span class=\"keyword\">in</span> testsAndExprs {\n\n         <span class=\"keyword\">if</span> <span class=\"call\">t</span>() {\n\n             <span class=\"keyword\">return</span> <span class=\"call\">e</span>()\n\n         }\n\n     }\n\n     <span class=\"keyword\">return</span> fallback\n\n}\n\n\n\n<span class=\"comment\">// And in use:</span>\n\n\n\n<span class=\"comment\">// y is assigned \\\"0 == 0, of course\\\"</span>\n\n<span class=\"keyword\">let</span> y = <span class=\"call\">cond</span>(fallback: \\<span class=\"string\">\"fallback</span>\\<span class=\"string\">\"</span>, (test: <span class=\"keyword\">false</span>, expr: \\<span class=\"string\">\"not</span> this branch\\<span class=\"string\">\"</span>), (test: <span class=\"number\">0</span> == <span class=\"number\">0</span>, expr: \\<span class=\"string\">\"0</span> == <span class=\"number\">0</span>, of course\\<span class=\"string\">\"</span>))\n</code></pre></code></pre>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>I completely omitted the language reference. Impossible to work\nthrough something like that during a chronically sleep-deprived week\nlike WWDC</p>\n</div>\n<div class=\"footnote-definition\" id=\"2\"><sup class=\"footnote-definition-label\">2</sup>\n<p>Rdar 17224140</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"Swift's @autoclosure allows to extend the Swift syntax in fantastic ways. Observe how we re-implement the `cond` function from Lisp\"\ntitle = \"Using @autoclosure to write a Swift syntax extension\"\ncreated = \"2014-06-08\"\npublished = true\nkeywords = [\"clojure\", \"lisp\", \"swift\", \"cond\", \"syntax\", \"macro\", \"extension\", \"cocoa\", \"ios\", \"feature\"]\nslug = \"2014-06-08-writing-simple-syntax-extensions-in-swift.html\"\ntags = [\"autoclosure\"]\ncategory = [\"Language\", \"All\"]\n\n[meta]\nswift_version = \"1.0\"\n---\n\n## Note\nThis article is severly outdated. I'm keeping it for posterity the way it is because\nit was writting at WWDC 2014 when Swift was released.\n## Endnote\n\nIt has been less than a week since Apple announced Swift, and people are\nalready writing libraries, snippet collections, or best practice posts.\nI suppose most did not even find the time to thouroughly read the Swift\nBook yet [^1].\n\nSome Examples are the [Swift\nCheatsheet](https://github.com/grant/swift-cheat-sheet), [Swiftz, a\nfunctional programming paradigm library for\nSwift](https://github.com/maxpow4h/swiftz), or [blog posts like this\none.](http://nategriswold.blogspot.com/2014/06/couple-swift-notes-from-wwdc.html)\n\n### Simple Custom Syntax\n\nOne Swift cricitism has been the lack of a macro system that would allow\nusers to freely extend the language like Lisp (and other homoiconic)\nlanguages do. While this is indeed not possible, there is a hidden gem\nin the Swift language that gives us some flexibility in this domain. If\nyou look at the Swift documentation for the various operators, you\\'ll\nfind this line:\n\n``` Swift\nfunc &&(lhs: LogicValue, rhs: @auto_closure () -> LogicValue) -> Bool\n```\n\nThe `&&` operator has two arguments: The left hand side and the right\nhand side. Swift first checks the left hand side. If this evaluates to\ntrue, only then will it evaluate the right hand side. This means that\nthe right hand side expression will defer evaluation until the left hand\nside was evaluated.\n\nHow does Swift do this? Through the magic `@auto_closure` syntax. This\ntells Swift to wrap the expression into a closure and only evaluate it\nif explicitly told to do so. The full function might look something like\nthis\n\n``` Swift\nfunc &&(lhs: LogicValue, rhs: @auto_closure () -> LogicValue) -> Bool {\n  // Proof for left hand side\n  if lhs {\n    // Only then execute and thus proof right hand side\n    if rhs() == true {\n      return true\n    }\n  }\n  return false\n}\n```\n\nThis is an interesting feature and allows us to implement more complex\nconstructs with a bit of tinkering. How about implementing something\nnew, namely the `cond` expression from Lisp?\n\n### Writing a cond expression for Swift\n\nIn Lisp, `cond` works as follows:\n\n``` Clojure\n(cond ((= a 1) \"a is one\")\n      ((= a 2) \"a is two\")\n      ((= a 4) \"a is four\"))\n```\n\nMuch like a `switch` statement, different cases are being tested for.\nEach line defines a test and after that a expression result. So if a\nequals 2 the switch statement will return \\\"a is two\\\". If a equals 1,\nit will return \\\"a is one\\\". In comparison to `switch`, `cond` also\nallows to test for different variables in one statement (i.e. is a 2 or\nis b 3). Another difference is that `cond` returns a value, while the\nSwift `switch` statement does not ([there\\'s actually a rdar bug for\nthis](http://nategriswold.blogspot.com/2014/06/couple-swift-notes-from-wwdc.html))\n\nGiven the `@auto_closure` feature from above, we can actually implement\n`cond` in Swift ourselves.\n\n-   We need an expression that evaluates to bool `() -> Bool`\n-   We need an expression that evaluates to Any result type `() -> Any`\n\nThese should be wrapped into closures, so that they will be evaluated\nsequentially and only if necessary. Lets start with a simple\nimplementation and build upon that.\n\nImagine the following situation: You\\'re processing user input, and you\nwant to delete something from either the memory or the database,\ndepending on what the user selected.\n\nWe want something that works for the current theoretical code:\n\n``` Swift\nvar a = get_user_input()\nvar b = get_current_entity()\n// delete fro memory or db depending on what user selected\nvar result = cond(a == 1, delete_from_db(b),\n                  a == 2, delete_from_memory(b))\n// make sure we deleted the correct one\nif result != b ....\n```\n\nThe important part here is that `delete_from_db` and\n`delete_from_memory` are only being executed if the condition \\'a == ?\\'\nis true for the selected case. Under no circumstance do we want our\nentity to be deleted from the db and the memory.\n\n### A first version\n\n``` Swift\nfunc cond_1 (a1: @auto_closure () -> Bool, b1: @auto_closure () -> Any,\n    a2: @auto_closure () -> Bool, b2: @auto_closure () -> Any,\n    bf: @auto_closure () -> Any) -> Any {\n        if a1() {\n            return b1()\n        } else if a2() {\n            return b2()\n        }\n        return bf()\n}\n```\n\nThere\\'s our expression. We can hand it two different cases and a\ndefault expression (as a fallback). Lets see how it works. We will\ndefine two simple functions that perform side effects (imagine deleting\na file, or writing to a file).\n\n``` Swift\nfunc perform_side_effects1() -> Any {\n    println(\"modify a state\")\n    return 1\n}\nfunc perform_side_effects2() -> Any {\n    println(\"modify another state\")\n    return 2\n}\n\nvar a = 1\nvar ctest = cond_1(a == 1, 2 + perform_side_effects1(),\n                  a == 2, 3 + perform_side_effects2(),\n                  0)\n// ctest is 3 (2 + 1)\n// prints only \"modify a state\"\nctest\n\n```\n\n### Handling more cases\n\nThis works fine, but it has a limitation in that it only works for two\ncases. This is clearly not optimal. Thankfully, Swift is pretty good at\nfunction overloading so we can simply define more functions with more\ncases and let swift do the hard work of figuring out which one to\nchoose:\n\n``` Swift\nfunc cond_2 (a1: @auto_closure () -> Bool, b1: @auto_closure () -> Any,\n    a2: @auto_closure () -> Bool, b2: @auto_closure () -> Any,\n    bf: @auto_closure () -> Any) -> Any {\n        if a1() {\n            return b1()\n        } else if a2() {\n            return b2()\n        }\n        return bf()\n}\n\nfunc cond_2 (a1: @auto_closure () -> Bool, b1: @auto_closure () -> Any,\n    a2: @auto_closure () -> Bool, b2: @auto_closure () -> Any,\n    a3: @auto_closure () -> Bool, b3: @auto_closure () -> Any,\n    bf: @auto_closure () -> Any) -> Any {\n        if a1() {\n            return b1()\n        } else if a2() {\n            return b2()\n        } else if a3() {\n            return a3()\n        }\n        return bf()\n}\n```\n\nYou can then extend this to ever more cases. Of course, this smells like\ncode duplication and there is a way around this, but that currently\ncrashes the Swift Compiler. I\\'ll come back to how to (at least\ntheoretically) do this at the end. First, there is another issue that we\nneed to address.\n\n### Making it generic\n\nOur current version succumbs every variable down to the `Any` type which\nmeans that the compiler won\\'t be able to perform advanced type\ninference for anything that comes out of this function. For example, the\nfollowing will not work because even though we\\'re clearly returning\n`Int` our actual function is set to return `Any`\n\n``` Swift\n// Causes an error\nvar b:Int = cond_2(0 == 1, 1, 0 == 2, 2, 3)\n// Works fine\nvar b:Any = cond_2(0 == 1, 1, 0 == 2, 2, 3)\n```\n\nSince types give us safety we\\'d rather have a funcion that tells us if\nwe accidentally try to do something wrong here. Thankfully, Swift has\nsupport for [Generic\nProgramming](http://en.wikipedia.org/wiki/Generic_programming) and only\na simple change is necessary for this:\n\n``` Swift\nfunc cond_3<T> (a1: @auto_closure () -> Bool, b1: @auto_closure () -> T,\n    a2: @auto_closure () -> Bool, b2: @auto_closure () -> T,\n    bf: @auto_closure () -> T) -> T {\n        if a1() {\n            return b1()\n        } else if a2() {\n            return b2()\n        }\n        return bf()\n}\n\n// Works fine!\nvar b:Int = cond_3(0 == 1, 1, 0 == 2, 2, 3)\n```\n\nThat\\'s it, now we\\'re telling Swift that this function handles items of\ntype T and that the very same type T is the return type of this funcion.\n\nThrough this, we can use our cond~3~ function on types of any kind like\nString, Array, Int, or custom types.\n\n### Wrap up\n\nThat\\'s it! We\\'ve implemented our own syntax extension for Swift! Now\nwe can write code this as this\n\n``` Swift\nvar a = get_user_input()\nvar b = get_current_entity()\n// delete fro memory or db depending on what user selected\nvar result = cond(a == 1, delete_from_db(b),\n                  a == 2, delete_from_memory(b))\n// make sure we deelted the correct one\nif result != b ....\n```\n\nNow, the entity would only be deleted from db or from memory if a\ncontains the correct variable. Keep in mind that this was only a simple\nexample. Much more is possible if you use this in a smart way.\n\nEven better if one combines this in a neat way with the first closure as\nbody mechanism or with operators. I\\'m sure that we can already create\nsome pretty stunning syntax extensions with this. However, this, only if\nit doesn\\'t crash the compiler, which brings us to the next and final\nsection.\n\n### Limitations\n\nAll current Swift projects suffer from the current slightly beta state\nof the build tools and the Swift compiler. This leads to much code that\nlooks a bit cumbersome but can easily be improved in the future. In this\ncase, here\\'s some untested code, that wraps the complete logic in one\nbig function and only defines additional lightweight wrappers to deal\nwith the parameters variations. Still not optimal but much more\nreadable. Sadly, this crashes the compiler (actually it kills Xcode the\nminute you type it in, which is pretty impressive.[^2]).\n\n``` Swift\nfunc _cond<T> (a1: @auto_closure () -> Bool, b1: @auto_closure () -> T?,\n    a2: @auto_closure () -> Bool, b2: @auto_closure () -> T?,\n    a3: @auto_closure () -> Bool, b3: @auto_closure () -> T?,\n    a4: @auto_closure () -> Bool, b4: @auto_closure () -> T?,\n    a5: @auto_closure () -> Bool, b5: @auto_closure () -> T?\n) -> T? {\n        if a1() {\n            return b1()\n        } else if a2() {\n            return b2()\n        } else if a3() {\n            return b3()\n        } else if a4() {\n            return b4()\n        } else if a5() {\n            return a5()\n        }\n        return nil\n}\n// two parameter implementation\nfunc cond<T>(a1: @auto_closure () -> Bool, b1: @auto_closure () -> T,\n    a2: @auto_closure () -> Bool, b2: @auto_closure () -> T,\n    bf: @auto_closure () -> T) -> T {\n        if let r = _cond(a1, b1, a2, b2, false, {}(), false, {}(), false, {}()) {\n            return r\n        }\n        return bf()\n}\n// three parameter implementation\nfunc cond<T>(a1: @auto_closure () -> Bool, b1: @auto_closure () -> T,\n    a2: @auto_closure () -> Bool, b2: @auto_closure () -> T,\n    a3: @auto_closure () -> Bool, b3: @auto_closure () -> T,\n    bf: @auto_closure () -> T) -> T {\n        if let r = _cond(a1, b1, a2, b2, a3, b3, false, {}(), false, {}()) {\n            return r\n        }\n        return bf()\n}\n```\n\nI\\'m not sure if this would lead to correct results if it would work,\nbut based on my current understanding of the language it should be fine.\n\n### Update\n\n[bjustin](https://news.ycombinator.com/user?id%3Dbjustin) offered [this\nslight modification](https://news.ycombinator.com/item?id%3D7865603)\nthat makes it easy to use unlimited cases. The only downside is that the\nfallback has to be the first item.\n\n``` Swift\nfunc cond<T>(#fallback: T, testsAndExprs: (test: @auto_closure () -> Bool, expr: @auto_closure () -> T)...) -> T {\n    for (t, e) in testsAndExprs {\n        if t() {\n            return e()\n        }\n    }\n    return fallback\n}\n\n// And in use:\n\n// y is assigned \"0 == 0, of course\"\nlet y = cond(fallback: \"fallback\", (test: false, expr: \"not this branch\"), (test: 0 == 0, expr: \"0 == 0, of course\"))\n```\n\n[^1]: I completely omitted the language reference. Impossible to work\n    through something like that during a chronically sleep-deprived week\n    like WWDC\n\n[^2]: Rdar 17224140\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/typealiases.md":["a8e53111970e1d01",{"identifier":"761b0aa9","filename":"typealiases.md","info":{"title":"The usefulness of typealiases in swift","tags":[],"keywords":["typealias","generics","struct"],"category":[],"created":"2019-05-15 10:30:30","description":"When thinking about the great language features of Swift, few people think about `typealias` first. However, there're many situations where they can become particularly useful.","description_html":"<p>When thinking about the great language features of Swift, few people think about <code>typealias</code> first. However, there're many situations where they can become particularly useful.</p>\n","published":true,"slug":null,"meta":{"feature_image":"/img-content/typealias-code.jpg","thumbnail":"/img-content/typealias.png"},"created_timestamp":1557916230,"date":"2019-05-15T10:30:30","date_info":{"year":2019,"month":5,"day":15,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2019-5-15-the-usefulness-of-typealiases-in-swift.html","content":"<h1>What is a <code>typealias</code>?</h1>\n<p>When thinking about the great language features of Swift, few people think about the <code>typealias</code>. However, there're many situations where a typealias can become useful. This article will give a brief introduction of what a <code>typealias</code> is, how you define it, and list multiple examples of how you can use them in your own code. Lets dive in.</p>\n<p>A <code>typealias</code> is - as the name implies - an alias for a specific type. Types, such as <code>Int</code>, <code>Double</code>, <code>UIViewController</code>, or one of your custom types. A <code>Int32</code> and a <code>Int8</code> are different types. A type alias, on the other hand, inserts a second name for an existing type into your codebase. For example:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Money = <span class=\"type\">Int</span>\n</code></pre></code></pre>\n<p>Creates an alias for the <code>Int</code> type. With this, you can use <code>Money</code> as if it were <code>Int</code> everywhere in your code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Bank {\n\n   <span class=\"keyword\">typealias</span> Money = <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">private var</span> credit: <span class=\"type\">Money</span> = <span class=\"number\">0</span>\n\n   <span class=\"keyword\">mutating func</span> deposit(amount: <span class=\"type\">Money</span>) {\n\n     credit += amount\n\n   }\n\n   <span class=\"keyword\">mutating func</span> withdraw(amount: <span class=\"type\">Money</span>) {\n\n     credit -= amount\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Above, we have a struct <code>Bank</code> that manages money. Instead of using <code>Int</code> for our amounts, though, we use our <code>Money</code> type. Observe that the <code>+=</code> and <code>-=</code> operators still work as expected.</p>\n<p>You can also mix and match type aliases and the original types. This is possible because, to the Swift compiler, they all resolve to the same thing:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Bank {\n\n   <span class=\"keyword\">typealias</span> DepositMoney = <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">typealias</span> WithdrawMoney = <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">private var</span> credit: <span class=\"type\">Int</span> = <span class=\"number\">0</span>\n\n   <span class=\"keyword\">mutating func</span> deposit(amount: <span class=\"type\">DepositMoney</span>) {\n\n     credit += amount\n\n   }\n\n   <span class=\"keyword\">mutating func</span> withdraw(amount: <span class=\"type\">WithdrawMoney</span>) {\n\n     credit -= amount\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Here, we're mixing <code>Int</code> and our different custom type aliases <code>DepositMoney</code> and <code>WithdrawMoney</code>.</p>\n<h2>Generic Type aliases</h2>\n<p>In addition to the above, a type aliase can also have generic parameters:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> MyArray&lt;T&gt; = <span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt;\n\n<span class=\"keyword\">let</span> newArray: <span class=\"type\">MyArray</span> = <span class=\"type\">MyArray</span>(arrayLiteral: <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n</code></pre></code></pre>\n<p>Above, we defined a typealias for <code>MyArray</code> that works just like the normal array.\nFinally, the generic parameters of your aliased types can even have constraints. Imagine that we want our new <code>MyArray</code> to only hold types that conform to <code>StringProtocol</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> MyArray&lt;T&gt; = <span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt; <span class=\"keyword\">where</span> <span class=\"type\">T</span>: <span class=\"type\">StringProtocol</span>\n</code></pre></code></pre>\n<p>This is already a nice feature as you can quickly define arrays for particular types without having to subclass <code>Array</code>. With that said, let us look at some practical applications of these typealias types.</p>\n<h1>Practical Applications</h1>\n<h2>Clearer Code</h2>\n<p>The first, and obvious, use case is something we already briefly touched on. A type alias can give your code more meaning. In our example <code>typealias Money = Int</code> we introduced a clear concept of what the <code>Money</code> type is. Using it like <code>let amount: Money = 0</code> is much more understandable than <code>let amount: Int = 0</code>. In the first example, you know immediately that this is an <em>amount</em> of <em>money</em>. In the second example, it could be anything: An amount of bikes, an amount of characters, an amount of donuts - who knows!</p>\n<p>Obviously, this is not always necessary. If your function signature already clearly explains the type of the parameter (<code>func orderDonuts(amount: Int)</code>) then it would be an unnecessary overhead to include another typealias. On the other hand, for variables and constants, it oftentimes improves readability and tremendously improves the documentation.</p>\n<h2>Simpler Optional Closures</h2>\n<p>Optional closures in Swift are a wee bit unwieldy. The normal definition of a closure accepting one <code>Int</code> parameter and returning <code>Int</code> looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> handle(action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) { ... }\n</code></pre></code></pre>\n<p>Now, if you want to make this closure optional, you can't just add a questionmark:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> handle(action: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>?) { ... }\n</code></pre></code></pre>\n<p>After all, this is not an optional closure but instead <em>a closure that returns optional <code>Int</code></em>. The right way to do this is by adding parentheses:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> handle(action: ((<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>)?) { ... }\n</code></pre></code></pre>\n<p>This becomes especially ugly if you have multiple of such actions. Below, have have a function that handles a success and failure case, as well as calling an additional closure with the progress of the operation.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> handle(success: ((<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>)?,\n\n             failure: ((<span class=\"type\">Error</span>) -&gt; <span class=\"type\">Void</span>)?,\n\n             progress: ((<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Void</span>)?) {\n\n     \n\n}\n</code></pre></code></pre>\n<p>This small section of code contains <em>a lot</em> of parentheses. As we're not aiming to become lispers, we'd like to address this by using typealiases for the different closures:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Success = (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>\n\n<span class=\"keyword\">typealias</span> Failure = (<span class=\"type\">Error</span>) -&gt; <span class=\"type\">Void</span>\n\n<span class=\"keyword\">typealias</span> Progress = (<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Void</span>\n\n\n\n<span class=\"keyword\">func</span> handle2(success: <span class=\"type\">Success</span>?, failure: <span class=\"type\">Failure</span>?, progress: <span class=\"type\">Progress</span>?) { ... }\n</code></pre></code></pre>\n<p>The actual function does look much more readable. While this is good, we did introduce additional syntax through three lines of <code>typealias</code>. This, however, might actually help us in the long run, as we will see next.</p>\n<h2>Centralizing Defintions</h2>\n<p>The action handlers in our previous example might not be the only place where this specific type is used. Here's a draft of what a slightly modified class would look like that actually uses the action handler:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> Dispatcher {\n\n   <span class=\"keyword\">private var</span> successHandler: ((<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span>)?\n\n   <span class=\"keyword\">private var</span> errorHandler: ((<span class=\"type\">Error</span>) -&gt; <span class=\"type\">Void</span>)?\n\n   \n\n   <span class=\"keyword\">func</span> handle(success: ((<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span>)?, error: ((<span class=\"type\">Error</span>) -&gt; <span class=\"type\">Void</span>)?) {\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">successHandler</span> = success\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">errorHandler</span> = error\n\n     <span class=\"call\">internalHandle</span>()\n\n   }\n\n   \n\n   <span class=\"keyword\">func</span> handle(success: ((<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span>)?) {\n\n    <span class=\"keyword\">self</span>.<span class=\"property\">successHandler</span> = success\n\n     <span class=\"call\">internalHandle</span>()\n\n   }\n\n   \n\n   <span class=\"keyword\">func</span> handle(error: ((<span class=\"type\">Int</span>)-&gt; <span class=\"type\">Void</span>?)) {\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">errorHandler</span> = error\n\n     <span class=\"call\">internalHandle</span>()\n\n   }\n\n   \n\n   <span class=\"keyword\">private func</span> internalHandle() {\n\n    ...\n\n   }\n\n}\n</code></pre></code></pre>\n<p>This struct introduces two closures, one for the success and one for the error case. However, we also want to offer convenience functions to call with only the one or the other handler. In the example above, if we want to add another parameter to the success and error handler, say the <code>HTTPResponse</code>, we'll need to update a lot of code. <code>((Int) -&gt; Void)?</code>  would need to become <code>((Int, HTTPResponse) -&gt; Void)?</code> in three places. Similarly for the errorHandler. By using multiple typealiases, we can circumvent this and only have to modify the type in one place:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> Dispatcher {\n\n   <span class=\"keyword\">typealias</span> Success = (<span class=\"type\">Int</span>, <span class=\"type\">HTTPResponse</span>) -&gt; <span class=\"type\">Void</span>\n\n   <span class=\"keyword\">typealias</span> Failure = (<span class=\"type\">Error</span>, <span class=\"type\">HTTPResponse</span>) -&gt; <span class=\"type\">Void</span>\n\n\n\n   <span class=\"keyword\">private var</span> successHandler: <span class=\"type\">Success</span>?\n\n   <span class=\"keyword\">private var</span> errorHandler: <span class=\"type\">Failure</span>?\n\n   \n\n   <span class=\"keyword\">func</span> handle(success: <span class=\"type\">Success</span>?, error: <span class=\"type\">Failure</span>?) {\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">successHandler</span> = success\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">errorHandler</span> = error\n\n     <span class=\"call\">internalHandle</span>()\n\n   }\n\n   \n\n   <span class=\"keyword\">func</span> handle(success: <span class=\"type\">Success</span>?) {\n\n    <span class=\"keyword\">self</span>.<span class=\"property\">successHandler</span> = success\n\n     <span class=\"call\">internalHandle</span>()\n\n   }\n\n   \n\n   <span class=\"keyword\">func</span> handle(error: <span class=\"type\">Failure</span>?) {\n\n     <span class=\"keyword\">self</span>.<span class=\"property\">errorHandler</span> = error\n\n     <span class=\"call\">internalHandle</span>()\n\n   }\n\n   \n\n   <span class=\"keyword\">private func</span> internalHandle() {\n\n    ...\n\n   }\n\n}\n</code></pre></code></pre>\n<p>Not only is this much easier to read, it will also continue to be helpful as we introduce the type in more places.</p>\n<h2>Generic Aliases</h2>\n<p>A typealias can also be generic. One simple use case would be to enforce a container with a special meaning. Say we have an app that processes books. A book consists out of chapters, chapters consist out of pages. Fundamentally, those are just arrays though. <code>typealias</code> to the resuce:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Page {}\n\n<span class=\"keyword\">typealias</span> Chapter = <span class=\"type\">Array</span>&lt;<span class=\"type\">Page</span>&gt;\n\n<span class=\"keyword\">typealias</span> Book = <span class=\"type\">Array</span>&lt;<span class=\"type\">Chapter</span>&gt;\n</code></pre></code></pre>\n<p>This has two benefits compared to just using a array.</p>\n<ol>\n<li>The code is more explanatory</li>\n<li>The array that houses the pages can <em>only</em> contain pages. Nothing else.</li>\n</ol>\n<p>Coming back to our earlier example of using <em>success</em> and <em>failure</em> handlers, we can improve this even more by using a generic handler:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Handler&lt;In&gt; = (<span class=\"type\">In</span>, <span class=\"type\">HTTPResponse</span>?, <span class=\"type\">Context</span>) -&gt; <span class=\"type\">Void</span>\n\n\n\n<span class=\"keyword\">func</span> handle(success: <span class=\"type\">Handler</span>&lt;<span class=\"type\">Int</span>&gt;?, \n\n             failure: <span class=\"type\">Handler</span>&lt;<span class=\"type\">Error</span>&gt;?,\n\n            progress: <span class=\"type\">Handler</span>&lt;<span class=\"type\">Double</span>&gt;?,)\n</code></pre></code></pre>\n<p>This composes really well and allows us to write a simpler function, and have one place where we edit the <code>Handler</code>.</p>\n<p>This approach is also very useful with your own types. You can create one generic definition and then define detailed typealiases:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> ComputationResult&lt;T&gt; {\n\n   <span class=\"keyword\">private var</span> result: <span class=\"type\">T</span>\n\n}\n\n\n\n<span class=\"keyword\">typealias</span> DataResult = <span class=\"type\">ComputationResult</span>&lt;<span class=\"type\">Data</span>&gt;\n\n<span class=\"keyword\">typealias</span> StringResult = <span class=\"type\">ComputationResult</span>&lt;<span class=\"type\">String</span>&gt;\n\n<span class=\"keyword\">typealias</span> IntResult = <span class=\"type\">ComputationResult</span>&lt;<span class=\"type\">Int</span>&gt;\n</code></pre></code></pre>\n<p>Again, the typealias allows us to write less code and simplifies our definitions.</p>\n<h2>Tuples like Functions</h2>\n<p>Similarly, you can use generics and tuples to define types without having to resort to structs. Below, we envision the datatype for a genetic algorithm that modifies its value <code>T</code> over multiple generations.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">typealias</span> Generation&lt;T: <span class=\"type\">Numeric</span>&gt; = (initial: <span class=\"type\">T</span>, seed: <span class=\"type\">T</span>, count: <span class=\"type\">Int</span>, current: <span class=\"type\">T</span>)\n</code></pre></code></pre>\n<p>If you define a typealias like this, you can actually initialize it like you would initialize a struct:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> firstGeneration = <span class=\"type\">Generation</span>(initial: <span class=\"number\">10</span>, seed: <span class=\"number\">42</span>, count: <span class=\"number\">0</span>, current: <span class=\"number\">10</span>)\n</code></pre></code></pre>\n<p>While this does look like a struct, it is just a type alias for a tuple.</p>\n<h2>Combining Protocols</h2>\n<p>Sometimes you end up in a situation where you have multiple protocols and there is one specific type that should implement them all. Usually this happens when you define a protocol hierachy in order to provide more flexibility.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> CanRead {}\n\n<span class=\"keyword\">protocol</span> CanWrite {}\n\n<span class=\"keyword\">protocol</span> CanAuthorize {}\n\n<span class=\"keyword\">protocol</span> CanCreateUser {}\n\n\n\n<span class=\"keyword\">typealias</span> Administrator = <span class=\"type\">CanRead</span> &amp; <span class=\"type\">CanWrite</span> &amp; <span class=\"type\">CanAuthorize</span> &amp; <span class=\"type\">CanCreateUser</span>\n\n\n\n<span class=\"keyword\">typealias</span> User = <span class=\"type\">CanRead</span> &amp; <span class=\"type\">CanWrite</span>\n\n\n\n<span class=\"keyword\">typealias</span> Consumer = <span class=\"type\">CanRead</span>\n\n\n</code></pre></code></pre>\n<p>Here, we define a permission hierachy. The administrator can do everything, a user can read and write, and a consumer can only read.</p>\n<h2>Associated Types</h2>\n<p>This goes beyond the scope of this article, but the associated types of protocols are also defined via type aliases:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Example {\n\n  <span class=\"keyword\">associatedtype</span> Payload: <span class=\"type\">Numeric</span>\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Implementation: <span class=\"type\">Example</span> {\n\n   <span class=\"keyword\">typealias</span> Payload = <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<h1>Drawbacks</h1>\n<p>While typealiases are generally a very useful feature, they have one small drawback: If you're new to a codebase, then there's an important difference between these two definitions:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> first(action: (<span class=\"type\">Int</span>, <span class=\"type\">Error</span>?) -&gt; <span class=\"type\">Void</span>) {}\n\n<span class=\"keyword\">func</span> second(action: <span class=\"type\">Success</span>) {}\n</code></pre></code></pre>\n<p>The second one is not immediately obvious. What kind of type is <code>Success</code>? How do you construct it? You'll have to option-click it in Xcode in order to understand what it does and how it works. This causes additional overhead. If you use many typealiases, this will take even more time. There's no good solution to this, except that it (as so often) depends on the usecase.</p>\n<h1>Final Words</h1>\n<p>I hope you enjoyed this brief overview of the potential of typealiases. If you have any feedback, <a href=\"https://twitter.com/terhechte\">you can find me on twitter.</a></p>\n","raw_content":"[frontMatter]\ndescription = \"When thinking about the great language features of Swift, few people think about `typealias` first. However, there're many situations where they can become particularly useful.\"\ntitle = \"The usefulness of typealiases in swift\"\ncreated = \"2019-05-15\"\npublished = true\nkeywords = [\"typealias\", \"generics\", \"struct\"]\ntags = []\n\n[meta]\nfeature_image = \"/img-content/typealias-code.jpg\"\nthumbnail = \"/img-content/typealias.png\"\n---\n# What is a `typealias`?\n\nWhen thinking about the great language features of Swift, few people think about the `typealias`. However, there're many situations where a typealias can become useful. This article will give a brief introduction of what a `typealias` is, how you define it, and list multiple examples of how you can use them in your own code. Lets dive in.\n\nA `typealias` is - as the name implies - an alias for a specific type. Types, such as `Int`, `Double`, `UIViewController`, or one of your custom types. A `Int32` and a `Int8` are different types. A type alias, on the other hand, inserts a second name for an existing type into your codebase. For example:\n\n``` swift\ntypealias Money = Int\n```\n\nCreates an alias for the `Int` type. With this, you can use `Money` as if it were `Int` everywhere in your code:\n\n``` swift\nstruct Bank {\n  typealias Money = Int\n  private var credit: Money = 0\n  mutating func deposit(amount: Money) {\n    credit += amount\n  }\n  mutating func withdraw(amount: Money) {\n    credit -= amount\n  }\n}\n```\n\nAbove, we have a struct `Bank` that manages money. Instead of using `Int` for our amounts, though, we use our `Money` type. Observe that the `+=` and `-=` operators still work as expected.\n\nYou can also mix and match type aliases and the original types. This is possible because, to the Swift compiler, they all resolve to the same thing:\n\n``` swift\nstruct Bank {\n  typealias DepositMoney = Int\n  typealias WithdrawMoney = Int\n  private var credit: Int = 0\n  mutating func deposit(amount: DepositMoney) {\n    credit += amount\n  }\n  mutating func withdraw(amount: WithdrawMoney) {\n    credit -= amount\n  }\n}\n```\n\nHere, we're mixing `Int` and our different custom type aliases `DepositMoney` and `WithdrawMoney`.\n\n## Generic Type aliases\n\nIn addition to the above, a type aliase can also have generic parameters:\n\n``` swift\ntypealias MyArray<T> = Array<T>\nlet newArray: MyArray = MyArray(arrayLiteral: 1, 2, 3)\n```\n\nAbove, we defined a typealias for `MyArray` that works just like the normal array.\nFinally, the generic parameters of your aliased types can even have constraints. Imagine that we want our new `MyArray` to only hold types that conform to `StringProtocol`:\n\n``` swift\ntypealias MyArray<T> = Array<T> where T: StringProtocol\n```\n\nThis is already a nice feature as you can quickly define arrays for particular types without having to subclass `Array`. With that said, let us look at some practical applications of these typealias types.\n\n# Practical Applications\n\n## Clearer Code\n\nThe first, and obvious, use case is something we already briefly touched on. A type alias can give your code more meaning. In our example `typealias Money = Int` we introduced a clear concept of what the `Money` type is. Using it like `let amount: Money = 0` is much more understandable than `let amount: Int = 0`. In the first example, you know immediately that this is an *amount* of *money*. In the second example, it could be anything: An amount of bikes, an amount of characters, an amount of donuts - who knows!\n\nObviously, this is not always necessary. If your function signature already clearly explains the type of the parameter (`func orderDonuts(amount: Int)`) then it would be an unnecessary overhead to include another typealias. On the other hand, for variables and constants, it oftentimes improves readability and tremendously improves the documentation. \n\n## Simpler Optional Closures\n\nOptional closures in Swift are a wee bit unwieldy. The normal definition of a closure accepting one `Int` parameter and returning `Int` looks like this:\n\n``` swift\nfunc handle(action: (Int) -> Int) { ... }\n```\n\nNow, if you want to make this closure optional, you can't just add a questionmark:\n\n``` swift\nfunc handle(action: (Int) -> Int?) { ... }\n```\n\nAfter all, this is not an optional closure but instead *a closure that returns optional `Int`*. The right way to do this is by adding parentheses:\n\n``` swift\nfunc handle(action: ((Int) -> Int)?) { ... }\n```\n\nThis becomes especially ugly if you have multiple of such actions. Below, have have a function that handles a success and failure case, as well as calling an additional closure with the progress of the operation.\n\n``` swift\nfunc handle(success: ((Int) -> Int)?,\n            failure: ((Error) -> Void)?,\n            progress: ((Double) -> Void)?) {\n    \n}\n```\n\nThis small section of code contains *a lot* of parentheses. As we're not aiming to become lispers, we'd like to address this by using typealiases for the different closures:\n\n``` swift\ntypealias Success = (Int) -> Int\ntypealias Failure = (Error) -> Void\ntypealias Progress = (Double) -> Void\n\nfunc handle2(success: Success?, failure: Failure?, progress: Progress?) { ... }\n```\n\nThe actual function does look much more readable. While this is good, we did introduce additional syntax through three lines of `typealias`. This, however, might actually help us in the long run, as we will see next.\n\n## Centralizing Defintions\n\nThe action handlers in our previous example might not be the only place where this specific type is used. Here's a draft of what a slightly modified class would look like that actually uses the action handler:\n\n``` swift\nfinal class Dispatcher {\n  private var successHandler: ((Int) -> Void)?\n  private var errorHandler: ((Error) -> Void)?\n  \n  func handle(success: ((Int) -> Void)?, error: ((Error) -> Void)?) {\n    self.successHandler = success\n    self.errorHandler = error\n    internalHandle()\n  }\n  \n  func handle(success: ((Int) -> Void)?) {\n   self.successHandler = success\n    internalHandle()\n  }\n  \n  func handle(error: ((Int)-> Void?)) {\n    self.errorHandler = error\n    internalHandle()\n  }\n  \n  private func internalHandle() {\n   ...\n  }\n}\n```\n\nThis struct introduces two closures, one for the success and one for the error case. However, we also want to offer convenience functions to call with only the one or the other handler. In the example above, if we want to add another parameter to the success and error handler, say the `HTTPResponse`, we'll need to update a lot of code. `((Int) -> Void)?`  would need to become `((Int, HTTPResponse) -> Void)?` in three places. Similarly for the errorHandler. By using multiple typealiases, we can circumvent this and only have to modify the type in one place:\n\n``` swift\nfinal class Dispatcher {\n  typealias Success = (Int, HTTPResponse) -> Void\n  typealias Failure = (Error, HTTPResponse) -> Void\n\n  private var successHandler: Success?\n  private var errorHandler: Failure?\n  \n  func handle(success: Success?, error: Failure?) {\n    self.successHandler = success\n    self.errorHandler = error\n    internalHandle()\n  }\n  \n  func handle(success: Success?) {\n   self.successHandler = success\n    internalHandle()\n  }\n  \n  func handle(error: Failure?) {\n    self.errorHandler = error\n    internalHandle()\n  }\n  \n  private func internalHandle() {\n   ...\n  }\n}\n```\n\nNot only is this much easier to read, it will also continue to be helpful as we introduce the type in more places.\n\n## Generic Aliases\n\nA typealias can also be generic. One simple use case would be to enforce a container with a special meaning. Say we have an app that processes books. A book consists out of chapters, chapters consist out of pages. Fundamentally, those are just arrays though. `typealias` to the resuce:\n\n``` swift\nstruct Page {}\ntypealias Chapter = Array<Page>\ntypealias Book = Array<Chapter>\n```\n\nThis has two benefits compared to just using a array.\n1. The code is more explanatory\n2. The array that houses the pages can *only* contain pages. Nothing else. \n\nComing back to our earlier example of using *success* and *failure* handlers, we can improve this even more by using a generic handler:\n\n``` swift\ntypealias Handler<In> = (In, HTTPResponse?, Context) -> Void\n\nfunc handle(success: Handler<Int>?, \n            failure: Handler<Error>?,\n           progress: Handler<Double>?,)\n```\n\nThis composes really well and allows us to write a simpler function, and have one place where we edit the `Handler`.\n\nThis approach is also very useful with your own types. You can create one generic definition and then define detailed typealiases:\n\n``` swift\nstruct ComputationResult<T> {\n  private var result: T\n}\n\ntypealias DataResult = ComputationResult<Data>\ntypealias StringResult = ComputationResult<String>\ntypealias IntResult = ComputationResult<Int>\n```\n\nAgain, the typealias allows us to write less code and simplifies our definitions.\n\n## Tuples like Functions\n\nSimilarly, you can use generics and tuples to define types without having to resort to structs. Below, we envision the datatype for a genetic algorithm that modifies its value `T` over multiple generations.\n\n``` swift\ntypealias Generation<T: Numeric> = (initial: T, seed: T, count: Int, current: T)\n```\n\nIf you define a typealias like this, you can actually initialize it like you would initialize a struct:\n\n``` swift\nlet firstGeneration = Generation(initial: 10, seed: 42, count: 0, current: 10)\n```\n\nWhile this does look like a struct, it is just a type alias for a tuple.\n\n## Combining Protocols\n\nSometimes you end up in a situation where you have multiple protocols and there is one specific type that should implement them all. Usually this happens when you define a protocol hierachy in order to provide more flexibility.\n\n``` swift\nprotocol CanRead {}\nprotocol CanWrite {}\nprotocol CanAuthorize {}\nprotocol CanCreateUser {}\n\ntypealias Administrator = CanRead & CanWrite & CanAuthorize & CanCreateUser\n\ntypealias User = CanRead & CanWrite\n\ntypealias Consumer = CanRead\n\n```\n\nHere, we define a permission hierachy. The administrator can do everything, a user can read and write, and a consumer can only read.\n\n## Associated Types\n\nThis goes beyond the scope of this article, but the associated types of protocols are also defined via type aliases:\n\n``` swift\nprotocol Example {\n associatedtype Payload: Numeric\n}\n\nstruct Implementation: Example {\n  typealias Payload = Int\n}\n```\n\n# Drawbacks\n\nWhile typealiases are generally a very useful feature, they have one small drawback: If you're new to a codebase, then there's an important difference between these two definitions:\n\n``` swift\nfunc first(action: (Int, Error?) -> Void) {}\nfunc second(action: Success) {}\n```\n\nThe second one is not immediately obvious. What kind of type is `Success`? How do you construct it? You'll have to option-click it in Xcode in order to understand what it does and how it works. This causes additional overhead. If you use many typealiases, this will take even more time. There's no good solution to this, except that it (as so often) depends on the usecase.\n\n# Final Words\n\nI hope you enjoyed this brief overview of the potential of typealiases. If you have any feedback, [you can find me on twitter.](https://twitter.com/terhechte)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/optionals/intro.md":["9e7ec2d630e65e01",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"What are Optionals","tags":["optionals"],"keywords":[],"category":[],"created":"2019-03-02 16:04:26","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551542666,"date":"2019-03-02T16:04:26","date_info":{"year":2019,"month":3,"day":2,"hour":16,"minute":4,"second":26},"identifier":"","indexed":true},"slug":"//2019-3-2-what-are-optionals.html","content":"<h1>What are Optionals</h1>\n<p>Optionals are one of the staple features of Swift. They're something that appears very, very often during normal iOS development. Much more often than other features such as enums or generics.</p>\n<p>However, if you're new to Swift and come from a different programming language such as Python, Ruby, or even Objective-C, then optionals can be daunting. This guide is split up into a basic introduction into <code>Optionals</code> for those new to the subject matter and an advanced guide that will showcase more advanced optional handling for more seasoned developers.</p>\n<p>Lets begin by briefly explaining why optionals are even needed.</p>\n","raw_content":"[frontMatter]\ntitle = \"What are Optionals\"\ntags = [\"optionals\"]\ncreated = \"2019-03-02 16:04:26\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# What are Optionals\n\nOptionals are one of the staple features of Swift. They're something that appears very, very often during normal iOS development. Much more often than other features such as enums or generics. \n\nHowever, if you're new to Swift and come from a different programming language such as Python, Ruby, or even Objective-C, then optionals can be daunting. This guide is split up into a basic introduction into `Optionals` for those new to the subject matter and an advanced guide that will showcase more advanced optional handling for more seasoned developers.\n\nLets begin by briefly explaining why optionals are even needed.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/working_around_associated_type_issues/method_only_types.md":["690bd022545ba1a3",{"identifier":"99094ea8","filename":"method_only_types.md","info":{"title":"Method-Only Types","tags":["box","associated"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-methodonly-types.html","content":"<h1>Method-Only Types</h1>\n<p>If your <code>associated type</code> requirement doesn't come from <code>Equatable</code>\nconformance but instead from your own use, you can double-check if you\nactually need these associated types.</p>\n<p>Take this example of a validator type:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Validator {\n\n     <span class=\"keyword\">associatedtype</span> I\n\n     <span class=\"keyword\">func</span> validate(<span class=\"keyword\">_</span> input: <span class=\"type\">I</span>) -&gt; <span class=\"type\">Bool</span>\n\n}\n</code></pre></code></pre>\n<p>As the <code>associated type</code> is only used in one method, you can\nalternatively just make it a <code>generic</code> method and thus save yourself\nfrom introducing unnecessary unfinished types:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Validator {\n\n     <span class=\"keyword\">func</span> validate&lt;I&gt;(<span class=\"keyword\">_</span> input: <span class=\"type\">I</span>) -&gt; <span class=\"type\">Bool</span>\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Method-Only Types\"\ntags = [\"box\", \"associated\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Method-Only Types\n\nIf your `associated type` requirement doesn\\'t come from `Equatable`\nconformance but instead from your own use, you can double-check if you\nactually need these associated types.\n\nTake this example of a validator type:\n\n``` Swift\nprotocol Validator {\n    associatedtype I\n    func validate(_ input: I) -> Bool\n}\n```\n\nAs the `associated type` is only used in one method, you can\nalternatively just make it a `generic` method and thus save yourself\nfrom introducing unnecessary unfinished types:\n\n``` Swift\nprotocol Validator {\n    func validate<I>(_ input: I) -> Bool\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/enable_disable_menubar_items.md":["02dfb82ee195a6da",{"identifier":"a684c96e","filename":"enable_disable_menubar_items.md","info":{"title":"How do I enable / disable menubar items based on whats visible on screen?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-enable-disable-menubar-items-based-on-whats-visible-on-screen.html","content":"<p>Catalyst, just like Cocoa, uses the <a href=\"how/responder_chain.md\">responder chain</a> to figure out whether an action in a menu can be performed. <a href=\"firststeps/modify_menubar.md\">Remember, that a menu bar on iOS is composed out of <code>UIAction</code>, <code>UICommand</code>, and <code>UIMenu</code> objects.</a></p>\n<p>The way that works is as follows:</p>\n<ol>\n<li>When you open a menu in the menu bar with your mouse</li>\n<li>UIKit will have a look at the first responder and call</li>\n<li><a href=\"https://developer.apple.com/documentation/uikit/uiresponder/1621105-canperformaction\"><code>canPerformAction(_:withSender:)</code></a> to figure out if the first responder has a matching <code>@IBAction someMethod</code> that fits the selector from the menubar item in question</li>\n<li>If the first responder returns no, it will ask the next responder</li>\n<li>If a responder returns yes, then this menu bar entry will be enabled (clickable) and this responder (i.e. object or view controller) will be set as the current <code>target</code> of the menu bar entry.</li>\n<li>If the next responder is nil - that is, it UIKit reached the end of the responder chain - it will stop and the menu bar entry will be disabled.</li>\n</ol>\n<p>This process happens for each item in the menubar.</p>\n<p>If you want to influence how a menu bar item becomes enabled / disabled based on the particulars of your view controller, you can override <code>canPerformAction</code> and write custom logic. Here is a quick example. Here, we imagine that a menubar action should only be enabled if we have actual text in our textField.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">override func</span> canPerformAction(<span class=\"keyword\">_</span> action: <span class=\"type\">Selector</span>, withSender sender: <span class=\"type\">Any</span>?) -&gt; <span class=\"type\">Bool</span> {\n\n   <span class=\"keyword\">guard</span> !(textField.<span class=\"property\">text</span> ?? \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>).<span class=\"property\">isEmpty</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return false</span> }\n\n   <span class=\"keyword\">return super</span>.<span class=\"call\">canPerformAction</span>(action, withSender: sender)\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I enable / disable menubar items based on whats visible on screen?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nCatalyst, just like Cocoa, uses the [responder chain](how/responder_chain.md) to figure out whether an action in a menu can be performed. [Remember, that a menu bar on iOS is composed out of `UIAction`, `UICommand`, and `UIMenu` objects.](firststeps/modify_menubar.md)\n\nThe way that works is as follows:\n\n1. When you open a menu in the menu bar with your mouse\n2. UIKit will have a look at the first responder and call\n3. [`canPerformAction(_:withSender:)`](https://developer.apple.com/documentation/uikit/uiresponder/1621105-canperformaction) to figure out if the first responder has a matching `@IBAction someMethod` that fits the selector from the menubar item in question\n4. If the first responder returns no, it will ask the next responder\n5. If a responder returns yes, then this menu bar entry will be enabled (clickable) and this responder (i.e. object or view controller) will be set as the current `target` of the menu bar entry.\n6. If the next responder is nil - that is, it UIKit reached the end of the responder chain - it will stop and the menu bar entry will be disabled.\n\nThis process happens for each item in the menubar.\n\nIf you want to influence how a menu bar item becomes enabled / disabled based on the particulars of your view controller, you can override `canPerformAction` and write custom logic. Here is a quick example. Here, we imagine that a menubar action should only be enabled if we have actual text in our textField.\n\n``` swift\noverride func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {\n  guard !(textField.text ?? \"\").isEmpty else { return false }\n  return super.canPerformAction(action, withSender: sender)\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/associated_types/type_erasure/an_abstract_class.md":["19cfaff806da8ff3",{"identifier":"7a41715e","filename":"an_abstract_class.md","info":{"title":"An Abstract Class","tags":["box","associated","generics","erasure"],"keywords":[],"category":[],"created":"2019-03-01 11:01:50","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551438110,"date":"2019-03-01T11:01:50","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":1,"second":50},"identifier":"","indexed":true},"slug":"//2019-3-1-an-abstract-class.html","content":"<h1>An Abstract Class</h1>\n<p>In essense, what we're going to build, is a generic wrapper (or box)\nthat hosts a type conforming to a <code>protocol</code> with an <code>associated type</code>.\nIt does so by implementing the requirements of the <code>protocol</code> and\nforwarding all invocations to the boxed type.</p>\n<p>The first new type we need for that is a base <code>class</code> that acts as a\nabstract class:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> AnyComputerBase&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n     <span class=\"keyword\">var</span> processor: <span class=\"type\">Processor</span> {\n\n         <span class=\"call\">fatalError</span>()\n\n     }\n\n     <span class=\"keyword\">var</span> processorCount: <span class=\"type\">Int</span> {\n\n         <span class=\"call\">fatalError</span>()\n\n     }\n\n}\n</code></pre></code></pre>\n<p>This <code>class</code> should never be initialized, as it only provides an\nabstract template of what subclasses should implement. While other\nlanguages (like Java) allow explicitly marking classes as abstract,\nSwift doesn't offer us a way to do so. One solution to this is adding a\n<code>fileprivate init</code> to this <code>class</code>. However as that requires subclasses\nto be in the same file as this superclass, we can also just make the\nwhole <code>class</code> <code>private</code> with an even better result. Now, other parts of\nthe code won't even know about the existence of <code>AnyComputerBase</code> or\neven <code>initialize</code> it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private class</span> AnyComputerBase&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n...\n\n}\n</code></pre></code></pre>\n<p>Why do we even need this, and what does it do? As you can see, it just\nimplements the <code>Computer</code> <code>protocol</code> by implementing the requirements\nand doing nothing in there. The more important part is that it moves the\n<code>associated type</code> from the protocol into a generic type for the <code>class</code>:\n<code>AnyComputerBase&lt;Processor: CPU&gt;</code>.</p>\n<p>Swift automatically figures out that <code>Processor</code> is the <code>typealias</code> for\n<code>Computer.ProcessorType</code>. However, when in doubt you can also add an\nextra typealias:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> AnyComputerBase&lt;Processor: <span class=\"type\">CPU</span>&gt;: <span class=\"type\">Computer</span> {\n\n   <span class=\"keyword\">typealias</span> ProcessorType = <span class=\"type\">Processor</span>\n\n   ...\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"An Abstract Class\"\ntags = [\"box\", \"associated\", \"generics\", \"erasure\"]\ncreated = \"2019-03-01 11:01:50\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# An Abstract Class\n\nIn essense, what we\\'re going to build, is a generic wrapper (or box)\nthat hosts a type conforming to a `protocol` with an `associated type`.\nIt does so by implementing the requirements of the `protocol` and\nforwarding all invocations to the boxed type.\n\nThe first new type we need for that is a base `class` that acts as a\nabstract class:\n\n``` Swift\nclass AnyComputerBase<Processor: CPU>: Computer {\n    var processor: Processor {\n        fatalError()\n    }\n    var processorCount: Int {\n        fatalError()\n    }\n}\n```\n\nThis `class` should never be initialized, as it only provides an\nabstract template of what subclasses should implement. While other\nlanguages (like Java) allow explicitly marking classes as abstract,\nSwift doesn\\'t offer us a way to do so. One solution to this is adding a\n`fileprivate init` to this `class`. However as that requires subclasses\nto be in the same file as this superclass, we can also just make the\nwhole `class` `private` with an even better result. Now, other parts of\nthe code won\\'t even know about the existence of `AnyComputerBase` or\neven `initialize` it:\n\n``` Swift\nprivate class AnyComputerBase<Processor: CPU>: Computer {\n...\n}\n```\n\nWhy do we even need this, and what does it do? As you can see, it just\nimplements the `Computer` `protocol` by implementing the requirements\nand doing nothing in there. The more important part is that it moves the\n`associated type` from the protocol into a generic type for the `class`:\n`AnyComputerBase<Processor: CPU>`.\n\nSwift automatically figures out that `Processor` is the `typealias` for\n`Computer.ProcessorType`. However, when in doubt you can also add an\nextra typealias:\n\n``` Swift\nclass AnyComputerBase<Processor: CPU>: Computer {\n  typealias ProcessorType = Processor\n  ...\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/types_of_keypath.md":["f79b397d1731ee5f",{"identifier":"2539098a","filename":"types_of_keypath.md","info":{"title":"Types of KeyPath","tags":["keypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-types-of-keypath.html","content":"<h1>Types of KeyPaths</h1>\n<p>We've already met our new friend, the <code>KeyPath</code>. However, the <code>KeyPath</code> will not be the only friend we meet in this guide. There're a couple more <code>KeyPath</code> types and they're core to what makes keypaths so very very useful. So without further ado, here they are.</p>\n","raw_content":"[frontMatter]\ntitle = \"Types of KeyPath\"\ntags = [\"keypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Types of KeyPaths\n\nWe've already met our new friend, the `KeyPath`. However, the `KeyPath` will not be the only friend we meet in this guide. There're a couple more `KeyPath` types and they're core to what makes keypaths so very very useful. So without further ado, here they are.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"guides/catalyst/complete_book.html":["e3b0c44298fc1c14",{"identifier":"4cfb","filename":"complete_book.html","info":{"title":"Ultimate Catalyst Guide","tags":["catalyst","macos","uikitformac"],"keywords":["catalyst","macos","uikitformac"],"category":[],"created":"2019-07-06 10:30:30","description":"Catalyst ports your iPad apps over to macOS. This guide contains a ton of tips and tricks to help you succeed in adding Catalyst support to your app","description_html":"<p>Catalyst ports your iPad apps over to macOS. This guide contains a ton of tips and tricks to help you succeed in adding Catalyst support to your app</p>\n","published":true,"slug":null,"meta":{"featured":"true","short_code":"<pre class='Swift'><code><span class='apvsource swift'>#if<span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'> targetEnvironment(</span>UIKitForMac</span><span class='apvkeyword apvoperator apvcustom apvpostfix apvunary swift'>)</span></code></pre>","feature_image":"/img-content/catalyst/feature_image.jpg","short_title":"🖥 Ultimate Catalyst Guide","swift_version":"5.1"},"created_timestamp":1562409030,"date":"2019-07-06T10:30:30","date_info":{"year":2019,"month":7,"day":6,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"guides/catalyst/complete_book.html","content":"<p>Catalyst is one of the major new features of iOS 13 and macOS 15. It allows you to take your iPad app, and, with the activation of a single checkbox, add a macOS target.</p>\n<p><img src=\"/img-content/catalyst/catalyst_checkbox.png\" alt=\"\" /></p>\n<p>For very simple projects, this works great, but there are multiple issues that might run in to. Here is a brief selection:</p>\n<ul>\n<li>Deprecated iOS classes, such as <code>AddressBookUI</code> or <code>UIWebView</code> are not supported anymore</li>\n<li>Some iOS classes, such as ARKit are not available on macOS</li>\n<li>Some iOS classes, such as StoreKit, have slightly different API</li>\n<li>The macOS API integrations such as <code>NSToolBar</code> or <code>NSMenuBar</code> are currently quite limited</li>\n<li>Problems with signing</li>\n</ul>\n<p>This guide is a very detailed developer explanation of Catalyst and all the issues that you can run into in the current beta. It will be updated as new macOS betas are released.</p>\n<h2>Contents of this Guide</h2>\n<p>This guide will initially <a href=\"rel::intro.md\">give a short introduction into Catalyst</a> Next, <a href=\"rel::firststeps/intro.md\">we will iterate over the first steps to support the various features that make an iPad app a good macOS citizen</a>. Finally, we will <a href=\"rel::how/intro.md\">go through a long <em>How Do I ...</em> list</a> of not-so-obvious things you might run into while working on Catalyst. As a sort of Appendix, <a href=\"rel::issues/issues.md\">we have a list of currently known issues</a> you might run into. This is helpful to keep you from trying to hunt down a bug that's not yours.</p>\n<p>Here's a bullet point guide on Catalyst:</p>\n<ul>\n<li>Run iPad apps on macOS</li>\n<li>macOS 13.0 only</li>\n<li>Supports most of iOS (i.e. no ARKit)</li>\n<li>Adds <a href=\"rel::how/sandbox.md\">macOS sandbox</a> support (and a <code>AppName.entitlements</code> file</li>\n<li>Uses <a href=\"rel::firststeps/preferences.md\">Settings.bundle</a> for automatic macOS Preferences</li>\n<li>You can build full-fledged macOS apps</li>\n<li>You can sell your apps outside of the Mac App Store</li>\n<li>Dynamic Type is disabled as it doesn't exist on macOS. Everything is <em>Large</em></li>\n<li>Your whole app, when run on macOS, is resized to 77% of the original size. That's all automatic and in the background</li>\n<li>A default menu bar for your app.</li>\n<li>Support for trackpad, mouse, and keyboard input.</li>\n<li>Support for window resizing and full-screen display.</li>\n<li>Mac-style scroll bars.</li>\n<li>Copy-and-paste support.</li>\n<li>Drag-and-drop support.</li>\n<li>Support for system Touch Bar controls.</li>\n</ul>\n<p>Apart from that, another major difference is that the Application Lifecycle behaves slightly different. We will look at that next.</p>\n<p>The <a href=\"https://developer.apple.com/videos/play/wwdc2019/235/\">&quot;Taking iPad apps for Mac to the Next Level&quot; talk at WWDC 2019</a> has a fantastic overview of all the changes. Here is a brief overview:</p>\n<ul>\n<li>The <code>UIApplication</code> lifecycle is fully supported on macOS</li>\n<li>The sequence is the same as on macOS</li>\n<li>State changes, however, do affect the Mac less, as are almost always <em>Foreground</em> + <em>Active</em> on macOS.</li>\n<li>Apps only enter background during termination and inactive when launching in the background.</li>\n<li>Your app should still take <a href=\"https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/AppNap.html\">App Napp</a> into account</li>\n<li>Background modes are allowed to finish when an app closes. The background tasks continue even though the app is already not visible anymore to the user</li>\n<li>Apps are not killed when they consume too much memory</li>\n<li>Background audio is not supported because users expect audio to stop when they quit an app</li>\n</ul>\n<p>So, in short, your app is always in <code>Foreground + Active</code> except when it is (mostly) launching or terminating.</p>\n<p>This is a short introduction into Catalyst. It will be extended constantly.</p>\n<p>Catalyst apps, just like simulator apps, do not require signing. However, since Catalyst apps run on the real hardware, right away, they are set up for signing by default.</p>\n<p>If you have a paid Apple Developer account, that is not a problem. However if you're a student or just looking into Catalyst, you might not have a paid Apple Developer account.</p>\n<p>Thankfully, you can test Catalyst apps just fine without a paid account. You only have to go into the signing settings of Xcode (<em>&quot;Target&quot;</em> -&gt; <em>&quot;Signing &amp; Capabilities&quot;</em> -&gt; <em>&quot;Signing Certificate&quot;</em>) and then select <em>Sign to Run Locally</em>.</p>\n<p>Now, Xcode will still complain with a small red alert that says <em>&quot;Signing for ... requires a development team&quot;</em>, however it will build the app just fine and also run it just fine.</p>\n<p><img src=\"/img-content/catalyst/signing_settings.png\" alt=\"\" /></p>\n<h2>Signing Frameworks</h2>\n<p>If you're signing locally and your code is split up into frameworks, it may be the case that you're getting code signing errors <em>when your binary starts</em>. So, your code is building fine, it is sining fine, but when the Catalyst App actually starts, it will crash with a code signing error. The current known way to prevent this is to have the following settings for your <em>main target</em> and for your <em>frameworks</em> (screenshots below):</p>\n<h3>Main Target</h3>\n<ul>\n<li>Automatically Manage Signing</li>\n<li>Team: A working account</li>\n<li>Signing Certificate: Apple Development</li>\n</ul>\n<p><img src=\"/img-content/catalyst/signing_frameworks1.png\" alt=\"\" /></p>\n<h3>Any Framework Target</h3>\n<ul>\n<li>Automatically Manage Signing</li>\n<li>Team: The same working account</li>\n<li>Signing Certificate: Sign to run locally</li>\n</ul>\n<p><img src=\"/img-content/catalyst/signing_frameworks2.png\" alt=\"\" /></p>\n<p>Keep in mind that the frameworks and the main target need to have distinct bundle identifiers.</p>\n<p>This issue does appear to only happen to some people.</p>\n<p>If you want to compile code that runs only on macOS, you can do that by using the following, new compile time attribute:</p>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyToolbar</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Obviously, to do it the other way around, you just inverse it:</p>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if !targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">import</span> ARKit\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Many of the macOS specific UIKit extensions require you to use a scene delegate. If your project was created before iOS 13 and you also don't intend to use multiple windows, you can follow these steps to add a scene delegate to your project and keep the app limited to one window:</p>\n<p>The first step is to add a scene manifest to your <code>Info.plist</code>. <a href=\"/img-content/catalyst/scene_manifest.png\">This can either be done in the Xcode plist editor</a> or by adding the following lines to your <code>Info.plist</code> in source code mode (You can just keep the default names. They're fine):</p>\n<pre class=\"XML\"><code><span class=\"techoutext techouxml\"><span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UIApplicationSceneManifest<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UIApplicationSupportsMultipleScenes<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">true</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">/&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneConfigurations<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n        <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UIWindowSceneSessionRoleApplication<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n        <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">array</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n            <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UILaunchStoryboardName<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>LaunchScreen<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneConfigurationName<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>Default Configuration<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneDelegateClassName<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>$(PRODUCT_MODULE_NAME).SceneDelegate<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>UISceneStoryboardFile<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">key</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n                <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>Main<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">string</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n            <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n        <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">array</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n    <span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n<span class=\"techoumeta techoutag techouxml\"><span class=\"techoupunctuation techoudefinition techoutag techoubegin techouxml\">&lt;/</span><span class=\"techouentity techouname techoutag techoulocalname techouxml\">dict</span><span class=\"techoupunctuation techoudefinition techoutag techouend techouxml\">&gt;</span></span>\n</span></code></pre></code></pre>\n<p>Next, add the following two functions to your <code>AppDelegate</code>. Note that only one of them is used, but for posterity, it makes sense to add both in one go:</p>\n<pre class=\"Swift\"><code>     <span class=\"keyword\">func</span> application(<span class=\"keyword\">_</span> application: <span class=\"type\">UIApplication</span>, configurationForConnecting connectingSceneSession: <span class=\"type\">UISceneSession</span>, options: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) -&gt; <span class=\"type\">UISceneConfiguration</span> {\n\n         <span class=\"comment\">// Called when a new scene session is being created.</span>\n\n         <span class=\"comment\">// Use this method to select a configuration to create the new scene with.</span>\n\n         <span class=\"keyword\">return</span> <span class=\"type\">UISceneConfiguration</span>(name: \\<span class=\"string\">\"Default</span> <span class=\"type\">Configuration</span>\\<span class=\"string\">\"</span>, sessionRole: connectingSceneSession.<span class=\"property\">role</span>)\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> application(<span class=\"keyword\">_</span> application: <span class=\"type\">UIApplication</span>, didDiscardSceneSessions sceneSessions: <span class=\"type\">Set</span>&lt;<span class=\"type\">UISceneSession</span>&gt;) {\n\n         <span class=\"comment\">// Called when the user discards a scene session.</span>\n\n         <span class=\"comment\">// If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.</span>\n\n         <span class=\"comment\">// Use this method to release any resources that were specific to the discarded scenes, as they will not return.</span>\n\n     }\n</code></pre></code></pre>\n<p>Finally, add a new file, <code>SceneDelegate.swift</code> to your project and add the following code to it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> UIKit\n\n\n\n<span class=\"keyword\">class</span> SceneDelegate: <span class=\"type\">UIResponder</span>, <span class=\"type\">UIWindowSceneDelegate</span> {\n\n\n\n     <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?\n\n\n\n     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"comment\">// Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.</span>\n\n         <span class=\"comment\">// If using a storyboard, the `window` property will automatically be initialized and attached to the scene.</span>\n\n         <span class=\"comment\">// This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).</span>\n\n         <span class=\"keyword\">guard let _</span> = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>By default, apple also adds the following, empty, methods to a new <code>UIWindowSceneDelegate</code> conforming class, but you don't necessarily need them and can always add them later:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> sceneDidDisconnect(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneDidBecomeActive(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneWillResignActive(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneWillEnterForeground(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n\n<span class=\"keyword\">func</span> sceneDidEnterBackground(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>)\n</code></pre></code></pre>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiscenedelegate?language=objc\">You can read more about them here.</a></p>\n<p>Initially, this is rather simple. You just need to enable the <em>Supports multiple windows</em> setting for your target:</p>\n<p><img src=\"/img-content/catalyst/multiwindow.png\" alt=\"\" /></p>\n<p>After this, if you didn't <a href=\"firststeps/modify_menubar.md\">create your own MenuBar</a>, you will have a new <em>New Window</em> <code>Control + N</code> shortcut that you can use to instantiate a new window.</p>\n<p>If you did modify your menubar (as explained above) <a href=\"how/custom_new_window_entry.md\">you can re-create the <em>New Window</em> shortcut by following these explanations.</a></p>\n<p>Finally, if you want to support multiple <em>different</em> windows, that is <a href=\"how/multiple_different_windows.md\">explained here</a></p>\n<p>There is one issue on beta 2 which means that you need to add a <em>bridging header</em> to your project and import a header file in there if you want to use the <code>NSTouchbar</code> or <code>NSToolbar</code> APIs.</p>\n<ol>\n<li>Add a new bridging header to your project, say <code>bridge-me.h</code> (If you don't have a bridging header yet)</li>\n<li>In your target Build Settings set the <code>Objective-C Bridging Header</code> value to your new bridging header (&quot;MyApp/bridge-me.h&quot;)</li>\n</ol>\n<p>Make sure to have the right path for the bridging header.</p>\n<h2>Then, insert the following code in your bridging header:</h2>\n<pre class=\"C\"><code><span class=\"techousource techouc\"><span class=\"techoumeta techoupreprocessor techouinclude techouc\"><span class=\"techoukeyword techoucontrol techouimport techouinclude techouc\">#import</span> <span class=\"techoustring techouquoted techouother techoult-gt techouinclude techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&lt;</span>Foundation/Foundation.h<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&gt;</span></span>\n</span><span class=\"techoumeta techoupreprocessor techouinclude techouc\"><span class=\"techoukeyword techoucontrol techouimport techouinclude techouc\">#import</span> <span class=\"techoustring techouquoted techouother techoult-gt techouinclude techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&lt;</span>UIKit/NSToolbar+UIKitAdditions.h<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&gt;</span></span>\n</span><span class=\"techoumeta techoupreprocessor techouinclude techouc\"><span class=\"techoukeyword techoucontrol techouimport techouinclude techouc\">#import</span> <span class=\"techoustring techouquoted techouother techoult-gt techouinclude techouc\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techouc\">&lt;</span>UIKit/NSTouchbar+UIKitAdditions.h<span class=\"techoupunctuation techoudefinition techoustring techouend techouc\">&gt;</span></span>\n</span></span></code></pre></code></pre>\n<h2>Preparations</h2>\n<p>Note that in <em>Beta 2</em> you need to manually import a special bridging header if you want to use <code>NSToolbar</code>. <a href=\"firststeps/bridgingheader.md\">Here's how to do it</a>.</p>\n<p>The best way to insert toolbars is to use the new <code>UIScene</code> API that Apple introduced with iOS 13. The gist is that you use a <code>SceneDelegate</code> and in the <code>scene:willConnectToSession:options</code> method, you can modify a window scene's <code>titlebar</code> by setting a new <code>NSToolbar</code> on it.</p>\n<p>If your project doesn't have a <code>SceneDelegate</code> yet, <a href=\"firststeps/scene_delegate.md\">here's a brief primer on how to set it up.</a>. This delegate is - as far as I'm aware - required to support toolbars.</p>\n<h2>Modifying the Scene</h2>\n<p>The first step is to modify the <code>scene(willConnectTo:options:)</code> method in your <code>SceneDelegate</code> to check if we're running <code>UIKitForMac</code> - after all, iOS doesn't have toolbars - and then make sure that our scene is actually a <code>UIWindowScene</code>:</p>\n<pre class=\"Swift\"><code>  <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n     <span class=\"preprocessing\">#endif</span>\n\n}\n</code></pre></code></pre>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiwindowscene\"><code>UIWindowScene</code></a> objects have a <code>titlebar</code> property on macOS. These <code>UITitleBar</code> objects are currently not documented, but the headers expose a <code>toolbar</code> property that you can use to assign a <code>NSToolbar</code> to your window:</p>\n<pre class=\"Swift\"><code>  <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n     <span class=\"comment\">// Create a new toolbar (see below)</span>\n\n     <span class=\"keyword\">let</span> newToolbar = <span class=\"call\">makeMyFancyToolbar</span>()\n\n\n\n     <span class=\"comment\">// Insert it into the titlebar</span>\n\n     windowScene.<span class=\"property\">titlebar</span>.<span class=\"property\">toolbar</span> = <span class=\"keyword\">self</span>\n\n\n\n     <span class=\"comment\">// Hide the window title, looks nicer</span>\n\n     windowScene.<span class=\"property\">titlebar</span>.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n     <span class=\"preprocessing\">#endif</span>\n\n}\n</code></pre></code></pre>\n<p>So this is how we insert an actual toolbar into our window. The last remaining step is to create such a toolbar, so how does that work?</p>\n<h2>Creating a Toolbar</h2>\n<p>This is actually a multi-step process as toolbars are quit versatile. You begin by instantiating a new toolbar and configuring it accordingly:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Create the toolbar</span>\n\n<span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyFancyToolbar</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// Assign the delegate</span>\n\ntoolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n</code></pre></code></pre>\n<p>As you can see, the configuration is just two lines of code (for now) but toolbars employ a delegate that you can leverage to configure them in much more detail. Lets see how.</p>\n<h2>Implementing the NSToolbarDelegate protocol</h2>\n<p>First, you need an object that can conform to your toolbar delegate. For simplicity, lets just take our <code>SceneDelegate</code>. However, this can be any object and for more complex setups could be, for example, your own <code>MyToolbarController</code> class.</p>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n<span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Again, make sure this code only compiles on macOS. Next, lets implement the bare minimum needed to display a toolbar.</p>\n<p>Toolbars are versatile and allow your users to configure them and modify their contents. Our toolbar will just display a button on the right side. Toolbars identify their contents via toolbar identifiers of type <code>NSToolbarItem.Identifier</code>. Each item in the toolbar has a custom identifier. This makes it easy for the system to understand which items are in the toolbar, which can be customized, removed, etc. So in order for us to add a button, we need an identifier for our button:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">private let</span> <span class=\"type\">OurButtonToolbarIdentifier</span> = <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"OurButton</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n<span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Next, we need to implement two methods that are called on the delegate to figure out what to display in the toolbar:</p>\n<ol>\n<li><code>toolbarDefaultItemIdentifiers</code>: This returns the identifiers for the items that should be in the toolbar <em>by default</em></li>\n<li><code>toolbarAllowedItemIdentifiers</code>: This returns the identifiers that are <em>currently</em> allowed in the toolbar</li>\n</ol>\n<p>We will implement default first:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>,\n\n                 <span class=\"type\">OurButtonToolbarIdentifier</span>]\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Here, we're returning an array of two items. The <em>last</em> is our <code>OurButtonToolbarIdentifier</code>. The <em>first</em> is a &quot;flexible space&quot; identifier that will consume as much horizontal space as possible, thus pushing our button all the way to the right.</p>\n<p>For simplicity, the second method, <code>toolbarAllowedItemIdentifiers</code> just calls the first one.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>,\n\n                 <span class=\"type\">OurButtonToolbarIdentifier</span>]\n\n     }\n\n     <span class=\"keyword\">func</span> toolbarAllowedItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> <span class=\"call\">toolbarDefaultItemIdentifiers</span>(toolbar)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Now that we told the toolbar how to display itself, we just need to create those items (in our case just our button):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbar(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>, itemForItemIdentifier itemIdentifier: <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>, willBeInsertedIntoToolbar flag: <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">NSToolbarItem</span>? {\n\n         <span class=\"keyword\">if</span> (itemIdentifier == <span class=\"type\">OurButtonToolbarIdentifier</span>) {\n\n         <span class=\"keyword\">let</span> barButtonItem = <span class=\"type\">UIBarButtonItem</span>(barButtonSystemItem: <span class=\"type\">UIBarButtonItem</span>.<span class=\"type\">SystemItem</span>.<span class=\"property\">add</span>,\n\n                               target: <span class=\"keyword\">self</span>,\n\n                   action: <span class=\"keyword\">#selector</span>(<span class=\"keyword\">self</span>.<span class=\"call\">myFancyAction</span>(sender:)))\n\n             <span class=\"keyword\">let</span> button = <span class=\"type\">NSToolbarItem</span>(itemIdentifier: itemIdentifier, barButtonItem: barButtonItem)\n\n             <span class=\"keyword\">return</span> button\n\n         }\n\n         <span class=\"keyword\">return nil</span>\n\n     }\n</code></pre></code></pre>\n<p>Again, this is simple enough. We just create a <code>UIBarButtonItem</code>, wrap it into a <code>NSToolbarItem</code> and return it. There're a lot of options here that we will not go into, but reading the headers and the documentation will help you along if you need more complex setups.</p>\n<p><a href=\"how/hide_tabbar_with_toolbar.md\">If you want to hide your existing iOS / UIKit toolbar, too, have a look at this section.</a></p>\n<p>If you want to display a nice segmented control your toolbar, like this:</p>\n<p><img src=\"/img-content/catalyst/segmentedcontrol_toolbar.png\" alt=\"\" /></p>\n<p><a href=\"how/segmented_control_toolbar.md\">There's an explanation on how to do this in the following section.</a></p>\n<p>Here's the whole code <code>SceneDelegate</code> in one section:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">import</span> UIKit\n\n\n\n<span class=\"keyword\">class</span> SceneDelegate: <span class=\"type\">UIResponder</span>, <span class=\"type\">UIWindowSceneDelegate</span> {\n\n\n\n     <span class=\"keyword\">var</span> window: <span class=\"type\">UIWindow</span>?\n\n\n\n     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n         <span class=\"keyword\">if let</span> titlebar = windowScene.<span class=\"property\">titlebar</span> {\n\n             titlebar.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n             titlebar.<span class=\"property\">toolbar</span> = <span class=\"call\">makeMyFancyToolbar</span>()\n\n         }\n\n         <span class=\"preprocessing\">#endif</span>\n\n     }\n\n\n\n     <span class=\"keyword\">private func</span> makeMyFancyToolbar() -&gt; <span class=\"type\">NSToolbar</span> {\n\n         <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyToolbar</span>\\<span class=\"string\">\"</span>)\n\n         toolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n         <span class=\"keyword\">return</span> toolbar\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> myFancyAction(sender: <span class=\"type\">UIBarButtonItem</span>) {\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"Button</span> <span class=\"type\">Pressed</span>\\<span class=\"string\">\"</span>)\n\n     }\n\n}\n\n\n\n<span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n\n\n<span class=\"keyword\">private let</span> <span class=\"type\">OurButtonToolbarIdentifier</span> = <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"OurButton</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">SceneDelegate</span>: <span class=\"type\">NSToolbarDelegate</span> {\n\n     <span class=\"keyword\">func</span> toolbar(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>, itemForItemIdentifier itemIdentifier: <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>, willBeInsertedIntoToolbar flag: <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">NSToolbarItem</span>? {\n\n         <span class=\"keyword\">if</span> (itemIdentifier == <span class=\"type\">OurButtonToolbarIdentifier</span>) {\n\n             <span class=\"keyword\">let</span> barButton = <span class=\"type\">UIBarButtonItem</span>(barButtonSystemItem: .<span class=\"dotAccess\">add</span>, target: <span class=\"keyword\">self</span>, action: <span class=\"keyword\">#selector</span>(<span class=\"call\">myFancyAction</span>(sender:)))\n\n             <span class=\"keyword\">let</span> button = <span class=\"type\">NSToolbarItem</span>(itemIdentifier: itemIdentifier, barButtonItem: barButton)\n\n             <span class=\"keyword\">return</span> button\n\n         }\n\n         <span class=\"keyword\">return nil</span>\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>, <span class=\"type\">OurButtonToolbarIdentifier</span>]\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarAllowedItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> <span class=\"call\">toolbarDefaultItemIdentifiers</span>(toolbar)\n\n     }\n\n}\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Sidebars are a staple of macOS. Many apps on macOS have sidebars and use them to support a huge variety of usage scenarios. Apple added sidebar support right into Catalyst. By default, any Master-Detail view implemented using the <code>UISplitViewController</code> will inhibit macOS sidebar behaviour. However, if you just do that, the sidebar contents (that is, the Master part of the Master Detail View) will look strangely out of place. The rows still look like normal UIKit Rows:</p>\n<p><img src=\"/img-content/catalyst/sidebars.jpeg\" alt=\"Sidebars\" /></p>\n<p>Thankfully, this can easily be fixed. Apple offers a new property on the <code>UISplitViewController</code>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// The background style of the primary view controller.</span>\n\n<span class=\"keyword\">@available</span>(iOS <span class=\"number\">13.0</span>, *)\n\n<span class=\"keyword\">open var</span> primaryBackgroundStyle: <span class=\"type\">UISplitViewController</span>.<span class=\"type\">BackgroundStyle</span>\n</code></pre></code></pre>\n<p>If you're on Catalyst, you can set this to <code>.sidebar</code> in order to get the macOS native sidebar look and feel from the right side of the screenshot above:</p>\n<pre class=\"Swift\"><code>primaryBackgroundStyle = .<span class=\"dotAccess\">sidebar</span>\n</code></pre></code></pre>\n<p>In the WWDC slides and the sample code, Apple touts a <code>buildCommands</code> method on <code>UIResponder</code> for menus. <a href=\"https://developer.apple.com/documentation/uikit/uiresponder/3175394-buildcommands\">However, this was deprecated with beta 1</a>. Instead, we should use <a href=\"https://developer.apple.com/documentation/uikit/uiresponder/3327317-buildmenu\">buildMenu(with:)</a>. This currently lacks documentation though.</p>\n<p>It seems, currently, the best way to modify the Menubar (or, <code>MainMenu</code>) is by using storyboards and dropping a <code>Main Menu</code> into your storyboard. This new scene will be just like the default menu, but you can edit it.</p>\n<h2>Preparations</h2>\n<p>Note that in <em>Beta 2</em> you need to manually import a special bridging header if you want to use touchbars. <a href=\"firststeps/bridgingheader.md\">Here's how to do it</a>.</p>\n<p>With that out of the way, lets have a brief look at touchbars. <a href=\"https://developer.apple.com/documentation/appkit/nstouchbar\">Apple's documentation for the <code>NSTouchBar</code> class is fantastic</a> and it would be a waste to try to replicate all that documentation here. Also, touchbars in Catalyst apps work just like the AppKit touchbars. So all the available <code>NSTouchBar</code> tutorials work just as well for your iPad app.</p>\n<p>In brief, touchbars work as follows: Each controller in the <a href=\"how/responder_chain.md\">responder chain</a> is asked whether he has a touchbar that he wants to display via the <code>func makeTouchBar() -&gt; NSTouchBar?</code> method on <code>UIResponder</code> (or <code>NSResponder</code>). The higher up items in the responder chain have priority. Within that method, you return a fully configured touchbar with a proper <code>NSTouchBarDelegate</code> set. The <code>NSTouchBarDelegate</code> allows you to configure the touchbar to your hearts contents. Here's a simple example:</p>\n<p>Make sure to remember that touchbars only appear for objects that conform to <code>UIResponder</code> and are in the <a href=\"how/responder_chain.md\">responder chain</a>. A good place for this code is your <code>UIViewController</code> that is currently being displayed.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Define the items we want to display in the touch bar via specific identifiers, so UIKit can track them</span>\n\n<span class=\"keyword\">let</span> <span class=\"type\">MyButtonTouchBarIdentifier</span> = <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"MyButton</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"keyword\">class</span> MyViewController: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">override func</span> makeTouchBar() -&gt; <span class=\"type\">NSTouchBar</span>? {\n\n         <span class=\"keyword\">let</span> touchBar = <span class=\"type\">NSTouchBar</span>()\n\n         touchBar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n         touchBar.<span class=\"property\">defaultItemIdentifiers</span> = [<span class=\"type\">MyButtonTouchBarIdentifier</span>,\n\n                                            <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">otherItemsProxy</span>]\n\n         <span class=\"keyword\">return</span> touchBar\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> buttonPressed(sender: <span class=\"type\">NSTouchBarItem</span>) {\n\n     }\n\n}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">MacSplitViewController</span>: <span class=\"type\">NSTouchBarDelegate</span> {\n\n\n\n     <span class=\"keyword\">func</span> touchBar(<span class=\"keyword\">_</span> touchBar: <span class=\"type\">NSTouchBar</span>, makeItemForIdentifier identifier: <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>) -&gt; <span class=\"type\">NSTouchBarItem</span>? {\n\n         <span class=\"keyword\">switch</span> identifier {\n\n         <span class=\"keyword\">case</span> <span class=\"type\">MyButtonTouchBarIdentifier</span>:\n\n             <span class=\"keyword\">return</span> <span class=\"type\">NSButtonTouchBarItem</span>.<span class=\"keyword\">init</span>(identifier: identifier,\n\n                                              title: \\<span class=\"string\">\"Press</span> <span class=\"type\">Me</span>\\<span class=\"string\">\"</span>,\n\n                                              target: <span class=\"keyword\">self</span>,\n\n                                              action: <span class=\"keyword\">#selector</span>(<span class=\"keyword\">self</span>.<span class=\"property\">buttonPressed</span>))\n\n         <span class=\"keyword\">default</span>: <span class=\"keyword\">return nil</span>\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<h2>Using Apple HIG TouchBar Images</h2>\n<p>Apple has a very nice set of default touchbar images outlined here:</p>\n<ul>\n<li>https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/</li>\n<li>https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc</li>\n</ul>\n<p>These currently can't be used in Catalyst apps (FB6312494).</p>\n<p>Context Menus in Catalyst are implemented via the new <a href=\"https://developer.apple.com/documentation/uikit/uicontextmenuinteraction\"><code>UIContextMenuInteraction</code> API that Apple shipped on iOS as part of iOS 13.</a>. <a href=\"https://developer.apple.com/documentation/uikit/menus_and_shortcuts\">They work hand in hand with menu and shortcut system that is documented here</a>.</p>\n<p>If you support context menus with <code>UIContextMenuInteraction</code>, they will automatically convert into right click context menus in your Catalyst app. Here's a simple example of how that works in action:</p>\n<p>For simplicity, <code>UITableView</code> (and also <code>UICollectionView</code>) have new delegate methods that allow you to return a <code>UIContextMenuInteraction</code> instance that will be used for 3D touch or long presses on iOS or context menus on macOS. Here is an example of a very simple menu that has two entries &quot;Move Priority Up&quot; and &quot;Move Priority Down&quot;:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">MyViewController</span>: <span class=\"type\">UITableViewDelegate</span> {\n\n     <span class=\"keyword\">public override func</span> tableView(<span class=\"keyword\">_</span> tableView: <span class=\"type\">UITableView</span>, contextMenuConfigurationForRowAt indexPath: <span class=\"type\">IndexPath</span>, point: <span class=\"type\">CGPoint</span>) -&gt; <span class=\"type\">UIContextMenuConfiguration</span>? {\n\n         <span class=\"comment\">// Action providers are closures that generate action menus. They are called lazily only</span>\n\n     <span class=\"comment\">// when the menu is actually invoked.</span>\n\n         <span class=\"keyword\">let</span> actionProvider: ([<span class=\"type\">UIMenuElement</span>]) -&gt; <span class=\"type\">UIMenu</span>? = { <span class=\"keyword\">_ in</span>\n\n             <span class=\"keyword\">let</span> upAction = <span class=\"type\">UIAction</span>(__title: \\<span class=\"string\">\"Move</span> <span class=\"type\">Priority Up</span>\\<span class=\"string\">\"</span>,\n\n                                     image: <span class=\"type\">UIImage</span>(systemName: \\<span class=\"string\">\"square</span>.<span class=\"property\">and</span>.<span class=\"property\">arrow</span>.<span class=\"property\">up</span>\\<span class=\"string\">\"</span>))\n\n             { [<span class=\"keyword\">weak self</span>] <span class=\"keyword\">_ in</span>\n\n                 <span class=\"keyword\">self</span>?.<span class=\"call\">changePriority</span>(.<span class=\"dotAccess\">up</span>, indexPath)\n\n             }\n\n             <span class=\"keyword\">let</span> downAction = <span class=\"type\">UIAction</span>(__title: \\<span class=\"string\">\"Move</span> <span class=\"type\">Priority Down</span>\\<span class=\"string\">\"</span>,\n\n                                       image: <span class=\"type\">UIImage</span>(systemName: \\<span class=\"string\">\"square</span>.<span class=\"property\">and</span>.<span class=\"property\">arrow</span>.<span class=\"property\">down</span>\\<span class=\"string\">\"</span>))\n\n             { [<span class=\"keyword\">weak self</span>] <span class=\"keyword\">_ in</span>\n\n                 <span class=\"keyword\">self</span>?.<span class=\"call\">changePriority</span>(.<span class=\"dotAccess\">down</span>, indexPath)\n\n             }\n\n\n\n         <span class=\"keyword\">let</span> actions = [upAction, downAction]\n\n\n\n             <span class=\"comment\">// We generate a new menu with our two actions</span>\n\n             <span class=\"keyword\">return</span> <span class=\"type\">UIMenu</span>(__title: \\<span class=\"string\">\"Actions</span>\\<span class=\"string\">\"</span>, image: <span class=\"keyword\">nil</span>, identifier: <span class=\"keyword\">nil</span>, children: actions)\n\n         }\n\n\n\n     <span class=\"comment\">// A context menu can have a `identifier`, a `previewProvider`,</span>\n\n     <span class=\"comment\">// and, finally, the `actionProvider that creates the menu</span>\n\n         <span class=\"keyword\">return</span> <span class=\"type\">UIContextMenuConfiguration</span>(identifier: <span class=\"keyword\">nil</span>,\n\n                                           previewProvider: <span class=\"keyword\">nil</span>,\n\n                                           actionProvider: actionProvider)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>That's all you need to support context menus in your tableView. <a href=\"https://developer.apple.com/documentation/uikit/menus_and_shortcuts\">For more complex use cases, refer to the detailed documentation on menus:</a>, and on <a href=\"https://developer.apple.com/documentation/uikit/uicontextmenuinteraction\"><code>UIContextMenuInteraction</code></a></p>\n<p>Keyboard shortcuts are implemented via the existing <code>UIKeyCommand</code> system on <code>UIResponder</code>. Here's a simple example of how your currently visible view controller can listen for <code>Escape</code> key presses by the user:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> MyKeyListeningViewController: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">override var</span> keyCommands: [<span class=\"type\">UIKeyCommand</span>]? {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">UIKeyCommand</span>(input: <span class=\"type\">UIKeyCommand</span>.<span class=\"property\">inputEscape</span>,\n\n                              modifierFlags: [],\n\n                              action: <span class=\"keyword\">#selector</span>(<span class=\"call\">doCancelCommand</span>(sender:)))\n\n         ]\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Keep in mind that on macOS multiple views can easily be visible at the same time and <a href=\"how/responder_chain.md\">the rules of the responder chain apply.</a></p>\n<p>In order to implement the preferences or your app, <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html\">Apple supports the <em>Settings.bundle</em> technology that has been there since iOS 2.0 (or rather, iPhoneOS 2.0)</a>. The documentation is actually so old, that it is archived and the documentation screenshots look like this:</p>\n<p><img src=\"/img-content/catalyst/settings2.jpg\" alt=\"\" />\n<img src=\"/img-content/catalyst/settings3.jpg\" alt=\"\" /></p>\n<p>On iOS, this means that you just need to add a new bundle target to your project and fill it with a collection of specially crafted <code>Plist</code> files. These settings then appear in the general iOS settings and any changes done there are stored in the <code>NSUserDefaults</code>.</p>\n<p>If your app supports settings bundles, then your Catalyst app will automatically add a Preferences window to your app that looks something like this:</p>\n<p><img src=\"/img-content/catalyst/settings1.png\" alt=\"\" /></p>\n<p>For details on how to achieve this, <a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html\">refer to Apples documentation.</a></p>\n<p>Now, if you have more involved logic in your settings, special view controllers, web views, and other things, then this doesn't work well for you. <a href=\"how/logic_preferences.md\">In that case, you can read here how to implement more complex preferences on macOS.</a></p>\n<h1>Preferences with a Toolbar</h1>\n<p>Now, one thing you might wonder is how to get this wonderful Preferences Toolbar, that Apple has in their Podcast app (see the last screenshot). <a href=\"rel::how/preferences_toolbar.md\">As it turns out, this is currently completely undocumented, and we're explaining the details of how to achieve this here.</a></p>\n<p>Catalyst requires new builds of your third party frameworks and SDKs. The iOS or Simulator builds are not appropriate. This means that until your third party, closed source advertising or tracking library offers a new release with an added <code>UIKitForMac</code> target, you won't be able to build your app.</p>\n<p>As a temporary solution, if you wrapped all these dependencies in a wrapper, <a href=\"rel::firststeps/conditional_compilation.md\">you can just use conditional compilation to just not ship them on macOS.</a></p>\n<h2>A brief list of notable differences</h2>\n<ul>\n<li>The bundle identifier for the macOS version of your app is different. If you use bundle identifiers for something specific, be aware of this</li>\n<li>KeyChain sharing differs briefly, <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps\">as outlined by Apple here</a> (search for &quot;macOS&quot; on that page)</li>\n<li>Custom multitouch behaviour can't be automated. Views have to be updated for that</li>\n<li>Your app will not be killed if it consumes too much memory. The system will just swap</li>\n</ul>\n<h2>With Catalyst, you should use the newever versions of these old, deprecated, frameworks:</h2>\n<ul>\n<li>AddressBook -&gt; Contacts</li>\n<li>AddressBookUI -&gt; ContactsUI</li>\n<li>AssetsLibrary -&gt; Photos</li>\n<li>OpenGL ES -&gt; Metal</li>\n<li>GLKit -&gt; MetalKit</li>\n<li>UIWebView -&gt; WKWebView</li>\n</ul>\n<p>Catalyst is still a fresh technology. So far, based on our current knowledge, the following best practices have emerged:</p>\n<ul>\n<li>Try to use conditional compilation (via <code>#if targetEnvironment(UIKitForMac</code>) sparringly</li>\n<li>Your view redraw code should be fast as macOS users frequently resize windows (in a dynamic manner)</li>\n<li>Have proper autolayout support for bigger and smaller sizes as windows can be resized in a variety of ways</li>\n<li>Be aware of the <a href=\"how/responder_chain.md\">responder chain</a> as multiple view controllers can be on the screen at the same time</li>\n<li>Your app can run forever, memory leaks can pile up</li>\n</ul>\n<p>These guidelines are based on information that Apple shared in different WWDC keynotes</p>\n<ul>\n<li>Most Important: <a href=\"https://developer.apple.com/design/human-interface-guidelines/ios/overview/ipad-apps-for-mac/\">Apple has Human Interface Guidelines for <em>iPad Apps for Mac</em></a></li>\n<li>Macs don't have dynamic type. Everything is &quot;Large&quot;</li>\n<li>Mac users have many windows open. Therefore you should set focus on the contents of the window. This means using less color so that the contents can shine</li>\n<li>Use side bars and toolbars instead of a UITabBar</li>\n<li>Try to take advantage of the bigger macOS windows. You can utilize different layouts and use the space wisely</li>\n<li>Default font size on macOS is 13pt compared to 17pt on iOS. This is handled automatically for you though, as each app is scaled to 77% of its actual size</li>\n</ul>\n<p>This is a list of <em>not-so-obvious</em> things which you might run into while working on your Catalyst app. Will be extended constantly.</p>\n<p>Once you modify your Main Menu, you will find that the entry to create a new window has suddenly disappeared. That happens because the <code>New Window</code> entry is dynamicaly inserted by UIKit depending on whether your app supports multiple windows (or not).</p>\n<p>In order to support this again, you have to do the following:</p>\n<ol>\n<li>Create a new <code>UICommand</code> in your Storyboard for the <code>New Window</code> entry.</li>\n<li>Assign the title and your desired shortcut (probably Command + N).</li>\n<li>Select the <code>First Responder</code> in your <code>MainMenu Scene</code></li>\n</ol>\n<p><img src=\"/img-content/catalyst/storyfirstresponder.png\" alt=\"\" /></p>\n<ol start=\"4\">\n<li>Switch to the <em>Attributes Inspector</em> (from the inspectors on the right)</li>\n<li>There, you will find an empty list named &quot;User Defined&quot;</li>\n<li>Add a new entry to this list with the following attributes:</li>\n<li>Action: <code>requestNewScene:</code>, Type: <code>id</code> (the default)</li>\n<li>Finally, drag from your <code>UICommand</code> menu entry to the First Responder and select the newly created action.</li>\n</ol>\n<p>A segmented control is a convenient replacement for the iOS tabbar, as it also groups related segments and only allows one of them to be active.\nIt is basically just another type of <code>NSToolbarItem</code>. Thus, the process is very similar to <a href=\"firststeps/toolbar.md\">how you set up a toolbar with elements before</a>.</p>\n<ol>\n<li>Define a identifier</li>\n<li>Return the identifiers</li>\n<li>For the new identifier, return a segmented control</li>\n<li>Set up an action and target for the segmented control</li>\n</ol>\n<p>As a bonus point, you can tell the toolbar that the segmented control should be the centered item in the toolbar (much like with a tabbar).</p>\n<p><a href=\"how/hide_tabbar_with_toolbar.md\">In this example, we also have a UITabBar that we're hiding</a>, so that the switching of the visible view controller is still handled by the hidden tabbar.</p>\n<p>Here is the necessary code:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> SceneDelegate: <span class=\"type\">UIResponder</span>, <span class=\"type\">UIWindowSceneDelegate</span>, <span class=\"type\">NSToolbarDelegate</span> {\n\n\n\n     <span class=\"comment\">// We need a toolbar identifier</span>\n\n     <span class=\"keyword\">static let</span> <span class=\"type\">SegmentedItemToolbarIdentifier</span> = <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>(rawValue: \\<span class=\"string\">\"PrimaryGroup</span>\\<span class=\"string\">\"</span>)\n\n\n\n     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n         <span class=\"keyword\">if let</span> windowScene = scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span> {\n\n             <span class=\"keyword\">if let</span> titlebar = windowScene.<span class=\"property\">titlebar</span> {\n\n                 <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"NerauToolbar</span>\\<span class=\"string\">\"</span>)\n\n\n\n                 <span class=\"keyword\">let</span> rootViewController = window?.<span class=\"property\">rootViewController</span> <span class=\"keyword\">as</span>? <span class=\"type\">UITabBarController</span>\n\n         <span class=\"comment\">// Hide the tabbasr</span>\n\n                 rootViewController?.<span class=\"property\">tabBar</span>.<span class=\"property\">isHidden</span> = <span class=\"keyword\">true</span>\n\n\n\n                 toolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n\n\n         <span class=\"comment\">// Our segmented control should be centered</span>\n\n\n\n                 toolbar.<span class=\"property\">centeredItemIdentifier</span> = <span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>\n\n                 titlebar.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n\n\n                 titlebar.<span class=\"property\">toolbar</span> = toolbar\n\n             }\n\n         }\n\n         <span class=\"preprocessing\">#endif</span>\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbar(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>, itemForItemIdentifier itemIdentifier: <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>, willBeInsertedIntoToolbar flag: <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">NSToolbarItem</span>? {\n\n             <span class=\"keyword\">if</span> (itemIdentifier == <span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>) {\n\n             <span class=\"comment\">// Create a new group item that hosts two buttons</span>\n\n                 <span class=\"keyword\">let</span> group = <span class=\"type\">NSToolbarItemGroup</span>(itemIdentifier: <span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>,\n\n                                                titles: [\\<span class=\"string\">\"Startpage</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"Categories</span>\\<span class=\"string\">\"</span>],\n\n                                                selectionMode: .<span class=\"dotAccess\">selectOne</span>,\n\n                                                labels: [\\<span class=\"string\">\"section1</span>\\<span class=\"string\">\"</span>, \\<span class=\"string\">\"section2</span>\\<span class=\"string\">\"</span>],\n\n                                                target: <span class=\"keyword\">self</span>,\n\n                                                action: <span class=\"keyword\">#selector</span>(toolbarGroupSelectionChanged))\n\n\n\n         <span class=\"comment\">// Set the initial selection</span>\n\n                 group.<span class=\"call\">setSelected</span>(<span class=\"keyword\">true</span>, at: <span class=\"number\">0</span>)\n\n\n\n                 <span class=\"keyword\">return</span> group\n\n             }\n\n         <span class=\"keyword\">return nil</span>\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> toolbarGroupSelectionChanged(sender: <span class=\"type\">NSToolbarItemGroup</span>) {\n\n         <span class=\"comment\">// This is called when the user changes the selection</span>\n\n     <span class=\"comment\">// Notice how we get the tab bar controller and change the selection there</span>\n\n         <span class=\"keyword\">let</span> rootViewController = window?.<span class=\"property\">rootViewController</span> <span class=\"keyword\">as</span>? <span class=\"type\">UITabBarController</span>\n\n         rootViewController?.<span class=\"property\">selectedIndex</span> = sender.<span class=\"property\">selectedIndex</span>\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarDefaultItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return</span> [<span class=\"type\">SceneDelegate</span>.<span class=\"type\">SegmentedItemToolbarIdentifier</span>,\n\n                 <span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">flexibleSpace</span>]\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> toolbarAllowedItemIdentifiers(<span class=\"keyword\">_</span> toolbar: <span class=\"type\">NSToolbar</span>) -&gt; [<span class=\"type\">NSToolbarItem</span>.<span class=\"type\">Identifier</span>] {\n\n         <span class=\"keyword\">return self</span>.<span class=\"call\">toolbarDefaultItemIdentifiers</span>(toolbar)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>If you want to hide your iOS tabbar, just as you're displaying your macOS toolbar, this is what you can do in your <code>SceneDelegate</code>:</p>\n<pre class=\"Swift\"><code>     <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n         <span class=\"keyword\">if let</span> windowScene = scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span> {\n\n             <span class=\"keyword\">if let</span> titlebar = windowScene.<span class=\"property\">titlebar</span> {\n\n                 <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"NerauToolbar</span>\\<span class=\"string\">\"</span>)\n\n\n\n                 <span class=\"keyword\">let</span> rootViewController = window?.<span class=\"property\">rootViewController</span> <span class=\"keyword\">as</span>? <span class=\"type\">UITabBarController</span>\n\n                 rootViewController?.<span class=\"property\">tabBar</span>.<span class=\"property\">isHidden</span> = <span class=\"keyword\">true</span>\n\n\n\n                 toolbar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n                 titlebar.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n\n\n                 titlebar.<span class=\"property\">toolbar</span> = toolbar\n\n             }\n\n         }\n\n         <span class=\"preprocessing\">#endif</span>\n\n     }\n</code></pre></code></pre>\n<h2>Preparations</h2>\n<p>Note that in <em>Beta 2</em> you need to manually import a special bridging header if you want to modify the title. <a href=\"firststeps/bridgingheader.md\">Here's how to do it</a>.</p>\n<p>The way to modify window titlebars is to use the <code>UIScene</code> API introduced with iOS 13. The gist is that you use a <code>SceneDelegate</code> and in the <code>scene:willConnectToSession:options</code> method, you can modify a window scene's <code>titlebar</code>.</p>\n<p>If your project doesn't have a <code>SceneDelegate</code> yet, <a href=\"firststeps/scene_delegate.md\">here's a brief primer on how to set it up.</a>. This delegate is - as far as I'm aware - required to support toolbars.</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiwindowscene\"><code>UIWindowScene</code></a> objects have a <code>titlebar</code> property on macOS. These <code>UITitleBar</code> objects are currently not documented, but the headers expose several properties:</p>\n<pre class=\"Swift\"><code>  <span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n         <span class=\"keyword\">guard let</span> windowScene = (scene <span class=\"keyword\">as</span>? <span class=\"type\">UIWindowScene</span>) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n     windowScene.<span class=\"property\">titlebar</span>.<span class=\"property\">titleVisibility</span> = .<span class=\"dotAccess\">hidden</span>\n\n     <span class=\"preprocessing\">#endif</span>\n\n}\n</code></pre></code></pre>\n<p>Apple has a very nice set of default touchbar images outlined here:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/\">https://developer.apple.com/design/human-interface-guidelines/macos/touch-bar/touch-bar-icons-and-images/</a></li>\n<li><a href=\"https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc\">https://developer.apple.com/documentation/appkit/nstouchbaritem?language=objc</a></li>\n</ul>\n<p>These currently can't be used in Catalyst apps (FB6312494).</p>\n<p>The documentation states that you just need to call <code>setNeedsTouchBarUpdate()</code> in order for the touch bar to be updated. However, as of beta 2, this does not work yet. A reliable way of achieving this is to just reset the <code>touchBar</code> property on <code>UIResponder</code> subclasses (like <code>UIViewController</code>) with the updated touchbar:</p>\n<pre class=\"Swift\"><code>     <span class=\"comment\">// Adding `self.` everywhere to make it clear where it lives in this example</span>\n\n     <span class=\"keyword\">@objc func</span> doChangeState(sender: <span class=\"type\">Any</span>) {\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">state</span> = <span class=\"keyword\">self</span>.<span class=\"property\">state</span> + <span class=\"number\">1</span>\n\n         <span class=\"keyword\">self</span>.<span class=\"property\">touchBar</span> = <span class=\"keyword\">self</span>.<span class=\"call\">makeTouchBar</span>()\n\n     }\n</code></pre></code></pre>\n<p>If you have multiple view controllers in your <a href=\"how/responder_chain.md\">responder chain</a> that each want to insert something in your <code>NSTouchBar</code> you can simply define the outermost (highest priority) touchbar to host other touchbars alongside. You do that by adding the system default <code>NSTouchBarItem.Identifier.otherItemsProxy</code> to your list of <code>defaultItemIdentifiers</code>:</p>\n<pre class=\"Swift\"><code>     <span class=\"keyword\">override func</span> makeTouchBar() -&gt; <span class=\"type\">NSTouchBar</span>? {\n\n         <span class=\"keyword\">let</span> touchBar = <span class=\"type\">NSTouchBar</span>()\n\n         touchBar.<span class=\"property\">delegate</span> = <span class=\"keyword\">self</span>\n\n         touchBar.<span class=\"property\">defaultItemIdentifiers</span> = [<span class=\"type\">MyButtonTouchBarIdentifier</span>,\n\n                                            <span class=\"type\">NSTouchBarItem</span>.<span class=\"type\">Identifier</span>.<span class=\"property\">otherItemsProxy</span>]\n\n         <span class=\"keyword\">return</span> touchBar\n\n     }\n</code></pre></code></pre>\n<p>Now, if, say, a child view controller would also implement <code>makeTouchBar</code>, its touchbar would be displayed next to our <code>MyButtonTouchBarIdentifier</code> button.</p>\n<p>Drag and drop is implemented via the same mechanisms that also support drag and drop on iOS. Below, you can see an example of a simple <code>UIViewContoller</code> that allows droping JSON files onto the application in order to import them.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// This is the identifier of a JSON File</span>\n\n<span class=\"keyword\">private let</span> <span class=\"type\">JSONTypeIdentifier</span> = \\<span class=\"string\">\"public</span>.<span class=\"property\">json</span>\\<span class=\"string\">\"</span>\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">MyDragAndDropSupportingViewController</span>: <span class=\"type\">UIDropInteractionDelegate</span> {\n\n     <span class=\"keyword\">func</span> dropInteraction(<span class=\"keyword\">_</span> interaction: <span class=\"type\">UIDropInteraction</span>,\n\n                          canHandle session: <span class=\"type\">UIDropSession</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"comment\">// We tell the drag and drop system that we support JSON</span>\n\n         <span class=\"keyword\">return</span> session.<span class=\"call\">hasItemsConforming</span>(toTypeIdentifiers: [<span class=\"type\">JSONTypeIdentifier</span>])\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> dropInteraction(<span class=\"keyword\">_</span> interaction: <span class=\"type\">UIDropInteraction</span>, sessionDidUpdate session: <span class=\"type\">UIDropSession</span>) -&gt; <span class=\"type\">UIDropProposal</span> {\n\n         <span class=\"comment\">// If a drag comes in, we copy the file. We don't want to consume it.</span>\n\n         <span class=\"keyword\">return</span> <span class=\"type\">UIDropProposal</span>(operation: .<span class=\"dotAccess\">copy</span>)\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> dropInteraction(<span class=\"keyword\">_</span> interaction: <span class=\"type\">UIDropInteraction</span>, performDrop session: <span class=\"type\">UIDropSession</span>) {\n\n         <span class=\"comment\">// This is called with an array of NSURL</span>\n\n     session.<span class=\"call\">loadObjects</span>(ofClass: <span class=\"type\">URL</span>.<span class=\"keyword\">self</span>) { urls <span class=\"keyword\">in</span>\n\n             <span class=\"keyword\">for</span> url <span class=\"keyword\">in</span> urls {\n\n                 <span class=\"call\">importJSONData</span>(from: url)\n\n             }\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>As with other Catalyst technologies, <a href=\"https://developer.apple.com/documentation/uikit/drag_and_drop/making_a_view_into_a_drop_destination\">there is a lot of good Apple documentation for this as this is the same as on iOS.</a></p>\n<p>For these actions, you can use the <code>UIDocumentPickerViewController</code> or <code>UIDocumentBrowserViewController</code> controllers. Here is a quick example of using a <code>UIDocumentPickerViewController</code> to allow the user to export JSON data to disk.</p>\n<p>Note, in order for this to work, you need to have the &quot;User Selected File&quot; permission in <a href=\"how/sandbox.md\">the macOS sandbox</a> set to <code>Read</code> or <code>Read/Write</code> depending on your use case.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> exportJSONData(<span class=\"keyword\">_</span> data: <span class=\"type\">Data</span>) {\n\n    <span class=\"keyword\">let</span> filename = \\<span class=\"string\">\"Export</span>.<span class=\"property\">json</span>\\<span class=\"string\">\"</span>\n\n\n\n    <span class=\"comment\">// Get a path in our document directory to temporarily store the data in</span>\n\n    <span class=\"keyword\">guard let</span> exportURL = <span class=\"type\">FileManager</span>.<span class=\"property\">default</span>\n\n            .<span class=\"call\">urls</span>(for: .<span class=\"dotAccess\">documentDirectory</span>, in: .<span class=\"dotAccess\">userDomainMask</span>)\n\n            .<span class=\"dotAccess\">first</span>?.<span class=\"call\">appendingPathComponent</span>(filename) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n    <span class=\"comment\">// Write the data out into the file</span>\n\n    <span class=\"keyword\">try</span>? data.<span class=\"call\">write</span>(to: exportURL)\n\n\n\n    <span class=\"comment\">// Present the save controller. We've set it to `exportToService` in order</span>\n\n    <span class=\"comment\">// to export the data</span>\n\n    <span class=\"keyword\">let</span> controller = <span class=\"type\">UIDocumentPickerViewController</span>(url: filePath, in: <span class=\"type\">UIDocumentPickerMode</span>.<span class=\"property\">exportToService</span>)\n\n    <span class=\"call\">present</span>(controller, animated: <span class=\"keyword\">true</span>) {\n\n        <span class=\"comment\">// Once we're done, delete the temporary file</span>\n\n        <span class=\"keyword\">try</span>? <span class=\"type\">FileManager</span>.<span class=\"property\">default</span>.<span class=\"call\">removeItem</span>(at: filePath)\n\n    }\n\n}\n</code></pre></code></pre>\n<p>Similarly, for importing data, you would use <code>.import</code> as in:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> controller = <span class=\"type\">UIDocumentPickerViewController</span>(url: filePath, in: .<span class=\"dotAccess\">import</span>)\n</code></pre></code></pre>\n<p>The macOS sandbox is a system that allows you to define which operating system services your app target is allowed to use. Here's a list of the available options:</p>\n<ul>\n<li>Incoming Connections: Your app is a server</li>\n<li>Outgoing Connections: Your app is a client (i.e. read anything from network)</li>\n<li>Camera access</li>\n<li>Audio Input</li>\n<li>USB</li>\n<li>Printing</li>\n<li>Bluetooth</li>\n<li>Accessing the users' Contacts</li>\n<li>Accessing the users' Location</li>\n<li>Accessing the users' Calendar</li>\n<li>File access to various user locations</li>\n</ul>\n<p>If you do not set these entitlements on your app, then you code is not allowed to access these services, and the app will crash or error when you try to do so.</p>\n<p>The sandbox is enabled automatically once you enable a Catalyst target on your iPad app. The settings can be found in the &quot;Signing &amp; Capabilities&quot; section and look like this:</p>\n<p><img src=\"/img-content/catalyst/sandbox.png\" alt=\"\" /></p>\n<p>Please note that the sandbox is not mandatory on macOS. You can disable it and then your app has much more leeway in what it can do on a users system. However, it is required if you want to ship your app on the macOS App Store.</p>\n<p>Dark mode works just as the Dark Mode on iOS 13. If your app supports dark mode on iOS 13 (i.e. semantic colors and so on) then dark mode will also work on macOS.</p>\n<h2>How do I setup the a new scene?</h2>\n<p>A new scene needs a new, different scene configuration. The creation of scene configurations</p>\n<p>First, you have to define a user activity and tell your application in the <code>info.plist</code> to accept it by adding it to the list of user activities:</p>\n<p><img src=\"/img-content/catalyst/useractivity.png\" alt=\"\" /></p>\n<p>Then, you need to define a new scene configuration in your <em>plist</em>:</p>\n<p><img src=\"/img-content/catalyst/multiscene.png\" alt=\"\" /></p>\n<p>Here you have the chance to load a different storyboard. Because, after all, we want the new window to be a different window. So it should also be a different storyboard.</p>\n<p>Next up, say we have a button that you can click in order to spawn the new window. This is what you do:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> userActivity = <span class=\"type\">NSUserActivity</span>(activityType: \\<span class=\"string\">\"com</span>.<span class=\"property\">stylemac</span>.<span class=\"property\">nerau</span>.<span class=\"property\">openResult</span>\\<span class=\"string\">\"</span>)\n\n\n\n<span class=\"comment\">// If you need custom data for your new window initialization, you can</span>\n\n<span class=\"comment\">// put it into the userInfo here</span>\n\nuserActivity.<span class=\"property\">userInfo</span> = [\\<span class=\"string\">\"userid</span>\\<span class=\"string\">\"</span>: <span class=\"number\">1234</span>]\n\n\n\n<span class=\"type\">UIApplication</span>.<span class=\"property\">shared</span>.<span class=\"call\">requestSceneSessionActivation</span>(<span class=\"keyword\">nil</span>, userActivity: userActivity, options: <span class=\"keyword\">nil</span>) { (e) <span class=\"keyword\">in</span>\n\n   <span class=\"comment\">// If we happen to have an error</span>\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"error</span>\\<span class=\"string\">\"</span>, e)\n\n}\n</code></pre></code></pre>\n<p>So, what's happening here. We create a new user activity. We told <code>UIApplication</code> to initialize a new scene with that activity. The activity can include an additional payload for the new window (user id, etc)</p>\n<p>Finally, we need to tell the system that this new scene that we're creating should use the other scene configuration. We can do that in our app delegate:</p>\n<pre class=\"Swift\"><code>   <span class=\"keyword\">func</span> application(<span class=\"keyword\">_</span> application: <span class=\"type\">UIApplication</span>,\n\n                    configurationForConnecting connectingSceneSession: <span class=\"type\">UISceneSession</span>,\n\n                    options: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) -&gt; <span class=\"type\">UISceneConfiguration</span> {\n\n     <span class=\"keyword\">if</span> options.<span class=\"property\">userActivities</span>.<span class=\"property\">first</span>?.<span class=\"property\">activityType</span> == \\<span class=\"string\">\"com</span>.<span class=\"property\">stylemac</span>.<span class=\"property\">nerau</span>.<span class=\"property\">openResult</span>\\<span class=\"string\">\"</span> {\n\n       <span class=\"comment\">// Load our new window configuration</span>\n\n       <span class=\"keyword\">return</span> <span class=\"type\">UISceneConfiguration</span>(name: \\<span class=\"string\">\"New</span> <span class=\"type\">Configuration</span>\\<span class=\"string\">\"</span>, sessionRole: connectingSceneSession.<span class=\"property\">role</span>)\n\n     }\n\n     <span class=\"comment\">// Load our default configuration</span>\n\n     <span class=\"keyword\">return</span> <span class=\"type\">UISceneConfiguration</span>(name: \\<span class=\"string\">\"Default</span> <span class=\"type\">Configuration</span>\\<span class=\"string\">\"</span>, sessionRole: connectingSceneSession.<span class=\"property\">role</span>)\n\n   }\n</code></pre></code></pre>\n<p>By doing it this way, you can create multiple, different windows. Note that in beta 2, sometimes the user activities disappear <em>on route</em> with Catalysts. So if your <code>options.userActivities</code> is empty, then wait for another beta .. or look at <em>Other Approaches</em> below.</p>\n<h2>Other Approaches</h2>\n<p>Another, simpler approach to doing this is to just replace the <code>rootViewController</code> of the <code>UIWindow</code> in the <code>SceneDelegate</code>'s</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> scene(<span class=\"keyword\">_</span> scene: <span class=\"type\">UIScene</span>, willConnectTo session: <span class=\"type\">UISceneSession</span>, options connectionOptions: <span class=\"type\">UIScene</span>.<span class=\"type\">ConnectionOptions</span>) {\n\n   window?.<span class=\"property\">rootViewController</span> = <span class=\"type\">MyCustomUIViewController</span>()\n\n}\n</code></pre></code></pre>\n<p><img src=\"/img-content/catalyst/hover.png\" alt=\"\" /></p>\n<p>Apple supports hovering in Catalyst via a new gesture recognizer, the so-called <code>UIHoverGestureRecognizer</code>. It works in a very simple manner.</p>\n<ol>\n<li>First you initialize a new hover gesture recognizer</li>\n<li>Then, you add it to your view</li>\n<li>Finally, you implement the method to be called when the user hovers</li>\n</ol>\n<p>Now, for every mouse movement within the containment of the view, your method will be called and you can query the gesture recognizer for the position in order to implement custom logic (as Apple does in the Stocks.app when you hover over a Stock's price history).</p>\n<p>Below is a simple implementation:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">final class</span> MyHoverViewController: <span class=\"type\">UIViewController</span> {\n\n     <span class=\"keyword\">override func</span> viewDidLoad() {\n\n         <span class=\"keyword\">super</span>.<span class=\"call\">viewDidLoad</span>()\n\n         <span class=\"comment\">// Create the recognizer</span>\n\n         <span class=\"keyword\">let</span> hover = <span class=\"type\">UIHoverGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: <span class=\"keyword\">#selector</span>(<span class=\"call\">mouseDidMove</span>(with:)))\n\n         <span class=\"comment\">// Add it to the view</span>\n\n         view.<span class=\"call\">addGestureRecognizer</span>(hover)\n\n     }\n\n\n\n     <span class=\"keyword\">@objc func</span> mouseDidMove(with recognizer: <span class=\"type\">UIHoverGestureRecognizer</span>) {\n\n         <span class=\"keyword\">guard let</span> view = recognizer.<span class=\"property\">view</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n         <span class=\"comment\">// Calculate the location</span>\n\n         <span class=\"keyword\">let</span> locationInView = recognizer.<span class=\"call\">location</span>(in: view)\n\n         <span class=\"call\">print</span>(\\<span class=\"string\">\"Hovering</span> at location \\(locationInView)\\<span class=\"string\">\"</span>)\n\n     }\n\n}\n</code></pre></code></pre>\n<p>You can implement conditional code via the new <code>targetEnvironment(UIKitForMac</code> directive:</p>\n<h2>Compile code only on the macOS target</h2>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">let</span> toolbar = <span class=\"type\">NSToolbar</span>(identifier: \\<span class=\"string\">\"MyToolbar</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<h2>Compile code only on the iOS target</h2>\n<pre class=\"Swift\"><code><span class=\"preprocessing\">#if !targetEnvironment(UIKitForMac)</span>\n\n   <span class=\"keyword\">import</span> ARKit\n\n<span class=\"preprocessing\">#endif</span>\n</code></pre></code></pre>\n<p>Now, if you have more involved logic in your settings, special view controllers, web views, and other things, then this doesn't work well for you. In that case, you basically have three options.</p>\n<ol>\n<li>Don't display the preferences in a window, but present the view controller as a modal form or sheet instead</li>\n<li>Use the <a href=\"firststeps/multiple_windows.md\">new iOS multi window support to</a>, only on macOS, open the settings controller in a new window. This is a bit more involved but certainly the most feasible solution.</li>\n<li>Use AppKit to macOS specific preferences in a separate AppKit bundle and load it at runtime. We won't dive into this here, but you can find <a href=\"https://www.highcaffeinecontent.com/blog/20190607-Beyond-the-Checkbox-with-Catalyst-and-AppKit\">more information on this in Steve Troughton-Smith' excellent article on the topic.</a></li>\n</ol>\n<p>Fortunately, each icon in the assets catalog (you're using assets catalogs, are you?) supports different varieties, including macOS. If you enable the &quot;Mac&quot; setting for any icon, additional slots will appear where you can add macOS specific icons to your asset. Catalyst will then automatically choose the right icons. This is what that looks like:</p>\n<p><img src=\"/img-content/catalyst/mac_icon_assets.png\" alt=\"\" /></p>\n<h2>General Icons</h2>\n<p>You could just use your general iOS icons on the Mac, but keep the following things in mind:</p>\n<ul>\n<li>iOS icons are scaled down 77% on macOS / Catalyst. This can add artifacts</li>\n<li>Many Macs still have non-retina displays (i.e. the Macbook Air 13&quot; is still non-retina and still being sold)</li>\n<li>If you don't have @1x variants of your icons, Catalyst will scale down the @2x variants, creating additional artifacts</li>\n<li>Icons might not look as good anymore in a scaled down manner. You might want to include separate macOS icons for some use cases</li>\n</ul>\n<h2>The App Icon</h2>\n<p>For a proper macOS app icon, the following sizes are needed:</p>\n<ul>\n<li>16pt, 16pt @ 2x</li>\n<li>32pt, 32pt @ 2x</li>\n<li>128pt, 128pt @ 2x</li>\n<li>256pt, 256pt @ 2x</li>\n<li>512pt, 512pt @ 2x</li>\n</ul>\n<p>That's 10 icons. However, if you don't care about the ability to add additional detail for retina variants, then you just need the following sizes - as some of those sizes overlap: 16, 32, 64, 128, 256, 512, 1024</p>\n<p>If you start one of Apple's prime Catalyst examples, the <em>Podcast App</em>, you will see this beautiful Preferences screen:</p>\n<p><img src=\"/img-content/catalyst/settings1.png\" alt=\"\" /></p>\n<p>As you already know, Preferences in Catalyst apps are handled via the <a href=\"rel::firststeps/preferences.md\">Settings.bundle</a> technology. However, one feature that is very much missing from Apples documentation is how to implement the toolbars and toolbar icons at the top of the window (General, Playback, Advanced) via the <code>Settings.bundle</code>. In this guide, we will explain how it works.</p>\n<h1>How to implement the Preferences toolbar</h1>\n<p>In addition to the regular settings bundle (with <code>Root.plist</code>), you need to add a couple of additional files first.</p>\n<ul>\n<li>A new <code>.plist</code> file for each section</li>\n<li>Two new icons for each section, the <code>@1x</code> and the <code>@2x</code> variant</li>\n</ul>\n<p>In our example, we will have two sections: <code>General</code>, and <code>Advanced</code>. So we need to <code>.plist</code> files, <code>Root</code> (for general) and <code>Advanced</code> for ... advanced. As well as corresponding images. It looks as follows:</p>\n<p><img src=\"/img-content/catalyst/settings_toolbar.png\" alt=\"\" /></p>\n<p>Next, we need to explain to the system that it should display two <code>Panes</code> in the toolbar. We do that by adding an additional section to the <code>Root.plist</code> that lists all the <code>Pane</code> sections:</p>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;key&gt;PreferenceSpecifiers&lt;/key&gt;\n&lt;array&gt;\n    ...\n    &lt;dict&gt;\n        &lt;key&gt;Type&lt;/key&gt;\n        &lt;string&gt;PSChildPaneSpecifier&lt;/string&gt;\n        &lt;key&gt;Title&lt;/key&gt;\n        &lt;string&gt;Advanced&lt;/string&gt;\n        &lt;key&gt;File&lt;/key&gt;\n        &lt;string&gt;Advanced&lt;/string&gt;\n    &lt;/dict&gt; \n&lt;/array&gt;\n</span></code></pre></code></pre>\n<p>So here we're adding a new Settings Entry, if you will, to the <code>Root</code> plist that tells the system to add a new <code>Child Pane</code> into the toolbar with the title <code>Advanced</code> and from the file <code>Advanced.plist</code>.</p>\n<p>If we wanted to add more panes, we would add more of those <code>&lt;dict&gt;</code> entries.</p>\n<p>This is how we add multiple panes, but it still doesn't explain how to add our beloved icons to the pane. For that, we add a final additional entry at the bottom of each <code>.plist</code>. file (i.e. Root and Advanced) with a <code>key</code> and a <code>string</code> value:</p>\n<h2>In Root.plist</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;key&gt;Icon&lt;/key&gt;                                                                                 \n&lt;string&gt;PreferencesGeneralButton&lt;/string&gt;        \n</span></code></pre></code></pre>\n<h2>In Advanced.plist</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;key&gt;Icon&lt;/key&gt;                                                                                 \n&lt;string&gt;PreferencesAdvancedButton&lt;/string&gt;        \n</span></code></pre></code></pre>\n<p>This is sufficient to give us a nice Preferences screen:</p>\n<p><img src=\"/img-content/catalyst/settings_toolbar2.png\" alt=\"\" /></p>\n<h1>The final PLIST files</h1>\n<p>Here're the full <code>.plist</code> files for you.</p>\n<h2>Root</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;\n&lt;plist version=&quot;1.0&quot;&gt;\n&lt;dict&gt;\n    &lt;key&gt;StringsTable&lt;/key&gt;\n    &lt;string&gt;Root&lt;/string&gt;\n    &lt;key&gt;PreferenceSpecifiers&lt;/key&gt;\n    &lt;array&gt;\n        &lt;dict&gt;\n            &lt;key&gt;Type&lt;/key&gt;\n            &lt;string&gt;PSToggleSwitchSpecifier&lt;/string&gt;\n            &lt;key&gt;Title&lt;/key&gt;\n            &lt;string&gt;Enabled&lt;/string&gt;\n            &lt;key&gt;Key&lt;/key&gt;\n            &lt;string&gt;enabled_another_preference&lt;/string&gt;\n            &lt;key&gt;DefaultValue&lt;/key&gt;\n            &lt;true/&gt;\n        &lt;/dict&gt;\n        &lt;dict&gt;\n            &lt;key&gt;Type&lt;/key&gt;\n            &lt;string&gt;PSChildPaneSpecifier&lt;/string&gt;\n            &lt;key&gt;Title&lt;/key&gt;\n            &lt;string&gt;Advanced&lt;/string&gt;\n            &lt;key&gt;File&lt;/key&gt;\n            &lt;string&gt;Advanced&lt;/string&gt;\n        &lt;/dict&gt; \n    &lt;/array&gt;\n    &lt;key&gt;Icon&lt;/key&gt;                                                                                 \n        &lt;string&gt;PreferencesGeneralButton&lt;/string&gt;        \n&lt;/dict&gt;\n&lt;/plist&gt;\n</span></code></pre></code></pre>\n<h2>Advanced</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;\n&lt;plist version=&quot;1.0&quot;&gt;\n&lt;dict&gt;\n    &lt;key&gt;StringsTable&lt;/key&gt;\n    &lt;string&gt;Root&lt;/string&gt;\n    &lt;key&gt;PreferenceSpecifiers&lt;/key&gt;\n    &lt;array&gt;\n        &lt;dict&gt;\n            &lt;key&gt;Type&lt;/key&gt;\n            &lt;string&gt;PSToggleSwitchSpecifier&lt;/string&gt;\n            &lt;key&gt;Title&lt;/key&gt;\n            &lt;string&gt;Enable Export&lt;/string&gt;\n            &lt;key&gt;Key&lt;/key&gt;\n            &lt;string&gt;enabled_preference&lt;/string&gt;\n            &lt;key&gt;DefaultValue&lt;/key&gt;\n            &lt;true/&gt;\n        &lt;/dict&gt;\n    &lt;/array&gt;\n    &lt;key&gt;Icon&lt;/key&gt;\n    &lt;string&gt;PreferencesAdvancedButton&lt;/string&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</span></code></pre></code></pre>\n<p>That should be it.</p>\n<p>Many of the iOS specific targets, such as iMessage extensions or Share Extensions are currently not supported on UIKitForMac.</p>\n<p>Catalyst, just like Cocoa, uses the <a href=\"how/responder_chain.md\">responder chain</a> to figure out whether an action in a menu can be performed. <a href=\"firststeps/modify_menubar.md\">Remember, that a menu bar on iOS is composed out of <code>UIAction</code>, <code>UICommand</code>, and <code>UIMenu</code> objects.</a></p>\n<p>The way that works is as follows:</p>\n<ol>\n<li>When you open a menu in the menu bar with your mouse</li>\n<li>UIKit will have a look at the first responder and call</li>\n<li><a href=\"https://developer.apple.com/documentation/uikit/uiresponder/1621105-canperformaction\"><code>canPerformAction(_:withSender:)</code></a> to figure out if the first responder has a matching <code>@IBAction someMethod</code> that fits the selector from the menubar item in question</li>\n<li>If the first responder returns no, it will ask the next responder</li>\n<li>If a responder returns yes, then this menu bar entry will be enabled (clickable) and this responder (i.e. object or view controller) will be set as the current <code>target</code> of the menu bar entry.</li>\n<li>If the next responder is nil - that is, it UIKit reached the end of the responder chain - it will stop and the menu bar entry will be disabled.</li>\n</ol>\n<p>This process happens for each item in the menubar.</p>\n<p>If you want to influence how a menu bar item becomes enabled / disabled based on the particulars of your view controller, you can override <code>canPerformAction</code> and write custom logic. Here is a quick example. Here, we imagine that a menubar action should only be enabled if we have actual text in our textField.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">override func</span> canPerformAction(<span class=\"keyword\">_</span> action: <span class=\"type\">Selector</span>, withSender sender: <span class=\"type\">Any</span>?) -&gt; <span class=\"type\">Bool</span> {\n\n   <span class=\"keyword\">guard</span> !(textField.<span class=\"property\">text</span> ?? \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>).<span class=\"property\">isEmpty</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">return false</span> }\n\n   <span class=\"keyword\">return super</span>.<span class=\"call\">canPerformAction</span>(action, withSender: sender)\n\n}\n</code></pre></code></pre>\n<p>Currently, there doesn't seem to be a way to do this. I've tracked this as issue <em>FB6360289</em> in Apple's Feedback tool.</p>\n<p>I could not figure out how to dynamically update the enabled / disabled status of toolbar items based on app actions such as a new controller entering the responder chain. This makes it very difficult to implement toolbars that adapt to the users actions. Event Apple’s own Catalyst apps seem to be affected by this: The Stocks app has a “Share” toolbar item that just does nothing when pressed and nothing is selected (it is enabled, not disabled).</p>\n<p>The best solution is to have a singleton with access to the toolbar (or as a dependency injection) and then call a method on it that updates the contents of the toolbar. An easy way to do that is by iterating over the <code>toolbar.items</code> property and updating each entry accordingly (disabling / enabling).</p>\n<p>This is similar to <a href=\"how/dynamically_update_touchbar.md\">how you would dynamically modify the contents of your touchbar: Update the touchbar and set it again.</a></p>\n<p>The responder chain is a event handling system at the heart of macOS and iOS.\nEvery touch event coming in, for example, uses this responder chain to reach the currently active <code>UIControl</code>. The main building block of the responder chain is the <code>UIResponder</code> class which is a superclass of <code>UIViewController</code> or <code>UIView</code>.</p>\n<p>Apple has very useful information on this available:</p>\n<ul>\n<li><a href=\"https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events\">iOS: Using Responders and the Responder Chain</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/EventOverview/EventArchitecture/EventArchitecture.html\">macOS: Event Architecture Overview</a></li>\n</ul>\n<p>Below, I'll quote the most important sections to understand the thing:</p>\n<p>Responders receive the raw event data and must either handle the event or forward it to another responder object. When your app receives an event, UIKit automatically directs that event to the most appropriate responder object, known as the first responder.</p>\n<p>Unhandled events are passed from responder to responder in the active responder chain.</p>\n<p>Here's an image from the Apple Documentation:</p>\n<p><img src=\"/img-content/catalyst/responderchain.png\" alt=\"\" /></p>\n<p>Now imagine that you're entering text in the text field. The following will happen:</p>\n<ol>\n<li>If the text field does not handle an event, UIKit sends the event to the text field’s parent UIView object</li>\n<li>If that does not handle the event, it is forwarded to the next UIView.</li>\n<li>If that does not handle the event, it is forwarded to the UIViewController (which is the root view controller of the window)</li>\n<li>If the view controller is not handling the event, it is forwarded to the <code>UIApplication</code></li>\n<li>If the UIApplication is not handling the event, it is handled by the <code>UIApplicationDelegate</code></li>\n</ol>\n<p>This also means that if you really need to catch a certain event, you can always set up the required selector / method in your app delegate.</p>\n<h2>Altering the Responder Chain</h2>\n<p>You can alter the responder chain by overriding the next property of your responder objects. When you do this, the next responder is the object that you return.</p>\n<h1>This more or less only affects paid apps</h1>\n<p>On iOS, Apple automatically deploys code that does receipt validation and makes sure that your app can't just be pirated by copying it from device to device (albeit this still being a possibilty on rooted iOS devices).</p>\n<p>On macOS, users can just copy the <code>MyApp.app</code> folder to a different Mac and run it. By default, macOS does not perform any receipt validation whatsoever. <a href=\"https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html\">Apple has some guides on how to implement the necessary code to perform receipt validation yourself.</a>.</p>\n<h1>Please Don't do that!</h1>\n<p>This is rather difficult to do properly, and even then you have to do it in a way that can't be easily circumvented by hackers. This is certainly doable but requires an astonishing amount of work. There's a much better solution.</p>\n<h1>Receigen</h1>\n<p><a href=\"http://receigen.etiemble.com\">Receigen</a> is a fantastic macOS app that will automatically generate the required receipt validation code for you. I strongly suggest using <em>Receigen</em> or an alternative solution.</p>\n<p>This is a list of somehow known issues, i.e. bugs where enough people seem to have them that it seems it is not an issue in your app but instead related to the current beta. This list is helpful to keep you from trying to hunt down a bug that's not yours.</p>\n<h2>My app crashes when I close a window</h2>\n<p>If you see this when closing a window:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"> <span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">***</span></span><span class=\"techoumeta techoufunction-call techouarguments techoushell\"> Terminating app due to uncaught exception <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>NSRangeException<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span>, reason: <span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>Cannot remove an observer &lt;UISystemInputAssistantViewController 0x1010adcf0&gt; for the key path &quot;bounds&quot; from &lt;CALayer 0x600000295bc0&gt; because it is not registered as an observer.<span class=\"techoupunctuation techoudefinition techoustring techouend techoushell\">&#39;</span></span></span>\n</span></code></pre></code></pre>\n<p>That seems to be an issue in the current beta</p>\n<h2>My app crashes with &quot;another instance of this process was already running&quot;</h2>\n<p>This seems to be a bug or a feature in Catalina. With AppKit apps, multiple instances of the same app (with the same bundle identifier) can be running without an issue. If you duplicate <code>Calculator.app</code> 5 times and start them all, you have 5 calculators running. This seems to not be the case with Catalyst apps. If a Catalyst apps crashes in a certain way, apparently the system thinks it is still running. Thus, you can't run it again. Currently the only solution I know of is to reboot Catalina. Congratulations. The full error is:</p>\n<pre class=\"Bourne Again Shell (bash)\"><code><span class=\"techousource techoushell techoubash\"><span class=\"techoumeta techoufunction-call techoushell\"><span class=\"techouvariable techoufunction techoushell\">Couldn<span class=\"techoustring techouquoted techousingle techoushell\"><span class=\"techoupunctuation techoudefinition techoustring techoubegin techoushell\">&#39;</span>t register uikitformac.com.stylemac.Nerau.gsEvents with the bootstrap server. Error: unknown error code (1100).\nThis generally means that another instance of this process was already running or is hung in the debugger.\n</span></span></span></span></code></pre></code></pre>\n<h2>I get weird SwiftUIKit compiler errors</h2>\n<p>Could it be that your <code>Xcode-beta.app</code> is either not in <code>/Applications</code> or not named <code>Xcode-beta.app</code>? (I.e. <code>Xcode-Beta v11.app</code>. Then, Catalyst apps currently won't compile.</p>\n<h2>When I create a new Window, the <code>NSUserActivity</code> disappears</h2>\n<p>This seems to be rather flaky currently.</p>\n","raw_content":"","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/open_save_export_import.md":["69ca45aa622a7241",{"identifier":"31a433c1","filename":"open_save_export_import.md","info":{"title":"How do I create file open / save / export / import dialogs?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-create-file-open-save-export-import-dialogs.html","content":"<p>For these actions, you can use the <code>UIDocumentPickerViewController</code> or <code>UIDocumentBrowserViewController</code> controllers. Here is a quick example of using a <code>UIDocumentPickerViewController</code> to allow the user to export JSON data to disk.</p>\n<p>Note, in order for this to work, you need to have the &quot;User Selected File&quot; permission in <a href=\"how/sandbox.md\">the macOS sandbox</a> set to <code>Read</code> or <code>Read/Write</code> depending on your use case.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> exportJSONData(<span class=\"keyword\">_</span> data: <span class=\"type\">Data</span>) {\n\n    <span class=\"keyword\">let</span> filename = \\<span class=\"string\">\"Export</span>.<span class=\"property\">json</span>\\<span class=\"string\">\"</span>\n\n\n\n    <span class=\"comment\">// Get a path in our document directory to temporarily store the data in</span>\n\n    <span class=\"keyword\">guard let</span> exportURL = <span class=\"type\">FileManager</span>.<span class=\"property\">default</span>\n\n            .<span class=\"call\">urls</span>(for: .<span class=\"dotAccess\">documentDirectory</span>, in: .<span class=\"dotAccess\">userDomainMask</span>)\n\n            .<span class=\"dotAccess\">first</span>?.<span class=\"call\">appendingPathComponent</span>(filename) <span class=\"keyword\">else</span> { <span class=\"keyword\">return</span> }\n\n\n\n    <span class=\"comment\">// Write the data out into the file</span>\n\n    <span class=\"keyword\">try</span>? data.<span class=\"call\">write</span>(to: exportURL)\n\n\n\n    <span class=\"comment\">// Present the save controller. We've set it to `exportToService` in order</span>\n\n    <span class=\"comment\">// to export the data</span>\n\n    <span class=\"keyword\">let</span> controller = <span class=\"type\">UIDocumentPickerViewController</span>(url: filePath, in: <span class=\"type\">UIDocumentPickerMode</span>.<span class=\"property\">exportToService</span>)\n\n    <span class=\"call\">present</span>(controller, animated: <span class=\"keyword\">true</span>) {\n\n        <span class=\"comment\">// Once we're done, delete the temporary file</span>\n\n        <span class=\"keyword\">try</span>? <span class=\"type\">FileManager</span>.<span class=\"property\">default</span>.<span class=\"call\">removeItem</span>(at: filePath)\n\n    }\n\n}\n</code></pre></code></pre>\n<p>Similarly, for importing data, you would use <code>.import</code> as in:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> controller = <span class=\"type\">UIDocumentPickerViewController</span>(url: filePath, in: .<span class=\"dotAccess\">import</span>)\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How do I create file open / save / export / import dialogs?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\n\nFor these actions, you can use the `UIDocumentPickerViewController` or `UIDocumentBrowserViewController` controllers. Here is a quick example of using a `UIDocumentPickerViewController` to allow the user to export JSON data to disk.\n\nNote, in order for this to work, you need to have the \"User Selected File\" permission in [the macOS sandbox](how/sandbox.md) set to `Read` or `Read/Write` depending on your use case.\n\n``` swift\nfunc exportJSONData(_ data: Data) {\n   let filename = \"Export.json\"\n\n   // Get a path in our document directory to temporarily store the data in\n   guard let exportURL = FileManager.default\n           .urls(for: .documentDirectory, in: .userDomainMask)\n           .first?.appendingPathComponent(filename) else { return }\n\n   // Write the data out into the file\n   try? data.write(to: exportURL)\n\n   // Present the save controller. We've set it to `exportToService` in order\n   // to export the data\n   let controller = UIDocumentPickerViewController(url: filePath, in: UIDocumentPickerMode.exportToService)\n   present(controller, animated: true) {\n       // Once we're done, delete the temporary file\n       try? FileManager.default.removeItem(at: filePath)\n   }\n}\n```\n\nSimilarly, for importing data, you would use `.import` as in:\n\n``` swift\nlet controller = UIDocumentPickerViewController(url: filePath, in: .import)\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/preferences_toolbar.md":["1dd32a2ff3737939",{"identifier":"ca8370b0","filename":"preferences_toolbar.md","info":{"title":"How do I implement a Preferences Toolbar like in the Podcast App?","tags":["catalyst","macos","uikitformac","toolbar","preferences"],"keywords":[],"category":[],"created":"2019-07-09 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562668230,"date":"2019-07-09T10:30:30","date_info":{"year":2019,"month":7,"day":9,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-9-how-do-i-implement-a-preferences-toolbar-like-in-the-podcast-app.html","content":"<p>If you start one of Apple's prime Catalyst examples, the <em>Podcast App</em>, you will see this beautiful Preferences screen:</p>\n<p><img src=\"/img-content/catalyst/settings1.png\" alt=\"\" /></p>\n<p>As you already know, Preferences in Catalyst apps are handled via the <a href=\"rel::firststeps/preferences.md\">Settings.bundle</a> technology. However, one feature that is very much missing from Apples documentation is how to implement the toolbars and toolbar icons at the top of the window (General, Playback, Advanced) via the <code>Settings.bundle</code>. In this guide, we will explain how it works.</p>\n<h1>How to implement the Preferences toolbar</h1>\n<p>In addition to the regular settings bundle (with <code>Root.plist</code>), you need to add a couple of additional files first.</p>\n<ul>\n<li>A new <code>.plist</code> file for each section</li>\n<li>Two new icons for each section, the <code>@1x</code> and the <code>@2x</code> variant</li>\n</ul>\n<p>In our example, we will have two sections: <code>General</code>, and <code>Advanced</code>. So we need to <code>.plist</code> files, <code>Root</code> (for general) and <code>Advanced</code> for ... advanced. As well as corresponding images. It looks as follows:</p>\n<p><img src=\"/img-content/catalyst/settings_toolbar.png\" alt=\"\" /></p>\n<p>Next, we need to explain to the system that it should display two <code>Panes</code> in the toolbar. We do that by adding an additional section to the <code>Root.plist</code> that lists all the <code>Pane</code> sections:</p>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;key&gt;PreferenceSpecifiers&lt;/key&gt;\n&lt;array&gt;\n    ...\n    &lt;dict&gt;\n        &lt;key&gt;Type&lt;/key&gt;\n        &lt;string&gt;PSChildPaneSpecifier&lt;/string&gt;\n        &lt;key&gt;Title&lt;/key&gt;\n        &lt;string&gt;Advanced&lt;/string&gt;\n        &lt;key&gt;File&lt;/key&gt;\n        &lt;string&gt;Advanced&lt;/string&gt;\n    &lt;/dict&gt; \n&lt;/array&gt;\n</span></code></pre></code></pre>\n<p>So here we're adding a new Settings Entry, if you will, to the <code>Root</code> plist that tells the system to add a new <code>Child Pane</code> into the toolbar with the title <code>Advanced</code> and from the file <code>Advanced.plist</code>.</p>\n<p>If we wanted to add more panes, we would add more of those <code>&lt;dict&gt;</code> entries.</p>\n<p>This is how we add multiple panes, but it still doesn't explain how to add our beloved icons to the pane. For that, we add a final additional entry at the bottom of each <code>.plist</code>. file (i.e. Root and Advanced) with a <code>key</code> and a <code>string</code> value:</p>\n<h2>In Root.plist</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;key&gt;Icon&lt;/key&gt;                                                                                 \n&lt;string&gt;PreferencesGeneralButton&lt;/string&gt;        \n</span></code></pre></code></pre>\n<h2>In Advanced.plist</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;key&gt;Icon&lt;/key&gt;                                                                                 \n&lt;string&gt;PreferencesAdvancedButton&lt;/string&gt;        \n</span></code></pre></code></pre>\n<p>This is sufficient to give us a nice Preferences screen:</p>\n<p><img src=\"/img-content/catalyst/settings_toolbar2.png\" alt=\"\" /></p>\n<h1>The final PLIST files</h1>\n<p>Here're the full <code>.plist</code> files for you.</p>\n<h2>Root</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;\n&lt;plist version=&quot;1.0&quot;&gt;\n&lt;dict&gt;\n    &lt;key&gt;StringsTable&lt;/key&gt;\n    &lt;string&gt;Root&lt;/string&gt;\n    &lt;key&gt;PreferenceSpecifiers&lt;/key&gt;\n    &lt;array&gt;\n        &lt;dict&gt;\n            &lt;key&gt;Type&lt;/key&gt;\n            &lt;string&gt;PSToggleSwitchSpecifier&lt;/string&gt;\n            &lt;key&gt;Title&lt;/key&gt;\n            &lt;string&gt;Enabled&lt;/string&gt;\n            &lt;key&gt;Key&lt;/key&gt;\n            &lt;string&gt;enabled_another_preference&lt;/string&gt;\n            &lt;key&gt;DefaultValue&lt;/key&gt;\n            &lt;true/&gt;\n        &lt;/dict&gt;\n        &lt;dict&gt;\n            &lt;key&gt;Type&lt;/key&gt;\n            &lt;string&gt;PSChildPaneSpecifier&lt;/string&gt;\n            &lt;key&gt;Title&lt;/key&gt;\n            &lt;string&gt;Advanced&lt;/string&gt;\n            &lt;key&gt;File&lt;/key&gt;\n            &lt;string&gt;Advanced&lt;/string&gt;\n        &lt;/dict&gt; \n    &lt;/array&gt;\n    &lt;key&gt;Icon&lt;/key&gt;                                                                                 \n        &lt;string&gt;PreferencesGeneralButton&lt;/string&gt;        \n&lt;/dict&gt;\n&lt;/plist&gt;\n</span></code></pre></code></pre>\n<h2>Advanced</h2>\n<pre class=\"Plain Text\"><code><span class=\"techoutext techouplain\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;\n&lt;plist version=&quot;1.0&quot;&gt;\n&lt;dict&gt;\n    &lt;key&gt;StringsTable&lt;/key&gt;\n    &lt;string&gt;Root&lt;/string&gt;\n    &lt;key&gt;PreferenceSpecifiers&lt;/key&gt;\n    &lt;array&gt;\n        &lt;dict&gt;\n            &lt;key&gt;Type&lt;/key&gt;\n            &lt;string&gt;PSToggleSwitchSpecifier&lt;/string&gt;\n            &lt;key&gt;Title&lt;/key&gt;\n            &lt;string&gt;Enable Export&lt;/string&gt;\n            &lt;key&gt;Key&lt;/key&gt;\n            &lt;string&gt;enabled_preference&lt;/string&gt;\n            &lt;key&gt;DefaultValue&lt;/key&gt;\n            &lt;true/&gt;\n        &lt;/dict&gt;\n    &lt;/array&gt;\n    &lt;key&gt;Icon&lt;/key&gt;\n    &lt;string&gt;PreferencesAdvancedButton&lt;/string&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</span></code></pre></code></pre>\n<p>That should be it.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I implement a Preferences Toolbar like in the Podcast App?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\", \"toolbar\", \"preferences\"]\ncreated = \"2019-07-09\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nIf you start one of Apple's prime Catalyst examples, the *Podcast App*, you will see this beautiful Preferences screen:\n\n![](/img-content/catalyst/settings1.png)\n\nAs you already know, Preferences in Catalyst apps are handled via the [Settings.bundle](rel::firststeps/preferences.md) technology. However, one feature that is very much missing from Apples documentation is how to implement the toolbars and toolbar icons at the top of the window (General, Playback, Advanced) via the `Settings.bundle`. In this guide, we will explain how it works.\n\n# How to implement the Preferences toolbar\n\nIn addition to the regular settings bundle (with `Root.plist`), you need to add a couple of additional files first.\n\n- A new `.plist` file for each section\n- Two new icons for each section, the `@1x` and the `@2x` variant\n\nIn our example, we will have two sections: `General`, and `Advanced`. So we need to `.plist` files, `Root` (for general) and `Advanced` for ... advanced. As well as corresponding images. It looks as follows:\n\n![](/img-content/catalyst/settings_toolbar.png)\n\nNext, we need to explain to the system that it should display two `Panes` in the toolbar. We do that by adding an additional section to the `Root.plist` that lists all the `Pane` sections:\n\n``` plist\n<key>PreferenceSpecifiers</key>\n<array>\n\t...\n\t<dict>\n\t\t<key>Type</key>\n\t\t<string>PSChildPaneSpecifier</string>\n\t\t<key>Title</key>\n\t\t<string>Advanced</string>\n\t\t<key>File</key>\n\t\t<string>Advanced</string>\n\t</dict> \n</array>\n```\n\nSo here we're adding a new Settings Entry, if you will, to the `Root` plist that tells the system to add a new `Child Pane` into the toolbar with the title `Advanced` and from the file `Advanced.plist`.\n\nIf we wanted to add more panes, we would add more of those `<dict>` entries.\n\nThis is how we add multiple panes, but it still doesn't explain how to add our beloved icons to the pane. For that, we add a final additional entry at the bottom of each `.plist`. file (i.e. Root and Advanced) with a `key` and a `string` value:\n\n\n## In Root.plist\n``` plist\n<key>Icon</key>                                                                                 \n<string>PreferencesGeneralButton</string>        \n```\n\n## In Advanced.plist\n``` plist\n<key>Icon</key>                                                                                 \n<string>PreferencesAdvancedButton</string>        \n```\n\nThis is sufficient to give us a nice Preferences screen:\n\n![](/img-content/catalyst/settings_toolbar2.png)\n\n# The final PLIST files\n\nHere're the full `.plist` files for you.\n\n## Root\n\n``` plist\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>StringsTable</key>\n\t<string>Root</string>\n\t<key>PreferenceSpecifiers</key>\n\t<array>\n\t\t<dict>\n\t\t\t<key>Type</key>\n\t\t\t<string>PSToggleSwitchSpecifier</string>\n\t\t\t<key>Title</key>\n\t\t\t<string>Enabled</string>\n\t\t\t<key>Key</key>\n\t\t\t<string>enabled_another_preference</string>\n\t\t\t<key>DefaultValue</key>\n\t\t\t<true/>\n\t\t</dict>\n\t\t<dict>\n\t\t\t<key>Type</key>\n\t\t\t<string>PSChildPaneSpecifier</string>\n\t\t\t<key>Title</key>\n\t\t\t<string>Advanced</string>\n\t\t\t<key>File</key>\n\t\t\t<string>Advanced</string>\n\t\t</dict> \n\t</array>\n\t<key>Icon</key>                                                                                 \n        <string>PreferencesGeneralButton</string>        \n</dict>\n</plist>\n```\n\n## Advanced\n``` plist\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>StringsTable</key>\n\t<string>Root</string>\n\t<key>PreferenceSpecifiers</key>\n\t<array>\n\t\t<dict>\n\t\t\t<key>Type</key>\n\t\t\t<string>PSToggleSwitchSpecifier</string>\n\t\t\t<key>Title</key>\n\t\t\t<string>Enable Export</string>\n\t\t\t<key>Key</key>\n\t\t\t<string>enabled_preference</string>\n\t\t\t<key>DefaultValue</key>\n\t\t\t<true/>\n\t\t</dict>\n\t</array>\n\t<key>Icon</key>\n\t<string>PreferencesAdvancedButton</string>\n</dict>\n</plist>\n```\n\nThat should be it.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/writablekeypath.md":["ffb0547975daae24",{"identifier":"452bfaf5","filename":"writablekeypath.md","info":{"title":"WritableKeyPath","tags":["keypath","writablekeypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-writablekeypath.html","content":"<h1>WritableKeyPath&lt;Root, Value&gt;</h1>\n<p>In <a href=\"javascript:prev()\">the earlier example</a>, our type was a <code>WritableKeyPath</code>. WritableKeyPaths are, as the name implies, keypaths that allow you to write information. They're formed for <code>var</code> properties on <code>var</code> instances.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> MutableUser {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span>\n\n}\n\n<span class=\"keyword\">var</span> firstUser = <span class=\"type\">MutableUser</span>(username: \\<span class=\"string\">\"Shinji</span>\\<span class=\"string\">\"</span>)\n\n\n\nfirstUser[keyPath: \\<span class=\"type\">MutableUser</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ikari</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>If you want to have a keypath argument to a function that allows mutating the contents, <code>WritableKeyPath</code> is a good choice:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> modify(user: <span class=\"type\">User</span>, keyPath: <span class=\"type\">WritableKeyPath</span>&lt;<span class=\"type\">User</span>, <span class=\"type\">String</span>&gt;) {\n\n   user[keyPath: keyPath] = \\<span class=\"string\">\"Hello</span> <span class=\"type\">World</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>There's another variant of the <code>WritableKeyPath</code>, which we will introduce next.</p>\n","raw_content":"[frontMatter]\ntitle = \"WritableKeyPath\"\ntags = [\"keypath\", \"writablekeypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# WritableKeyPath<Root, Value>\n\nIn [the earlier example](javascript:prev()), our type was a `WritableKeyPath`. WritableKeyPaths are, as the name implies, keypaths that allow you to write information. They're formed for `var` properties on `var` instances.\n\n``` Swift\nstruct MutableUser {\n  var username: String\n}\nvar firstUser = MutableUser(username: \"Shinji\")\n\nfirstUser[keyPath: \\MutableUser.username] = \"Ikari\"\n```\n\nIf you want to have a keypath argument to a function that allows mutating the contents, `WritableKeyPath` is a good choice:\n\n``` Swift\nfunc modify(user: User, keyPath: WritableKeyPath<User, String>) {\n  user[keyPath: keyPath] = \"Hello World\"\n}\n```\n\nThere's another variant of the `WritableKeyPath`, which we will introduce next.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/example/intro.md":["76febe8f04e138ec",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Practical Example","tags":[],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-practical-example.html","content":"<h1>Structs to Core Data</h1>\n<p>Imagine we're working at the newest, hot, tech startup: <strong>Books\nBunny</strong>. We offer an Artificial Intelligence with a browser plugin that\nautomatically analyses all the sites that the user visits and\nautomatically bookmarks the relevant urls.</p>\n<p>Our server backend is\nobviously written in Swift. Since we have millions of site visits active\nin our system at a time, we'd like to use <code>structs</code> for the analysis\npart of each site that a user visits. However, if our AI decides that\nthis is worthy of a bookmark, we'd like to use CoreData to store this\ntype in a database.</p>\n<p>Now, we don't want to write custom serialization to Core Data code\nwhenever we introduce a new <code>struct</code>. Rather, we'd like to develop this\nin a way so that we can utilize it for all future <code>structs</code> we develop.</p>\n<p>So, how do we do that?</p>\n","raw_content":"[frontMatter]\ntitle = \"Practical Example\"\ntags = []\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Structs to Core Data\n\nImagine we\\'re working at the newest, hot, tech startup: **Books\nBunny**. We offer an Artificial Intelligence with a browser plugin that\nautomatically analyses all the sites that the user visits and\nautomatically bookmarks the relevant urls.\n\nOur server backend is\nobviously written in Swift. Since we have millions of site visits active\nin our system at a time, we\\'d like to use `structs` for the analysis\npart of each site that a user visits. However, if our AI decides that\nthis is worthy of a bookmark, we\\'d like to use CoreData to store this\ntype in a database.\n\nNow, we don\\'t want to write custom serialization to Core Data code\nwhenever we introduce a new `struct`. Rather, we\\'d like to develop this\nin a way so that we can utilize it for all future `structs` we develop.\n\nSo, how do we do that?\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/map_flatmap_reduce_more/more_examples/interpose.md":["0c9b36acc54f664d",{"identifier":"cb93dd1d","filename":"interpose.md","info":{"title":"Interpose","tags":["reduce"],"keywords":[],"category":[],"created":"2019-02-20 19:49:10","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550692150,"date":"2019-02-20T19:49:10","date_info":{"year":2019,"month":2,"day":20,"hour":19,"minute":49,"second":10},"identifier":"","indexed":true},"slug":"//2019-2-20-interpose.html","content":"<h1>Interpose</h1>\n<p>This function returns the given <code>items</code>, with <code>element</code> inserted between\nevery <code>count</code> items. The implementation below makes sure that the\nelements are only interposed and not appended at the end.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> interpose&lt;T&gt;(items: [<span class=\"type\">T</span>], element: <span class=\"type\">T</span>, count: <span class=\"type\">Int</span> = <span class=\"number\">1</span>) -&gt; [<span class=\"type\">T</span>] {\n\n    <span class=\"keyword\">typealias</span> Acc = (ac: [<span class=\"type\">T</span>], cur: <span class=\"type\">Int</span>, cnt: <span class=\"type\">Int</span>)\n\n    <span class=\"keyword\">return</span> items.<span class=\"call\">reduce</span>((ac: [], cur: <span class=\"number\">0</span>, cnt: <span class=\"number\">1</span>), { (a: <span class=\"type\">Acc</span>, o: <span class=\"type\">T</span>) -&gt; <span class=\"type\">Acc</span> <span class=\"keyword\">in</span> \n\n        <span class=\"keyword\">switch</span> a {\n\n        <span class=\"comment\">// the last item will not have any interposition</span>\n\n        <span class=\"keyword\">case let</span> (ac, cur, <span class=\"keyword\">_</span>) <span class=\"keyword\">where</span> (cur+<span class=\"number\">1</span>) == items.<span class=\"property\">count</span>: <span class=\"keyword\">return</span> (ac + [o], <span class=\"number\">0</span>, <span class=\"number\">0</span>)\n\n        <span class=\"comment\">// interpose</span>\n\n        <span class=\"keyword\">case let</span> (ac, cur, c) <span class=\"keyword\">where</span> c == count:\n\n           <span class=\"keyword\">return</span> (ac + [o, element], cur + <span class=\"number\">1</span>, <span class=\"number\">1</span>)\n\n        <span class=\"comment\">// next</span>\n\n        <span class=\"keyword\">case let</span> (ac, cur, c):\n\n           <span class=\"keyword\">return</span> (ac + [o], cur + <span class=\"number\">1</span>, c + <span class=\"number\">1</span>)\n\n        }\n\n    }).<span class=\"property\">ac</span>\n\n}\n\n<span class=\"call\">print</span>(<span class=\"call\">interpose</span>(items: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], element: <span class=\"number\">9</span>))\n\n<span class=\"comment\">// : [1, 9, 2, 9, 3, 9, 4, 9, 5]</span>\n\n<span class=\"call\">print</span>(<span class=\"call\">interpose</span>(items: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], element: <span class=\"number\">9</span>, count: <span class=\"number\">2</span>))\n\n<span class=\"comment\">// : [1, 2, 9, 3, 4, 9, 5]</span>\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Interpose\"\ntags = [\"reduce\"]\ncreated = \"2019-02-20 19:49:10\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Interpose\n\nThis function returns the given `items`, with `element` inserted between\nevery `count` items. The implementation below makes sure that the\nelements are only interposed and not appended at the end.\n\n``` Swift\nfunc interpose<T>(items: [T], element: T, count: Int = 1) -> [T] {\n   typealias Acc = (ac: [T], cur: Int, cnt: Int)\n   return items.reduce((ac: [], cur: 0, cnt: 1), { (a: Acc, o: T) -> Acc in \n       switch a {\n       // the last item will not have any interposition\n       case let (ac, cur, _) where (cur+1) == items.count: return (ac + [o], 0, 0)\n       // interpose\n       case let (ac, cur, c) where c == count:\n          return (ac + [o, element], cur + 1, 1)\n       // next\n       case let (ac, cur, c):\n          return (ac + [o], cur + 1, c + 1)\n       }\n   }).ac\n}\nprint(interpose(items: [1, 2, 3, 4, 5], element: 9))\n// : [1, 9, 2, 9, 3, 9, 4, 9, 5]\nprint(interpose(items: [1, 2, 3, 4, 5], element: 9, count: 2))\n// : [1, 2, 9, 3, 4, 9, 5]\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/tips/dictionary_keys.md":["4cfe6e223ebe6868",{"identifier":"830c00fc","filename":"dictionary_keys.md","info":{"title":"Dictionary Keys","tags":["keypath","hashable","key","dictionary"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-dictionary-keys.html","content":"<h1>3. KeyPaths conform to <code>Hashable</code></h1>\n<p>We did not see an example of this  yet, but it is one of my all-time favorite keypaths functions. Every <code>KeyPath</code> type is <code>Hashable</code> which means that it can be used as a key in a dictionary. One use case for this is storing meta information about properties in a dictionary. Here, we have a dictionary that maps from partial key paths to <code>String</code>. It stores two different keypaths (<code>username</code>, <code>age</code>) and their titles:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> meta: [<span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt;: <span class=\"type\">String</span>] = [\n\n   \\<span class=\"type\">User</span>.<span class=\"property\">username</span>: \\<span class=\"string\">\"Your</span> <span class=\"type\">Username</span>\\<span class=\"string\">\"</span>,\n\n   \\<span class=\"type\">User</span>.<span class=\"property\">age</span>: \\<span class=\"string\">\"Your</span> <span class=\"type\">Age</span>\\<span class=\"string\">\"</span>\n\n]\n</code></pre></code></pre>\n<p>We can now write a function <code>renderTitle</code> that will retrieve this meta information and print it out alongside the actual value:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> renderTitle(on: <span class=\"type\">User</span>, keyPath: <span class=\"type\">AnyKeyPath</span>) {\n\n   <span class=\"keyword\">if let</span> title = meta[keyPath] {\n\n     <span class=\"call\">print</span>(title, terminator: \\<span class=\"string\">\"</span>: \\<span class=\"string\">\"</span>)\n\n   }\n\n   <span class=\"call\">print</span>(on[keyPath: keyPath])\n\n}\n\n\n\n<span class=\"keyword\">let</span> myUser = <span class=\"type\">User</span>(username: \\<span class=\"string\">\"Jon</span>\\<span class=\"string\">\"</span>, age: <span class=\"number\">44</span>)\n\n\n\n<span class=\"call\">renderTitle</span>(on: myUser, keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">age</span>)\n</code></pre></code></pre>\n<p>This would print <code>Your Age: 44</code></p>\n<p>This pattern can be used for many more situations. Whenever you have information about a type, you can utilize it to store the information. Another example would be input validation.</p>\n","raw_content":"[frontMatter]\ntitle = \"Dictionary Keys\"\ntags = [\"keypath\", \"hashable\", \"key\", \"dictionary\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# 3. KeyPaths conform to `Hashable`\n\nWe did not see an example of this  yet, but it is one of my all-time favorite keypaths functions. Every `KeyPath` type is `Hashable` which means that it can be used as a key in a dictionary. One use case for this is storing meta information about properties in a dictionary. Here, we have a dictionary that maps from partial key paths to `String`. It stores two different keypaths (`username`, `age`) and their titles:\n\n``` Swift\nlet meta: [PartialKeyPath<User>: String] = [\n  \\User.username: \"Your Username\",\n  \\User.age: \"Your Age\"\n]\n```\n\nWe can now write a function `renderTitle` that will retrieve this meta information and print it out alongside the actual value:\n\n``` Swift\nfunc renderTitle(on: User, keyPath: AnyKeyPath) {\n  if let title = meta[keyPath] {\n    print(title, terminator: \": \")\n  }\n  print(on[keyPath: keyPath])\n}\n\nlet myUser = User(username: \"Jon\", age: 44)\n\nrenderTitle(on: myUser, keyPath: \\User.age)\n```\n\nThis would print `Your Age: 44`\n\nThis pattern can be used for many more situations. Whenever you have information about a type, you can utilize it to store the information. Another example would be input validation.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/status_codes.md":["2db487486c08dc2f",{"identifier":"52ff54f5","filename":"status_codes.md","info":{"title":"Status Codes","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-status-codes.html","content":"<h1>Status Codes</h1>\n<p>If you're working with an outside system which uses status codes (or\nerror codes) to convey information, like HTTP Status Codes, enums are\nobviously a great way to encode the information. <sup class=\"footnote-reference\"><a href=\"#7\">1</a></sup></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> HttpError: <span class=\"type\">String</span> {\n\n   <span class=\"keyword\">case</span> code400 = \\<span class=\"string\">\"Bad</span> <span class=\"type\">Request</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code401 = \\<span class=\"string\">\"Unauthorized</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code402 = \\<span class=\"string\">\"Payment</span> <span class=\"type\">Required</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code403 = \\<span class=\"string\">\"Forbidden</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> code404 = \\<span class=\"string\">\"Not</span> <span class=\"type\">Found</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Status Codes\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Status Codes\n\nIf you\\'re working with an outside system which uses status codes (or\nerror codes) to convey information, like HTTP Status Codes, enums are\nobviously a great way to encode the information. [^7]\n\n``` Swift\nenum HttpError: String {\n  case code400 = \"Bad Request\"\n  case code401 = \"Unauthorized\"\n  case code402 = \"Payment Required\"\n  case code403 = \"Forbidden\"\n  case code404 = \"Not Found\"\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/real_world_examples/word_frequencies.md":["839a8935c11615a6",{"identifier":"563aab3f","filename":"word_frequencies.md","info":{"title":"Word Frequencies","tags":["pattern matching","switch","compactMap","map","filter"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-word-frequencies.html","content":"<h1>Word Frequencies</h1>\n<p>We have a sequence of pairs, each representing a word and its frequency\nin some text. Our goal is to filter out those pairs whose frequency is\nbelow or above a certain threshold, and then only return the remaining\nwords, without their respective frequencies.</p>\n<p>Here're our words:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> wordFreqs = [(\\<span class=\"string\">\"k</span>\\<span class=\"string\">\"</span>, <span class=\"number\">5</span>), (\\<span class=\"string\">\"a</span>\\<span class=\"string\">\"</span>, <span class=\"number\">7</span>), (\\<span class=\"string\">\"b</span>\\<span class=\"string\">\"</span>, <span class=\"number\">3</span>)]\n</code></pre></code></pre>\n<p>A simple solution would be to model this with <a href=\"lnk::map-filter-reduce\"><code>map</code> and <code>filter</code></a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> res = wordFreqs.<span class=\"call\">filter</span>({ (e) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">if</span> e.<span class=\"number\">1</span> &gt; <span class=\"number\">3</span> {\n\n         <span class=\"keyword\">return true</span>\n\n     } <span class=\"keyword\">else</span> {\n\n         <span class=\"keyword\">return false</span>\n\n     }\n\n}).<span class=\"call\">map</span> { $0.<span class=\"number\">0</span> }\n\n<span class=\"call\">print</span>(res)\n</code></pre></code></pre>\n<p>However, with <code>compactMap</code> a map that only returns the non-nil elements, we\ncan improve a lot upon this solution. First and foremost, we can get rid\nof the <code>e.1</code> and instead have proper destructuring by utilizing (you\nguessed it) tuples. And then, we only need one call <code>compactMap</code> instead of\n<code>filter</code> and then <code>map</code> which adds unnecessary performance overhead.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> res = wordFreqs.<span class=\"call\">compactMap</span> { (e) -&gt; <span class=\"type\">String</span>? <span class=\"keyword\">in</span>\n\n     <span class=\"keyword\">switch</span> e {\n\n     <span class=\"keyword\">case let</span> (s, t) <span class=\"keyword\">where</span> t &gt; <span class=\"number\">3</span>: <span class=\"keyword\">return</span> s\n\n     <span class=\"keyword\">default</span>: <span class=\"keyword\">return nil</span>\n\n     }\n\n}\n\n<span class=\"call\">print</span>(res)\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Word Frequencies\"\ntags = [\"pattern matching\", \"switch\", \"compactMap\", \"map\", \"filter\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Word Frequencies\n\nWe have a sequence of pairs, each representing a word and its frequency\nin some text. Our goal is to filter out those pairs whose frequency is\nbelow or above a certain threshold, and then only return the remaining\nwords, without their respective frequencies.\n\nHere\\'re our words:\n\n``` Swift\nlet wordFreqs = [(\"k\", 5), (\"a\", 7), (\"b\", 3)]\n```\n\nA simple solution would be to model this with [`map` and `filter`](lnk::map-filter-reduce):\n\n``` Swift\nlet res = wordFreqs.filter({ (e) -> Bool in\n    if e.1 > 3 {\n        return true\n    } else {\n        return false\n    }\n}).map { $0.0 }\nprint(res)\n```\n\nHowever, with `compactMap` a map that only returns the non-nil elements, we\ncan improve a lot upon this solution. First and foremost, we can get rid\nof the `e.1` and instead have proper destructuring by utilizing (you\nguessed it) tuples. And then, we only need one call `compactMap` instead of\n`filter` and then `map` which adds unnecessary performance overhead.\n\n``` Swift\nlet res = wordFreqs.compactMap { (e) -> String? in\n    switch e {\n    case let (s, t) where t > 3: return s\n    default: return nil\n    }\n}\nprint(res)\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/partialkeypath.md":["e59cdace8484e15d",{"identifier":"b26abeb3","filename":"partialkeypath.md","info":{"title":"PartialKeyPath","tags":["keypath","partialkeypath","type-erase","erase"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-partialkeypath.html","content":"<h1>PartialKeyPath</h1>\n<p><code>PartialKeyPath</code> is a type-erased <code>KeyPath</code> that erases the <code>Value</code> type parameter.</p>\n<p>As we've seen in the previous chapter, sometimes you want to have a <code>KeyPath</code> that does not require a <code>Value</code> type parameter. That is, what the <code>PartialKeyPath</code> is for. Its type signature is <code>PartialKeyPath&lt;Root&gt;</code>. As you can see, there is no <code>Value</code> type anymore. This <code>KeyPath</code>, again, is read-only. However, it is very useful because it allows you to be much more flexible when storing keypaths in arrays or writing functions that accept keypaths. Here is a quick example:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Value would be `String`</span>\n\n<span class=\"keyword\">let</span> a: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">name</span>\n\n\n\n<span class=\"comment\">/// Value would be `Int`</span>\n\n<span class=\"keyword\">let</span> b: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">age</span>\n\n\n\n<span class=\"comment\">/// Value would be `Address`</span>\n\n<span class=\"keyword\">let</span> c: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt; = \\<span class=\"type\">User</span>.<span class=\"property\">address</span>\n</code></pre></code></pre>\n<p>See how these totally different types (<code>KeyPath&lt;User, String&gt;, KeyPath&lt;User, Int&gt;, ...</code>) are actually stored with the same type, just <code>PartialKeyPath&lt;User&gt;</code>. We type-erase the <code>Value</code> parameter.</p>\n<p>This is useful because it allows you to call the same function with different types of keypaths:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> acceptKeyPath(<span class=\"keyword\">_</span> keyPath: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">User</span>&gt;) {\n\n   ...\n\n}\n\n<span class=\"call\">acceptKeyPath</span>(\\<span class=\"type\">User</span>.<span class=\"property\">age</span>)\n\n<span class=\"call\">acceptKeyPath</span>(\\<span class=\"type\">User</span>.<span class=\"property\">username</span>)\n</code></pre></code></pre>\n<p>More importantly, it allows us to solve the issue we had with the <code>DebugPrinter</code> in the <a href=\"javascript:prev()\">previous code</a>. We can now implement is as follows:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">/// Dynamically define a debug description for an object</span>\n\n<span class=\"keyword\">class</span> DebugPrinter&lt;T&gt; <span class=\"keyword\">where</span> <span class=\"type\">T</span>: <span class=\"type\">AnyObject</span> {\n\n     <span class=\"keyword\">var</span> keyPaths: [(<span class=\"type\">String</span>?, <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">T</span>&gt;)] = []\n\n     <span class=\"keyword\">let</span> reference: <span class=\"type\">T</span>\n\n     <span class=\"keyword\">let</span> prefix: <span class=\"type\">String</span>\n\n\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> prefixString: <span class=\"type\">String</span>, for instance: <span class=\"type\">T</span>) {\n\n         reference = instance\n\n         prefix = prefixString\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> addLog(<span class=\"keyword\">_</span> path: <span class=\"type\">PartialKeyPath</span>&lt;<span class=\"type\">T</span>&gt;, prefix: <span class=\"type\">String</span>? = <span class=\"keyword\">nil</span>) {\n\n         keyPaths.<span class=\"call\">append</span>((prefix, path))\n\n     }\n\n\n\n     <span class=\"keyword\">func</span> log() {\n\n         <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>: \\<span class=\"string\">\"</span>)\n\n         <span class=\"keyword\">for</span> entry <span class=\"keyword\">in</span> keyPaths {\n\n           <span class=\"keyword\">if let</span> prefix = entry.<span class=\"number\">0</span> { <span class=\"call\">print</span>(prefix, terminator: \\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>) }\n\n           <span class=\"call\">print</span>(reference[keyPath: entry.<span class=\"number\">1</span>], terminator: \\<span class=\"string\">\"</span>, \\<span class=\"string\">\"</span>)\n\n         }\n\n     }\n\n}\n</code></pre></code></pre>\n<p>Just by replacing <code>KeyPath&lt;T, String&gt;</code> with <code>PartialKeyPath&lt;T&gt;</code> we could fix the issue with this code, and now it can be used with all types.</p>\n<p>Now, you're probably wondering whether there is a <code>KeyPath</code> type that also type-erases the <code>Root</code> type parameter, and in fact, there is! Next up, the appropriately named <code>AnyKeyPath</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"PartialKeyPath\"\ntags = [\"keypath\", \"partialkeypath\", \"type-erase\", \"erase\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# PartialKeyPath\n\n`PartialKeyPath` is a type-erased `KeyPath` that erases the `Value` type parameter.\n\nAs we've seen in the previous chapter, sometimes you want to have a `KeyPath` that does not require a `Value` type parameter. That is, what the `PartialKeyPath` is for. Its type signature is `PartialKeyPath<Root>`. As you can see, there is no `Value` type anymore. This `KeyPath`, again, is read-only. However, it is very useful because it allows you to be much more flexible when storing keypaths in arrays or writing functions that accept keypaths. Here is a quick example:\n\n``` Swift\n/// Value would be `String`\nlet a: PartialKeyPath<User> = \\User.name\n\n/// Value would be `Int`\nlet b: PartialKeyPath<User> = \\User.age\n\n/// Value would be `Address`\nlet c: PartialKeyPath<User> = \\User.address\n```\n\nSee how these totally different types (`KeyPath<User, String>, KeyPath<User, Int>, ...`) are actually stored with the same type, just `PartialKeyPath<User>`. We type-erase the `Value` parameter.\n\nThis is useful because it allows you to call the same function with different types of keypaths:\n\n``` Swift\nfunc acceptKeyPath(_ keyPath: PartialKeyPath<User>) {\n  ...\n}\nacceptKeyPath(\\User.age)\nacceptKeyPath(\\User.username)\n```\n\nMore importantly, it allows us to solve the issue we had with the `DebugPrinter` in the [previous code](javascript:prev()). We can now implement is as follows:\n\n``` Swift\n/// Dynamically define a debug description for an object\nclass DebugPrinter<T> where T: AnyObject {\n    var keyPaths: [(String?, PartialKeyPath<T>)] = []\n    let reference: T\n    let prefix: String\n\n    init(_ prefixString: String, for instance: T) {\n        reference = instance\n        prefix = prefixString\n    }\n\n    func addLog(_ path: PartialKeyPath<T>, prefix: String? = nil) {\n        keyPaths.append((prefix, path))\n    }\n\n    func log() {\n        print(prefix, terminator: \": \")\n        for entry in keyPaths {\n          if let prefix = entry.0 { print(prefix, terminator: \"\") }\n          print(reference[keyPath: entry.1], terminator: \", \")\n        }\n    }\n}\n```\n\nJust by replacing `KeyPath<T, String>` with `PartialKeyPath<T>` we could fix the issue with this code, and now it can be used with all types.\n\nNow, you're probably wondering whether there is a `KeyPath` type that also type-erases the `Root` type parameter, and in fact, there is! Next up, the appropriately named `AnyKeyPath`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/comparing_enums.md":["063e35e94dc48948",{"identifier":"87f6d616","filename":"comparing_enums.md","info":{"title":"Comparing Enums","tags":["enum","equatable","associated"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"new":"3/2019","swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-comparing-enums.html","content":"<h1>Comparing Enums</h1>\n<p>Just like need to compare strings (<code>&quot;world&quot; == &quot;hello&quot;</code>) or numbers you sometimes also need to compare enums. For very simple ones, like the following, this is easy as Swift takes care of it:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Toggle {\n\n   <span class=\"keyword\">case</span> on, off\n\n}\n\n\n\n<span class=\"type\">Toggle</span>.<span class=\"property\">on</span> == <span class=\"type\">Toggle</span>.<span class=\"property\">off</span>\n</code></pre></code></pre>\n<p>But what if you have a more complex <code>enum</code> with <code>associated values</code> like this one?</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character {\n\n   <span class=\"keyword\">case</span> warrior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>, strength: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, magic: <span class=\"type\">Int</span>, spells: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>If you'd try to compare to instances of <code>Character</code> Swift would complain. By default, it doesn't know how to compare <code>enum</code> types that have <code>associated values</code>. However, you can explicitly tell Swift to just compare all the values of each <code>case</code> and if they're the same, then the types are <code>equal</code>. To do that, you'd just add an empty conformance to the <code>Equatable</code> protocol:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Character: <span class=\"type\">Equatable</span> {\n\n   <span class=\"keyword\">case</span> warrior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>, strength: <span class=\"type\">Int</span>)\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, magic: <span class=\"type\">Int</span>, spells: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>Just this one addition <code>Equatable</code> will allow you to compare your types. This only works if all the values in your cases are also <code>Equatable</code>. This works in our example as <code>Int</code>, <code>String</code> and arrays of <code>String</code> are <code>Equatable</code> by default.</p>\n<p>If you have a custom type that doesn't conform to <code>Equatable</code>, the above will not work:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Weapon { \n\n   <span class=\"keyword\">let</span> name: <span class=\"type\">String</span> \n\n}\n\n\n\n<span class=\"keyword\">enum</span> Character: <span class=\"type\">Equatable</span> {\n\n   <span class=\"keyword\">case</span> warrior(name: <span class=\"type\">String</span>, level: <span class=\"type\">Int</span>, strength: <span class=\"type\">Int</span>, weapon: <span class=\"type\">Weapon</span>)\n\n   <span class=\"keyword\">case</span> wizard(name: <span class=\"type\">String</span>, magic: <span class=\"type\">Int</span>, spells: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>In this case, Swift will complain that <code>Character</code> does not conform to <code>Equatable</code>. So the solution here is to also conform <code>Weapon</code> to <code>Equatable</code>.</p>\n<p>If that is not an option, you an always implement a custom <code>Equatable</code> conformance:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Not Equatable Stock</span>\n\n<span class=\"keyword\">struct</span> Stock { ... }\n\n<span class=\"keyword\">enum</span> Trade {\n\n     <span class=\"keyword\">case</span> buy(stock: <span class=\"type\">Stock</span>, amount: <span class=\"type\">Int</span>)\n\n     <span class=\"keyword\">case</span> sell(stock: <span class=\"type\">Stock</span>, amount: <span class=\"type\">Int</span>)\n\n}\n\n<span class=\"keyword\">func</span> ==(lhs: <span class=\"type\">Trade</span>, rhs: <span class=\"type\">Trade</span>) -&gt; <span class=\"type\">Bool</span> {\n\n    <span class=\"keyword\">switch</span> (lhs, rhs) {\n\n    <span class=\"keyword\">case let</span> (.<span class=\"call\">buy</span>(stock1, amount1), .<span class=\"dotAccess\">buy</span>(stock2, amount2))\n\n          <span class=\"keyword\">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:\n\n          <span class=\"keyword\">return true</span>\n\n    <span class=\"keyword\">case let</span> (.<span class=\"call\">sell</span>(stock1, amount1), .<span class=\"dotAccess\">sell</span>(stock2, amount2))\n\n          <span class=\"keyword\">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:\n\n          <span class=\"keyword\">return true</span>\n\n    <span class=\"keyword\">default</span>: <span class=\"keyword\">return false</span>\n\n    }\n\n}\n</code></pre></code></pre>\n<p>As you can see, we're comparing the two possible <code>enum cases</code> via a\nswitch, and only if the cases match (i.e. .buy &amp; .buy) will we compare\nthe actual associated values.</p>\n","raw_content":"[frontMatter]\ntitle = \"Comparing Enums\"\ntags = [\"enum\", \"equatable\", \"associated\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\nnew = \"3/2019\"\n---\n\n# Comparing Enums\n\nJust like need to compare strings (`\"world\" == \"hello\"`) or numbers you sometimes also need to compare enums. For very simple ones, like the following, this is easy as Swift takes care of it:\n\n``` Swift\nenum Toggle {\n  case on, off\n}\n\nToggle.on == Toggle.off\n```\n\nBut what if you have a more complex `enum` with `associated values` like this one?\n\n``` Swift\nenum Character {\n  case warrior(name: String, level: Int, strength: Int)\n  case wizard(name: String, magic: Int, spells: [String])\n}\n```\n\nIf you'd try to compare to instances of `Character` Swift would complain. By default, it doesn't know how to compare `enum` types that have `associated values`. However, you can explicitly tell Swift to just compare all the values of each `case` and if they're the same, then the types are `equal`. To do that, you'd just add an empty conformance to the `Equatable` protocol:\n\n``` Swift\nenum Character: Equatable {\n  case warrior(name: String, level: Int, strength: Int)\n  case wizard(name: String, magic: Int, spells: [String])\n}\n```\n\nJust this one addition `Equatable` will allow you to compare your types. This only works if all the values in your cases are also `Equatable`. This works in our example as `Int`, `String` and arrays of `String` are `Equatable` by default.\n\nIf you have a custom type that doesn't conform to `Equatable`, the above will not work:\n\n``` Swift\nstruct Weapon { \n  let name: String \n}\n\nenum Character: Equatable {\n  case warrior(name: String, level: Int, strength: Int, weapon: Weapon)\n  case wizard(name: String, magic: Int, spells: [String])\n}\n```\n\nIn this case, Swift will complain that `Character` does not conform to `Equatable`. So the solution here is to also conform `Weapon` to `Equatable`. \n\nIf that is not an option, you an always implement a custom `Equatable` conformance:\n\n``` Swift\n// Not Equatable Stock\nstruct Stock { ... }\nenum Trade {\n    case buy(stock: Stock, amount: Int)\n    case sell(stock: Stock, amount: Int)\n}\nfunc ==(lhs: Trade, rhs: Trade) -> Bool {\n   switch (lhs, rhs) {\n   case let (.buy(stock1, amount1), .buy(stock2, amount2))\n         where stock1 == stock2 && amount1 == amount2:\n         return true\n   case let (.sell(stock1, amount1), .sell(stock2, amount2))\n         where stock1 == stock2 && amount1 == amount2:\n         return true\n   default: return false\n   }\n}\n```\n\nAs you can see, we\\'re comparing the two possible `enum cases` via a\nswitch, and only if the cases match (i.e. .buy & .buy) will we compare\nthe actual associated values.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/uikit_identifiers.md":["22f57eb14b8ad027",{"identifier":"1cc248af","filename":"uikit_identifiers.md","info":{"title":"UIKit Identifiers","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-uikit-identifiers.html","content":"<h1>UIKit Identifiers</h1>\n<p>Enums can be used to map reuse identifiers or storyboard identifiers\nfrom stringly typed information to something the type checker can\nunderstand. Imagine a UITableView with different prototype cells:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> CellType: <span class=\"type\">String</span> {\n\n     <span class=\"keyword\">case</span> buttonValueCell = \\<span class=\"string\">\"ButtonValueCell</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> unitEditCell = \\<span class=\"string\">\"UnitEditCell</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> labelCell = \\<span class=\"string\">\"LabelCell</span>\\<span class=\"string\">\"</span>\n\n     <span class=\"keyword\">case</span> resultLabelCell = \\<span class=\"string\">\"ResultLabelCell</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"UIKit Identifiers\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# UIKit Identifiers\n\nEnums can be used to map reuse identifiers or storyboard identifiers\nfrom stringly typed information to something the type checker can\nunderstand. Imagine a UITableView with different prototype cells:\n\n``` Swift\nenum CellType: String {\n    case buttonValueCell = \"ButtonValueCell\"\n    case unitEditCell = \"UnitEditCell\"\n    case labelCell = \"LabelCell\"\n    case resultLabelCell = \"ResultLabelCell\"\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/finishing_words.md":["b0823382a3d82bfd",{"identifier":"ed9d80a7","filename":"finishing_words.md","info":{"title":"Finishing Words","tags":["pattern matching","switch"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-finishing-words.html","content":"<h1>Finishing Words</h1>\n<p>Pattern Matching is a really powerful feature of Swift. It is one of the defining features that makes Swift Code so much nicer to read than what you'd write in Objective-C. It is also deeply integrated into the language as it can be used with <code>let</code>, <code>guard</code>, <code>for</code>, <code>if</code>, and <code>switch</code>. It also allows adding <code>where</code> clauses, using <code>is</code> or <code>as</code> for type casts, lets you extend it via <code>~=</code> and much more.</p>\n","raw_content":"[frontMatter]\ntitle = \"Finishing Words\"\ntags = [\"pattern matching\", \"switch\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Finishing Words\n\nPattern Matching is a really powerful feature of Swift. It is one of the defining features that makes Swift Code so much nicer to read than what you'd write in Objective-C. It is also deeply integrated into the language as it can be used with `let`, `guard`, `for`, `if`, and `switch`. It also allows adding `where` clauses, using `is` or `as` for type casts, lets you extend it via `~=` and much more. \n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/stringly_typed_code.md":["2f2c4c75d6e05b36",{"identifier":"b24de7cb","filename":"stringly_typed_code.md","info":{"title":"Stringly Typed Code","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-stringly-typed-code.html","content":"<h1>Stringly Typed Code</h1>\n<p>In bigger Xcode projects, you're quickly accumulating lots of resources\nwhich are accessed by string. We've already mentioned reuse identifiers\nand storyboard identifiers above, but there's also: Images, Segues,\nNibs, Fonts, and other resources. Oftentimes, those resources can be\ngrouped into several distinct sets. If that's the case, a <code>String</code>\ntyped <code>enum</code> is a good way of having the compiler check this for you.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> DetailViewImages: <span class=\"type\">String</span> {\n\n   <span class=\"keyword\">case</span> background = \\<span class=\"string\">\"bg1</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> sidebar = \\<span class=\"string\">\"sbg</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> actionButton1 = \\<span class=\"string\">\"btn1_1</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n   <span class=\"keyword\">case</span> actionButton2 = \\<span class=\"string\">\"btn2_1</span>.<span class=\"property\">png</span>\\<span class=\"string\">\"</span>\n\n}\n</code></pre></code></pre>\n<p>For iOS users, <a href=\"https://github.com/mac-cain13/R.swift\">there's also R.swift which auto generates <code>structs</code> for\nmost of those use cases.</a>\nSometimes you may need more control though (or you may be on a Mac <sup class=\"footnote-reference\"><a href=\"#8\">1</a></sup>)</p>\n","raw_content":"[frontMatter]\ntitle = \"Stringly Typed Code\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Stringly Typed Code\n\nIn bigger Xcode projects, you\\'re quickly accumulating lots of resources\nwhich are accessed by string. We\\'ve already mentioned reuse identifiers\nand storyboard identifiers above, but there\\'s also: Images, Segues,\nNibs, Fonts, and other resources. Oftentimes, those resources can be\ngrouped into several distinct sets. If that\\'s the case, a `String`\ntyped `enum` is a good way of having the compiler check this for you.\n\n``` Swift\nenum DetailViewImages: String {\n  case background = \"bg1.png\"\n  case sidebar = \"sbg.png\"\n  case actionButton1 = \"btn1_1.png\"\n  case actionButton2 = \"btn2_1.png\"\n}\n```\n\nFor iOS users, [there\\'s also R.swift which auto generates `structs` for\nmost of those use cases.](https://github.com/mac-cain13/R.swift)\nSometimes you may need more control though (or you may be on a Mac [^8])\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/language_support/intro.md":["3b698c7af44dbae1",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Language Support","tags":["pattern matching","switch"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-language-support.html","content":"<h1>Patterns with other Keywords</h1>\n<p>The Swift documentation points out, that not all patterns can be used\nwith the <code>if</code>, <code>for</code> or the <code>guard</code> statement. However, the docs seem to\nbe outdated. All 7 patterns work for all three keywords.</p>\n<p>As a shorter example, see the <strong>Value Binding</strong>, <strong>Tuple</strong>, and <strong>Type\nCasting</strong> pattern used for all three keywords in one example:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// This is just a collection of keywords that compiles. This code makes no sense</span>\n\n<span class=\"keyword\">func</span> valueTupleType(a: (<span class=\"type\">Int</span>, <span class=\"type\">Any</span>)) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"comment\">// guard case Example</span>\n\n     <span class=\"keyword\">guard case let</span> (x, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>) = a <span class=\"keyword\">else</span> { <span class=\"keyword\">return false</span>}\n\n     <span class=\"call\">print</span>(x)\n\n\n\n     <span class=\"comment\">// for case example</span>\n\n     <span class=\"keyword\">for case let</span> (a, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>) <span class=\"keyword\">in</span> [a] {\n\n         <span class=\"call\">print</span>(a)\n\n     }\n\n\n\n     <span class=\"comment\">// if case example</span>\n\n     <span class=\"keyword\">if case let</span> (x, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>) = a {\n\n        <span class=\"call\">print</span>(\\<span class=\"string\">\"if</span>\\<span class=\"string\">\"</span>, x)\n\n     }\n\n\n\n     <span class=\"comment\">// switch case example</span>\n\n     <span class=\"keyword\">switch</span> a {\n\n     <span class=\"keyword\">case let</span> (a, <span class=\"keyword\">_ as</span> <span class=\"type\">String</span>):\n\n         <span class=\"call\">print</span>(a)\n\n         <span class=\"keyword\">return true</span>\n\n     <span class=\"keyword\">default</span>: <span class=\"keyword\">return false</span>\n\n     }\n\n}\n</code></pre></code></pre>\n<p>With this in mind, we will have a short look at each of those keywords\nin detail.</p>\n","raw_content":"[frontMatter]\ntitle = \"Language Support\"\ntags = [\"pattern matching\", \"switch\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Patterns with other Keywords\n\nThe Swift documentation points out, that not all patterns can be used\nwith the `if`, `for` or the `guard` statement. However, the docs seem to\nbe outdated. All 7 patterns work for all three keywords.\n\nAs a shorter example, see the **Value Binding**, **Tuple**, and **Type\nCasting** pattern used for all three keywords in one example:\n\n``` Swift\n// This is just a collection of keywords that compiles. This code makes no sense\nfunc valueTupleType(a: (Int, Any)) -> Bool {\n    // guard case Example\n    guard case let (x, _ as String) = a else { return false}\n    print(x)\n\n    // for case example\n    for case let (a, _ as String) in [a] {\n        print(a)\n    }\n\n    // if case example\n    if case let (x, _ as String) = a {\n       print(\"if\", x)\n    }\n\n    // switch case example\n    switch a {\n    case let (a, _ as String):\n        print(a)\n        return true\n    default: return false\n    }\n}\n```\n\nWith this in mind, we will have a short look at each of those keywords\nin detail.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/example/implementation.md":["dea59362cebff641",{"identifier":"9f74c1a0","filename":"implementation.md","info":{"title":"Structs to Core Data","tags":["reflection","coredata"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-structs-to-core-data.html","content":"<h1>Structs to Core Data</h1>\n<p>Remember, we have a <code>struct</code> and want to automatically convert this to\n<code>NSManagedObject</code> (<strong>Core Data</strong>).</p>\n<p>If we want to support different <code>structs</code> or even types, we can\nimplement this as a protocol and then make sure our desired types\nconform to it. So which functionality should our imaginary protocol\noffer?</p>\n<ul>\n<li>First, it should allow us to define the name of the <strong>Core Data\nEntity</strong> that we want to create</li>\n<li>Second, it should have a way to tell it to convert itself to an\n<code>NSManagedObject</code></li>\n</ul>\n<p>Our <code>protocol</code> could look something like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> StructDecoder {\n\n     <span class=\"comment\">// The name of our Core Data Entity</span>\n\n     <span class=\"keyword\">static var</span> <span class=\"type\">EntityName</span>: <span class=\"type\">String</span> { <span class=\"keyword\">get</span> }\n\n     <span class=\"comment\">// Return an NSManagedObject with our properties set</span>\n\n     <span class=\"keyword\">func</span> toCoreData(context: <span class=\"type\">NSManagedObjectContext</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">NSManagedObject</span>\n\n}\n</code></pre></code></pre>\n<p>The <code>toCoreData</code> method uses exception handling to\nthrow an error, if the conversion fails. There're several possible\nerror cases, which are outlined in the <code>ErrorType</code> <code>enum</code> below:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> SerializationError: <span class=\"type\">ErrorType</span> {\n\n     <span class=\"comment\">// We only support structs</span>\n\n     <span class=\"keyword\">case</span> structRequired\n\n     <span class=\"comment\">// The entity does not exist in the Core Data Model</span>\n\n     <span class=\"keyword\">case</span> unknownEntity(name: <span class=\"type\">String</span>)\n\n     <span class=\"comment\">// The provided type cannot be stored in core data</span>\n\n     <span class=\"keyword\">case</span> unsupportedSubType(label: <span class=\"type\">String</span>?)\n\n}\n</code></pre></code></pre>\n<p>We have three error cases that our conversion has to look out for. The\nfirst one is that we're trying to apply it to something that is not a\n<code>struct</code>. The second is that the <code>entity</code> we're trying to create does\nnot exist in our Core Data Model. The third is that we're trying to\nwrite something into Core Data which can not be stored there (i.e. an\n<code>enum</code>).</p>\n<p>Let's create a struct and add protocol conformance:</p>\n<h2>Bookmark struct</h2>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Bookmark {\n\n    <span class=\"keyword\">let</span> title: <span class=\"type\">String</span>\n\n    <span class=\"keyword\">let</span> url: <span class=\"type\">URL</span>\n\n    <span class=\"keyword\">let</span> pagerank: <span class=\"type\">Int</span>\n\n    <span class=\"keyword\">let</span> created: <span class=\"type\">Date</span>\n\n}\n</code></pre></code></pre>\n<p>Next, we'd like to implement the <code>toCoreData</code> method.</p>\n<h2>Protocol Extension</h2>\n<p>We could, of course, write this anew for each <code>struct</code>, but that's a\nlot of work. Structs do not support inheritance, so we can't use a base\nclass. However, we can use a <code>protocol extension</code> to extend to all\nconforming <code>structs</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">StructDecoder</span> {\n\n     <span class=\"keyword\">func</span> toCoreData(context: <span class=\"type\">NSManagedObjectContext</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">NSManagedObject</span> {\n\n     }\n\n}\n</code></pre></code></pre>\n<p>As this extension is being applied to our conforming <code>structs</code>, this\nmethod will be called in the structs context. Thus, within the\nextension, <code>self</code> refers to the <code>struct</code> which we'd like to analyze.</p>\n<p>So, the first step for us is to create an <code>NSManagedObject</code> into which\nwe can then write the values from our <code>Bookmark struct</code>. How do we do\nthat?</p>\n<h2>A Bit of Core Data</h2>\n<p>Core Data is a tad verbose, so in order to create an object, we need the\nfollowing steps:</p>\n<ol>\n<li>Get the name of the entity which we'd like to create (as a string)</li>\n<li>Take the <code>NSManagedObjectContext</code>, and create an\n<code>NSEntityDescription</code> for our entity</li>\n<li>Create an <code>NSManagedObject</code> with this information.</li>\n</ol>\n<p>When we implement this, we have:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Get the name of the Core Data Entity</span>\n\n<span class=\"keyword\">let</span> entityName = <span class=\"call\">type</span>(of: <span class=\"keyword\">self</span>).<span class=\"type\">EntityName</span>\n\n\n\n<span class=\"comment\">// Create the Entity Description</span>\n\n<span class=\"comment\">// The entity may not exist, so we're using a 'guard let' to throw</span> \n\n<span class=\"comment\">// an error in case it does not exist in our core data model</span>\n\n<span class=\"keyword\">guard let</span> desc = <span class=\"type\">NSEntityDescription</span>.<span class=\"call\">entityForName</span>(entityName, inManagedObjectContext: context)\n\n     <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"call\">unknownEntity</span>(name: entityName) }\n\n\n\n<span class=\"comment\">// Create the NSManagedObject</span>\n\n<span class=\"keyword\">let</span> managedObject = <span class=\"type\">NSManagedObject</span>(entity: desc, insertIntoManagedObjectContext: context)\n</code></pre></code></pre>\n<h2>Implementing the Reflection</h2>\n<p>Next up, we'd like to use the Reflection API to read our bookmarks\nproperties and write it into our <code>NSManagedObject</code> instance.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Create a Mirror</span>\n\n<span class=\"keyword\">let</span> mirror = <span class=\"type\">Mirror</span>(reflecting: <span class=\"keyword\">self</span>)\n\n\n\n<span class=\"comment\">// Make sure we're analyzing a struct</span>\n\n<span class=\"keyword\">guard</span> mirror.<span class=\"property\">displayStyle</span> == .<span class=\"dotAccess\">struct</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">SerializationError</span>.<span class=\"property\">structRequired</span> }\n</code></pre></code></pre>\n<p>We're making sure that this is indeed a <code>struct</code> by testing the\n<code>displayStyle</code> property.</p>\n<p>So now we have a <code>Mirror</code> that allows us to read properties, and we have\na <code>NSManagedObject</code> which we can set properties on. As the mirror offers\na way to read all children, we can iterate over them and set the values.\nSo let's do that.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for case let</span> (label?, value) <span class=\"keyword\">in</span> mirror.<span class=\"property\">children</span> {\n\n     managedObject.<span class=\"call\">setValue</span>(value, forKey: label)\n\n}\n</code></pre></code></pre>\n<p>Now, the only thing left to do is return our <code>NSManagedObject</code>. The\ncomplete code looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">extension</span> <span class=\"type\">StructDecoder</span> {\n\n     <span class=\"keyword\">func</span> toCoreData(context: <span class=\"type\">NSManagedObjectContext</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">NSManagedObject</span> {\n\n         <span class=\"keyword\">let</span> entityName = <span class=\"call\">type</span>(of:<span class=\"keyword\">self</span>).<span class=\"type\">EntityName</span>\n\n\n\n         <span class=\"comment\">// Create the Entity Description</span>\n\n         <span class=\"keyword\">guard let</span> desc = <span class=\"type\">NSEntityDescription</span>.<span class=\"call\">entityForName</span>(entityName, inManagedObjectContext: context)\n\n             <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">UnknownEntity</span>(name: entityName) }\n\n\n\n         <span class=\"comment\">// Create the NSManagedObject</span>\n\n         <span class=\"keyword\">let</span> managedObject = <span class=\"type\">NSManagedObject</span>(entity: desc, insertIntoManagedObjectContext: context)\n\n\n\n         <span class=\"comment\">// Create a Mirror</span>\n\n         <span class=\"keyword\">let</span> mirror = <span class=\"type\">Mirror</span>(reflecting: <span class=\"keyword\">self</span>)\n\n\n\n         <span class=\"comment\">// Make sure we're analyzing a struct</span>\n\n         <span class=\"keyword\">guard</span> mirror.<span class=\"property\">displayStyle</span> == .<span class=\"dotAccess\">Struct</span> <span class=\"keyword\">else</span> { <span class=\"keyword\">throw</span> <span class=\"type\">SerializationError</span>.<span class=\"property\">structRequired</span> }\n\n\n\n         <span class=\"keyword\">for case let</span> (label?, anyValue) <span class=\"keyword\">in</span> mirror.<span class=\"property\">children</span> {\n\n             managedObject.<span class=\"call\">setValue</span>(anyValue, forKey: label)\n\n         }\n\n\n\n         <span class=\"keyword\">return</span> managedObject\n\n     }\n\n}\n</code></pre></code></pre>\n<p>That's it. We're converting our <code>struct</code> to <code>NSManagedObject</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Structs to Core Data\"\ntags = [\"reflection\", \"coredata\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Structs to Core Data\n\nRemember, we have a `struct` and want to automatically convert this to\n`NSManagedObject` (**Core Data**).\n\nIf we want to support different `structs` or even types, we can\nimplement this as a protocol and then make sure our desired types\nconform to it. So which functionality should our imaginary protocol\noffer?\n\n-   First, it should allow us to define the name of the **Core Data\n    Entity** that we want to create\n-   Second, it should have a way to tell it to convert itself to an\n    `NSManagedObject`\n\nOur `protocol` could look something like this:\n\n``` Swift\nprotocol StructDecoder {\n    // The name of our Core Data Entity\n    static var EntityName: String { get }\n    // Return an NSManagedObject with our properties set\n    func toCoreData(context: NSManagedObjectContext) throws -> NSManagedObject\n}\n```\n\nThe `toCoreData` method uses exception handling to\nthrow an error, if the conversion fails. There\\'re several possible\nerror cases, which are outlined in the `ErrorType` `enum` below:\n\n``` Swift\nenum SerializationError: ErrorType {\n    // We only support structs\n    case structRequired\n    // The entity does not exist in the Core Data Model\n    case unknownEntity(name: String)\n    // The provided type cannot be stored in core data\n    case unsupportedSubType(label: String?)\n}\n```\n\nWe have three error cases that our conversion has to look out for. The\nfirst one is that we\\'re trying to apply it to something that is not a\n`struct`. The second is that the `entity` we\\'re trying to create does\nnot exist in our Core Data Model. The third is that we\\'re trying to\nwrite something into Core Data which can not be stored there (i.e. an\n`enum`).\n\nLet\\'s create a struct and add protocol conformance:\n\n## Bookmark struct\n\n``` Swift\nstruct Bookmark {\n   let title: String\n   let url: URL\n   let pagerank: Int\n   let created: Date\n}\n```\n\nNext, we\\'d like to implement the `toCoreData` method.\n\n## Protocol Extension\n\nWe could, of course, write this anew for each `struct`, but that\\'s a\nlot of work. Structs do not support inheritance, so we can\\'t use a base\nclass. However, we can use a `protocol extension` to extend to all\nconforming `structs`:\n\n``` Swift\nextension StructDecoder {\n    func toCoreData(context: NSManagedObjectContext) throws -> NSManagedObject {\n    }\n}\n```\n\nAs this extension is being applied to our conforming `structs`, this\nmethod will be called in the structs context. Thus, within the\nextension, `self` refers to the `struct` which we\\'d like to analyze.\n\nSo, the first step for us is to create an `NSManagedObject` into which\nwe can then write the values from our `Bookmark struct`. How do we do\nthat?\n\n## A Bit of Core Data\n\nCore Data is a tad verbose, so in order to create an object, we need the\nfollowing steps:\n\n1.  Get the name of the entity which we\\'d like to create (as a string)\n2.  Take the `NSManagedObjectContext`, and create an\n    `NSEntityDescription` for our entity\n3.  Create an `NSManagedObject` with this information.\n\nWhen we implement this, we have:\n\n``` Swift\n// Get the name of the Core Data Entity\nlet entityName = type(of: self).EntityName\n\n// Create the Entity Description\n// The entity may not exist, so we're using a 'guard let' to throw \n// an error in case it does not exist in our core data model\nguard let desc = NSEntityDescription.entityForName(entityName, inManagedObjectContext: context)\n    else { throw unknownEntity(name: entityName) }\n\n// Create the NSManagedObject\nlet managedObject = NSManagedObject(entity: desc, insertIntoManagedObjectContext: context)\n```\n\n## Implementing the Reflection\n\nNext up, we\\'d like to use the Reflection API to read our bookmarks\nproperties and write it into our `NSManagedObject` instance.\n\n``` Swift\n// Create a Mirror\nlet mirror = Mirror(reflecting: self)\n\n// Make sure we're analyzing a struct\nguard mirror.displayStyle == .struct else { throw SerializationError.structRequired }\n```\n\nWe\\'re making sure that this is indeed a `struct` by testing the\n`displayStyle` property.\n\nSo now we have a `Mirror` that allows us to read properties, and we have\na `NSManagedObject` which we can set properties on. As the mirror offers\na way to read all children, we can iterate over them and set the values.\nSo let\\'s do that.\n\n``` Swift\nfor case let (label?, value) in mirror.children {\n    managedObject.setValue(value, forKey: label)\n}\n```\n\nNow, the only thing left to do is return our `NSManagedObject`. The\ncomplete code looks like this:\n\n``` Swift\nextension StructDecoder {\n    func toCoreData(context: NSManagedObjectContext) throws -> NSManagedObject {\n        let entityName = type(of:self).EntityName\n\n        // Create the Entity Description\n        guard let desc = NSEntityDescription.entityForName(entityName, inManagedObjectContext: context)\n            else { throw UnknownEntity(name: entityName) }\n\n        // Create the NSManagedObject\n        let managedObject = NSManagedObject(entity: desc, insertIntoManagedObjectContext: context)\n\n        // Create a Mirror\n        let mirror = Mirror(reflecting: self)\n\n        // Make sure we're analyzing a struct\n        guard mirror.displayStyle == .Struct else { throw SerializationError.structRequired }\n\n        for case let (label?, anyValue) in mirror.children {\n            managedObject.setValue(anyValue, forKey: label)\n        }\n\n        return managedObject\n    }\n}\n```\n\nThat\\'s it. We\\'re converting our `struct` to `NSManagedObject`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/settings.md":["7718b56dc2d42342",{"identifier":"4159cf65","filename":"settings.md","info":{"title":"Settings","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-settings.html","content":"<h1>Settings</h1>\n<p><a href=\"http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign%3DSwift%252BSandbox&amp;utm_medium%3Demail&amp;utm_source%3DSwift_Sandbox_12\">This is a very, very smart solution that Erica Sadun came up\nwith</a>.\nBasically whenever you'd use a dictionary of attribute keys as a way to\nconfigure an item, you'd instead use a <code>Set</code> of enums with associated\nvalues. That way, the type checker can confirm that your configuration\nvalues are of the correct type.</p>\n<p><a href=\"http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign%3DSwift%252BSandbox&amp;utm_medium%3Demail&amp;utm_source%3DSwift_Sandbox_12\">For more details, and proper examples, check out her original blog\npost.</a></p>\n","raw_content":"[frontMatter]\ntitle = \"Settings\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Settings\n\n[This is a very, very smart solution that Erica Sadun came up\nwith](http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign%3DSwift%252BSandbox&utm_medium%3Demail&utm_source%3DSwift_Sandbox_12).\nBasically whenever you\\'d use a dictionary of attribute keys as a way to\nconfigure an item, you\\'d instead use a `Set` of enums with associated\nvalues. That way, the type checker can confirm that your configuration\nvalues are of the correct type.\n\n[For more details, and proper examples, check out her original blog\npost.](http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign%3DSwift%252BSandbox&utm_medium%3Demail&utm_source%3DSwift_Sandbox_12)\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/recursive_or_indirect_types.md":["5f7eaf219ea2bf8a",{"identifier":"a7e3a6aa","filename":"recursive_or_indirect_types.md","info":{"title":"Recursive / Indirect Types","tags":["enum","indirect"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-recursive-indirect-types.html","content":"<h1>Recursive / Indirect Types</h1>\n<p>Indirect types allow\nyou to define enums where the associated value of a <code>case</code> is the very\nsame enum again.</p>\n<p>As an example, consider that you want to define a file\nsystem representations with files and folders containing files. If\n<strong>File</strong> and <strong>Folder</strong> were enum cases, then the <strong>Folder</strong> case would\nneed to have an array of <strong>File</strong> cases as it's <code>associated value</code>. Since\nthis is a recursive operation, the compiler has to make special\npreparations for it. Quoting from the Swift documentation:</p>\n<blockquote>\n<p>Enums and cases can be marked indirect, which causes the associated\nvalue for the enum to be stored indirectly, allowing for recursive\ndata structures to be defined.</p>\n</blockquote>\n<p>So to implement our <strong>FileNode</strong> <code>enum</code>, we'd have to write it like\nthis:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> FileNode {\n\n   <span class=\"keyword\">case</span> file(name: <span class=\"type\">String</span>)\n\n   <span class=\"keyword\">indirect case</span> folder(name: <span class=\"type\">String</span>, files: [<span class=\"type\">FileNode</span>])\n\n}\n</code></pre></code></pre>\n<p>The <code>indirect</code> keyword tells the compiler to handle this <code>enum case</code>\nindirectly. You can also add the keyword for the whole enum. <a href=\"http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/\">As an\nexample imagine mapping a binary\ntree</a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">indirect enum</span> Tree&lt;Element: <span class=\"type\">Comparable</span>&gt; {\n\n     <span class=\"keyword\">case</span> empty\n\n     <span class=\"keyword\">case</span> node(<span class=\"type\">Tree</span>&lt;<span class=\"type\">Element</span>&gt;,<span class=\"type\">Element</span>,<span class=\"type\">Tree</span>&lt;<span class=\"type\">Element</span>&gt;)\n\n}\n</code></pre></code></pre>\n<p>This is a very powerful feature that allows you to map complex\nrelationships in a very clean way with an enum.</p>\n","raw_content":"[frontMatter]\ntitle = \"Recursive / Indirect Types\"\ntags = [\"enum\", \"indirect\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Recursive / Indirect Types\n\nIndirect types allow\nyou to define enums where the associated value of a `case` is the very\nsame enum again. \n\nAs an example, consider that you want to define a file\nsystem representations with files and folders containing files. If\n**File** and **Folder** were enum cases, then the **Folder** case would\nneed to have an array of **File** cases as it\\'s `associated value`. Since\nthis is a recursive operation, the compiler has to make special\npreparations for it. Quoting from the Swift documentation:\n\n> Enums and cases can be marked indirect, which causes the associated\n> value for the enum to be stored indirectly, allowing for recursive\n> data structures to be defined.\n\nSo to implement our **FileNode** `enum`, we\\'d have to write it like\nthis:\n\n``` Swift\nenum FileNode {\n  case file(name: String)\n  indirect case folder(name: String, files: [FileNode])\n}\n```\n\nThe `indirect` keyword tells the compiler to handle this `enum case`\nindirectly. You can also add the keyword for the whole enum. [As an\nexample imagine mapping a binary\ntree](http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/):\n\n``` Swift\nindirect enum Tree<Element: Comparable> {\n    case empty\n    case node(Tree<Element>,Element,Tree<Element>)\n}\n```\n\nThis is a very powerful feature that allows you to map complex\nrelationships in a very clean way with an enum.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/intro/generic_types.md":["5044dbb1fca592a7",{"identifier":"efbca4fb","filename":"generic_types.md","info":{"title":"Generic Types","tags":["keypath","root","value"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-generic-types.html","content":"<h1>Generic Types</h1>\n<p>We don't always have to spell out the two generic types <code>Root</code> and <code>Value</code>. We can, for example, write a generic function that works for any object with any property:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> accept&lt;MyRoot, MyValue&gt;(<span class=\"keyword\">_</span> object: <span class=\"type\">MyRoot</span>, keyPath: <span class=\"type\">KeyPath</span>&lt;<span class=\"type\">MyRoot</span>, <span class=\"type\">MyValue</span>&gt;) {\n\n   <span class=\"call\">print</span>(object[keyPath: keyPath])\n\n}\n</code></pre></code></pre>\n<p>Here, we introduce the generic types <code>MyRoot</code> and <code>MyValue</code> specifically for our <code>accept</code> function and also use them for our <code>KeyPath&lt;MyRoot, MyValue&gt;</code> definition. Now, we can use this function for different keypaths:</p>\n<pre class=\"Swift\"><code><span class=\"call\">accept</span>(user, keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>)\n\n<span class=\"call\">accept</span>(\\<span class=\"string\">\"</span>\\<span class=\"string\">\"</span>, keyPath: \\<span class=\"type\">String</span>.<span class=\"property\">count</span>)\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Generic Types\"\ntags = [\"keypath\", \"root\", \"value\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Generic Types\n\nWe don't always have to spell out the two generic types `Root` and `Value`. We can, for example, write a generic function that works for any object with any property:\n\n``` Swift\nfunc accept<MyRoot, MyValue>(_ object: MyRoot, keyPath: KeyPath<MyRoot, MyValue>) {\n  print(object[keyPath: keyPath])\n}\n```\n\nHere, we introduce the generic types `MyRoot` and `MyValue` specifically for our `accept` function and also use them for our `KeyPath<MyRoot, MyValue>` definition. Now, we can use this function for different keypaths:\n\n``` Swift\naccept(user, keyPath: \\User.username)\naccept(\"\", keyPath: \\String.count)\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/how/share_extensions.md":["9f6e4bfafe702f2d",{"identifier":"f8021435","filename":"share_extensions.md","info":{"title":"How do I use Share Extensions?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-use-share-extensions.html","content":"<p>Many of the iOS specific targets, such as iMessage extensions or Share Extensions are currently not supported on UIKitForMac.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I use Share Extensions?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\nMany of the iOS specific targets, such as iMessage extensions or Share Extensions are currently not supported on UIKitForMac.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./posts/2015-08-25-optional-throw-swift.md":["4949ed77d4ab158f",{"identifier":"8464e311","filename":"2015-08-25-optional-throw-swift.md","info":{"title":"Optional throw via try? in Swift 2","tags":["try","error"],"keywords":["swift","error","throw","result","either","rethrow","try","syntax","swift2"],"category":["Language","All"],"created":"2015-08-25 10:30:30","description":"Swift 2.0 includes a new way of handling exceptions via the try? keyword. This is a quick post to explain the basics, and why this is cool.","description_html":"<p>Swift 2.0 includes a new way of handling exceptions via the try? keyword. This is a quick post to explain the basics, and why this is cool.</p>\n","published":true,"slug":"2015-08-25-optional-throw-swift.html","meta":{"swift_version":"2.3","feature_image":"https://appventure.me/img-content/2015-08-25-optional-throw-swift-feature-image.jpg"},"created_timestamp":1440498630,"date":"2015-08-25T10:30:30","date_info":{"year":2015,"month":8,"day":25,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"/posts/2015-08-25-optional-throw-swift.html","content":"<p>Swift 2.0 includes a new way of handling exceptions via the <code>try?</code>\nkeyword. This is a quick post to explain the basics, and why this is\ncool.</p>\n<p>In Swift 1.x, all we had for error handling were optionals and\n<code>NSError</code>. Which is <a href=\"https://github.com/antitypical/Result\">why many people adopted <code>Either</code> / <code>Result</code>\ntypes</a> as they can be found in\n<a href=\"https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Either.html\">other</a>\n<a href=\"http://www.scala-lang.org/api/2.9.3/scala/Either.html\">programming</a>\nlanguages:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> success = <span class=\"type\">Result</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">NSError</span>&gt;.<span class=\"type\">Success</span>(\\<span class=\"string\">\"success</span>\\<span class=\"string\">\"</span>)\n</code></pre></code></pre>\n<p>With Swift 2 and the introduction of <code>try / catch</code> exception handling.\nInternally, this doesn't use expensive stack unwinding, as other (say,\nObjective-C or Java) do it, but instead seems to pretty much return\nsomething akin to <code>Either</code> or <code>Result</code>. Only the syntax hides this from\nthe user in order to make it simpler to use<sup class=\"footnote-reference\"><a href=\"#1\">1</a></sup>.</p>\n<h1>Swift 2 b5 and earlier</h1>\n<p>However, once you start using the new <code>do / try / catch</code> more, what\nhappens from time to time is that you start nesting code into messy\nbranches because <code>do</code> is (was) incompatible with the other major way of\nhandling potentially unknown states: optionals. Here's a particular\nugly piece of code. Observe how we're nesting <code>if let</code> with <code>let</code> with\n<code>do</code> with <code>let</code> <sup class=\"footnote-reference\"><a href=\"#2\">2</a></sup>.</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">if let</span> uid = <span class=\"call\">loggedInUser</span>() {\n\n     <span class=\"keyword\">do</span> {\n\n         <span class=\"keyword\">let</span> username = <span class=\"keyword\">try</span> <span class=\"call\">getUserName</span>(uid)\n\n         <span class=\"keyword\">if let</span> data = <span class=\"call\">imagePostForUserName</span>(username, imageURL: <span class=\"keyword\">nil</span>) {\n\n             <span class=\"keyword\">do</span> {\n\n                 <span class=\"keyword\">let</span> success = <span class=\"keyword\">try</span> <span class=\"call\">postImage</span>(data)\n\n                 <span class=\"keyword\">if</span> success {\n\n                     print (\\<span class=\"string\">\"Submitted</span>\\<span class=\"string\">\"</span>)\n\n                 }  \n\n             } <span class=\"keyword\">catch</span> {\n\n                 <span class=\"comment\">// more error handling</span>\n\n             }\n\n         }\n\n     } <span class=\"keyword\">catch</span> {\n\n         <span class=\"comment\">// todo: error handling</span>\n\n     }\n\n}\n\n\n</code></pre></code></pre>\n<p>One reason why this is difficult to simplify is that the <code>do</code> forces a\nbreak in any multi <code>guard</code> or multi <code>let</code> <sup class=\"footnote-reference\"><a href=\"#3\">3</a></sup>.</p>\n<h1>Swift 2 b6</h1>\n<p>With beta 6, we get a new keyword, <code>try?</code> which performs a throwing\noperation and returns optional <code>None</code> in case of failure and optional\n<code>Some</code> in case of success. <a href=\"http://adcdownload.apple.com/Developer_Tools/Xcode_7_beta_6/Xcode_7_beta_6_Release_Notes.pdf\">Quoting straight from the\nchangelog:</a></p>\n<blockquote>\n<p>A new keyword 'try?' has been added to Swift. 'try?' attempts to\nperform an operation that may throw. If the operation succeeds, the\nresult is wrapped in an optional; if it fails (I.e. if an error is\nthrown), the result is 'nil' and the error is discarded. 'try?' is\nparticularly useful when used in conjunction with &quot;if let&quot; and\n&quot;guard&quot;.</p>\n</blockquote>\n<p>This makes it possible to retrieve the value of a potential throwing\noperation as an optional. If we apply this to our code above, we can\nsimplify it quite a bit:</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">if let</span> uid = <span class=\"call\">loggedInUser</span>(),\n\n    username = <span class=\"keyword\">try</span>? <span class=\"call\">getUserName</span>(uid),\n\n    data = <span class=\"call\">imagePostForUserName</span>(username, imageURL: <span class=\"keyword\">nil</span>),\n\n    success = <span class=\"keyword\">try</span>? <span class=\"call\">postImage</span>(data)\n\n    <span class=\"keyword\">where</span> success == <span class=\"keyword\">true</span> {\n\n       print (\\<span class=\"string\">\"Submitted</span>\\<span class=\"string\">\"</span>)\n\n}\n\n\n</code></pre></code></pre>\n<p>This is, of course a bit of a contrived example, engineered to explain\n<code>try?</code>. But still, that's definitely less code. We're, of course,\nloosing a lot of possibly valuable error information that would\notherwise be available in the <code>catch</code>.</p>\n<h1>Which to choose?</h1>\n<p><code>try?</code> can help you write terser code at the expense of loosing\ninsights. Using <code>try?</code> only returns an optional without further\ninformation on the particular cause of the error / exception. The\nbenefit, of course, is beautiful composability with <strong>a lot</strong> of the\nother Swift syntax, like <code>map</code>, <code>flatmap</code>, <code>switch</code>, <code>guard</code>, <code>if let</code>,\n<code>for case</code>, and others.</p>\n<p>The non-optional <code>try</code> works great for distinct task where you're not\ndependant on earlier or later possible optional results.</p>\n<p>The aforementioned <code>Result</code> type, on the other hand offers both; either\nthe requested value, or a possible error. You can just continue using\n<code>Result</code>, which also has support for wrapping throws and much more,\nhowever keep in mind that this is not the direction Swift seems to\nintend to go <sup class=\"footnote-reference\"><a href=\"#4\">4</a></sup>. Otherwise, we'd have a full blown Result or Either\ntype in Swift 2.</p>\n<p>I'm really happy about the introduction of <code>try?</code> as it will make many\nsnippets, particularly when interacting with the Cocoa API, easier to\nsolve.</p>\n<div class=\"footnote-definition\" id=\"1\"><sup class=\"footnote-definition-label\">1</sup>\n<p>Much like the lifting into / out of monads in Swift optionals is\nhidden via the <code>?</code> syntax</p>\n</div>\n<div class=\"footnote-definition\" id=\"2\"><sup class=\"footnote-definition-label\">2</sup>\n<p>There're ways to improve this code without <code>try?</code>, of course, but\nit makes for a nice example</p>\n</div>\n<div class=\"footnote-definition\" id=\"3\"><sup class=\"footnote-definition-label\">3</sup>\n<p>Another is, of course, that I'm using raw NSRegularExpression\nhere, instead of a simplifying library</p>\n</div>\n<div class=\"footnote-definition\" id=\"4\"><sup class=\"footnote-definition-label\">4</sup>\n<p>Also, you'll always need to add additional dependencies to your\nproject</p>\n</div>\n","raw_content":"[frontMatter]\ndescription = \"Swift 2.0 includes a new way of handling exceptions via the try? keyword. This is a quick post to explain the basics, and why this is cool.\"\ntitle = \"Optional throw via try? in Swift 2\"\ncreated = \"2015-08-25\"\npublished = true\nkeywords = [\"swift\", \"error\", \"throw\", \"result\", \"either\", \"rethrow\", \"try\", \"syntax\", \"swift2\"]\nslug = \"2015-08-25-optional-throw-swift.html\"\ntags = [\"try\", \"error\"]\ncategory = [\"Language\", \"All\"]\n\n[meta]\nswift_version = \"2.3\"\nfeature_image = \"https://appventure.me/img-content/2015-08-25-optional-throw-swift-feature-image.jpg\"\n---\n\nSwift 2.0 includes a new way of handling exceptions via the `try?`\nkeyword. This is a quick post to explain the basics, and why this is\ncool.\n\nIn Swift 1.x, all we had for error handling were optionals and\n`NSError`. Which is [why many people adopted `Either` / `Result`\ntypes](https://github.com/antitypical/Result) as they can be found in\n[other](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Either.html)\n[programming](http://www.scala-lang.org/api/2.9.3/scala/Either.html)\nlanguages:\n\n``` Swift\nlet success = Result<String, NSError>.Success(\"success\")\n```\n\nWith Swift 2 and the introduction of `try / catch` exception handling.\nInternally, this doesn\\'t use expensive stack unwinding, as other (say,\nObjective-C or Java) do it, but instead seems to pretty much return\nsomething akin to `Either` or `Result`. Only the syntax hides this from\nthe user in order to make it simpler to use[^1].\n\n# Swift 2 b5 and earlier\n\nHowever, once you start using the new `do / try / catch` more, what\nhappens from time to time is that you start nesting code into messy\nbranches because `do` is (was) incompatible with the other major way of\nhandling potentially unknown states: optionals. Here\\'s a particular\nugly piece of code. Observe how we\\'re nesting `if let` with `let` with\n`do` with `let` [^2].\n\n``` Swift\n\nif let uid = loggedInUser() {\n    do {\n        let username = try getUserName(uid)\n        if let data = imagePostForUserName(username, imageURL: nil) {\n            do {\n                let success = try postImage(data)\n                if success {\n                    print (\"Submitted\")\n                }  \n            } catch {\n                // more error handling\n            }\n        }\n    } catch {\n        // todo: error handling\n    }\n}\n\n```\n\nOne reason why this is difficult to simplify is that the `do` forces a\nbreak in any multi `guard` or multi `let` [^3].\n\n# Swift 2 b6\n\nWith beta 6, we get a new keyword, `try?` which performs a throwing\noperation and returns optional `None` in case of failure and optional\n`Some` in case of success. [Quoting straight from the\nchangelog:](http://adcdownload.apple.com/Developer_Tools/Xcode_7_beta_6/Xcode_7_beta_6_Release_Notes.pdf)\n\n> A new keyword \\'try?\\' has been added to Swift. \\'try?\\' attempts to\n> perform an operation that may throw. If the operation succeeds, the\n> result is wrapped in an optional; if it fails (I.e. if an error is\n> thrown), the result is \\'nil\\' and the error is discarded. 'try?' is\n> particularly useful when used in conjunction with \"if let\" and\n> \"guard\".\n\nThis makes it possible to retrieve the value of a potential throwing\noperation as an optional. If we apply this to our code above, we can\nsimplify it quite a bit:\n\n``` Swift\n\nif let uid = loggedInUser(),\n   username = try? getUserName(uid),\n   data = imagePostForUserName(username, imageURL: nil),\n   success = try? postImage(data)\n   where success == true {\n      print (\"Submitted\")\n}\n\n```\n\nThis is, of course a bit of a contrived example, engineered to explain\n`try?`. But still, that\\'s definitely less code. We\\'re, of course,\nloosing a lot of possibly valuable error information that would\notherwise be available in the `catch`.\n\n# Which to choose?\n\n`try?` can help you write terser code at the expense of loosing\ninsights. Using `try?` only returns an optional without further\ninformation on the particular cause of the error / exception. The\nbenefit, of course, is beautiful composability with **a lot** of the\nother Swift syntax, like `map`, `flatmap`, `switch`, `guard`, `if let`,\n`for case`, and others.\n\nThe non-optional `try` works great for distinct task where you\\'re not\ndependant on earlier or later possible optional results.\n\nThe aforementioned `Result` type, on the other hand offers both; either\nthe requested value, or a possible error. You can just continue using\n`Result`, which also has support for wrapping throws and much more,\nhowever keep in mind that this is not the direction Swift seems to\nintend to go [^4]. Otherwise, we\\'d have a full blown Result or Either\ntype in Swift 2.\n\nI\\'m really happy about the introduction of `try?` as it will make many\nsnippets, particularly when interacting with the Cocoa API, easier to\nsolve.\n\n[^1]: Much like the lifting into / out of monads in Swift optionals is\n    hidden via the `?` syntax\n\n[^2]: There\\'re ways to improve this code without `try?`, of course, but\n    it makes for a nice example\n\n[^3]: Another is, of course, that I\\'m using raw NSRegularExpression\n    here, instead of a simplifying library\n\n[^4]: Also, you\\'ll always need to add additional dependencies to your\n    project\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/identifier_pattern.md":["08d34e0ac0f27fff",{"identifier":"a5aeda9a","filename":"identifier_pattern.md","info":{"title":"Identifier Pattern","tags":["pattern matching","switch"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-identifier-pattern.html","content":"<h1>Identifier Pattern</h1>\n<p>Matches a concrete value. This is how things work in Objective-C's\n<code>switch</code> implementation:</p>\n<p>Here, we have a special case just for the number 5</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> number = <span class=\"number\">4</span>\n\n<span class=\"keyword\">switch</span> number {\n\n<span class=\"keyword\">case</span> <span class=\"number\">5</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"it</span> <span class=\"keyword\">is</span> a <span class=\"number\">5</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"it</span> <span class=\"keyword\">is</span> something <span class=\"keyword\">else</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>We can also match strings, see our code below to greet people\nin their native language.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> language = \\<span class=\"string\">\"Japanese</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">switch</span> name {\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"Japanese</span>\\<span class=\"string\">\"</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"おはようございます</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"English</span>\\<span class=\"string\">\"</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Hello</span>!\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> \\<span class=\"string\">\"German</span>\\<span class=\"string\">\"</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Guten</span> <span class=\"type\">Tag</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Identifier Pattern\"\ntags = [\"pattern matching\", \"switch\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Identifier Pattern\n\nMatches a concrete value. This is how things work in Objective-C\\'s\n`switch` implementation:\n\nHere, we have a special case just for the number 5\n\n``` Swift\nlet number = 4\nswitch number {\ncase 5: print(\"it is a 5\")\ndefault: print(\"it is something else\")\n}\n```\n\n\nWe can also match strings, see our code below to greet people\nin their native language.\n\n``` Swift\nlet language = \"Japanese\"\nswitch name {\ncase \"Japanese\": print(\"おはようございます\")\ncase \"English\": print(\"Hello!\")\ncase \"German\": print(\"Guten Tag\")\n}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/swift_reflection/mirrors/how_to_use_a_mirror.md":["ad703af058d61d76",{"identifier":"393d6af1","filename":"how_to_use_a_mirror.md","info":{"title":"How to use a Mirror","tags":["reflection","mirror"],"keywords":[],"category":[],"created":"2019-03-01 11:47:01","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551440821,"date":"2019-03-01T11:47:01","date_info":{"year":2019,"month":3,"day":1,"hour":11,"minute":47,"second":1},"identifier":"","indexed":true},"slug":"//2019-3-1-how-to-use-a-mirror.html","content":"<h1>How to use a Mirror</h1>\n<p>So we have our <code>myMirror</code> instance variable that reflects our <code>Bookmark</code>. What do we do with it?</p>\n<p>These are the available properties / methods on a <code>Mirror</code>:</p>\n<ul>\n<li><code>let children: Children</code>: The child elements of our subject</li>\n<li><code>displayStyle: Mirror.DisplayStyle?</code>: The display style of the\nsubject</li>\n<li><code>let subjectType: Any.Type</code> : The type of the subject</li>\n<li><code>func superclassMirror() -&gt; Mirror?</code>: The mirror of the subject's\nsuperclass</li>\n</ul>\n<p>In the next step, we will analyze each of these.</p>\n<h3>displayStyle</h3>\n<p>This is easy. It will just return a case of the <code>DisplayStyle</code> <code>enum</code>.\nIf you're trying to reflect over an unsupported type, you'll get an\nempty <code>Optional</code> back (as explained above).</p>\n<pre class=\"Swift\"><code>print (aMirror.<span class=\"property\">displayStyle</span>)\n\n<span class=\"comment\">// prints: Optional(Swift.Mirror.DisplayStyle.struct)</span>\n</code></pre></code></pre>\n<h3>children</h3>\n<p>This returns a <code>AnyCollection&lt;Child&gt;</code> with all the children that\nthe subject contains. Children are not limited to entries in an <code>Array</code>\nor <code>Dictionary</code>. All properties of a <code>struct</code> or <code>class</code>, for example,\nare also children returned by this property. The protocol\n<code>AnyCollection</code> means that this is a type <a href=\"lnk::type-erase\">erased <code>Collection</code>.</a></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for case let</span> (label?, value) <span class=\"keyword\">in</span> myMirror.<span class=\"property\">children</span> {\n\n     print (label, value)\n\n}\n\n<span class=\"comment\">//prints:</span>\n\n<span class=\"comment\">//: store main.BookmarkStore</span>\n\n<span class=\"comment\">//: title Optional(\\\"Appventure\\\")</span>\n\n<span class=\"comment\">//: url appventure.me</span>\n\n<span class=\"comment\">//: keywords [\\\"Swift\\\", \\\"iOS\\\", \\\"OSX\\\"]</span>\n\n<span class=\"comment\">//: group tech</span>\n</code></pre></code></pre>\n<h3>SubjectType</h3>\n<p>This is the type of the subject:</p>\n<pre class=\"Swift\"><code><span class=\"call\">print</span>(aMirror.<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//prints : Bookmark</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: <span class=\"number\">5</span>).<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//prints : Int</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: \\<span class=\"string\">\"test</span>\\<span class=\"string\">\"</span>).<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//prints : String</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: <span class=\"type\">Null</span>()).<span class=\"property\">subjectType</span>)\n\n<span class=\"comment\">//print : Null</span>\n</code></pre></code></pre>\n<p>However, the Swift documentation has the following to say:</p>\n<blockquote>\n<p>This type may differ from the subject's dynamic type when <code>self</code> is\nthe <code>superclassMirror()</code> of another mirror.</p>\n</blockquote>\n<h3>SuperclassMirror</h3>\n<p>This is the mirror of the superclass of our subject. If the subject is\nnot a class, this will be an empty <code>Optional</code>. If this is a class-based\ntype, you'll get a new <code>Mirror</code>:</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// try our struct</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: aBookmark).<span class=\"call\">superclassMirror</span>())\n\n<span class=\"comment\">// prints: nil</span>\n\n<span class=\"comment\">// try a class</span>\n\n<span class=\"call\">print</span>(<span class=\"type\">Mirror</span>(reflecting: myBookmark.<span class=\"property\">store</span>).<span class=\"call\">superclassMirror</span>())\n\n<span class=\"comment\">// prints: Optional(Mirror for Store)</span>\n\n\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"How to use a Mirror\"\ntags = [\"reflection\", \"mirror\"]\ncreated = \"2019-03-01 11:47:01\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# How to use a Mirror\n\nSo we have our `myMirror` instance variable that reflects our `Bookmark`. What do we do with it?\n\nThese are the available properties / methods on a `Mirror`:\n\n-   `let children: Children`: The child elements of our subject\n-   `displayStyle: Mirror.DisplayStyle?`: The display style of the\n    subject\n-   `let subjectType: Any.Type` : The type of the subject\n-   `func superclassMirror() -> Mirror?`: The mirror of the subject\\'s\n    superclass\n\nIn the next step, we will analyze each of these.\n\n### displayStyle\n\nThis is easy. It will just return a case of the `DisplayStyle` `enum`.\nIf you\\'re trying to reflect over an unsupported type, you\\'ll get an\nempty `Optional` back (as explained above).\n\n``` Swift\nprint (aMirror.displayStyle)\n// prints: Optional(Swift.Mirror.DisplayStyle.struct)\n```\n\n### children\n\nThis returns a `AnyCollection<Child>` with all the children that\nthe subject contains. Children are not limited to entries in an `Array`\nor `Dictionary`. All properties of a `struct` or `class`, for example,\nare also children returned by this property. The protocol\n`AnyCollection` means that this is a type [erased `Collection`.](lnk::type-erase)\n\n``` Swift\nfor case let (label?, value) in myMirror.children {\n    print (label, value)\n}\n//prints:\n//: store main.BookmarkStore\n//: title Optional(\"Appventure\")\n//: url appventure.me\n//: keywords [\"Swift\", \"iOS\", \"OSX\"]\n//: group tech\n```\n\n### SubjectType\n\nThis is the type of the subject:\n\n``` Swift\nprint(aMirror.subjectType)\n//prints : Bookmark\nprint(Mirror(reflecting: 5).subjectType)\n//prints : Int\nprint(Mirror(reflecting: \"test\").subjectType)\n//prints : String\nprint(Mirror(reflecting: Null()).subjectType)\n//print : Null\n```\n\nHowever, the Swift documentation has the following to say:\n\n> This type may differ from the subject\\'s dynamic type when `self` is\n> the `superclassMirror()` of another mirror.\n\n### SuperclassMirror\n\nThis is the mirror of the superclass of our subject. If the subject is\nnot a class, this will be an empty `Optional`. If this is a class-based\ntype, you\\'ll get a new `Mirror`:\n\n``` Swift\n// try our struct\nprint(Mirror(reflecting: aBookmark).superclassMirror())\n// prints: nil\n// try a class\nprint(Mirror(reflecting: myBookmark.store).superclassMirror())\n// prints: Optional(Mirror for Store)\n\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/expressionpattern.md":["321eabb0788f0289",{"identifier":"dbba81b3","filename":"expressionpattern.md","info":{"title":"Expression Pattern","tags":["pattern matching","switch","equatable"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-expression-pattern.html","content":"<h1>Expression Pattern</h1>\n<p>The expression pattern is very powerful. It matches the <code>switch</code> value\nagainst an expression implementing the <code>~=</code> operator. There're default\nimplementations for this operator, for example for ranges, so that you\ncan do:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> <span class=\"number\">5</span> {\n\n<span class=\"keyword\">case</span> <span class=\"number\">0</span>..<span class=\"number\">10</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"In</span> range <span class=\"number\">0</span>-<span class=\"number\">10</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"In</span> another range\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>However, the much more interesting possibility is overloading the\noperator yourself in order to add matchability to your custom types.\nLet's say that you decided to rewrite the soldier game we wrote earlier\nand you want to use structs after all.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Soldier {\n\n   <span class=\"keyword\">let</span> hp: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>\n\n   <span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Now you'd like to easily match against all entities with a health of\n<strong>0</strong>. We can simply implement the <code>~=</code> operators as follows.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> ~= (pattern: <span class=\"type\">Int</span>, value: <span class=\"type\">Soldier</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">return</span> pattern == value.<span class=\"property\">hp</span>\n\n}\n</code></pre></code></pre>\n<p>Now we can match against an entity. In this example, only soldiers that\nhave a <code>hp</code> of <code>0</code> would be matched (thus, we print <code>dead soldier</code>),\nbecause we're commparing the <code>value.hp</code> to the <code>switch</code> pattern in our\n<code>~=</code> implementation above.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> soldier = <span class=\"type\">Soldier</span>(hp: <span class=\"number\">99</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)\n\n<span class=\"keyword\">switch</span> soldier {\n\n<span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"dead</span> soldier\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>What if you'd like to not just compare the <code>hp</code> but also the <code>x</code> and the <code>y</code>? You\ncan just implement <code>pattern</code> with a <a href=\"lnk::tuple\">tuple</a>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> ~= (pattern: (hp: <span class=\"type\">Int</span>, x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>), value: <span class=\"type\">Soldier</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">let</span> (hp, x, y) = pattern\n\n     <span class=\"keyword\">return</span> hp == value.<span class=\"property\">hp</span> &amp;&amp; x == value.<span class=\"property\">x</span> &amp;&amp; y == value.<span class=\"property\">y</span>\n\n}\n\n\n\n\n\n<span class=\"keyword\">let</span> soldier = <span class=\"type\">Soldier</span>(hp: <span class=\"number\">99</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)\n\n<span class=\"keyword\">switch</span> soldier {\n\n<span class=\"keyword\">case</span> (<span class=\"number\">50</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"health</span> <span class=\"number\">50</span> at pos <span class=\"number\">10</span>/<span class=\"number\">10</span>\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>You can even match structs against structs. However, this only works if your\nstructs are <code>Equatable</code>. Swift can implement this automatically, as long as\nyou tell it to by conforming to the protocol. So lets first extend our <code>Soldier</code>\nstruct to conform to <code>Equatable</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">struct</span> Soldier: <span class=\"type\">Equatable</span> {\n\n     <span class=\"keyword\">let</span> hp: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">let</span> x: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>\n\n}\n</code></pre></code></pre>\n<p>Now, we can add a new match implementation. Since both soldiers are equatable <code>value types</code>, we can actually just directly compare them. If they both have the same values for their three properties (hp, x, y), then they are considered equal:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> ~= (pattern: <span class=\"type\">Soldier</span>, value: <span class=\"type\">Soldier</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">return</span> pattern == value\n\n}\n\n\n\n<span class=\"keyword\">let</span> soldier = <span class=\"type\">Soldier</span>(hp: <span class=\"number\">50</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)\n\n<span class=\"keyword\">switch</span> soldier {\n\n<span class=\"keyword\">case</span> <span class=\"type\">Soldier</span>(hp: <span class=\"number\">50</span>, x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"The</span> same\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>The left side of the <code>~=</code> operator (the <code>pattern</code> argument) can be anything. So\nit can even be a <code>protocol</code>:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">protocol</span> Entity {\n\n     <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> {<span class=\"keyword\">get</span>}\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Tank: <span class=\"type\">Entity</span> {\n\n     <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> value: <span class=\"type\">Int</span>) { <span class=\"keyword\">self</span>.<span class=\"property\">value</span> = value }\n\n}\n\n\n\n<span class=\"keyword\">struct</span> Peasant: <span class=\"type\">Entity</span> {\n\n     <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span>\n\n     <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> value: <span class=\"type\">Int</span>) { <span class=\"keyword\">self</span>.<span class=\"property\">value</span> = value }\n\n}\n\n\n\n<span class=\"keyword\">func</span> ~=(pattern: <span class=\"type\">Entity</span>, x: <span class=\"type\">Entity</span>) -&gt; <span class=\"type\">Bool</span> {\n\n     <span class=\"keyword\">return</span> pattern.<span class=\"property\">value</span> == x.<span class=\"property\">value</span>\n\n}\n\n\n\n<span class=\"keyword\">switch</span> <span class=\"type\">Tank</span>(<span class=\"number\">42</span>) {\n\n<span class=\"keyword\">case</span> <span class=\"type\">Peasant</span>(<span class=\"number\">42</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Matched</span>\\<span class=\"string\">\"</span>) <span class=\"comment\">// Does match</span>\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>There's a lot of things you can do with <code>Expression Patterns</code>. For a\nmuch more detailed explanation of Expression Patterns, <a href=\"http://austinzheng.com/2014/12/17/custom-pattern-matching/\">have a look at\nthis terrific blog post by Austin\nZheng</a>.</p>\n<p>This completes list of possible switch patterns. Our next topic is\nflow control in <code>switch</code> statements.</p>\n","raw_content":"[frontMatter]\ntitle = \"Expression Pattern\"\ntags = [\"pattern matching\", \"switch\", \"equatable\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Expression Pattern\n\nThe expression pattern is very powerful. It matches the `switch` value\nagainst an expression implementing the `~=` operator. There\\'re default\nimplementations for this operator, for example for ranges, so that you\ncan do:\n\n``` Swift\nswitch 5 {\ncase 0..10: print(\"In range 0-10\")\ndefault: print(\"In another range\")\n}\n```\n\nHowever, the much more interesting possibility is overloading the\noperator yourself in order to add matchability to your custom types.\nLet\\'s say that you decided to rewrite the soldier game we wrote earlier\nand you want to use structs after all.\n\n``` Swift\nstruct Soldier {\n  let hp: Int\n  let x: Int\n  let y: Int\n}\n```\n\nNow you\\'d like to easily match against all entities with a health of\n**0**. We can simply implement the `~=` operators as follows.\n\n``` Swift\nfunc ~= (pattern: Int, value: Soldier) -> Bool {\n    return pattern == value.hp\n}\n```\n\nNow we can match against an entity. In this example, only soldiers that\nhave a `hp` of `0` would be matched (thus, we print `dead soldier`),\nbecause we're commparing the `value.hp` to the `switch` pattern in our\n`~=` implementation above.\n\n``` Swift\nlet soldier = Soldier(hp: 99, x: 10, y: 10)\nswitch soldier {\ncase 0: print(\"dead soldier\")\ndefault: ()\n}\n```\n\nWhat if you'd like to not just compare the `hp` but also the `x` and the `y`? You\ncan just implement `pattern` with a [tuple](lnk::tuple):\n\n``` Swift\nfunc ~= (pattern: (hp: Int, x: Int, y: Int), value: Soldier) -> Bool {\n    let (hp, x, y) = pattern\n    return hp == value.hp && x == value.x && y == value.y\n}\n\n\nlet soldier = Soldier(hp: 99, x: 10, y: 10)\nswitch soldier {\ncase (50, 10, 10): print(\"health 50 at pos 10/10\")\ndefault: ()\n}\n```\n\nYou can even match structs against structs. However, this only works if your\nstructs are `Equatable`. Swift can implement this automatically, as long as\nyou tell it to by conforming to the protocol. So lets first extend our `Soldier`\nstruct to conform to `Equatable`:\n\n``` Swift\nstruct Soldier: Equatable {\n    let hp: Int\n    let x: Int\n    let y: Int\n}\n```\n\nNow, we can add a new match implementation. Since both soldiers are equatable `value types`, we can actually just directly compare them. If they both have the same values for their three properties (hp, x, y), then they are considered equal:\n\n``` Swift\nfunc ~= (pattern: Soldier, value: Soldier) -> Bool {\n    return pattern == value\n}\n\nlet soldier = Soldier(hp: 50, x: 10, y: 10)\nswitch soldier {\ncase Soldier(hp: 50, x: 10, y: 10): print(\"The same\")\ndefault: ()\n}\n```\n\nThe left side of the `~=` operator (the `pattern` argument) can be anything. So \nit can even be a `protocol`:\n\n``` Swift\nprotocol Entity {\n    var value: Int {get}\n}\n\nstruct Tank: Entity {\n    var value: Int\n    init(_ value: Int) { self.value = value }\n}\n\nstruct Peasant: Entity {\n    var value: Int\n    init(_ value: Int) { self.value = value }\n}\n\nfunc ~=(pattern: Entity, x: Entity) -> Bool {\n    return pattern.value == x.value\n}\n\nswitch Tank(42) {\ncase Peasant(42): print(\"Matched\") // Does match\ndefault: ()\n}\n```\n\nThere\\'s a lot of things you can do with `Expression Patterns`. For a\nmuch more detailed explanation of Expression Patterns, [have a look at\nthis terrific blog post by Austin\nZheng](http://austinzheng.com/2014/12/17/custom-pattern-matching/).\n\nThis completes list of possible switch patterns. Our next topic is \nflow control in `switch` statements.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/tuples/absolute_basics/tuples_for_pattern_matching.md":["8300a8ace036cde6",{"identifier":"8f14fde4","filename":"tuples_for_pattern_matching.md","info":{"title":"Tuples for Pattern Matching","tags":["tuples","pattern matching"],"keywords":[],"category":[],"created":"2019-03-01 17:35:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551461730,"date":"2019-03-01T17:35:30","date_info":{"year":2019,"month":3,"day":1,"hour":17,"minute":35,"second":30},"identifier":"","indexed":true},"slug":"//2019-3-1-tuples-for-pattern-matching.html","content":"<h1>Tuples for Pattern Matching</h1>\n<p>Pattern matching oftentimes feels like the strongest use case for\ntuples. Swift's <code>switch</code> statement offers a really powerful yet easy\nway to define complex conditionals without cluttering up the source\ncode. You can then match for the type, existence, and value of multiple\nvariables in one statement.</p>\n<p>We wrote a game where both players have to take a quiz. After each question we evaluate\nwho won or lost. There're four states:</p>\n<ul>\n<li>Player 1 is correct</li>\n<li>Player 2 is correct</li>\n<li>Both were correct</li>\n<li>Both were wrong</li>\n</ul>\n<p>We can model this logic very nicely with a <code>switch</code> statement such as the following:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> player1 = <span class=\"keyword\">true</span>\n\n<span class=\"keyword\">let</span> player2 = <span class=\"keyword\">false</span>\n\n<span class=\"keyword\">switch</span> (player1, player2) {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Player</span> <span class=\"number\">1</span> won\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Player</span> <span class=\"number\">2</span> won\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Draw</span>, both won\\<span class=\"string\">\"</span>)\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>): <span class=\"call\">print</span>(\\<span class=\"string\">\"Draw</span>, both lost\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>Here, we create a tuple <code>(player1, player2)</code> and then match each of\nthe possible cases.</p>\n<p>Much more complex matchings are also possible. Below, we will match over\na tuple that has the type <code>(Int, String?, Any)</code>.</p>\n<pre class=\"Swift\"><code><span class=\"comment\">// Contrived example</span>\n\n<span class=\"comment\">// These would be return values from various functions.</span>\n\n<span class=\"keyword\">let</span> age: <span class=\"type\">Int</span> = <span class=\"number\">23</span>\n\n<span class=\"keyword\">let</span> job: <span class=\"type\">String</span>? = \\<span class=\"string\">\"Operator</span>\\<span class=\"string\">\"</span>\n\n<span class=\"keyword\">let</span> payload: <span class=\"type\">Any</span> = [\\<span class=\"string\">\"cars</span>\\<span class=\"string\">\"</span>: <span class=\"number\">1</span>]\n</code></pre></code></pre>\n<p>In the code above, we want to find the persons younger than 30 with a\njob and a Dictionary payload. Imagine the payload as something from the\nObjective-C world, it could be a Dictionary or an Array or a Number,\nweakly typed code that somebody else wrote years ago, and you have to interact with\nit now.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">switch</span> (age, job, payload) {\n\n<span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> age, <span class=\"keyword\">_</span>?, <span class=\"keyword\">_ as</span> <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">AnyHashable</span>, <span class=\"type\">Any</span>&gt;) <span class=\"keyword\">where</span> age &lt; <span class=\"number\">30</span>:\n\n     <span class=\"call\">print</span>(age)\n\n<span class=\"keyword\">default</span>:\n\n     <span class=\"keyword\">break</span>\n\n}\n</code></pre></code></pre>\n<p>By constructing the switch argument as a tuple <code>(age, job, payload)</code> we\ncan query for specific or nonspecific attributes of all tuple elements\nat once. This allows for elaborately constrained conditionals.</p>\n","raw_content":"[frontMatter]\ntitle = \"Tuples for Pattern Matching\"\ntags = [\"tuples\", \"pattern matching\"]\ncreated = \"2019-03-01 17:35:30\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Tuples for Pattern Matching\n\nPattern matching oftentimes feels like the strongest use case for\ntuples. Swift\\'s `switch` statement offers a really powerful yet easy\nway to define complex conditionals without cluttering up the source\ncode. You can then match for the type, existence, and value of multiple\nvariables in one statement.\n\nWe wrote a game where both players have to take a quiz. After each question we evaluate\nwho won or lost. There're four states: \n\n- Player 1 is correct\n- Player 2 is correct\n- Both were correct\n- Both were wrong\n\nWe can model this logic very nicely with a `switch` statement such as the following:\n\n``` Swift\nlet player1 = true\nlet player2 = false\nswitch (player1, player2) {\ncase (true, false): print(\"Player 1 won\")\ncase (false, true): print(\"Player 2 won\")\ncase (true, true): print(\"Draw, both won\")\ncase (false, false): print(\"Draw, both lost\")\n}\n```\n\nHere, we create a tuple `(player1, player2)` and then match each of\nthe possible cases.\n\nMuch more complex matchings are also possible. Below, we will match over\na tuple that has the type `(Int, String?, Any)`.\n\n``` Swift\n// Contrived example\n// These would be return values from various functions.\nlet age: Int = 23\nlet job: String? = \"Operator\"\nlet payload: Any = [\"cars\": 1]\n```\n\nIn the code above, we want to find the persons younger than 30 with a\njob and a Dictionary payload. Imagine the payload as something from the\nObjective-C world, it could be a Dictionary or an Array or a Number,\nweakly typed code that somebody else wrote years ago, and you have to interact with\nit now.\n\n``` Swift\nswitch (age, job, payload) {\ncase (let age, _?, _ as Dictionary<AnyHashable, Any>) where age < 30:\n    print(age)\ndefault:\n    break\n}\n```\n\nBy constructing the switch argument as a tuple `(age, job, payload)` we\ncan query for specific or nonspecific attributes of all tuple elements\nat once. This allows for elaborately constrained conditionals.\n\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/advanced_enum_usage/iterating_over_enum_cases.md":["9b7a67f98f9095eb",{"identifier":"448cf5a8","filename":"iterating_over_enum_cases.md","info":{"title":"Iterating over Enum Cases","tags":["enum","CaseIterable"],"keywords":[],"category":[],"created":"2019-03-01 16:29:51","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0","updated":"true"},"created_timestamp":1551457791,"date":"2019-03-01T16:29:51","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":29,"second":51},"identifier":"","indexed":true},"slug":"//2019-3-1-iterating-over-enum-cases.html","content":"<h1>Iterating over Enum Cases</h1>\n<p>Say you've created a nice new enum with several cases:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Drink: <span class=\"type\">String</span> {\n\n   <span class=\"keyword\">case</span> coke, beer, water, soda, lemonade, wine, vodka, gin\n\n}\n</code></pre></code></pre>\n<p>Now, you'd like to display all of those drinks at runtime in a list. You somehow want to run a <code>for-each</code> loop over all of your enum cases. The <code>enum</code> type does not offer this ability out-of-the-box. Instead, you have to explicitly tell the Swift compiler that you wish for your enum to be iterable. You do this by conforming to the empty <code>CaseIterable</code> protocol:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Drink: <span class=\"type\">String</span>, <span class=\"type\">CaseIterable</span> {\n\n   <span class=\"keyword\">case</span> coke, beer, water, soda, lemonade, wine, vodka, gin\n\n}\n</code></pre></code></pre>\n<p>Now, you can easily iterate over your <code>enum</code> with the new <code>allCases</code> property:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">for</span> drink <span class=\"keyword\">in</span> <span class=\"type\">Drink</span>.<span class=\"property\">allCases</span> {\n\n   <span class=\"call\">print</span>(\\<span class=\"string\">\"For</span> lunch <span class=\"type\">I</span> like to drink \\(drink)\\)\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>This works only if your <code>enum</code> cases do not contain any associated values:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Drink: <span class=\"type\">CaseIterable</span> {\n\n   <span class=\"keyword\">case</span> beer \n\n   <span class=\"keyword\">case</span> cocktail(ingredients: [<span class=\"type\">String</span>])\n\n}\n</code></pre></code></pre>\n<p>This code will not compile and the reason for that is simple. The Swift compiler does not know how to construct the <code>cocktail</code> case. And for good reason, should it be a Gin Tonic, or a Cuba libre? You wouldn't want the Swift compiler to decide that, but it has to! Because in order for you use <code>allCases</code> it will need to return an <code>enum</code> case including associated values.</p>\n<p>So there it is, <code>CaseIterable</code> is a great Swift feature, however keep in mind that it can only be used with simple <code>enum</code> cases.</p>\n","raw_content":"[frontMatter]\ntitle = \"Iterating over Enum Cases\"\ntags = [\"enum\", \"CaseIterable\"]\ncreated = \"2019-03-01 16:29:51\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\nupdated = \"true\"\n---\n\n# Iterating over Enum Cases\n\nSay you've created a nice new enum with several cases:\n\n``` Swift\nenum Drink: String {\n  case coke, beer, water, soda, lemonade, wine, vodka, gin\n}\n```\n\nNow, you'd like to display all of those drinks at runtime in a list. You somehow want to run a `for-each` loop over all of your enum cases. The `enum` type does not offer this ability out-of-the-box. Instead, you have to explicitly tell the Swift compiler that you wish for your enum to be iterable. You do this by conforming to the empty `CaseIterable` protocol:\n\n``` Swift\nenum Drink: String, CaseIterable {\n  case coke, beer, water, soda, lemonade, wine, vodka, gin\n}\n```\n\nNow, you can easily iterate over your `enum` with the new `allCases` property:\n\n``` Swift\nfor drink in Drink.allCases {\n  print(\"For lunch I like to drink \\(drink)\\)\")\n}\n```\n\nThis works only if your `enum` cases do not contain any associated values:\n\n``` Swift\nenum Drink: CaseIterable {\n  case beer \n  case cocktail(ingredients: [String])\n}\n```\n\nThis code will not compile and the reason for that is simple. The Swift compiler does not know how to construct the `cocktail` case. And for good reason, should it be a Gin Tonic, or a Cuba libre? You wouldn't want the Swift compiler to decide that, but it has to! Because in order for you use `allCases` it will need to return an `enum` case including associated values.\n\nSo there it is, `CaseIterable` is a great Swift feature, however keep in mind that it can only be used with simple `enum` cases.\n\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/games.md":["f9733785e4c8ea2e",{"identifier":"06ea204e","filename":"games.md","info":{"title":"Games","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-games.html","content":"<h1>Games</h1>\n<p>Enums are a great use case for games, where many entities on screen\nbelong to a specific family of items (enemies, obstacles, textures,\n...). In comparison to native iOS or Mac apps, games oftentimes are a\ntabula rasa. Meaning you invent a new world with new relationships and\nnew kinds of objects, whereas on iOS or OSX you're using a well-defined\nworld of <code>UIButtons</code>, <code>UITableViews</code>, <code>UITableViewCells</code> or <code>NSStackView</code>.</p>\n<p>What's more, since Enums can conform to protocols, you can utilize\nprotocol extensions and protocol based programming to add functionality\nto the various enums that you defined for your game. Here's a short\nexample that tries to display such a hierarchy:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> FlyingBeast { <span class=\"keyword\">case</span> dragon, hippogriff, gargoyle }\n\n<span class=\"keyword\">enum</span> Horde { <span class=\"keyword\">case</span> ork, troll }\n\n<span class=\"keyword\">enum</span> Player { <span class=\"keyword\">case</span> mage, warrior, barbarian }\n\n<span class=\"keyword\">enum</span> NPC { <span class=\"keyword\">case</span> vendor, blacksmith }\n\n<span class=\"keyword\">enum</span> Element { <span class=\"keyword\">case</span> tree, fence, stone }\n\n\n\n<span class=\"keyword\">protocol</span> Hurtable {}\n\n<span class=\"keyword\">protocol</span> Killable {}\n\n<span class=\"keyword\">protocol</span> Flying {}\n\n<span class=\"keyword\">protocol</span> Attacking {}\n\n<span class=\"keyword\">protocol</span> Obstacle {}\n\n\n\n<span class=\"keyword\">extension</span> <span class=\"type\">FlyingBeast</span>: <span class=\"type\">Hurtable</span>, <span class=\"type\">Killable</span>, <span class=\"type\">Flying</span>, <span class=\"type\">Attacking</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Horde</span>: <span class=\"type\">Hurtable</span>, <span class=\"type\">Killable</span>, <span class=\"type\">Attacking</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Player</span>: <span class=\"type\">Hurtable</span>, <span class=\"type\">Obstacle</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">NPC</span>: <span class=\"type\">Hurtable</span> {}\n\n<span class=\"keyword\">extension</span> <span class=\"type\">Element</span>: <span class=\"type\">Obstacle</span> {}\n</code></pre></code></pre>\n","raw_content":"[frontMatter]\ntitle = \"Games\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Games\n\nEnums are a great use case for games, where many entities on screen\nbelong to a specific family of items (enemies, obstacles, textures,\n...). In comparison to native iOS or Mac apps, games oftentimes are a\ntabula rasa. Meaning you invent a new world with new relationships and\nnew kinds of objects, whereas on iOS or OSX you\\'re using a well-defined\nworld of `UIButtons`, `UITableViews`, `UITableViewCells` or `NSStackView`.\n\nWhat\\'s more, since Enums can conform to protocols, you can utilize\nprotocol extensions and protocol based programming to add functionality\nto the various enums that you defined for your game. Here\\'s a short\nexample that tries to display such a hierarchy:\n\n``` Swift\nenum FlyingBeast { case dragon, hippogriff, gargoyle }\nenum Horde { case ork, troll }\nenum Player { case mage, warrior, barbarian }\nenum NPC { case vendor, blacksmith }\nenum Element { case tree, fence, stone }\n\nprotocol Hurtable {}\nprotocol Killable {}\nprotocol Flying {}\nprotocol Attacking {}\nprotocol Obstacle {}\n\nextension FlyingBeast: Hurtable, Killable, Flying, Attacking {}\nextension Horde: Hurtable, Killable, Attacking {}\nextension Player: Hurtable, Obstacle {}\nextension NPC: Hurtable {}\nextension Element: Obstacle {}\n```\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/optionals/why_optionals_are_useful.md":["75fe59b96d207abb",{"identifier":"e11d8550","filename":"why_optionals_are_useful.md","info":{"title":"Why Optionals are useful","tags":["optionals","enum"],"keywords":[],"category":[],"created":"2019-03-02 16:04:26","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551542666,"date":"2019-03-02T16:04:26","date_info":{"year":2019,"month":3,"day":2,"hour":16,"minute":4,"second":26},"identifier":"","indexed":true},"slug":"//2019-3-2-why-optionals-are-useful.html","content":"<h1>Why Optionals are useful</h1>\n<p>Optionals aim to solve a problem related to something called &quot;null pointers&quot;. We don't want to go too much into the history here, instead, we will showcase a typical situation where optionals are needed.</p>\n<p>Imagine that you write your own User Defaults. We want to store a value <code>String</code> for a key <code>String</code> . We will ignore almost everything except for the one function <code>get</code> that allows us to get a <code>String</code> from the defaults.</p>\n<pre class=\"Swift\"><code>\n\n<span class=\"keyword\">struct</span> MyDefaults {\n\n   ...\n\n   <span class=\"comment\">/// A function that returns a `String`</span>\n\n   <span class=\"keyword\">func</span> get(key: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> {\n\n   }\n\n}\n\n\n</code></pre></code></pre>\n<p>The problem is what do we do when we don't have that value in our defaults? What would we return? Now, we could return an &quot;Empty&quot; string, but that wouldn't be right, would it? Imagine you'd save the username in the defaults. Next time the user starts his app he'd see an empty username.</p>\n<p>What you really want to do is express the notifion of &quot;Nothing&quot;. We kinda want to write something like the following:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">func</span> get(key: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> or <span class=\"type\">Nothing</span> {\n\n}\n\n\n</code></pre></code></pre>\n<p>This either gives us back a string or it gives us back nothing. This is fundamentally what optionals are good for. They explain to the Swift type system <em>and</em> to the user that a value can either be Something or Nothing. The implementation is also really simple. It is just an <code>enum</code> with two cases: <code>some</code> and <code>none</code>. Some, has the actual value. Here's a simplified version:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> MyOptional {\n\n   <span class=\"keyword\">case</span> some(<span class=\"type\">String</span>)\n\n   <span class=\"keyword\">case</span> none\n\n}\n</code></pre></code></pre>\n<p>That's it. Now, the actual Swift Optional is not limited to Strings, instead it uses <code>generics</code> in order to provide support for any kind of type. It kinda looks like this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Optional&lt;Wrapped&gt;\n\n   <span class=\"keyword\">case</span> some(<span class=\"type\">Wrapped</span>)\n\n   <span class=\"keyword\">case</span> none\n</code></pre></code></pre>\n<p>So what do we do if we call a function that returns an optional? Since optionals are just simple enums, we can just use Swift's normal <code>enum</code> handling for this:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> optionalValue = <span class=\"call\">functionReturningOptional</span>()\n\n<span class=\"keyword\">switch</span> optionalValue {\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">some</span>(value): <span class=\"call\">print</span>(value)\n\n<span class=\"keyword\">case</span> .<span class=\"dotAccess\">none</span>: <span class=\"call\">print</span>(\\<span class=\"string\">\"Nothing</span>\\<span class=\"string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<h2>The types of Optionals</h2>\n<p>Thankfully, we don't have to spell out the long <code>Optional.some</code> all the time. Instead, Swift offers us a very brief alternative, which is just adding a questionmark <code>?</code> to a type. This will tell Swift that this type is an <code>Optional</code>. This means that the following two are equal:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> one: <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt; = <span class=\"type\">Optional</span>.<span class=\"call\">some</span>(<span class=\"number\">5</span>)\n\n<span class=\"keyword\">let</span> two: <span class=\"type\">Int</span>? = <span class=\"number\">5</span>\n</code></pre></code></pre>\n<p>This is usually the default Syntax for <code>Optionals</code> in Swift. You'll hardly see the other Syntax, but it is still good to know as you might stumble upon it from time to time.</p>\n<p>Also, if you want to create an empty optional, you can just use <code>nil</code> as a shorthand for the empty optional. Again, the following two lines are equal:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> one: <span class=\"type\">Int</span>? = <span class=\"type\">Optional</span>.<span class=\"property\">none</span>\n\n<span class=\"keyword\">let</span> two: <span class=\"type\">Int</span>? = <span class=\"keyword\">nil</span>\n</code></pre></code></pre>\n<p>You can only use <code>nil</code> if Swift can somehow infer the type of the Optional, so the next example does not work because Swift does not know what kind of <code>Optional</code> this is. Is this a <code>Int?</code> or a <code>Float?</code> or a <code>String?</code>. Swift can't find out:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> doesNotWork = <span class=\"keyword\">nil</span>\n</code></pre></code></pre>\n<p>Swift offers many ways of handling <code>Optional</code> types. Lets look at them next.</p>\n","raw_content":"[frontMatter]\ntitle = \"Why Optionals are useful\"\ntags = [\"optionals\", \"enum\"]\ncreated = \"2019-03-02 16:04:26\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Why Optionals are useful\n\nOptionals aim to solve a problem related to something called \"null pointers\". We don't want to go too much into the history here, instead, we will showcase a typical situation where optionals are needed.\n\nImagine that you write your own User Defaults. We want to store a value `String` for a key `String` . We will ignore almost everything except for the one function `get` that allows us to get a `String` from the defaults.\n\n``` swift\n\nstruct MyDefaults {\n  ...\n  /// A function that returns a `String`\n  func get(key: String) -> String {\n  }\n}\n\n```\n\nThe problem is what do we do when we don't have that value in our defaults? What would we return? Now, we could return an \"Empty\" string, but that wouldn't be right, would it? Imagine you'd save the username in the defaults. Next time the user starts his app he'd see an empty username. \n\nWhat you really want to do is express the notifion of \"Nothing\". We kinda want to write something like the following:\n\n``` swift\nfunc get(key: String) -> String or Nothing {\n}\n\n```\n\nThis either gives us back a string or it gives us back nothing. This is fundamentally what optionals are good for. They explain to the Swift type system *and* to the user that a value can either be Something or Nothing. The implementation is also really simple. It is just an `enum` with two cases: `some` and `none`. Some, has the actual value. Here's a simplified version:\n\n``` Swift\nenum MyOptional {\n  case some(String)\n  case none\n}\n```\n\nThat's it. Now, the actual Swift Optional is not limited to Strings, instead it uses `generics` in order to provide support for any kind of type. It kinda looks like this:\n\n``` Swift\nenum Optional<Wrapped>\n  case some(Wrapped)\n  case none\n```\n\nSo what do we do if we call a function that returns an optional? Since optionals are just simple enums, we can just use Swift's normal `enum` handling for this:\n\n``` Swift\nlet optionalValue = functionReturningOptional()\nswitch optionalValue {\ncase .some(value): print(value)\ncase .none: print(\"Nothing\")\n}\n```\n\n## The types of Optionals\n\nThankfully, we don't have to spell out the long `Optional.some` all the time. Instead, Swift offers us a very brief alternative, which is just adding a questionmark `?` to a type. This will tell Swift that this type is an `Optional`. This means that the following two are equal:\n\n``` Swift\nlet one: Optional<Int> = Optional.some(5)\nlet two: Int? = 5\n```\n\nThis is usually the default Syntax for `Optionals` in Swift. You'll hardly see the other Syntax, but it is still good to know as you might stumble upon it from time to time.\n\nAlso, if you want to create an empty optional, you can just use `nil` as a shorthand for the empty optional. Again, the following two lines are equal:\n\n``` Swift\nlet one: Int? = Optional.none\nlet two: Int? = nil\n```\n\nYou can only use `nil` if Swift can somehow infer the type of the Optional, so the next example does not work because Swift does not know what kind of `Optional` this is. Is this a `Int?` or a `Float?` or a `String?`. Swift can't find out:\n\n``` Swift\nlet doesNotWork = nil\n```\n\nSwift offers many ways of handling `Optional` types. Lets look at them next.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/advanced_pattern_matching/type_casting_pattern.md":["7ce873e7eaa22f59",{"identifier":"cc015a51","filename":"type_casting_pattern.md","info":{"title":"Type Casting Pattern","tags":["pattern matching","switch","is","as"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-type-casting-pattern.html","content":"<h1>Type Casting Pattern</h1>\n<p>As the name already implies, this pattern casts or matches types. It has\ntwo different keywords:</p>\n<ul>\n<li><code>is</code> <strong>type</strong>: Matches the runtime type (or a subclass of it)\nagainst the right hand side. This performs a type cast but\ndisregards the returned type. So your <code>case</code> block won't know about\nthe matched type.</li>\n<li>pattern <code>as</code> <strong>type</strong>: Performs the same match as the <code>is</code> pattern\nbut for a successful match casts the type into the pattern specified\non the left hand side.</li>\n</ul>\n<p>Here is an example of the two.</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">let</span> a: <span class=\"type\">Any</span> = <span class=\"number\">5</span> \n\n<span class=\"keyword\">switch</span> a {\n\n\n\n<span class=\"comment\">// this fails because a is still Any</span>\n\n<span class=\"comment\">// error: binary operator '+' cannot be applied to operands of type 'Any' and 'Int'</span>\n\n<span class=\"keyword\">case is</span> <span class=\"type\">Int</span>: print (a + <span class=\"number\">1</span>)\n\n\n\n<span class=\"comment\">// This works and returns '6'</span>\n\n<span class=\"keyword\">case let</span> n <span class=\"keyword\">as</span> <span class=\"type\">Int</span>: print (n + <span class=\"number\">1</span>)\n\n\n\n<span class=\"keyword\">default</span>: ()\n\n}\n</code></pre></code></pre>\n<p>Note that there is no <code>pattern</code> before the <code>is</code>. It matches directly\nagainst <code>a</code>.</p>\n","raw_content":"[frontMatter]\ntitle = \"Type Casting Pattern\"\ntags = [\"pattern matching\", \"switch\", \"is\", \"as\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Type Casting Pattern\n\nAs the name already implies, this pattern casts or matches types. It has\ntwo different keywords:\n\n-   `is` **type**: Matches the runtime type (or a subclass of it)\n    against the right hand side. This performs a type cast but\n    disregards the returned type. So your `case` block won\\'t know about\n    the matched type.\n-   pattern `as` **type**: Performs the same match as the `is` pattern\n    but for a successful match casts the type into the pattern specified\n    on the left hand side.\n\nHere is an example of the two.\n\n``` Swift\nlet a: Any = 5 \nswitch a {\n\n// this fails because a is still Any\n// error: binary operator '+' cannot be applied to operands of type 'Any' and 'Int'\ncase is Int: print (a + 1)\n\n// This works and returns '6'\ncase let n as Int: print (n + 1)\n\ndefault: ()\n}\n```\n\nNote that there is no `pattern` before the `is`. It matches directly\nagainst `a`.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/intro.md":["ff8602cd40c42d49",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Practical Usecases","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-practical-usecases.html","content":"<h1>Practical Usecases</h1>\n<p>We've already seen a couple of useful <code>enums</code> in the previous feature\ndescriptions. Examples would be <code>Optional</code>, <code>Either</code>,\n<code>FileNode</code>, or the binary tree. However, there're many more scenarios\nwhere using an <code>enum</code> wins over a <code>struct</code> or <code>class</code>. Usually, if your\nproblem domain can be divided into a finite set of distinctive\ncategories, an <code>enum</code> may be the right choice. Even only two cases are a\nperfectly valid scenario for an enum, as the Optional and Either types\nshow.</p>\n<p>Here, then, are some more examples of practical <code>enum</code> usage to fuel\nyour creativity.</p>\n","raw_content":"[frontMatter]\ntitle = \"Practical Usecases\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Practical Usecases\n\nWe\\'ve already seen a couple of useful `enums` in the previous feature\ndescriptions. Examples would be `Optional`, `Either`,\n`FileNode`, or the binary tree. However, there\\'re many more scenarios\nwhere using an `enum` wins over a `struct` or `class`. Usually, if your\nproblem domain can be divided into a finite set of distinctive\ncategories, an `enum` may be the right choice. Even only two cases are a\nperfectly valid scenario for an enum, as the Optional and Either types\nshow.\n\nHere, then, are some more examples of practical `enum` usage to fuel\nyour creativity.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/advanced_practical_enum_examples/practical_use_cases/api_endpoints.md":["60a30a05f48935fa",{"identifier":"c3b46424","filename":"api_endpoints.md","info":{"title":"API Endpoints","tags":[],"keywords":[],"category":[],"created":"2019-03-01 16:31:41","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1551457901,"date":"2019-03-01T16:31:41","date_info":{"year":2019,"month":3,"day":1,"hour":16,"minute":31,"second":41},"identifier":"","indexed":true},"slug":"//2019-3-1-api-endpoints.html","content":"<h1>API Endpoints</h1>\n<p>Rest APIs are a great use case for enums. They're naturally grouped,\nthey're limited to a finite set of APIs, and they may have additional\nquery or named parameters which can be modelled through associated\nvalues.</p>\n<p>Take, for example, a look at a simplified version of the <a href=\"https://instagram.com/developer/endpoints/media/\"><strong>Instagram\nAPI</strong></a></p>\n<pre class=\"Swift\"><code><span class=\"keyword\">enum</span> Instagram {\n\n   <span class=\"keyword\">enum</span> Media {\n\n     <span class=\"keyword\">case</span> popular\n\n     <span class=\"keyword\">case</span> shortcode(id: <span class=\"type\">String</span>)\n\n     <span class=\"keyword\">case</span> search(lat: <span class=\"type\">Float</span>, \n\n                 min_timestamp: <span class=\"type\">Int</span>, \n\n                 lng: <span class=\"type\">Float</span>, \n\n                 max_timestamp: <span class=\"type\">Int</span>, \n\n                 distance: <span class=\"type\">Int</span>)\n\n   }\n\n   <span class=\"keyword\">enum</span> Users {\n\n     <span class=\"keyword\">case</span> user(id: <span class=\"type\">String</span>)\n\n     <span class=\"keyword\">case</span> feed\n\n     <span class=\"keyword\">case</span> recent(id: <span class=\"type\">String</span>)\n\n   }\n\n}\n</code></pre></code></pre>\n<p><a href=\"https://github.com/Moya/Moya\">Ash Furrow's <strong>Moya</strong> library</a> is based\naround this idea of using <code>enums</code> to map rest endpoints.</p>\n","raw_content":"[frontMatter]\ntitle = \"API Endpoints\"\ntags = []\ncreated = \"2019-03-01 16:31:41\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# API Endpoints\n\nRest APIs are a great use case for enums. They\\'re naturally grouped,\nthey\\'re limited to a finite set of APIs, and they may have additional\nquery or named parameters which can be modelled through associated\nvalues.\n\nTake, for example, a look at a simplified version of the [**Instagram\nAPI**](https://instagram.com/developer/endpoints/media/)\n\n``` Swift\nenum Instagram {\n  enum Media {\n    case popular\n    case shortcode(id: String)\n    case search(lat: Float, \n                min_timestamp: Int, \n                lng: Float, \n                max_timestamp: Int, \n                distance: Int)\n  }\n  enum Users {\n    case user(id: String)\n    case feed\n    case recent(id: String)\n  }\n}\n```\n\n[Ash Furrow\\'s **Moya** library](https://github.com/Moya/Moya) is based\naround this idea of using `enums` to map rest endpoints.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/keypaths/types/referencewritablekeypath.md":["23a76f89e8f21ed3",{"identifier":"0b927375","filename":"referencewritablekeypath.md","info":{"title":"ReferenceWritableKeyPath","tags":["keypath","referencewritablekeypath"],"keywords":[],"category":[],"created":"2019-03-29 12:26:11","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1553862371,"date":"2019-03-29T12:26:11","date_info":{"year":2019,"month":3,"day":29,"hour":12,"minute":26,"second":11},"identifier":"","indexed":true},"slug":"//2019-3-29-referencewritablekeypath.html","content":"<h1>ReferenceWritableKeyPath</h1>\n<p>In the previous example code, we always defined <code>User</code> <code>struct</code> instances. Which meant that the actual instance we instantiated also had to be mutable (<code>var</code>):</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">var</span> firstUser = <span class=\"type\">User</span>(username: <span class=\"type\">String</span>)\n\nfirstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Ok</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>If this had be a <code>let firstUser</code>, it would not have worked, because <code>let</code> instances are immutable. However, if our <code>User</code> is a <code>class</code> type, we could still mutate it just fine:</p>\n<pre class=\"Swift\"><code><span class=\"keyword\">class</span> User {\n\n   <span class=\"keyword\">var</span> username: <span class=\"type\">String</span> = \\<span class=\"string\">\"Nothing</span>\\<span class=\"string\">\"</span>\n\n}\n\n<span class=\"keyword\">let</span> firstUser = <span class=\"type\">User</span>()\n\n<span class=\"comment\">// This works</span>\n\nfirstUser[keyPath: \\<span class=\"type\">User</span>.<span class=\"property\">username</span>] = \\<span class=\"string\">\"Something</span>\\<span class=\"string\">\"</span>\n</code></pre></code></pre>\n<p>in The example above, the <code>username</code> property can still be modified because <code>User</code> is a <code>class</code>. Swift distinguishes between keypaths for <code>reference</code> (class) types and <code>value</code> types. Keypaths to reference types are of the type <code>ReferenceWritableKeyPath&lt;Root, Value&gt;</code>.</p>\n<p>It is important to note that <code>ReferenceWritableKeyPath</code>s are subclasses of <code>WritableKeyPath</code>, so any function that accepts a <code>WritableKeyPath</code> can also accept a <code>ReferenceWritableKeyPath</code>.</p>\n<p>The next <code>KeyPath</code> we want to look at is the <code>PartialKeyPath</code>, however, before we do so, we'll have a detour and look at a short example to better understand the need for it and to see some of what we've seen so far in action.</p>\n","raw_content":"[frontMatter]\ntitle = \"ReferenceWritableKeyPath\"\ntags = [\"keypath\", \"referencewritablekeypath\"]\ncreated = \"2019-03-29 12:26:11\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# ReferenceWritableKeyPath\n\nIn the previous example code, we always defined `User` `struct` instances. Which meant that the actual instance we instantiated also had to be mutable (`var`):\n\n``` Swift\nvar firstUser = User(username: String)\nfirstUser[keyPath: \\User.username] = \"Ok\"\n```\n\nIf this had be a `let firstUser`, it would not have worked, because `let` instances are immutable. However, if our `User` is a `class` type, we could still mutate it just fine:\n\n``` Swift\nclass User {\n  var username: String = \"Nothing\"\n}\nlet firstUser = User()\n// This works\nfirstUser[keyPath: \\User.username] = \"Something\"\n```\n\nin The example above, the `username` property can still be modified because `User` is a `class`. Swift distinguishes between keypaths for `reference` (class) types and `value` types. Keypaths to reference types are of the type `ReferenceWritableKeyPath<Root, Value>`.\n\nIt is important to note that `ReferenceWritableKeyPath`s are subclasses of `WritableKeyPath`, so any function that accepts a `WritableKeyPath` can also accept a `ReferenceWritableKeyPath`.\n\nThe next `KeyPath` we want to look at is the `PartialKeyPath`, however, before we do so, we'll have a detour and look at a short example to better understand the need for it and to see some of what we've seen so far in action.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/catalyst/firststeps/signing.md":["f2e16f47b0b5bc7a",{"identifier":"deec1092","filename":"signing.md","info":{"title":"How do I sign the app?","tags":["catalyst","macos","uikitformac"],"keywords":[],"category":[],"created":"2019-07-05 10:30:30","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.1"},"created_timestamp":1562322630,"date":"2019-07-05T10:30:30","date_info":{"year":2019,"month":7,"day":5,"hour":10,"minute":30,"second":30},"identifier":"","indexed":true},"slug":"//2019-7-5-how-do-i-sign-the-app.html","content":"<p>Catalyst apps, just like simulator apps, do not require signing. However, since Catalyst apps run on the real hardware, right away, they are set up for signing by default.</p>\n<p>If you have a paid Apple Developer account, that is not a problem. However if you're a student or just looking into Catalyst, you might not have a paid Apple Developer account.</p>\n<p>Thankfully, you can test Catalyst apps just fine without a paid account. You only have to go into the signing settings of Xcode (<em>&quot;Target&quot;</em> -&gt; <em>&quot;Signing &amp; Capabilities&quot;</em> -&gt; <em>&quot;Signing Certificate&quot;</em>) and then select <em>Sign to Run Locally</em>.</p>\n<p>Now, Xcode will still complain with a small red alert that says <em>&quot;Signing for ... requires a development team&quot;</em>, however it will build the app just fine and also run it just fine.</p>\n<p><img src=\"/img-content/catalyst/signing_settings.png\" alt=\"\" /></p>\n<h2>Signing Frameworks</h2>\n<p>If you're signing locally and your code is split up into frameworks, it may be the case that you're getting code signing errors <em>when your binary starts</em>. So, your code is building fine, it is sining fine, but when the Catalyst App actually starts, it will crash with a code signing error. The current known way to prevent this is to have the following settings for your <em>main target</em> and for your <em>frameworks</em> (screenshots below):</p>\n<h3>Main Target</h3>\n<ul>\n<li>Automatically Manage Signing</li>\n<li>Team: A working account</li>\n<li>Signing Certificate: Apple Development</li>\n</ul>\n<p><img src=\"/img-content/catalyst/signing_frameworks1.png\" alt=\"\" /></p>\n<h3>Any Framework Target</h3>\n<ul>\n<li>Automatically Manage Signing</li>\n<li>Team: The same working account</li>\n<li>Signing Certificate: Sign to run locally</li>\n</ul>\n<p><img src=\"/img-content/catalyst/signing_frameworks2.png\" alt=\"\" /></p>\n<p>Keep in mind that the frameworks and the main target need to have distinct bundle identifiers.</p>\n<p>This issue does appear to only happen to some people.</p>\n","raw_content":"[frontMatter]\ntitle = \"How do I sign the app?\"\ntags = [\"catalyst\", \"macos\", \"uikitformac\"]\ncreated = \"2019-07-05\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.1\"\n---\n\n\nCatalyst apps, just like simulator apps, do not require signing. However, since Catalyst apps run on the real hardware, right away, they are set up for signing by default.\n\nIf you have a paid Apple Developer account, that is not a problem. However if you're a student or just looking into Catalyst, you might not have a paid Apple Developer account.\n\nThankfully, you can test Catalyst apps just fine without a paid account. You only have to go into the signing settings of Xcode (*\"Target\"* -> *\"Signing & Capabilities\"* -> *\"Signing Certificate\"*) and then select *Sign to Run Locally*.\n\nNow, Xcode will still complain with a small red alert that says *\"Signing for ... requires a development team\"*, however it will build the app just fine and also run it just fine.\n\n![](/img-content/catalyst/signing_settings.png)\n\n## Signing Frameworks\n\nIf you're signing locally and your code is split up into frameworks, it may be the case that you're getting code signing errors *when your binary starts*. So, your code is building fine, it is sining fine, but when the Catalyst App actually starts, it will crash with a code signing error. The current known way to prevent this is to have the following settings for your *main target* and for your *frameworks* (screenshots below):\n\n### Main Target\n- Automatically Manage Signing\n- Team: A working account\n- Signing Certificate: Apple Development\n\n![](/img-content/catalyst/signing_frameworks1.png)\n\n### Any Framework Target\n- Automatically Manage Signing\n- Team: The same working account\n- Signing Certificate: Sign to run locally\n\n![](/img-content/catalyst/signing_frameworks2.png)\n\nKeep in mind that the frameworks and the main target need to have distinct bundle identifiers.\n\nThis issue does appear to only happen to some people.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}],"./guides/pattern_matching/intro.md":["2c209cc90256d799",{"identifier":"e37a3048","filename":"intro.md","info":{"title":"Introduction","tags":["pattern matching","switch","destructure","enum"],"keywords":[],"category":[],"created":"2019-02-15 20:40:47","description":"","description_html":"","published":true,"slug":null,"meta":{"swift_version":"5.0"},"created_timestamp":1550263247,"date":"2019-02-15T20:40:47","date_info":{"year":2019,"month":2,"day":15,"hour":20,"minute":40,"second":47},"identifier":"","indexed":true},"slug":"//2019-2-15-introduction.html","content":"<h1>Introduction</h1>\n<p>Swift's <code>switch</code> statement bears little resemblance to the similarly named\nequivalent in C or Objective-C. Even though they share the same name,\nthe Swift version can do much, much more.</p>\n<p>In the\nfollowing guide, I will try to explain the various usages for these\nnew features in more detail.</p>\n<p>The main feature of <code>switch</code> is, of course, pattern matching: the ability\nto destructure values and match different switch cases based on correct\nmatch of the values to the cases.</p>\n<h2>Destructure</h2>\n<p>Destructuring means to take something of a certain structure and destructure it\ninto smaller items again. Imagaine you had a <code>lnk::tuple</code> variable <code>user</code> with the following value: <code>(firstname: &quot;Harry&quot;, lastname: &quot;Potter&quot;, age: 21, occupation: &quot;Wizard&quot;)</code></p>\n<p>Destructuring means taking this tuple and converting it into individual variables:</p>\n<pre class=\"Swift\"><code><span class=\"swift-keyword\">let</span> harry = (firstname: \\<span class=\"swift-string\">\"Harry</span>\\<span class=\"swift-string\">\"</span>, lastname: \\<span class=\"swift-string\">\"Potter</span>\\<span class=\"swift-string\">\"</span>, age: <span class=\"swift-number\">21</span>, occupation: \\<span class=\"swift-string\">\"Wizard</span>\\<span class=\"swift-string\">\"</span>)\n\n\n\n<span class=\"swift-keyword\">let</span> (name, surname, age, occupation) = harry\n\n<span class=\"swift-call\">print</span>(surname)\n</code></pre></code></pre>\n<p>Destructuring is a great method for handling the information in complex types. It is also a fundamental part of Swift's <code>switch</code> statement. The next step, then, is to have a look at <code>switch</code>:</p>\n<h2>A simple example</h2>\n<p>We wrote a game where both players have to take a quiz. After each question we evaluate\nwho won or lost. There're four states:</p>\n<ul>\n<li>Player 1 is correct</li>\n<li>Player 2 is correct</li>\n<li>Both were correct</li>\n<li>Both were wrong</li>\n</ul>\n<p>We can model this logic very nicely with a <code>switch</code> statement such as the following:</p>\n<pre class=\"Swift\"><code><span class=\"swift-keyword\">let</span> player1 = <span class=\"swift-keyword\">true</span>\n\n<span class=\"swift-keyword\">let</span> player2 = <span class=\"swift-keyword\">false</span>\n\n<span class=\"swift-keyword\">switch</span> (player1, player2) {\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">true</span>, <span class=\"swift-keyword\">false</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Player</span> <span class=\"swift-number\">1</span> won\\<span class=\"swift-string\">\"</span>)\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">false</span>, <span class=\"swift-keyword\">true</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Player</span> <span class=\"swift-number\">2</span> won\\<span class=\"swift-string\">\"</span>)\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">true</span>, <span class=\"swift-keyword\">true</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Draw</span>, both won\\<span class=\"swift-string\">\"</span>)\n\n<span class=\"swift-keyword\">case</span> (<span class=\"swift-keyword\">false</span>, <span class=\"swift-keyword\">false</span>): <span class=\"swift-call\">print</span>(\\<span class=\"swift-string\">\"Draw</span>, both lost\\<span class=\"swift-string\">\"</span>)\n\n}\n</code></pre></code></pre>\n<p>Here, we create a tuple <code>(player1, player2)</code> and then match each of\nthe possible cases.</p>\n<p>This was a very short introduction, now we will go into more detail.</p>\n","raw_content":"[frontMatter]\ntitle = \"Introduction\"\ntags = [\"pattern matching\", \"switch\", \"destructure\", \"enum\"]\ncreated = \"2019-02-15 20:40:47\"\ndescription = \"\"\npublished = true\n\n[meta]\nswift_version = \"5.0\"\n---\n\n# Introduction\n\nSwift's `switch` statement bears little resemblance to the similarly named\nequivalent in C or Objective-C. Even though they share the same name,\nthe Swift version can do much, much more.\n\nIn the\nfollowing guide, I will try to explain the various usages for these\nnew features in more detail. \n\nThe main feature of `switch` is, of course, pattern matching: the ability\nto destructure values and match different switch cases based on correct\nmatch of the values to the cases.\n\n## Destructure\n\nDestructuring means to take something of a certain structure and destructure it\ninto smaller items again. Imagaine you had a `lnk::tuple` variable `user` with the following value: `(firstname: \"Harry\", lastname: \"Potter\", age: 21, occupation: \"Wizard\")`\n\nDestructuring means taking this tuple and converting it into individual variables:\n\n``` Swift\nlet harry = (firstname: \"Harry\", lastname: \"Potter\", age: 21, occupation: \"Wizard\")\n\nlet (name, surname, age, occupation) = harry\nprint(surname)\n```\n\nDestructuring is a great method for handling the information in complex types. It is also a fundamental part of Swift's `switch` statement. The next step, then, is to have a look at `switch`:\n\n## A simple example\n\nWe wrote a game where both players have to take a quiz. After each question we evaluate\nwho won or lost. There're four states: \n\n- Player 1 is correct\n- Player 2 is correct\n- Both were correct\n- Both were wrong\n\nWe can model this logic very nicely with a `switch` statement such as the following:\n\n``` Swift\nlet player1 = true\nlet player2 = false\nswitch (player1, player2) {\ncase (true, false): print(\"Player 1 won\")\ncase (false, true): print(\"Player 2 won\")\ncase (true, true): print(\"Draw, both won\")\ncase (false, false): print(\"Draw, both lost\")\n}\n```\n\nHere, we create a tuple `(player1, player2)` and then match each of\nthe possible cases.\n\nThis was a very short introduction, now we will go into more detail.\n","sections":[],"similar_documents":[],"previous_document":null,"next_document":null,"updated":true}]}